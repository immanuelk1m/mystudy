# Backend Development Guide

## 1. Introduction

*   Purpose of this backend server: To provide APIs and services for the [Your Frontend Application Name] application.
*   Brief overview of its functionalities (managing notebooks, chapters, content, user sessions, file uploads, PDF content analysis including classification, chapter segmentation, summarization, and quiz generation, as well as automated podcast audio creation from text content, etc.).
*   Link to `backend_integration_points.md` for frontend integration context.

## 2. Technology Stack

*   **Runtime Environment:** Node.js (LTS version, e.g., v18.x or v20.x)
*   **Web Framework:** Express.js
*   **Language:** JavaScript (ES6+)
*   **Database:** PostgreSQL (e.g., v12+)
    *   **ORM:** Sequelize (e.g., v6+)
*   **Authentication:** Google OAuth 2.0
*   **File Uploads:** Multer
*   **Package Manager:** npm
*   **AI & External Services:**
    *   **Google Cloud AI (Gemini 2.5 Flash):** For PDF content analysis, classification, chapter segmentation, summarization, and quiz generation.
    *   **Eleven Labs API:** For text-to-speech conversion to generate podcast audio.
*   **Key Libraries:**
    *   `jsonwebtoken`: For JWT creation and verification (used for session management post-OAuth).
    *   `pg`, `pg-hstore`: PostgreSQL client for Node.js.
    *   `cors`: For Cross-Origin Resource Sharing.
    *   `dotenv`: For environment variable management.
    *   `express-validator`: For input validation.
    *   `morgan`: HTTP request logger (for development).
    *   `bcryptjs`: (Recommended for password hashing if extending to non-guest users - though primary auth is Google).
    *   `winston` or `pino`: For structured, production-ready logging.
    *   `@google-cloud/aiplatform`: Node.js client library for Google Cloud AI services.

## 3. Project Structure

*   Overview of the main directories and their purpose:
    ```
    backend-server/
    ├── src/
    │   ├── api/              # API route definitions (e.g., auth.routes.js, notebooks.routes.js)
    │   ├── controllers/      # Request handling logic (e.g., auth.controller.js)
    │   ├── middleware/       # Custom middleware (e.g., auth.middleware.js, error.handler.js)
    │   ├── models/           # Sequelize database models (e.g., user.model.js, notebook.model.js)
    │   ├── services/         # Business logic (e.g., auth.service.js, notebook.service.js)
    │   ├── config/           # Configuration files (db.config.js, app.config.js)
    │   ├── utils/            # Utility functions (logger.js, AppError.js)
    │   ├── app.js            # Express application setup
    │   └── server.js         # Server initialization
    ├── uploads/              # Default directory for local file uploads (MUST be in .gitignore)
    ├── .env.example          # Example environment variables file
    ├── .sequelizerc          # Sequelize-CLI configuration file
    ├── migrations/           # Database migration files generated by Sequelize-CLI
    ├── seeders/              # Database seeder files generated by Sequelize-CLI
    ├── .gitignore
    ├── package.json
    └── backend_development_guide.md # This document
    ```

## 4. Setup and Installation

### 4.1. Prerequisites
*   Node.js (LTS: v18.x or v20.x recommended) - Download from [https://nodejs.org/](https://nodejs.org/)
*   npm (comes with Node.js) or Yarn
*   PostgreSQL server (v12+ recommended) - Download from [https://www.postgresql.org/download/](https://www.postgresql.org/download/) or use Docker.
*   Git for version control.

### 4.2. Installation Steps
1.  **Clone the repository (assuming one exists or will be created):**
    ```bash
    git clone <your_repository_url>
    cd backend-server
    ```
2.  **Install dependencies:**
    ```bash
    npm install
    # OR if using Yarn:
    # yarn install
    ```
3.  **Set up PostgreSQL Database:**
    *   Ensure your PostgreSQL server is running.
    *   Connect to PostgreSQL (e.g., using `psql` or a GUI like pgAdmin).
    *   Create a database: `CREATE DATABASE your_app_db;`
    *   Create a user (role): `CREATE USER your_app_user WITH PASSWORD 'your_secure_password';`
    *   Grant privileges: `GRANT ALL PRIVILEGES ON DATABASE your_app_db TO your_app_user;`
    *   (Optional, for UUID extension if not enabled by default): `CREATE EXTENSION IF NOT EXISTS "uuid-ossp";` (in your_app_db)
4.  **Configure Environment Variables:**
    *   Copy `.env.example` to `.env`:
        ```bash
        cp .env.example .env
        ```
    *   Edit `.env` with your local settings. **CRITICAL: Change `JWT_SECRET` to a long, random, unique string.**
        ```env
        NODE_ENV=development
        PORT=3001

        # Database Configuration
        DB_HOST=localhost
        DB_PORT=5432
        DB_USER=your_app_user
        DB_PASSWORD=your_secure_password
        DB_NAME=your_app_db
        DB_DIALECT=postgres # Do not change for PostgreSQL

        # JWT Configuration (for session tokens)
        JWT_SECRET=!!!REPLACE_THIS_WITH_A_VERY_STRONG_RANDOM_KEY!!!
        JWT_SESSION_EXPIRES_IN=1d # Example: Session tokens valid for 1 day

        # Google OAuth Configuration
        GOOGLE_CLIENT_ID=your_google_client_id
        GOOGLE_CLIENT_SECRET=your_google_client_secret
        # Ensure the backend URL is correctly configured (e.g., http://localhost:3001 or https://yourdomain.com)
        API_BASE_URL=http://localhost:3001

        # Google Cloud AI (Gemini)
        # GOOGLE_APPLICATION_CREDENTIALS=/path/to/your/gcp-service-account-key.json # Or configure via other auth methods

        # Eleven Labs API
        ELEVENLABS_API_KEY=your_elevenlabs_api_key

        # File Upload Configuration (Local Storage)
        UPLOAD_DIR=uploads/ # Relative to project root (e.g., uploads/pdfs, uploads/audio)
        ```
5.  **Database Migrations (using Sequelize-CLI - Recommended):**
    *   Install `sequelize-cli` if not already a dev dependency: `npm install --save-dev sequelize-cli`
    *   Initialize Sequelize (if not already done, creates `migrations`, `seeders`, `config/config.json` - adapt `config/config.json` or use `.sequelizerc` to point to your `src/config/db.config.js` and `src/models`):
        ```bash
        # npx sequelize-cli init # Only if starting from scratch
        ```
    *   Ensure your `src/config/db.config.js` exports configurations in a way `sequelize-cli` understands (often a top-level object with `development`, `production` keys). Or, update the `config/config.json` that `sequelize-cli init` creates.
    *   Create migration files based on your models (e.g., `npx sequelize-cli model:generate --name User --attributes ...` then refine migration file).
    *   Run migrations:
        ```bash
        npx sequelize-cli db:migrate
        ```
    *   (Optional) Create and run seeders for initial data:
        ```bash
        # npx sequelize-cli seed:generate --name demo-user
        # npx sequelize-cli db:seed:all
        ```

### 4.3. Running the Server
*   **Development Mode (with `nodemon` if configured in `package.json`'s `dev` script):**
    ```bash
    npm run dev
    ```
    (Example `package.json` script: `"dev": "nodemon src/server.js"`)
*   **Production Mode:**
    ```bash
    npm start
    ```
    (Example `package.json` script: `"start": "node src/server.js"`)
*   The server should now be running at `http://localhost:PORT` (e.g., `http://localhost:3001`).
*   A common health check endpoint (if you implement one): `GET /api/health`

## 5. Data Schema

This section details the structure of the primary data models managed by the backend. These models will be implemented using Sequelize ORM with PostgreSQL. Relationships between models (e.g., Foreign Keys) are crucial for data integrity.

*   **User Model (`user.model.js`):**
    *   `id`: UUID, Primary Key, defaultValue UUIDV4. Represents the unique identifier for a user.
    *   `googleId`: String, Unique. Stores the unique ID provided by Google for the authenticated user.
    *   `email`: String, Unique, allowNull: false. User's email address, obtained from Google.
    *   `displayName`: String, allowNull: true. User's display name, obtained from Google.
    *   `profilePictureUrl`: String, allowNull: true. URL to the user's profile picture, obtained from Google.
    *   `createdAt`, `updatedAt`: DATE. Timestamps for record creation and last update.
    *   *(Note: The previous `isGuest` field is removed as Google Authentication is the exclusive method.)*

*   **Notebook Model (`notebook.model.js`):**
    *   `id`: UUID, Primary Key.
    *   `title`: String, allowNull: false.
    *   `description`: TEXT (allowNull: true).
    *   `ownerId`: UUID, Foreign Key referencing `User.id`.
    *   `createdAt`, `updatedAt`: DATE.

*   **UploadedFile Model (`uploadedfile.model.js`):**
    *   `id`: UUID, Primary Key.
    *   `uploaderId`: UUID, Foreign Key referencing `User.id`. The user who uploaded the file.
    *   `notebookId`: UUID (Optional, Foreign Key referencing `Notebook.id`). Links the file to a specific notebook if applicable.
    *   `pdfClassId`: UUID (Optional, Foreign Key referencing `PdfClass.id`). The automatically inferred class/category of the PDF content.
    *   `originalFilename`: String, allowNull: false. The original name of the uploaded file.
    *   `storedFilename`: String, allowNull: false, unique. The unique name used for storing the file on the server/cloud storage.
    *   `filePath`: String, allowNull: false. Path to the stored file in the local or cloud storage.
    *   `fileType`: String (MIME type), allowNull: false.
    *   `fileSize`: Integer (bytes), allowNull: false.
    *   `processingStatus`: String, defaultValue 'pending'. Indicates the status of PDF processing (e.g., "pending", "processing", "completed", "failed").
    *   `extractedTextPath`: String (Optional). Path to a file containing the raw extracted text from the PDF, if stored separately.
    *   `createdAt`, `updatedAt`: DATE.

*   **PdfClass Model (`pdfclass.model.js`):** (New Model)
    *   `id`: UUID, Primary Key, defaultValue UUIDV4.
    *   `name`: String, allowNull: false, unique. The name of the inferred PDF class/category (e.g., "Physics", "History").
    *   `description`: TEXT (Optional). A brief description of the class.
    *   `createdAt`, `updatedAt`: DATE.

*   **Chapter Model (`chapter.model.js`):**
    *   `id`: UUID, Primary Key, defaultValue UUIDV4.
    *   `sourcePdfFileId`: UUID, Foreign Key referencing `UploadedFile.id`. The PDF file from which this chapter was derived.
    *   `notebookId`: UUID, Foreign Key referencing `Notebook.id`. The notebook this chapter belongs to.
    *   `title`: String, allowNull: false. Title of the chapter, potentially AI-generated or user-defined.
    *   `order`: Integer, allowNull: false. The sequence number of this chapter within the PDF/notebook.
    *   `documentContent`: JSONB (Optional). Stores the original segmented content blocks from the PDF for this chapter.
    *   `summary`: TEXT (Optional). AI-generated summary of the chapter's content.
    *   `podcastScriptContent`: JSONB (Optional). Stores the generated script for the podcast episode of this chapter, possibly structured for multiple voices (e.g., `[{speaker: "Voice1", line: "..."}, {speaker: "Voice2", line: "..."}]`).
    *   `podcastAudioPath`: String (Optional). Path/URL to the generated podcast audio file for this chapter.
    *   `userUploadedAudioPath`: String (Optional). Path/URL to an audio file manually uploaded by the user for this chapter (distinct from generated podcast).
    *   `createdAt`, `updatedAt`: DATE.
    *   *(Note: Renamed `audioPath` to `userUploadedAudioPath` for clarity vs. `podcastAudioPath`)*

*   **QuizQuestion Model (`quizquestion.model.js`):** (New Model)
    *   `id`: UUID, Primary Key, defaultValue UUIDV4.
    *   `chapterId`: UUID, Foreign Key referencing `Chapter.id`. The chapter this quiz question belongs to.
    *   `questionText`: TEXT, allowNull: false. The text of the multiple-choice question.
    *   `options`: JSONB, allowNull: false. Stores the multiple-choice options, correct answer, and explanations. Example structure: `[{"text": "Option A", "isCorrect": false, "explanation": "Why A is incorrect/less correct"}, {"text": "Option B", "isCorrect": true, "explanation": "Why B is correct"}, ...]`
    *   `order`: Integer (Optional). For ordering questions within a chapter quiz.
    *   `createdAt`, `updatedAt`: DATE.

*   **QuizProgress Model (`quizprogress.model.js`):** (No changes from current, description for context)
    *   `id`: UUID, Primary Key.
    *   `userId`: UUID, Foreign Key referencing `User.id`.
    *   `chapterId`: UUID, Foreign Key referencing `Chapter.id`.
    *   `answers`: JSONB. Stores the user's answers to quiz questions.
    *   `unknownStatus`: JSONB. (Purpose to be clarified based on frontend needs, e.g., for "I don't know" options).
    *   `results`: JSONB. Stores the outcome/score of the quiz attempt.
    *   `lastAttemptedAt`: DATE.
    *   (Consider unique constraint on `userId` and `chapterId` if only one progress record per user/chapter is desired).

*   **AiNoteSettings Model (`ainotesettings.model.js`):** (No changes from current, description for context)
    *   `id`: UUID, Primary Key.
    *   `userId`: UUID, Foreign Key referencing `User.id`.
    *   `chapterId`: UUID, Foreign Key referencing `Chapter.id`.
    *   `keyConceptExplanationLevels`: JSONB. User preferences for AI note generation detail.
    *   `updatedAt`: DATE.
    *   (Consider unique constraint on `userId` and `chapterId`).

## 6. API Endpoint Documentation

This section details the API endpoints provided by the backend. All protected endpoints require a session token (typically a JWT) obtained after successful user authentication via the Google OAuth 2.0 flow. This session token must be included in the `Authorization: Bearer <SESSION_TOKEN>` header for all authenticated requests. The backend will validate this token to identify and authorize the user.

*(The list below is not exhaustive and will be expanded as development progresses. It focuses on newly added services and updates to existing authentication patterns.)*

**Template for API Endpoints:**

*   **`[METHOD] [URL_PATH]`** e.g., `POST /api/notebooks`
*   **Description:** A brief explanation of what the endpoint does.
*   **Authentication:** `Required (Session Token)` or `None`.
*   **Request Headers (if specific):** e.g., `Authorization: Bearer <SESSION_TOKEN>`, `Content-Type: application/json`.
*   **URL Parameters (if any):** e.g., `{fileId}` - Description of the parameter.
*   **Query Parameters (if any):** e.g., `page=1&limit=10` - Description of parameters.
*   **Request Body (Example JSON or Data Type):** Example of the request payload, if applicable.
*   **Response - Success (Status Code, Example JSON):** Example of a successful response.
*   **Response - Error (Status Code, Example JSON):** Examples of common error responses (e.g., 400 Bad Request, 401 Unauthorized, 404 Not Found, 500 Internal Server Error).
*   **Key Validations:** Important validation rules for request parameters or body.

---
**Example: Create Notebook** (Updated)
*   **`POST /api/notebooks`**
*   **Description:** Creates a new notebook for the authenticated user.
*   **Authentication:** `Required (Session Token)`.
*   **Request Headers:** `Authorization: Bearer <SESSION_TOKEN>`, `Content-Type: application/json`.
*   **Request Body:**
    ```json
    {
      "title": "Advanced Calculus Notes",
      "description": "Covering topics from Math 301."
    }
    ```
*   **Response - Success (201 Created):**
    ```json
    {
      "id": "a1b2c3d4-e5f6-7890-1234-567890abcdef", // Notebook ID
      "title": "Advanced Calculus Notes",
      "description": "Covering topics from Math 301.",
      "ownerId": "c9d8e7f6-g5h4-3210-i1j2-k3l4m5n6o7p8", // User's ID from session token
      "createdAt": "2023-10-27T10:00:00.000Z",
      "updatedAt": "2023-10-27T10:00:00.000Z"
    }
    ```
*   **Response - Error (400 Bad Request - Validation Error):**
    ```json
    {
      "errors": [
        {
          "type": "field",
          "msg": "Title must be between 3 and 100 characters.",
          "path": "title",
          "location": "body",
          "value": "AB"
        }
      ]
    }
    ```
*   **Response - Error (401 Unauthorized):** If session token is missing, invalid, or expired.
*   **Key Validations:**
    *   `title`: Required, String, min 3 chars, max 100 chars.
    *   `description`: Optional, String, max 500 chars.

---
**PDF Processing Endpoints**

*   **`POST /api/files/pdf/upload`**
    *   **Description:** Uploads a PDF file for processing. The processing (classification, chapterization, summarization, quiz generation) is initiated asynchronously.
    *   **Authentication:** `Required (Session Token)`.
    *   **Request Headers:** `Authorization: Bearer <SESSION_TOKEN>`.
    *   **Request Body:** `multipart/form-data` containing the PDF file.
        *   `file`: The PDF file to be uploaded.
    *   **Response - Success (202 Accepted):**
        ```json
        {
          "id": "file_uuid_12345",
          "originalFilename": "my_document.pdf",
          "processingStatus": "pending",
          "uploaderId": "user_uuid_abcde",
          "createdAt": "2023-11-01T12:00:00.000Z"
          // ... other relevant fields from UploadedFile model
        }
        ```
    *   **Response - Error (400 Bad Request):** If no file is uploaded, or file type is incorrect (if validated).
    *   **Key Validations:**
        *   `file`: Must be a PDF file. Max file size might be enforced by server configuration (e.g., via Multer).

*   **`GET /api/files/pdf/{fileId}/status`**
    *   **Description:** Retrieves the current processing status and basic information of an uploaded PDF file.
    *   **Authentication:** `Required (Session Token)`.
    *   **Request Headers:** `Authorization: Bearer <SESSION_TOKEN>`.
    *   **URL Parameters:**
        *   `{fileId}`: UUID of the uploaded file.
    *   **Response - Success (200 OK):**
        ```json
        {
          "id": "file_uuid_12345",
          "originalFilename": "my_document.pdf",
          "processingStatus": "processing_chapters", // Or "completed", "failed", "pending_classification" etc.
          "pdfClassId": "class_uuid_67890", // Nullable, present if classification is done
          "pdfClassName": "Physics", // Example, could be joined or added
          // ... other relevant fields from UploadedFile model
          "createdAt": "2023-11-01T12:00:00.000Z",
          "updatedAt": "2023-11-01T12:05:00.000Z"
        }
        ```
    *   **Response - Error (404 Not Found):** If `fileId` does not exist or doesn't belong to the user.

*   **`GET /api/pdf-classes`**
    *   **Description:** Retrieves a list of all defined PDF classes in the system.
    *   **Authentication:** `Required (Session Token)`. (Or `None` if classes are public information)
    *   **Request Headers:** `Authorization: Bearer <SESSION_TOKEN>`.
    *   **Response - Success (200 OK):**
        ```json
        [
          {
            "id": "class_uuid_67890",
            "name": "Physics",
            "description": "Documents related to physics concepts and theories."
          },
          {
            "id": "class_uuid_abcdef",
            "name": "History",
            "description": "Documents covering historical events and periods."
          }
        ]
        ```

*   **`GET /api/chapters/by-file/{fileId}`**
    *   **Description:** Retrieves all chapters generated from a specific processed PDF file, including their summaries. This endpoint is used after PDF processing is completed.
    *   **Authentication:** `Required (Session Token)`.
    *   **Request Headers:** `Authorization: Bearer <SESSION_TOKEN>`.
    *   **URL Parameters:**
        *   `{fileId}`: UUID of the source `UploadedFile`.
    *   **Response - Success (200 OK):**
        ```json
        [
          {
            "id": "chapter_uuid_aaaaa",
            "sourcePdfFileId": "file_uuid_12345",
            "title": "Chapter 1: Introduction to Mechanics",
            "order": 1,
            "summary": "This chapter introduces the fundamental concepts of classical mechanics...",
            "podcastAudioPath": "/uploads/podcasts/chapter_uuid_aaaaa.mp3", // If available
            "quizAvailable": true, // Indicates if quiz questions exist for this chapter
            "createdAt": "2023-11-01T12:10:00.000Z"
          },
          {
            "id": "chapter_uuid_bbbbb",
            "sourcePdfFileId": "file_uuid_12345",
            "title": "Chapter 2: Kinematics",
            "order": 2,
            "summary": "Kinematics is the study of motion without considering its causes...",
            "podcastAudioPath": null,
            "quizAvailable": true,
            "createdAt": "2023-11-01T12:15:00.000Z"
          }
        ]
        ```
    *   **Response - Error (404 Not Found):** If `fileId` does not exist or processing is not complete.

*   **`GET /api/chapters/{chapterId}/quiz`**
    *   **Description:** Retrieves the full set of quiz questions (with options and explanations) for a specific chapter.
    *   **Authentication:** `Required (Session Token)`.
    *   **Request Headers:** `Authorization: Bearer <SESSION_TOKEN>`.
    *   **URL Parameters:**
        *   `{chapterId}`: UUID of the chapter.
    *   **Response - Success (200 OK):**
        ```json
        [
          {
            "id": "quizq_uuid_xxxxx",
            "chapterId": "chapter_uuid_aaaaa",
            "questionText": "What is Newton's first law of motion?",
            "options": [
              {"text": "F=ma", "isCorrect": false, "explanation": "This is Newton's second law."},
              {"text": "An object at rest stays at rest...", "isCorrect": true, "explanation": "Correct, also known as the law of inertia."},
              {"text": "For every action, there is an equal and opposite reaction.", "isCorrect": false, "explanation": "This is Newton's third law."}
            ],
            "order": 1
          }
          // ...more questions
        ]
        ```
    *   **Response - Error (404 Not Found):** If `chapterId` does not exist or has no quiz questions.

---
**Podcast Generation Endpoints**

*   **`POST /api/chapters/{chapterId}/podcast/generate`**
    *   **Description:** Initiates the generation of a podcast audio episode for a specific chapter using its summary or full content. This is an asynchronous operation.
    *   **Authentication:** `Required (Session Token)`.
    *   **Request Headers:** `Authorization: Bearer <SESSION_TOKEN>`.
    *   **URL Parameters:**
        *   `{chapterId}`: UUID of the chapter for which to generate the podcast.
    *   **Response - Success (202 Accepted):**
        ```json
        {
          "message": "Podcast generation initiated for chapter.",
          "chapterId": "chapter_uuid_aaaaa",
          "podcastJobStatus": "pending" // Or an initial status from the Chapter model
        }
        ```
    *   **Response - Error (404 Not Found):** If `chapterId` does not exist.
    *   **Response - Error (409 Conflict):** If podcast generation is already in progress or completed for this chapter.

*   **`GET /api/chapters/{chapterId}/podcast/status`**
    *   **Description:** Retrieves the status of podcast generation for a chapter and the URL to the audio file if available.
    *   **Authentication:** `Required (Session Token)`.
    *   **Request Headers:** `Authorization: Bearer <SESSION_TOKEN>`.
    *   **URL Parameters:**
        *   `{chapterId}`: UUID of the chapter.
    *   **Response - Success (200 OK):**
        ```json
        {
          "chapterId": "chapter_uuid_aaaaa",
          "podcastGenerationStatus": "completed", // Or "pending", "failed", "processing_script", "generating_audio"
          "podcastAudioUrl": "/uploads/podcasts/chapter_uuid_aaaaa.mp3", // Null if not ready or failed
          "podcastScriptContent": [ // May also return the script
            {"speaker": "Voice1", "line": "Welcome to the summary of Introduction to Mechanics."},
            {"speaker": "Voice2", "line": "Let's dive into the core concepts..."}
          ],
          "updatedAt": "2023-11-01T14:00:00.000Z"
        }
        ```
    *   **Response - Error (404 Not Found):** If `chapterId` does not exist.

---
*(This documentation will be expanded to cover all other existing and future API endpoints, such as those for managing user profiles, notebook CRUD, chapter CRUD (if manual editing is allowed), etc.)*

## 7. Authentication System

*   **Method:** Google Authentication will be the exclusive method for user authentication.
*   **Flow:** Users will be redirected to Google for authentication. Upon successful authentication, Google will redirect the user back to our application with an authentication code. This code will be exchanged for tokens (access, refresh, ID) from Google. The ID token will be used to identify the user.
*   **User Management:** A new user record will be created in the database upon their first successful Google login.
*   **Configuration:**
    *   **Environment Variables:** The system relies on specific environment variables for Google OAuth integration:
        *   `GOOGLE_CLIENT_ID`: The client ID obtained from Google Cloud Console.
        *   `GOOGLE_CLIENT_SECRET`: The client secret obtained from Google Cloud Console.
    *   **Callback URLs:** Ensure the authorized redirect URIs (callback URLs) are correctly configured in the Google Cloud Console (e.g., `http://localhost:3001/api/auth/google/callback` for development, and the production equivalent).
*   **Token Handling:**
    *   The application will receive an ID token from Google, which should be validated.
    *   Session management will be handled by issuing a session token (e.g., a JWT or a session cookie) to the client after successful Google authentication and user verification. This session token will be used for subsequent authenticated requests to the backend.
*   **Middleware (`auth.middleware.js`):** This middleware will be updated to verify the application's session token. It will extract user information and attach it to `req.user`.
*   **Security:** All communication with Google's OAuth 2.0 endpoints must use HTTPS.

## 8. File Handling (Local Storage Strategy)

*   **General Uploads:** The system handles uploads primarily via `POST /api/files/pdf/upload` using `multer` middleware for PDF files. Other file types might be handled by different endpoints if necessary.
*   **Storage of Uploaded PDFs:** Original PDF files are stored in a designated subdirectory within `UPLOAD_DIR` (e.g., `uploads/pdfs/`). Their metadata, including `filePath`, is tracked in the `UploadedFile` model.
*   **Temporary Files during Processing:** PDF processing by services like Google Cloud AI might involve temporary local copies or direct streaming. Ensure sufficient temporary storage if files are staged locally before sending to the cloud service.
*   **Storage of Extracted Text:** If raw text extracted from PDFs is stored as separate files (see `UploadedFile.extractedTextPath`), these would reside in a subdirectory like `uploads/extracted_text/`.
*   **Storage of Generated Audio:** Podcast audio files (e.g., MP3, WAV) generated by the Eleven Labs API are stored in a dedicated subdirectory (e.g., `uploads/podcast_audio/`). The path is recorded in the `Chapter.podcastAudioPath` field.
*   **User-Uploaded Audio:** Any audio files uploaded directly by users (e.g., via `Chapter.userUploadedAudioPath`) would also be stored in an appropriate subdirectory.
*   **Database:** Metadata about all primary stored files (original PDFs, generated podcasts, user-uploaded audio, extracted text files) including their paths, types, and sizes are stored in the relevant Sequelize models (`UploadedFile`, `Chapter`).
*   **Serving Files:**
    *   Uploaded/generated files intended for client access (e.g., podcast audio, user-uploaded chapter audio) are typically served statically via Express: `app.use('/media', express.static(path.join(__dirname, '..', process.env.UPLOAD_DIR)));`. API endpoints would then return URLs like `/media/podcast_audio/chapter_id.mp3`.
    *   Careful consideration should be given to access control for served files, ensuring only authorized users can access specific content. This might involve a separate endpoint that streams files after an auth check.
*   **Security:**
    *   Validate file types and sizes rigorously using Multer or similar mechanisms.
    *   Sanitize filenames to prevent path traversal or other injection attacks.
    *   Ensure that directories used for temporary file storage during processing are properly secured and cleaned up.
*   **Production Note:** For production environments, using cloud storage services (AWS S3, Google Cloud Storage) is strongly recommended over local file system storage. This enhances scalability, durability, security, and performance. Configuration would involve:
    *   Using appropriate Multer storage engines (e.g., `multer-s3`, `multer-google-storage`).
    *   Configuring cloud provider SDKs with necessary credentials (see Section 12 and 13).
    *   Serving files via cloud provider URLs, potentially through a CDN or signed URLs for access control.

## 9. PDF Processing Service

*   **Purpose:** To analyze uploaded PDF files for content extraction, organization, and generation of learning materials.
*   **AI Model:** The service will utilize "Gemini 2.5 Flash" for inference tasks related to content analysis and generation.
*   **Workflow:**
    1.  **PDF Upload:** User uploads a PDF file through a designated endpoint.
    2.  **Class Inference:** The service processes the PDF to infer its main topic or category, assigning it to a "class" (e.g., "Physics", "History of Art", "Mathematics"). This helps in organizing and contextualizing the content.
    3.  **Chapter Segmentation:** For each identified class/document, the service segments the PDF content into logical chapters or sections based on the document's structure and content flow.
    4.  **Summary Generation:** For each chapter, a concise summary of its key content and concepts is generated.
    5.  **Quiz Generation:** For each chapter, a set of multiple-choice questions is generated. Each question will typically have 4 options, a clearly indicated correct answer, and a brief explanation for why the correct answer is right and/or why the distractors are incorrect.
*   **Data Structures:**
    *   The backend will manage data related to the uploaded PDFs, their assigned classes, the derived chapters, chapter summaries, and the generated quiz questions (including questions, options, correct answers, and explanations).
    *   Specific model definitions for `PdfDocument`, `DocumentClass`, `Chapter`, `Summary`, and `QuizQuestion` will be detailed in the "Data Schema" section (Section 5) and implemented using Sequelize.
*   **Integration:** This service will likely involve asynchronous processing. Upon PDF upload, the initial file record is created. The PDF is then queued for processing. The status of processing can be tracked via API calls, and results (chapters, summaries, quizzes) will be associated with the original PDF record once available.

## 10. Podcast Generation Service

*   **Purpose:** To create engaging audio podcast episodes from the textual content derived by the PDF Processing Service, such as chapter summaries or other relevant text segments.
*   **Script Generation:**
    *   The service will first transform the input text (e.g., a chapter summary) into a script suitable for a podcast.
    *   To enhance engagement, scripts will be designed for two distinct voice actors/personalities (e.g., a primary narrator and a co-host or questioner). This may involve rephrasing content, adding conversational elements, or dividing the text into dialogue.
*   **Text-to-Speech (TTS) API:** The "Eleven Labs API" will be used for converting the generated scripts into high-quality audio. This API is chosen for its ability to produce natural-sounding speech and offer voice customization options.
*   **Process:**
    1.  **Input:** The service receives textual content (e.g., chapter summaries from the PDF Processing Service) as input.
    2.  **Scripting:** It processes this text to create a structured script, allocating parts to different "voices" or "personalities."
    3.  **API Interaction:** The service sends script segments to the Eleven Labs API. This may include specifying desired voice characteristics (if available and configured) for each part of the script.
    4.  **Audio Reception & Storage:** The backend receives the generated audio data (e.g., MP3 or WAV files) from the Eleven Labs API and stores it, typically linking it to the source chapter or document. Storage details will align with the strategy in Section 8 (File Handling).
*   **Output:** The generated podcast audio will be made accessible, for instance, via an API endpoint that provides a URL to the stored audio file. This allows the frontend to stream or offer the podcast for download.
*   **Data Structures:**
    *   The backend may need to store metadata about the generated podcast scripts (e.g., the script text, voice assignments).
    *   Information regarding the status of audio generation (e.g., "pending", "completed", "failed") and the storage location (path or URL) of the final audio files will be maintained, likely in a new `PodcastEpisode` model or similar, linked to the relevant `Chapter` or `DocumentClass`.
*   **Dependencies:** This service relies on outputs from the "PDF Processing Service" (Section 9) and external API keys for Eleven Labs, which should be managed via environment variables (e.g., `ELEVENLABS_API_KEY`).

## 11. Error Handling and Validation

*   **Centralized Error Handler (`src/middleware/error.handler.js`):** Catches all errors passed via `next(error)`. Logs errors. Sends standardized JSON error response (status, message, stack in dev).
*   **Custom Error Classes (`src/utils/AppError.js`):** `AppError`, `NotFoundError`, `BadRequestError`, `UnauthorizedError` for specific error types with status codes.
*   **Input Validation (`express-validator`):** Used in route definitions to validate request body, params, queries. See API endpoint examples.
*   **Async Errors:** Controllers use `try...catch` with `next(error)` or a wrapper like `express-async-handler`.

## 12. Contribution and Further Development

*   **Coding Style:** (Suggest ESLint, Prettier setup if desired).
*   **Testing:** (Suggest Jest, Mocha/Chai for unit/integration tests. Example: Test service logic, controller responses).
    ```bash
    # npm test (if test script is configured)
    ```
*   **API Key Management:** Securely manage API keys and credentials for external services:
    *   **Google Cloud (Gemini/Vertex AI):** If using service account keys, store the JSON key file securely and set the `GOOGLE_APPLICATION_CREDENTIALS` environment variable to its path. Do not commit the key file to the repository. For production, prefer workload identity federation or other keyless methods if available and appropriate for your deployment environment.
    *   **Eleven Labs API:** Store your `ELEVENLABS_API_KEY` as an environment variable.
    *   Use `.env` files for local development to store these secrets and ensure `.env` is in `.gitignore`.
    *   In production, use the deployment platform's mechanism for managing secrets/environment variables (e.g., Docker secrets, Kubernetes Secrets, PaaS environment variable configuration).
*   **Logging:** Use a structured logger like Winston or Pino for better log management, especially in production.
*   **Security Headers:** Consider adding security headers using middleware like `helmet`.
*   **Rate Limiting:** Implement rate limiting (e.g., `express-rate-limit`) for public APIs and potentially for calls to external AI services if not handled by their SDKs.
*   **CORS:** Configure `cors` middleware carefully for allowed origins.

## 13. Deployment Considerations

*   **Environment Variables:**
    *   Ensure `NODE_ENV=production` is set.
    *   All necessary environment variables must be configured in the production environment:
        *   `PORT`
        *   Database credentials (`DB_HOST`, `DB_USER`, `DB_PASSWORD`, `DB_NAME`, `DB_PORT`)
        *   `JWT_SECRET` (for session tokens)
        *   `GOOGLE_CLIENT_ID`, `GOOGLE_CLIENT_SECRET` (for Google OAuth)
        *   `API_BASE_URL` (the public URL of your backend for OAuth callbacks)
        *   `GOOGLE_APPLICATION_CREDENTIALS` (if using service account keys for Google Cloud AI) or other GCP authentication setup.
        *   `ELEVENLABS_API_KEY`
        *   `UPLOAD_DIR` (if using local storage, though cloud storage is preferred).
*   **External Service Access:**
    *   The deployment environment must have network access to Google Cloud AI services and the Eleven Labs API.
    *   Ensure any necessary SDKs or client libraries for these services are included in the production build and dependencies.
*   **Process Manager:** Use PM2 or similar to manage Node.js processes.
*   **Database:** Ensure production database is properly backed up and secured.
*   **File Storage:** Strongly consider cloud storage (AWS S3, Google Cloud Storage) for production, especially for PDFs and generated audio files. This will require appropriate cloud provider SDKs and credentials configured.
*   **HTTPS:** Essential for production. Use a reverse proxy (Nginx, Caddy) to handle SSL termination.
*   **Containerization:** Docker can simplify deployment and ensure consistency across environments.
