[
  {
    "node": "start_processing",
    "status": "completed",
    "state_snapshot": {
      "run_id": "a9d3b848-7887-4676-a9e0-4d590ff0b031",
      "pdf_file_paths": [
        "temp_pdf_uploads/a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf"
      ],
      "notebook_title": "",
      "holistic_chapters": [],
      "generated_content": [],
      "final_result": ""
    }
  },
  {
    "node": "start_processing",
    "status": "completed",
    "state_snapshot": {
      "run_id": "a9d3b848-7887-4676-a9e0-4d590ff0b031",
      "pdf_file_paths": [
        "temp_pdf_uploads/a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf"
      ],
      "notebook_title": "",
      "holistic_chapters": [],
      "generated_content": [],
      "final_result": ""
    }
  },
  {
    "node": "analyze_overall_structure",
    "status": "completed",
    "state_snapshot": {
      "run_id": "a9d3b848-7887-4676-a9e0-4d590ff0b031",
      "pdf_file_paths": [
        "temp_pdf_uploads/a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf"
      ],
      "notebook_title": "데이터베이스 정규화: 원리, 과정 및 적용",
      "holistic_chapters": [
        {
          "chapter_title": "데이터베이스 정규화 개요 및 필요성",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "데이터가 혼합될 때 발생하는 문제점(데이터 중복, 일관성 문제, 삽입/삭제/갱신 이상 현상)을 설명하고, 이러한 문제에 대한 해결책으로 데이터베이스 정규화의 필요성과 분해(Decomposition)의 개념, 그리고 손실 분해(Lossy Decomposition)와 무손실 분해(Lossless Decomposition)의 차이를 소개합니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems2\nWhen Data is Jumbled…•Suppose that we combine instructor and department •(Below represents the join on instructor and department)\nECE30030/ITP30010 Database Systems3\nWhen Data is Jumbled…•Key issues•Repetition of data à increases the size of database•Data consistency issues•Insertion anomaly: Inserting redundant data for every new record•Deletion anomaly: Loss of related data, when some data is deleted•Update anomaly: When updating certain information, every single record must be updated\nECE30030/ITP30010 Database Systems4\nSolution: Decomposition!•How to avoid the repetition-of-information problem?\n•A: Decompose it into two schemas (as they were)•Normalization = decomposition of relational schemas•Key idea: split relational schemas such that only directly related data composes a relation\nECE30030/ITP30010 Database Systems5\nDecomposition•Less redundancy à Uses smaller disk storage; Causes less issues associated with insertion, deletion, and update anomalies•Not all decompositions are good•E.g., Suppose we decompose   employee(ID, name, street, city, salary)into  employee1 (ID, name)  employee2 (name, street, city, salary)à Problem: What if there are two employees with the same name?•Lossy decomposition: a decomposition from which the original relation cannot be reconstructedECE30030/ITP30010 Database Systems6\nLossy Decomposition\nECE30030/ITP30010 Database Systems7\nLossless Decomposition•Let R be a relation schema and let R1 and R2 form a decomposition of R; that is, R = R1 U R2•A decomposition is a lossless decomposition if there is no loss of information by replacing R with the two relation schemas R1 U R2•Formally,\nÕR1(r)  ⋈  ÕR2(r) = r•C.f., Conversely, a decomposition is lossy if when the join of the projection results is computed, a proper superset of the original relation is returned     r  Ì  ÕR1(r)  ⋈  ÕR2(r)\nECE30030/ITP30010 Database Systems8\nExample: Lossless Decomposition•Decomposition of R = (A, B, C)  à  R1 = (A, B); R2 = (B, C)\nECE30030/ITP30010 Database Systems9\nNormalization•Database normalization: Process of structuring a database to reduce data redundancy and improve data integrity•In accordance with a series of normal forms (next topic)•Through the process:•One can decompose relations to suppress data anomalies•One can make sure the decomposition is lossless"
        },
        {
          "chapter_title": "데이터베이스 정규화 과정 및 일반 형식",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "데이터베이스 정규화가 관계형 데이터베이스 테이블을 더 높은 정규형으로 설계하는 과정임을 설명하고, 논리적으로 독립적인 데이터를 분리하여 키를 통해 연결하는 점진적인 프로세스를 소개합니다. 또한, UNF, 1NF, 2NF, 3NF, BCNF, 4NF 등 주요 정규형의 종류를 나열하고, 이들이 함수적 종속성 등의 이론적 기반을 가진다는 점을 강조합니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems11\nNormal Forms•Normalization process•Normalization is a database design technique, which is used to design a relational database table up to higher normal form•Procedurally separates logically independent (but related) data entities into multiple relations•Maintains the connections using keys•Progressive process•A higher level of database normalization cannot be achieved unless the previous levels have been satisfied•UNF: Unnormalized form•1NF: First normal form•2NF: Second normal form•3NF: Third normal form•BCNF: Boyce-Codd normal form (3.5NF)•4NF: Fourth normal form•…\nECE30030/ITP30010 Database Systems12\nNormal Forms•Normal forms are backed by a set of normalization theories•Functional dependencies•Partial dependencies•Transitive dependencies•Multi-valued dependencies•These theories decide whether a particular relation R is in “good form”•For a relation R is not in “good form”, decompose it into a set of relations {R1, R2, ..., Rn} such that•Each relation is in good form•The decomposition is a lossless decomposition"
        },
        {
          "chapter_title": "함수적 종속성 이해",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "함수적 종속성(Functional Dependency, FD)의 개념을 정의하고, 실제 데이터 제약 조건과의 연관성을 설명합니다. 릴레이션 스키마에서 속성 집합 간의 결정 관계를 예시를 통해 보여주며, 슈퍼 키와 후보 키와의 관계, 그리고 항상 만족되는 자명한 함수적 종속성(Trivial Functional Dependencies)에 대해 다룹니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems15\nFunctional Dependencies•There are usually a variety of constraints (rules) on the data in the real world•E.g., some of the constraints that are expected to hold in the university database are:•Students and instructors are uniquely identified by their ID•Each student and instructor has only one name•Each instructor and student is associated with only one department•Each department has only one value for its budget, and only one associated building•Relations require that the value for a certain set of attributes determines uniquely the value for another set of attributes•A functional dependency is a generalization of the notion of a key(= trivial dependency)\nECE30030/ITP30010 Database Systems16\nFunctional Dependencies•Let R be a relation schema, a and b be its attributes (a Í R and b Í R)•The functional dependency a ® b  holds on R if and only if, for any relations r(R), whenever any two tuples t1 and t2 of r agree on the attributes a, they also agree on the attributes b•That is,  t1[a] = t2 [a]    Þ    t1[b ] = t2 [b ]•E.g., Consider r(A,B) with the following instance of r\nA     B  1     4  1     5  3     7\n•On this instance, B ® A hold;  A ® B does NOT hold (only the values of B are unique)\nECE30030/ITP30010 Database Systems17\nKeys and Functional Dependencies•Functional dependencies allow us to express constraints that cannot be expressed using super keys•E.g., consider the schema:\nin_dep (ID, name, salary, dept_name, building, budget )•ID = instructor ID•dept_name = department of the instructor•We expect the following functional dependencies to hold:•dept_name ® building•ID ® buildingÞdept_name and ID are super keys = candidate keys* ID, dept_name, {ID, dept_name}•We would not expect the next to hold:•dept_name ® salary\nECE30030/ITP30010 Database Systems18\nFunctional Dependencies•For relation R = a1 a2 a3 a4\n•a1 is a part of the key•Functional dependency: a4 depends on its key, a1a2a3•b_id,  b_name, bd_detail_attrib1, , bd_detail_attrib2•Candidate keys: b_id, b_name, {b_id, b_name}•It should not be such that a4 depends on a1, and does not depend on a1a2a3 (a1 ➝ a4)  ⇒  partial dependency\nECE30030/ITP30010 Database Systems19\nCandidate key = a1, a2, a3, {a1, a2}, {a2,a3}, {a1, a3}, {a1,a2,a3}\nTrivial Functional Dependencies•A functional dependency is trivial if it is satisfied by all instances of a relation•Example:•ID, name ® ID•name ® name•In general, a ® b is trivial if b Í a\nECE30030/ITP30010 Database Systems20\nFunctional Dependencies•Example: student2(ID, name, tot_cred)•Hold•ID à name•ID à tot_cred•Not hold•tot_cred à name•name à tot_cred\nECE30030/ITP30010 Database Systems21\nFunctional Dependencies•score(score_id, student_id, subject_id, score)•{student_id, subject_id} à score\nECE30030/ITP30010 Database Systems22\nECE30030/ITP30010 Database Systems22\nECE30030/ITP30010 Database Systems67\nFunctional Dependencies•There are usually a variety of constraints (rules) on the data in the real world•E.g., some of the constraints that are expected to hold in a university database are:•Students and instructors are uniquely identified by their ID•Each student and instructor has only one name•Each instructor and student is (primarily) associated with only one department•Each department has only one value for its budget, and only one associated building•Relations require that the value for a certain set of attributes determines uniquely the value for another set of attributes•A functional dependency is a generalization of the notion of a key(= trivial dependency)\nECE30030/ITP30010 Database Systems68\nFunctional Dependencies•Let R be a relation schema, a and b be its attributes (a Í R and b Í R)•The functional dependency a ® b  holds on R if and only if, for any relations r(R), whenever any two tuples t1 and t2 of r agree on the attributes a, they also agree on the attributes b•That is,  t1[a] = t2 [a]    Þ    t1[b ] = t2 [b ]•E.g., Consider r(A,B) with the following instance of r\nA     B  1     4  1     5  3     7\n•On this instance, B ® A hold;  A ® B does NOT hold (only the values of B are unique)\nECE30030/ITP30010 Database Systems69\nKeys and Functional Dependencies•Functional dependencies allow us to express constraints that cannot be expressed using super keys•E.g., consider the schema:\nin_dep (ID, name, salary, dept_name, building, budget )•ID = instructor ID•dept_name = department of the instructor•We expect the following functional dependencies to hold:•dept_name® building•ID à buildingÞdept_name and ID are super keys = candidate keys* ID, dept_name, {ID, dept_name}•We would not expect the next to hold:•dept_name ® salary\nECE30030/ITP30010 Database Systems70\nFunctional Dependencies•For relation R = a1 a2 a3 a4\n•a1 is a part of the key•Functional dependency: a4 depends on its key, a1a2a3•b_id,  b_name, bd_detail_attrib1, , bd_detail_attrib2•Candidate keys: b_id, b_name, {b_id, b_name}•It should not be such that a4 depends on a1, and does not depend on a1a2a3 (a1 ➝ a4)  ⇒  partial dependency\nECE30030/ITP30010 Database Systems71\nCandidate key = a1, a2, a3, {a1, a2}, {a2,a3}, {a1, a3}, {a1,a2,a3}\nTrivial Functional Dependencies•A functional dependency is trivial if it is satisfied by all instances of a relation•Example:•ID, name ® ID•name ® name•In general, a ® b is trivial if b Í a\nECE30030/ITP30010 Database Systems72\nFunctional Dependencies•student2(ID, name, tot_cred)•ID à name•ID à tot_cred•tot_cred à name (X)\nECE30030/ITP30010 Database Systems73\nFunctional Dependencies•SCORE(score_id, student_id, subject_id, score)•{student_id, subject_id} à score"
        },
        {
          "chapter_title": "제1 정규형 (1NF): 원자성 및 고유성",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "제1 정규형(1NF)의 요구사항을 설명하며, 모든 속성 값이 원자적이어야 하고, 각 컬럼은 동일한 데이터 도메인 내의 값을 포함하며, 고유한 이름을 가져야 한다는 점을 강조합니다. 중복된 행이 없어야 하며, 기본 키(PK)가 고유성과 Not Null을 보장하는 역할을 설명하고, 실제 예시를 통해 1NF로의 변환 과정을 보여줍니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems13\nFirst Normal Form (1NF)•Requirements•A relation should consist of atomic values•Atomic value: a value that cannot be divided (≃primitive data types in JAVA)•Atomic - INT, FLOAT, DOUBLE, DECIMAL (NUMERIC), CHAR, VARCHAR, BLOB, TEXT•NOGO - Structure, List (array)•Attributes should have unique identifiers•Step 1 of the normalization process•“If the tables in your DB does not follow 1NF, stop using database”\nECE30030/ITP30010 Database Systems14\nFirst Normal Form (1NF)•1NF checklist1.Each column should contain an atomic value•Entries like (x, y) violate this rule2.Each column should contain values that are in the same data domain•Do not mix different types of values in a column3.Each column should have a unique name•Duplicate names lead to confusion while accessing data4.The order in which data is stored does not matter•Using SQL, one can easily fetch data in any order5.There are no duplicated rows in the table•Primary key (PK) ensures: •Attributes that are part of PK are unique•Attributes that are part of PK are not null\nECE30030/ITP30010 Database Systems23\nFirst Normal Form (1NF)•Example\nstudent_idnamecourse\n21800999James InexistenteAlgorithm, OS\n21800998Mike InexistenteJava\n21800997Matt InexistenteAlgorithm, DB\nECE30030/ITP30010 Database Systems24\nFirst Normal Form (1NF)•Example\nstudent_idname\n21800999James Inexistente\n21800998Mike Inexistente\n21800997Matt Inexistente\nstudent_idcourse\n21800999Algorithm\n21800999OS\n21800998Java\n21800997Algorithm\n21800997DB\nECE30030/ITP30010 Database Systems25\nFirst Normal Form (1NF)•Example\nstudent_idname\n21800999James Inexistente\n21800998Mike Inexistente\n21800997Matt Inexistente\nstudent_idcourse\n21800999Algorithm\n21800999OS\n21800998Java\n21800997Algorithm\n21800997DB"
        },
        {
          "chapter_title": "제2 정규형 (2NF): 부분 종속성 제거",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "제2 정규형(2NF)의 요구사항을 설명하며, 1NF를 만족하고 기본 키가 아닌 속성이 후보 키의 어떤 부분 집합에도 함수적으로 종속되지 않아야 함을 강조합니다. 부분 종속성(Partial Dependency)의 정의와 이를 제거하기 위한 관계 분해(Decomposition) 과정을 다양한 예시를 통해 구체적으로 설명합니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems26\nSecond Normal Form (2NF)•Requirements•A relation should be in 1NF (normal forms should be applied in order)•A relation should NOT have a non-PK that is functionally dependent on any subset of any candidate key = NO PARTIAL DEPENDENCIES!•Any attributes other than PK should be dependent on PK•It should not have partial dependencies•PK: Primary Key•An attribute or a set of attributes that uniquely identifies each tuple in a relation•A PK can fetch data from any specific data in a relation•E.g., get the department name of student_ID = 21800999\nECE30030/ITP30010 Database Systems27\nPartial Dependencies•For relation R = a1 a2 a3 a4\n•a1 is a part of the primary key•Partial dependency: a4 depends on a1, and does not depend on a1a2a3•Key: a1 a2 a3•Dependency: a1 ➝ a4\nPrimary key (Composite)\nECE30030/ITP30010 Database Systems28\nEliminating Partial Dependencies•Example: teaches2(ID, course_id, sec_id, semester, year, name)•ID à name\nECE30030/ITP30010 Database Systems29\nEliminating Partial Dependencies•Example: •teaches2a(ID, course_id, sec_id, semester, year)•teaches2b(ID, name)\nECE30030/ITP30030Database Systems 30\nEliminating Partial Dependencies•Example: score(score_id, student_id, subject_id, score, instructor)•subject_id à instructor : partial dependency\nscore_idstudent_idsubject_idscoreinstructor\n1 10 1 82James Packer\n3 11 1 95James Packer\n2 10 2 77Cole Miller\n4 11 2 71Cole Miller\n5 11 4 96Adam Lee\nECE30030/ITP30030Database Systems 31\nEliminating Partial Dependencies•Example: score_a(score_id, student_id, subject_id, score)                 score_b(subject_id, instructor)\nscore_idstudent_idsubject_idscore\n1 10 1 82\n3 11 1 95\n2 10 2 77\n4 11 2 71\n5 11 4 96\nsubject_idinstructor\n1 James Packer\n2 Cole Miller\n4 Adam Lee\nECE30030/ITP30010 Database Systems74\nPartial Dependencies•For relation R = a1 a2 a3 a4\n•a1 is a part of the primary key•a4 depends on a1, and does not depend on a1a2a3 (a1 ➝ a4)•Key: a1 a2 a3•Dependency: a1 ➝ a4\nPrimary key (Composite)\nECE30030/ITP30010 Database Systems75\nPartial Dependencies•teaches2(ID, course_id, sec_id, semester, year, name)•ID à name•{course_id, sec_id, semester, year} à name\nECE30030/ITP30010 Database Systems76\nPartial Dependencies•SCORE(score_id, student_id, subject_id, score, instructor)•subject_id à instructor (partial dependency) :: WE DON’T WANT TO HAVE THIS"
        },
        {
          "chapter_title": "제3 정규형 (3NF): 이행적 종속성 제거",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "제3 정규형(3NF)의 요구사항을 설명하며, 2NF를 만족하고 이행적 종속성(Transitive Dependency)이 없어야 함을 강조합니다. 이행적 종속성은 기본 키가 아닌 속성이 다른 기본 키가 아닌 속성에 종속되는 경우를 의미하며, 이를 제거하기 위한 관계 분해 과정을 다양한 도서 및 시험 점수 관리 예시를 통해 상세히 제시합니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems32\nThird Normal Form (3NF)•Requirements•A relation should be in 2NF •A relation should NOT have transitive dependencies•Transitive dependency: A non-PK attribute depends on another non-PK attribute or a set of non-PK attributes\nECE30030/ITP30010 Database Systems33\nTransitive Dependencies•For relation R = a1 a2 a3 a4\n•a1 is the primary key in R•a3 depends on a1 (a1 ➝ a3) -- OK•a4 depends on a3 (a1 ➝ a3 ➝ a4) … non-PK à non-PK\nCandidate key = a1, a2, {a1,a2}\nECE30030/ITP30010 Database Systems34\nEliminating Transitive Dependencies•Example\nBookNoPatronAddressDue\nB1J. Fisher101 Main Street3/2/15\nB2L. Perez202 Market Street 2/28/15\nECE30030/ITP30010 Database Systems35\nEliminating Transitive Dependencies•Example\n•PK: BookNo•Patron à Address\nBookNoPatronAddressDue\nB1J. Fisher101 Main Street3/2/15\nB2L. Perez202 Market Street 2/28/15\nECE30030/ITP30010 Database Systems36\nEliminating Transitive Dependencies•Example\nBookNoPatronDue\nB1J. Fisher3/2/15\nB2L. Perez2/28/15PatronAddressJ. Fisher101 Main StreetL. Perez202 Market Street\nECE30030/ITP30010 Database Systems37\nEliminating Transitive Dependencies•Example\n•PK: {Tournament, Year}•Winner à DOB\nTournamentYearWinner DOB\nIndiana Invitational1998Al Fredrickson21 July 1975\nCleveland Open1999Bob Albertson28 Sept. 1968\nDes Moines Masters1999Al Fredrickson21 July 1975\nECE30030/ITP30010 Database Systems38\nEliminating Transitive Dependencies•Example: score2(id, student_id, subject_id, exam_name, exam_score)•{student_id, subject_id} --> FINAL or MIDTERM•{student_id, subject_id} --> 77   43 … from which ?•{student_id, subject_id} à exam_name à exam_score :: transitive dependency\nECE30030/ITP30010 Database Systems39\nEliminating Transitive Dependencies•Example: score2(id, student_id, subject_id, exam_name, exam_score)•student_id, subject_id à exam_name•student_id, subject_id à exam_name à exam_score\nECE30030/ITP30010 Database Systems40\nEliminating Transitive Dependencies•Example: score2a(id, student_id, subject_id, exam_id, exam_name)                 score2b(student_id, subject_id, exam_id, exam_score)\nECE30030/ITP30010 Database Systems77\nTransitive Dependencies•For relation R = a1 a2 a3 a4\n•a1 is the primary key in R•a3 depends on a1 (a1 ➝ a3) -- OK•a4 depends on a3 (a1 ➝ a3 ➝ a4) … non-PK à non-PK\nCandidate key = a1, a2, {a1,a2}\nECE30030/ITP30010 Database Systems78\nTransitive Dependencies•EXAM_SCORE(id, student_id, subject_id, exam_name, exam_score)•{student_id, subject_id} --> FINAL or MIDTERM•{student_id, subject_id} --> 77   43 … from which ?•{student_id, subject_id} à exam_name à exam_score :: transitive dependency"
        },
        {
          "chapter_title": "보이스-코드 정규형 (BCNF): 강화된 제3 정규형",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "보이스-코드 정규형(BCNF)은 제3 정규형을 강화한 형태로, A → B 종속성이 있을 때 A가 반드시 슈퍼 키여야 한다는 요구사항을 설명합니다. 즉, 기본 키가 아닌 속성이 기본 키의 일부를 결정하는 경우가 없어야 하며, 이를 위반하는 사례와 BCNF를 만족하도록 관계를 분해하는 과정을 예시를 통해 보여줍니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems41\nBoyce-Codd Normal Form (BCNF) = 3.5NF•Requirements•A relation should be in 3NF•For any dependency A à B, A should be a super key•For A à B, if A is non-PK, then it is NOT in BCNF\nECE30030/ITP30010 Database Systems42\nBoyce-Codd Normal Form (BCNF)•Example: takes2(student_id, subject, instructor)\n•(student, subject) à instructor•Instructor à subject•A non-PK identifies a member of PK: Not in BCNF\nstudent_idsubjectinstructor\n21800999C++ Dr. Cpp\n21800999Java Dr. Java\n21800998C++ Dr. C\n21800997PythonDr. Python\n21800996C++ Dr. Cpp\nECE30030/ITP30010 Database Systems43\nBoyce-Codd Normal Form (BCNF)•Example: takes2a(student_id, section_id),\ntakes2b(section_id, subject, instructor)\nstudent_idsection_id\n21800999101\n21800999103\n21800998102\n21800997104\n21800996101section_idsubjectinstructor\n101 C++ Dr. Cpp\n103 Java Dr. Java\n102 C++ Dr. C\n104 PythonDr. Python\nECE30030/ITP30010 Database Systems44\nBoyce-Codd Normal Form (BCNF)•Example: takes2a(student_id, section_id),\ntakes2b(section_id, subject, instructor)\nstudent_idsection_id\n21800999101\n21800999103\n21800998102\n21800997104\n21800996101section_idsubjectinstructor\n101 C++ Dr. Cpp\n103 Java Dr. Java\n102 C++ Dr. C\n104 PythonDr. Python"
        },
        {
          "chapter_title": "제4 정규형 (4NF): 다치 종속성 제거",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "제4 정규형(4NF)의 요구사항을 설명하며, BCNF를 만족하고 다치 종속성(Multi-valued Dependency, MVD)이 없어야 함을 강조합니다. 다치 종속성은 릴레이션에 3개 이상의 속성이 있고, 서로 독립적인 다치 속성 집합이 존재할 때 발생할 수 있으며, 이를 제거하기 위한 관계 분해 과정을 학생의 수강 과목 및 활동 예시를 통해 설명합니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems45\nFourth Normal Form (4NF)•Requirements•A relation should be in BCNF•A relation should NOT have multi-valued dependency•Multi-valued dependency occurs due to a bad DB schema•Multi-valued dependency occurs when a relation has more than 3 attributes•For a relation with attributes A, B, C•having dependency, A à B, and•B and C are independent from each otherè Then, the relation may have a multi-valued dependency\nECE30030/ITP30010 Database Systems46\nMulti-valued Dependencies•Example•student_id à course•student_id à activity•course ⊥ activity (independent)\nstudent_idcourseactivity\n21800999StatisticsSoccer\n21800999Linear algebraBasketball\n21800999StatisticsBasketball\n21800999Linear algebraSoccer\nECE30030/ITP30010 Database Systems47\nMulti-valued Dependencies•Example\nstudent_idcourse\n21800999Statistics\n21800999Linear algebra\n21800998Physics\n21800998Programming 101student_idactivity\n21800999Soccer\n21800999Basketball\n21800998Pool\n21800997Soccer\nECE30030/ITP40001 Database Systems79\nMulti-valued Dependencies (MVDs)•Suppose we record names of children, and phone numbers for instructors•inst_child(ID, child_name)•inst_phone(ID, phone_number)à If we combine these schemas to obtain: (multiple orthogonal values in single table à this causes redundancy)•inst_info(ID, child_name, phone_number)à Example tuples: ID=999999 à {David, William} & {x-x-1234, x-x-4321}  (99999, David, 512-555-1234)  (99999, David, 512-555-4321)  (99999, William, 512-555-1234)  (99999, William, 512-555-4321)•Any issues?\nECE30030/ITP40001 Database Systems80\nMulti-valued Dependencies (MVDs)•Let R be a relation schema and let a Í R and b Í R. •The multivalued dependency a ®® b holds on R if in any relation r(R), for all pairs for tuples t1 and t2 in r such that t1[a] = t2 [a], there exist tuples t3 and t4 in r such that:    t1[a] = t2 [a] = t3 [a] = t4 [a]           t3[b] =  t1 [b]           t3[R  – b] =  t2[R  – b]           t4 [b] =  t2[b]           t4[R  – b] =  t1[R  – b]\nECE30030/ITP40001 Database Systems81\nMulti-valued Dependencies (MVDs)•Let R be a relation schema with a set of attributes that are partitioned into 3 non-empty subsets Y, Z, W•We say that Y ®® Z (Y multidetermines Z )if and only if for all possible relations r(R)  < y1, z1, w1 > Î r and < y1, z2, w2 > Î rthen  < y1, z1, w2 > Î r and < y1, z2, w1 > Î r•Note that since the behavior of Z and W are identical it follows that Y ®® Z if Y ®® W\nECE30030/ITP40001 Database Systems82\nMulti-valued Dependencies (MVDs)•Tabular representation of a ®® b\nECE30030/ITP40001 Database Systems83\nMulti-valued Dependencies (MVDs)•FAV(student_id, course, activity)•21800999 - {statistics, Linear algebra} & {Soccer, basketball}•Favorite courses & favorite activities <= they are orthogonal\nstudent_idcourseactivity\n21800999StatisticsSoccer\n21800999Linear algebraBasketball\n21800999StatisticsBasketball\n21800999Linear algebraSoccer"
        },
        {
          "chapter_title": "정규화 이론 및 종속성 요약",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "각 정규형(2NF, 3NF, BCNF, 4NF, 5NF)과 관련된 핵심 이론 및 종속성(함수적, 부분, 이행적, 다치, 조인 종속성)을 요약하여 제시합니다. 정규화 이론이 '좋은 형태'의 릴레이션을 결정하고 무손실 분해를 통해 이를 달성하는 데 사용됨을 강조하며, 함수적 종속성과 다치 종속성이 데이터베이스의 유효성 검사 및 제약 조건 지정에 어떻게 활용되는지 설명합니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems48\nSummary: Normal Forms•Theories – Normal forms\nTheory Key IdeaNormal Form\nFunctional dependency(PK à non-PK)2NF\nPartial dependencyPart of PK à non-PK2NF\nTransitive dependencyNon-PK à non-PK3NF\n- Non-PK à PK BCNF\nMulti-valued dependency4NF\nJoin dependency5NF\nECE30030/ITP30010 Database Systems65\nNormalization Theory•Decide whether a particular relation R is in “good form”•For a relation R is not in “good form”, decompose it into a set of relations {R1, R2, ..., Rn} such that•Each relation is in good form•The decomposition is a lossless decomposition\nECE30030/ITP30010 Database Systems66\nNormalization Theory•The normalization is based on a set of relevant theories:•Functional dependencies•Partial dependencies•Transitive dependencies•Multivalued dependencies\nECE30030/ITP40001 Database Systems84\nUse of Functional Dependencies•We use functional dependencies to:•Test relations to see if they are legal under a given set of functional dependencies•We say that r satisfies F, if a relation r is legal under a set F of functional dependencies•To specify constraints on the set of legal relations•We say that F holds on R if all legal relations on R satisfy the set of functional dependencies F•Note:  A specific instance of a relation schema may satisfy a functional dependency even if the functional dependency does not hold on all legal instances•E.g., a specific instance of instructor may, by chance, satisfy:  name ® ID\nECE30030/ITP40001 Database Systems85\nUse of Multi\n-\nvalued Dependencies•We use multivalued dependencies in two ways:1.To test relations to determine whether they are legal under a given set of functional and multivalued dependencies2.To specify constraints on the set of legal relations. We shall concern ourselves only with relations that satisfy a given set of functional and multivalued dependencies•If a relation r fails to satisfy a given multivalued dependency, we can construct a relations r¢  that does satisfy the multivalued dependency by adding tuples to r"
        },
        {
          "chapter_title": "정규화 실전 예시",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "위키피디아에서 가져온 서적 소매업 데이터베이스 예시를 통해 데이터베이스 정규화 과정을 단계별로 상세히 설명합니다. 1NF, 2NF, 3NF, BCNF, 그리고 4NF를 만족하도록 테이블을 분해하고 종속성을 제거하는 실제 적용 사례를 보여주며, 각 정규형의 요구사항이 어떻게 충족되는지 시각적으로 제시합니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems53\nExample (taken from Wikipedia)•Provided:\nECE30030/ITP30010 Database Systems54\nExample (taken from Wikipedia)•Satisfying 1NF\nECE30030/ITP30010 Database Systems55\nExample (taken from Wikipedia)•Satisfying 1NF (cont’d – further improvement)\nECE30030/ITP30010 Database Systems56\nExample (taken from Wikipedia)•Provided:\n•Compound key {Title, Format}•Partial dependency: Title à Author, Author Nationality, Pages, Thickness, Genre ID, Genre Name, Publisher ID\nECE30030/ITP30010 Database Systems57\nExample (taken from Wikipedia)•Satisfying 2NF\nECE30030/ITP30010 Database Systems58\nExample (taken from Wikipedia)•Satisfying 3NF\n•Transitive dependency: Genre ID à Genre Name\nECE30030/ITP30010 Database Systems59\nExample (taken from Wikipedia)•Satisfying 3NF\nECE30030/ITP30010 Database Systems60\nExample (taken from Wikipedia)•Satisfying BCNF\n•Non-PK à Non-PK: Author à Author Nationality\nECE30030/ITP30010 Database Systems61\nExample (taken from Wikipedia)•Satisfying BCNF\nECE30030/ITP30010 Database Systems62\nExample (taken from Wikipedia)•Provided:•Assume the database is owned by a book retailer franchise that has several franchisees that own shops in different locations\nECE30030/ITP30010 Database Systems63\nExample (taken from Wikipedia)•Satisfying 4NF•If we assume that all available books are offered in each area, the Title is not unambiguously bound to a certain Locationà Does not satisfy 4NF\nECE30030/ITP30030Database Systems 64\n•Source: https://en.wikipedia.org/wiki/Database_normalization"
        },
        {
          "chapter_title": "데이터베이스 설계 과정 및 비정규화",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "데이터베이스 설계 과정에서 정규화가 어떻게 통합되는지 설명합니다. E-R 모델 설계의 중요성과 정규화의 관계를 다루고, 성능 향상을 위해 의도적으로 정규화되지 않은 스키마를 사용하는 비정규화(Denormalization)의 개념과 그 장단점을 제시합니다. 또한, 연도별 수익 데이터와 같은 특정 설계 문제가 정규화만으로는 해결되지 않을 수 있음을 지적하며 더 나은 스키마 설계를 제안합니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems49\nOverall DB Design Process•Let us assume schema R is given:(E-R Model)•R could have been generated when converting E-R diagram to a set of tables(Normalization)•R could have been a single relation containing all attributes that are of interest (called universal relation)•Normalization breaks R into smaller relations(Mixed)•R could have been the result of some ad-hoc design of relations, which we then test/convert to normal form\nECE30030/ITP30010 Database Systems50\nE-R Model and Normalization•When an E-R diagram is carefully designed, identifying all entities correctly, the tables generated from the E-R diagram should not need further normalization•However, in a real (imperfect) design, there can be functional dependencies from non-key attributes of an entity to other attributes of the entity•E.g., an employee entity with•attributesdepartment_name and building•functional dependencydepartment_name® building•Good design would have made department an entity•Functional dependencies from non-key attributes of a relationship set possible, but rare --- most relationships are binary\nECE30030/ITP30010 Database Systems51\nDenormalization for Performance•We may want to use non-normalized schema for performance•For example, displaying prereqs along with course_id, and title requires join of course with prereq•Alternative 1: Use denormalized relation containing attributes of course as well as prereq with all above attributes•faster lookup•extra space and extra execution time for updates•extra coding work for programmer and possibility of error in extra code•Alternative 2: Use a materialized view defined a course ⋈ prereq•Benefits and drawbacks same as above, except no extra coding work for programmer and avoids possible errors\nECE30030/ITP30010 Database Systems52\nRemaining Issues•Some aspects of database design are not caught by normalization•Example (to be avoided)•earnings_2004, earnings_2005, earnings_2006, etc., all on the schema (company_id, earnings)•Above are well normalized (in BCNF), but make querying across years difficult and needs new table each year•company_year (company_id, earnings_2004, earnings_2005,  earnings_2006)•Above are well normalized (in BCNF), but makes querying across years difficult and requires new attribute each year•This is an example of a crosstab, where values for one attribute become column namesà Better schema: earnings (company_id, year, amount)"
        }
      ],
      "generated_content": [],
      "final_result": ""
    }
  },
  {
    "node": "start_processing",
    "status": "completed",
    "state_snapshot": {
      "run_id": "a9d3b848-7887-4676-a9e0-4d590ff0b031",
      "pdf_file_paths": [
        "temp_pdf_uploads/a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf"
      ],
      "notebook_title": "",
      "holistic_chapters": [],
      "generated_content": [],
      "final_result": ""
    }
  },
  {
    "node": "start_processing",
    "status": "completed",
    "state_snapshot": {
      "run_id": "a9d3b848-7887-4676-a9e0-4d590ff0b031",
      "pdf_file_paths": [
        "temp_pdf_uploads/a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf"
      ],
      "notebook_title": "",
      "holistic_chapters": [],
      "generated_content": [],
      "final_result": ""
    }
  },
  {
    "node": "analyze_overall_structure",
    "status": "completed",
    "state_snapshot": {
      "run_id": "a9d3b848-7887-4676-a9e0-4d590ff0b031",
      "pdf_file_paths": [
        "temp_pdf_uploads/a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf"
      ],
      "notebook_title": "데이터베이스 정규화: 원리, 과정 및 적용",
      "holistic_chapters": [
        {
          "chapter_title": "데이터베이스 정규화 개요 및 필요성",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "데이터가 혼합될 때 발생하는 문제점(데이터 중복, 일관성 문제, 삽입/삭제/갱신 이상 현상)을 설명하고, 이러한 문제에 대한 해결책으로 데이터베이스 정규화의 필요성과 분해(Decomposition)의 개념, 그리고 손실 분해(Lossy Decomposition)와 무손실 분해(Lossless Decomposition)의 차이를 소개합니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems2\nWhen Data is Jumbled…•Suppose that we combine instructor and department •(Below represents the join on instructor and department)\nECE30030/ITP30010 Database Systems3\nWhen Data is Jumbled…•Key issues•Repetition of data à increases the size of database•Data consistency issues•Insertion anomaly: Inserting redundant data for every new record•Deletion anomaly: Loss of related data, when some data is deleted•Update anomaly: When updating certain information, every single record must be updated\nECE30030/ITP30010 Database Systems4\nSolution: Decomposition!•How to avoid the repetition-of-information problem?\n•A: Decompose it into two schemas (as they were)•Normalization = decomposition of relational schemas•Key idea: split relational schemas such that only directly related data composes a relation\nECE30030/ITP30010 Database Systems5\nDecomposition•Less redundancy à Uses smaller disk storage; Causes less issues associated with insertion, deletion, and update anomalies•Not all decompositions are good•E.g., Suppose we decompose   employee(ID, name, street, city, salary)into  employee1 (ID, name)  employee2 (name, street, city, salary)à Problem: What if there are two employees with the same name?•Lossy decomposition: a decomposition from which the original relation cannot be reconstructedECE30030/ITP30010 Database Systems6\nLossy Decomposition\nECE30030/ITP30010 Database Systems7\nLossless Decomposition•Let R be a relation schema and let R1 and R2 form a decomposition of R; that is, R = R1 U R2•A decomposition is a lossless decomposition if there is no loss of information by replacing R with the two relation schemas R1 U R2•Formally,\nÕR1(r)  ⋈  ÕR2(r) = r•C.f., Conversely, a decomposition is lossy if when the join of the projection results is computed, a proper superset of the original relation is returned     r  Ì  ÕR1(r)  ⋈  ÕR2(r)\nECE30030/ITP30010 Database Systems8\nExample: Lossless Decomposition•Decomposition of R = (A, B, C)  à  R1 = (A, B); R2 = (B, C)\nECE30030/ITP30010 Database Systems9\nNormalization•Database normalization: Process of structuring a database to reduce data redundancy and improve data integrity•In accordance with a series of normal forms (next topic)•Through the process:•One can decompose relations to suppress data anomalies•One can make sure the decomposition is lossless"
        },
        {
          "chapter_title": "데이터베이스 정규화 과정 및 일반 형식",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "데이터베이스 정규화가 관계형 데이터베이스 테이블을 더 높은 정규형으로 설계하는 과정임을 설명하고, 논리적으로 독립적인 데이터를 분리하여 키를 통해 연결하는 점진적인 프로세스를 소개합니다. 또한, UNF, 1NF, 2NF, 3NF, BCNF, 4NF 등 주요 정규형의 종류를 나열하고, 이들이 함수적 종속성 등의 이론적 기반을 가진다는 점을 강조합니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems11\nNormal Forms•Normalization process•Normalization is a database design technique, which is used to design a relational database table up to higher normal form•Procedurally separates logically independent (but related) data entities into multiple relations•Maintains the connections using keys•Progressive process•A higher level of database normalization cannot be achieved unless the previous levels have been satisfied•UNF: Unnormalized form•1NF: First normal form•2NF: Second normal form•3NF: Third normal form•BCNF: Boyce-Codd normal form (3.5NF)•4NF: Fourth normal form•…\nECE30030/ITP30010 Database Systems12\nNormal Forms•Normal forms are backed by a set of normalization theories•Functional dependencies•Partial dependencies•Transitive dependencies•Multi-valued dependencies•These theories decide whether a particular relation R is in “good form”•For a relation R is not in “good form”, decompose it into a set of relations {R1, R2, ..., Rn} such that•Each relation is in good form•The decomposition is a lossless decomposition"
        },
        {
          "chapter_title": "함수적 종속성 이해",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "함수적 종속성(Functional Dependency, FD)의 개념을 정의하고, 실제 데이터 제약 조건과의 연관성을 설명합니다. 릴레이션 스키마에서 속성 집합 간의 결정 관계를 예시를 통해 보여주며, 슈퍼 키와 후보 키와의 관계, 그리고 항상 만족되는 자명한 함수적 종속성(Trivial Functional Dependencies)에 대해 다룹니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems15\nFunctional Dependencies•There are usually a variety of constraints (rules) on the data in the real world•E.g., some of the constraints that are expected to hold in the university database are:•Students and instructors are uniquely identified by their ID•Each student and instructor has only one name•Each instructor and student is associated with only one department•Each department has only one value for its budget, and only one associated building•Relations require that the value for a certain set of attributes determines uniquely the value for another set of attributes•A functional dependency is a generalization of the notion of a key(= trivial dependency)\nECE30030/ITP30010 Database Systems16\nFunctional Dependencies•Let R be a relation schema, a and b be its attributes (a Í R and b Í R)•The functional dependency a ® b  holds on R if and only if, for any relations r(R), whenever any two tuples t1 and t2 of r agree on the attributes a, they also agree on the attributes b•That is,  t1[a] = t2 [a]    Þ    t1[b ] = t2 [b ]•E.g., Consider r(A,B) with the following instance of r\nA     B  1     4  1     5  3     7\n•On this instance, B ® A hold;  A ® B does NOT hold (only the values of B are unique)\nECE30030/ITP30010 Database Systems17\nKeys and Functional Dependencies•Functional dependencies allow us to express constraints that cannot be expressed using super keys•E.g., consider the schema:\nin_dep (ID, name, salary, dept_name, building, budget )•ID = instructor ID•dept_name = department of the instructor•We expect the following functional dependencies to hold:•dept_name ® building•ID ® buildingÞdept_name and ID are super keys = candidate keys* ID, dept_name, {ID, dept_name}•We would not expect the next to hold:•dept_name ® salary\nECE30030/ITP30010 Database Systems18\nFunctional Dependencies•For relation R = a1 a2 a3 a4\n•a1 is a part of the key•Functional dependency: a4 depends on its key, a1a2a3•b_id,  b_name, bd_detail_attrib1, , bd_detail_attrib2•Candidate keys: b_id, b_name, {b_id, b_name}•It should not be such that a4 depends on a1, and does not depend on a1a2a3 (a1 ➝ a4)  ⇒  partial dependency\nECE30030/ITP30010 Database Systems19\nCandidate key = a1, a2, a3, {a1, a2}, {a2,a3}, {a1, a3}, {a1,a2,a3}\nTrivial Functional Dependencies•A functional dependency is trivial if it is satisfied by all instances of a relation•Example:•ID, name ® ID•name ® name•In general, a ® b is trivial if b Í a\nECE30030/ITP30010 Database Systems20\nFunctional Dependencies•Example: student2(ID, name, tot_cred)•Hold•ID à name•ID à tot_cred•Not hold•tot_cred à name•name à tot_cred\nECE30030/ITP30010 Database Systems21\nFunctional Dependencies•score(score_id, student_id, subject_id, score)•{student_id, subject_id} à score\nECE30030/ITP30010 Database Systems22\nECE30030/ITP30010 Database Systems22\nECE30030/ITP30010 Database Systems67\nFunctional Dependencies•There are usually a variety of constraints (rules) on the data in the real world•E.g., some of the constraints that are expected to hold in a university database are:•Students and instructors are uniquely identified by their ID•Each student and instructor has only one name•Each instructor and student is (primarily) associated with only one department•Each department has only one value for its budget, and only one associated building•Relations require that the value for a certain set of attributes determines uniquely the value for another set of attributes•A functional dependency is a generalization of the notion of a key(= trivial dependency)\nECE30030/ITP30010 Database Systems68\nFunctional Dependencies•Let R be a relation schema, a and b be its attributes (a Í R and b Í R)•The functional dependency a ® b  holds on R if and only if, for any relations r(R), whenever any two tuples t1 and t2 of r agree on the attributes a, they also agree on the attributes b•That is,  t1[a] = t2 [a]    Þ    t1[b ] = t2 [b ]•E.g., Consider r(A,B) with the following instance of r\nA     B  1     4  1     5  3     7\n•On this instance, B ® A hold;  A ® B does NOT hold (only the values of B are unique)\nECE30030/ITP30010 Database Systems69\nKeys and Functional Dependencies•Functional dependencies allow us to express constraints that cannot be expressed using super keys•E.g., consider the schema:\nin_dep (ID, name, salary, dept_name, building, budget )•ID = instructor ID•dept_name = department of the instructor•We expect the following functional dependencies to hold:•dept_name® building•ID à buildingÞdept_name and ID are super keys = candidate keys* ID, dept_name, {ID, dept_name}•We would not expect the next to hold:•dept_name ® salary\nECE30030/ITP30010 Database Systems70\nFunctional Dependencies•For relation R = a1 a2 a3 a4\n•a1 is a part of the key•Functional dependency: a4 depends on its key, a1a2a3•b_id,  b_name, bd_detail_attrib1, , bd_detail_attrib2•Candidate keys: b_id, b_name, {b_id, b_name}•It should not be such that a4 depends on a1, and does not depend on a1a2a3 (a1 ➝ a4)  ⇒  partial dependency\nECE30030/ITP30010 Database Systems71\nCandidate key = a1, a2, a3, {a1, a2}, {a2,a3}, {a1, a3}, {a1,a2,a3}\nTrivial Functional Dependencies•A functional dependency is trivial if it is satisfied by all instances of a relation•Example:•ID, name ® ID•name ® name•In general, a ® b is trivial if b Í a\nECE30030/ITP30010 Database Systems72\nFunctional Dependencies•student2(ID, name, tot_cred)•ID à name•ID à tot_cred•tot_cred à name (X)\nECE30030/ITP30010 Database Systems73\nFunctional Dependencies•SCORE(score_id, student_id, subject_id, score)•{student_id, subject_id} à score"
        },
        {
          "chapter_title": "제1 정규형 (1NF): 원자성 및 고유성",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "제1 정규형(1NF)의 요구사항을 설명하며, 모든 속성 값이 원자적이어야 하고, 각 컬럼은 동일한 데이터 도메인 내의 값을 포함하며, 고유한 이름을 가져야 한다는 점을 강조합니다. 중복된 행이 없어야 하며, 기본 키(PK)가 고유성과 Not Null을 보장하는 역할을 설명하고, 실제 예시를 통해 1NF로의 변환 과정을 보여줍니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems13\nFirst Normal Form (1NF)•Requirements•A relation should consist of atomic values•Atomic value: a value that cannot be divided (≃primitive data types in JAVA)•Atomic - INT, FLOAT, DOUBLE, DECIMAL (NUMERIC), CHAR, VARCHAR, BLOB, TEXT•NOGO - Structure, List (array)•Attributes should have unique identifiers•Step 1 of the normalization process•“If the tables in your DB does not follow 1NF, stop using database”\nECE30030/ITP30010 Database Systems14\nFirst Normal Form (1NF)•1NF checklist1.Each column should contain an atomic value•Entries like (x, y) violate this rule2.Each column should contain values that are in the same data domain•Do not mix different types of values in a column3.Each column should have a unique name•Duplicate names lead to confusion while accessing data4.The order in which data is stored does not matter•Using SQL, one can easily fetch data in any order5.There are no duplicated rows in the table•Primary key (PK) ensures: •Attributes that are part of PK are unique•Attributes that are part of PK are not null\nECE30030/ITP30010 Database Systems23\nFirst Normal Form (1NF)•Example\nstudent_idnamecourse\n21800999James InexistenteAlgorithm, OS\n21800998Mike InexistenteJava\n21800997Matt InexistenteAlgorithm, DB\nECE30030/ITP30010 Database Systems24\nFirst Normal Form (1NF)•Example\nstudent_idname\n21800999James Inexistente\n21800998Mike Inexistente\n21800997Matt Inexistente\nstudent_idcourse\n21800999Algorithm\n21800999OS\n21800998Java\n21800997Algorithm\n21800997DB\nECE30030/ITP30010 Database Systems25\nFirst Normal Form (1NF)•Example\nstudent_idname\n21800999James Inexistente\n21800998Mike Inexistente\n21800997Matt Inexistente\nstudent_idcourse\n21800999Algorithm\n21800999OS\n21800998Java\n21800997Algorithm\n21800997DB"
        },
        {
          "chapter_title": "제2 정규형 (2NF): 부분 종속성 제거",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "제2 정규형(2NF)의 요구사항을 설명하며, 1NF를 만족하고 기본 키가 아닌 속성이 후보 키의 어떤 부분 집합에도 함수적으로 종속되지 않아야 함을 강조합니다. 부분 종속성(Partial Dependency)의 정의와 이를 제거하기 위한 관계 분해(Decomposition) 과정을 다양한 예시를 통해 구체적으로 설명합니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems26\nSecond Normal Form (2NF)•Requirements•A relation should be in 1NF (normal forms should be applied in order)•A relation should NOT have a non-PK that is functionally dependent on any subset of any candidate key = NO PARTIAL DEPENDENCIES!•Any attributes other than PK should be dependent on PK•It should not have partial dependencies•PK: Primary Key•An attribute or a set of attributes that uniquely identifies each tuple in a relation•A PK can fetch data from any specific data in a relation•E.g., get the department name of student_ID = 21800999\nECE30030/ITP30010 Database Systems27\nPartial Dependencies•For relation R = a1 a2 a3 a4\n•a1 is a part of the primary key•Partial dependency: a4 depends on a1, and does not depend on a1a2a3•Key: a1 a2 a3•Dependency: a1 ➝ a4\nPrimary key (Composite)\nECE30030/ITP30010 Database Systems28\nEliminating Partial Dependencies•Example: teaches2(ID, course_id, sec_id, semester, year, name)•ID à name\nECE30030/ITP30010 Database Systems29\nEliminating Partial Dependencies•Example: •teaches2a(ID, course_id, sec_id, semester, year)•teaches2b(ID, name)\nECE30030/ITP30030Database Systems 30\nEliminating Partial Dependencies•Example: score(score_id, student_id, subject_id, score, instructor)•subject_id à instructor : partial dependency\nscore_idstudent_idsubject_idscoreinstructor\n1 10 1 82James Packer\n3 11 1 95James Packer\n2 10 2 77Cole Miller\n4 11 2 71Cole Miller\n5 11 4 96Adam Lee\nECE30030/ITP30030Database Systems 31\nEliminating Partial Dependencies•Example: score_a(score_id, student_id, subject_id, score)                 score_b(subject_id, instructor)\nscore_idstudent_idsubject_idscore\n1 10 1 82\n3 11 1 95\n2 10 2 77\n4 11 2 71\n5 11 4 96\nsubject_idinstructor\n1 James Packer\n2 Cole Miller\n4 Adam Lee\nECE30030/ITP30010 Database Systems74\nPartial Dependencies•For relation R = a1 a2 a3 a4\n•a1 is a part of the primary key•a4 depends on a1, and does not depend on a1a2a3 (a1 ➝ a4)•Key: a1 a2 a3•Dependency: a1 ➝ a4\nPrimary key (Composite)\nECE30030/ITP30010 Database Systems75\nPartial Dependencies•teaches2(ID, course_id, sec_id, semester, year, name)•ID à name•{course_id, sec_id, semester, year} à name\nECE30030/ITP30010 Database Systems76\nPartial Dependencies•SCORE(score_id, student_id, subject_id, score, instructor)•subject_id à instructor (partial dependency) :: WE DON’T WANT TO HAVE THIS"
        },
        {
          "chapter_title": "제3 정규형 (3NF): 이행적 종속성 제거",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "제3 정규형(3NF)의 요구사항을 설명하며, 2NF를 만족하고 이행적 종속성(Transitive Dependency)이 없어야 함을 강조합니다. 이행적 종속성은 기본 키가 아닌 속성이 다른 기본 키가 아닌 속성에 종속되는 경우를 의미하며, 이를 제거하기 위한 관계 분해 과정을 다양한 도서 및 시험 점수 관리 예시를 통해 상세히 제시합니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems32\nThird Normal Form (3NF)•Requirements•A relation should be in 2NF •A relation should NOT have transitive dependencies•Transitive dependency: A non-PK attribute depends on another non-PK attribute or a set of non-PK attributes\nECE30030/ITP30010 Database Systems33\nTransitive Dependencies•For relation R = a1 a2 a3 a4\n•a1 is the primary key in R•a3 depends on a1 (a1 ➝ a3) -- OK•a4 depends on a3 (a1 ➝ a3 ➝ a4) … non-PK à non-PK\nCandidate key = a1, a2, {a1,a2}\nECE30030/ITP30010 Database Systems34\nEliminating Transitive Dependencies•Example\nBookNoPatronAddressDue\nB1J. Fisher101 Main Street3/2/15\nB2L. Perez202 Market Street 2/28/15\nECE30030/ITP30010 Database Systems35\nEliminating Transitive Dependencies•Example\n•PK: BookNo•Patron à Address\nBookNoPatronAddressDue\nB1J. Fisher101 Main Street3/2/15\nB2L. Perez202 Market Street 2/28/15\nECE30030/ITP30010 Database Systems36\nEliminating Transitive Dependencies•Example\nBookNoPatronDue\nB1J. Fisher3/2/15\nB2L. Perez2/28/15PatronAddressJ. Fisher101 Main StreetL. Perez202 Market Street\nECE30030/ITP30010 Database Systems37\nEliminating Transitive Dependencies•Example\n•PK: {Tournament, Year}•Winner à DOB\nTournamentYearWinner DOB\nIndiana Invitational1998Al Fredrickson21 July 1975\nCleveland Open1999Bob Albertson28 Sept. 1968\nDes Moines Masters1999Al Fredrickson21 July 1975\nECE30030/ITP30010 Database Systems38\nEliminating Transitive Dependencies•Example: score2(id, student_id, subject_id, exam_name, exam_score)•{student_id, subject_id} --> FINAL or MIDTERM•{student_id, subject_id} --> 77   43 … from which ?•{student_id, subject_id} à exam_name à exam_score :: transitive dependency\nECE30030/ITP30010 Database Systems39\nEliminating Transitive Dependencies•Example: score2(id, student_id, subject_id, exam_name, exam_score)•student_id, subject_id à exam_name•student_id, subject_id à exam_name à exam_score\nECE30030/ITP30010 Database Systems40\nEliminating Transitive Dependencies•Example: score2a(id, student_id, subject_id, exam_id, exam_name)                 score2b(student_id, subject_id, exam_id, exam_score)\nECE30030/ITP30010 Database Systems77\nTransitive Dependencies•For relation R = a1 a2 a3 a4\n•a1 is the primary key in R•a3 depends on a1 (a1 ➝ a3) -- OK•a4 depends on a3 (a1 ➝ a3 ➝ a4) … non-PK à non-PK\nCandidate key = a1, a2, {a1,a2}\nECE30030/ITP30010 Database Systems78\nTransitive Dependencies•EXAM_SCORE(id, student_id, subject_id, exam_name, exam_score)•{student_id, subject_id} --> FINAL or MIDTERM•{student_id, subject_id} --> 77   43 … from which ?•{student_id, subject_id} à exam_name à exam_score :: transitive dependency"
        },
        {
          "chapter_title": "보이스-코드 정규형 (BCNF): 강화된 제3 정규형",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "보이스-코드 정규형(BCNF)은 제3 정규형을 강화한 형태로, A → B 종속성이 있을 때 A가 반드시 슈퍼 키여야 한다는 요구사항을 설명합니다. 즉, 기본 키가 아닌 속성이 기본 키의 일부를 결정하는 경우가 없어야 하며, 이를 위반하는 사례와 BCNF를 만족하도록 관계를 분해하는 과정을 예시를 통해 보여줍니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems41\nBoyce-Codd Normal Form (BCNF) = 3.5NF•Requirements•A relation should be in 3NF•For any dependency A à B, A should be a super key•For A à B, if A is non-PK, then it is NOT in BCNF\nECE30030/ITP30010 Database Systems42\nBoyce-Codd Normal Form (BCNF)•Example: takes2(student_id, subject, instructor)\n•(student, subject) à instructor•Instructor à subject•A non-PK identifies a member of PK: Not in BCNF\nstudent_idsubjectinstructor\n21800999C++ Dr. Cpp\n21800999Java Dr. Java\n21800998C++ Dr. C\n21800997PythonDr. Python\n21800996C++ Dr. Cpp\nECE30030/ITP30010 Database Systems43\nBoyce-Codd Normal Form (BCNF)•Example: takes2a(student_id, section_id),\ntakes2b(section_id, subject, instructor)\nstudent_idsection_id\n21800999101\n21800999103\n21800998102\n21800997104\n21800996101section_idsubjectinstructor\n101 C++ Dr. Cpp\n103 Java Dr. Java\n102 C++ Dr. C\n104 PythonDr. Python\nECE30030/ITP30010 Database Systems44\nBoyce-Codd Normal Form (BCNF)•Example: takes2a(student_id, section_id),\ntakes2b(section_id, subject, instructor)\nstudent_idsection_id\n21800999101\n21800999103\n21800998102\n21800997104\n21800996101section_idsubjectinstructor\n101 C++ Dr. Cpp\n103 Java Dr. Java\n102 C++ Dr. C\n104 PythonDr. Python"
        },
        {
          "chapter_title": "제4 정규형 (4NF): 다치 종속성 제거",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "제4 정규형(4NF)의 요구사항을 설명하며, BCNF를 만족하고 다치 종속성(Multi-valued Dependency, MVD)이 없어야 함을 강조합니다. 다치 종속성은 릴레이션에 3개 이상의 속성이 있고, 서로 독립적인 다치 속성 집합이 존재할 때 발생할 수 있으며, 이를 제거하기 위한 관계 분해 과정을 학생의 수강 과목 및 활동 예시를 통해 설명합니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems45\nFourth Normal Form (4NF)•Requirements•A relation should be in BCNF•A relation should NOT have multi-valued dependency•Multi-valued dependency occurs due to a bad DB schema•Multi-valued dependency occurs when a relation has more than 3 attributes•For a relation with attributes A, B, C•having dependency, A à B, and•B and C are independent from each otherè Then, the relation may have a multi-valued dependency\nECE30030/ITP30010 Database Systems46\nMulti-valued Dependencies•Example•student_id à course•student_id à activity•course ⊥ activity (independent)\nstudent_idcourseactivity\n21800999StatisticsSoccer\n21800999Linear algebraBasketball\n21800999StatisticsBasketball\n21800999Linear algebraSoccer\nECE30030/ITP30010 Database Systems47\nMulti-valued Dependencies•Example\nstudent_idcourse\n21800999Statistics\n21800999Linear algebra\n21800998Physics\n21800998Programming 101student_idactivity\n21800999Soccer\n21800999Basketball\n21800998Pool\n21800997Soccer\nECE30030/ITP40001 Database Systems79\nMulti-valued Dependencies (MVDs)•Suppose we record names of children, and phone numbers for instructors•inst_child(ID, child_name)•inst_phone(ID, phone_number)à If we combine these schemas to obtain: (multiple orthogonal values in single table à this causes redundancy)•inst_info(ID, child_name, phone_number)à Example tuples: ID=999999 à {David, William} & {x-x-1234, x-x-4321}  (99999, David, 512-555-1234)  (99999, David, 512-555-4321)  (99999, William, 512-555-1234)  (99999, William, 512-555-4321)•Any issues?\nECE30030/ITP40001 Database Systems80\nMulti-valued Dependencies (MVDs)•Let R be a relation schema and let a Í R and b Í R. •The multivalued dependency a ®® b holds on R if in any relation r(R), for all pairs for tuples t1 and t2 in r such that t1[a] = t2 [a], there exist tuples t3 and t4 in r such that:    t1[a] = t2 [a] = t3 [a] = t4 [a]           t3[b] =  t1 [b]           t3[R  – b] =  t2[R  – b]           t4 [b] =  t2[b]           t4[R  – b] =  t1[R  – b]\nECE30030/ITP40001 Database Systems81\nMulti-valued Dependencies (MVDs)•Let R be a relation schema with a set of attributes that are partitioned into 3 non-empty subsets Y, Z, W•We say that Y ®® Z (Y multidetermines Z )if and only if for all possible relations r(R)  < y1, z1, w1 > Î r and < y1, z2, w2 > Î rthen  < y1, z1, w2 > Î r and < y1, z2, w1 > Î r•Note that since the behavior of Z and W are identical it follows that Y ®® Z if Y ®® W\nECE30030/ITP40001 Database Systems82\nMulti-valued Dependencies (MVDs)•Tabular representation of a ®® b\nECE30030/ITP40001 Database Systems83\nMulti-valued Dependencies (MVDs)•FAV(student_id, course, activity)•21800999 - {statistics, Linear algebra} & {Soccer, basketball}•Favorite courses & favorite activities <= they are orthogonal\nstudent_idcourseactivity\n21800999StatisticsSoccer\n21800999Linear algebraBasketball\n21800999StatisticsBasketball\n21800999Linear algebraSoccer"
        },
        {
          "chapter_title": "정규화 이론 및 종속성 요약",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "각 정규형(2NF, 3NF, BCNF, 4NF, 5NF)과 관련된 핵심 이론 및 종속성(함수적, 부분, 이행적, 다치, 조인 종속성)을 요약하여 제시합니다. 정규화 이론이 '좋은 형태'의 릴레이션을 결정하고 무손실 분해를 통해 이를 달성하는 데 사용됨을 강조하며, 함수적 종속성과 다치 종속성이 데이터베이스의 유효성 검사 및 제약 조건 지정에 어떻게 활용되는지 설명합니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems48\nSummary: Normal Forms•Theories – Normal forms\nTheory Key IdeaNormal Form\nFunctional dependency(PK à non-PK)2NF\nPartial dependencyPart of PK à non-PK2NF\nTransitive dependencyNon-PK à non-PK3NF\n- Non-PK à PK BCNF\nMulti-valued dependency4NF\nJoin dependency5NF\nECE30030/ITP30010 Database Systems65\nNormalization Theory•Decide whether a particular relation R is in “good form”•For a relation R is not in “good form”, decompose it into a set of relations {R1, R2, ..., Rn} such that•Each relation is in good form•The decomposition is a lossless decomposition\nECE30030/ITP30010 Database Systems66\nNormalization Theory•The normalization is based on a set of relevant theories:•Functional dependencies•Partial dependencies•Transitive dependencies•Multivalued dependencies\nECE30030/ITP40001 Database Systems84\nUse of Functional Dependencies•We use functional dependencies to:•Test relations to see if they are legal under a given set of functional dependencies•We say that r satisfies F, if a relation r is legal under a set F of functional dependencies•To specify constraints on the set of legal relations•We say that F holds on R if all legal relations on R satisfy the set of functional dependencies F•Note:  A specific instance of a relation schema may satisfy a functional dependency even if the functional dependency does not hold on all legal instances•E.g., a specific instance of instructor may, by chance, satisfy:  name ® ID\nECE30030/ITP40001 Database Systems85\nUse of Multi\n-\nvalued Dependencies•We use multivalued dependencies in two ways:1.To test relations to determine whether they are legal under a given set of functional and multivalued dependencies2.To specify constraints on the set of legal relations. We shall concern ourselves only with relations that satisfy a given set of functional and multivalued dependencies•If a relation r fails to satisfy a given multivalued dependency, we can construct a relations r¢  that does satisfy the multivalued dependency by adding tuples to r"
        },
        {
          "chapter_title": "정규화 실전 예시",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "위키피디아에서 가져온 서적 소매업 데이터베이스 예시를 통해 데이터베이스 정규화 과정을 단계별로 상세히 설명합니다. 1NF, 2NF, 3NF, BCNF, 그리고 4NF를 만족하도록 테이블을 분해하고 종속성을 제거하는 실제 적용 사례를 보여주며, 각 정규형의 요구사항이 어떻게 충족되는지 시각적으로 제시합니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems53\nExample (taken from Wikipedia)•Provided:\nECE30030/ITP30010 Database Systems54\nExample (taken from Wikipedia)•Satisfying 1NF\nECE30030/ITP30010 Database Systems55\nExample (taken from Wikipedia)•Satisfying 1NF (cont’d – further improvement)\nECE30030/ITP30010 Database Systems56\nExample (taken from Wikipedia)•Provided:\n•Compound key {Title, Format}•Partial dependency: Title à Author, Author Nationality, Pages, Thickness, Genre ID, Genre Name, Publisher ID\nECE30030/ITP30010 Database Systems57\nExample (taken from Wikipedia)•Satisfying 2NF\nECE30030/ITP30010 Database Systems58\nExample (taken from Wikipedia)•Satisfying 3NF\n•Transitive dependency: Genre ID à Genre Name\nECE30030/ITP30010 Database Systems59\nExample (taken from Wikipedia)•Satisfying 3NF\nECE30030/ITP30010 Database Systems60\nExample (taken from Wikipedia)•Satisfying BCNF\n•Non-PK à Non-PK: Author à Author Nationality\nECE30030/ITP30010 Database Systems61\nExample (taken from Wikipedia)•Satisfying BCNF\nECE30030/ITP30010 Database Systems62\nExample (taken from Wikipedia)•Provided:•Assume the database is owned by a book retailer franchise that has several franchisees that own shops in different locations\nECE30030/ITP30010 Database Systems63\nExample (taken from Wikipedia)•Satisfying 4NF•If we assume that all available books are offered in each area, the Title is not unambiguously bound to a certain Locationà Does not satisfy 4NF\nECE30030/ITP30030Database Systems 64\n•Source: https://en.wikipedia.org/wiki/Database_normalization"
        },
        {
          "chapter_title": "데이터베이스 설계 과정 및 비정규화",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "데이터베이스 설계 과정에서 정규화가 어떻게 통합되는지 설명합니다. E-R 모델 설계의 중요성과 정규화의 관계를 다루고, 성능 향상을 위해 의도적으로 정규화되지 않은 스키마를 사용하는 비정규화(Denormalization)의 개념과 그 장단점을 제시합니다. 또한, 연도별 수익 데이터와 같은 특정 설계 문제가 정규화만으로는 해결되지 않을 수 있음을 지적하며 더 나은 스키마 설계를 제안합니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems49\nOverall DB Design Process•Let us assume schema R is given:(E-R Model)•R could have been generated when converting E-R diagram to a set of tables(Normalization)•R could have been a single relation containing all attributes that are of interest (called universal relation)•Normalization breaks R into smaller relations(Mixed)•R could have been the result of some ad-hoc design of relations, which we then test/convert to normal form\nECE30030/ITP30010 Database Systems50\nE-R Model and Normalization•When an E-R diagram is carefully designed, identifying all entities correctly, the tables generated from the E-R diagram should not need further normalization•However, in a real (imperfect) design, there can be functional dependencies from non-key attributes of an entity to other attributes of the entity•E.g., an employee entity with•attributesdepartment_name and building•functional dependencydepartment_name® building•Good design would have made department an entity•Functional dependencies from non-key attributes of a relationship set possible, but rare --- most relationships are binary\nECE30030/ITP30010 Database Systems51\nDenormalization for Performance•We may want to use non-normalized schema for performance•For example, displaying prereqs along with course_id, and title requires join of course with prereq•Alternative 1: Use denormalized relation containing attributes of course as well as prereq with all above attributes•faster lookup•extra space and extra execution time for updates•extra coding work for programmer and possibility of error in extra code•Alternative 2: Use a materialized view defined a course ⋈ prereq•Benefits and drawbacks same as above, except no extra coding work for programmer and avoids possible errors\nECE30030/ITP30010 Database Systems52\nRemaining Issues•Some aspects of database design are not caught by normalization•Example (to be avoided)•earnings_2004, earnings_2005, earnings_2006, etc., all on the schema (company_id, earnings)•Above are well normalized (in BCNF), but make querying across years difficult and needs new table each year•company_year (company_id, earnings_2004, earnings_2005,  earnings_2006)•Above are well normalized (in BCNF), but makes querying across years difficult and requires new attribute each year•This is an example of a crosstab, where values for one attribute become column namesà Better schema: earnings (company_id, year, amount)"
        }
      ],
      "generated_content": [],
      "final_result": ""
    }
  },
  {
    "node": "generate_chapter_content",
    "status": "completed",
    "state_snapshot": {
      "run_id": "a9d3b848-7887-4676-a9e0-4d590ff0b031",
      "pdf_file_paths": [
        "temp_pdf_uploads/a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf"
      ],
      "all_pdf_texts": [
        {
          "filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "text": "ECE30030/ITP30010 Database SystemsNormalizationReading: Chapter 7\nCharmgil Hongcharmgil@handong.eduSpring, 2025Handong Global University\n1\nAgenda•Motivating example•Normal forms•Normalization example•Appendix: Normalization theory\nECE30030/ITP30010 Database Systems2\nWhen Data is Jumbled…•Suppose that we combine instructor and department •(Below represents the join on instructor and department)\nECE30030/ITP30010 Database Systems3\nWhen Data is Jumbled…•Key issues•Repetition of data à increases the size of database•Data consistency issues•Insertion anomaly: Inserting redundant data for every new record•Deletion anomaly: Loss of related data, when some data is deleted•Update anomaly: When updating certain information, every single record must be updated\nECE30030/ITP30010 Database Systems4\nSolution: Decomposition!•How to avoid the repetition-of-information problem?\n•A: Decompose it into two schemas (as they were)•Normalization = decomposition of relational schemas•Key idea: split relational schemas such that only directly related data composes a relation\nECE30030/ITP30010 Database Systems5\nDecomposition•Less redundancy à Uses smaller disk storage;  Causes less issues associated with insertion, deletion, and update anomalies•Not all decompositions are good•E.g., Suppose we decompose   employee(ID, name, street, city, salary)into  employee1 (ID, name)  employee2 (name, street, city, salary)à Problem: What if there are two employees with the same name?•Lossy decomposition: a decomposition from which the original relation cannot be reconstructedECE30030/ITP30010 Database Systems6\nLossy Decomposition\nECE30030/ITP30010 Database Systems7\nLossless Decomposition•Let R be a relation schema and let R1 and R2 form a decomposition of R; that is, R = R1 U R2•A decomposition is a lossless decomposition if there is no loss of information by replacing R with the two relation schemas R1 U R2•Formally,    ÕR1(r)  ⋈  ÕR2(r) = r•C.f., Conversely, a decomposition is lossy if when the join of the projection results is computed, a proper superset of the original relation is returned     r  Ì  ÕR1(r)  ⋈  ÕR2(r) \nECE30030/ITP30010 Database Systems8\nExample: Lossless Decomposition•Decomposition of R = (A, B, C)  à  R1 = (A, B); R2 = (B, C)\nECE30030/ITP30010 Database Systems9\nNormalization•Database normalization: Process of structuring a database to reduce data redundancy and improve data integrity•In accordance with a series of normal forms (next topic)•Through the process:•One can decompose relations to suppress data anomalies•One can make sure the decomposition is lossless\nECE30030/ITP30010 Database Systems10\nAgenda•Motivating example•Normal forms•Normalization example•Appendix: Normalization theory\nECE30030/ITP30010 Database Systems11\nNormal Forms•Normalization process•Normalization is a database design technique, which is used to design a relational database table up to higher normal form•Procedurally separates logically independent (but related) data entities into multiple relations•Maintains the connections using keys•Progressive process•A higher level of database normalization cannot be achieved unless the previous levels have been satisfied•UNF: Unnormalized form•1NF: First normal form•2NF: Second normal form•3NF: Third normal form•BCNF: Boyce-Codd normal form (3.5NF)•4NF: Fourth normal form•…\nECE30030/ITP30010 Database Systems12\nNormal Forms•Normal forms are backed by a set of normalization theories•Functional dependencies•Partial dependencies•Transitive dependencies•Multi-valued dependencies•These theories decide whether a particular relation R is in “good form”•For a relation R is not in “good form”, decompose it into a set of relations {R1, R2, ..., Rn} such that•Each relation is in good form•The decomposition is a lossless decomposition\nECE30030/ITP30010 Database Systems13\nFirst Normal Form (1NF)•Requirements•A relation should consist of atomic values•Atomic value: a value that cannot be divided (≃primitive data types in JAVA)•Atomic - INT, FLOAT, DOUBLE, DECIMAL (NUMERIC), CHAR, VARCHAR, BLOB, TEXT•NOGO - Structure, List (array)•Attributes should have unique identifiers•Step 1 of the normalization process•“If the tables in your DB does not follow 1NF, stop using database”\nECE30030/ITP30010 Database Systems14\nFirst Normal Form (1NF)•1NF checklist1.Each column should contain an atomic value•Entries like (x, y) violate this rule2.Each column should contain values that are in the same data domain•Do not mix different types of values in a column3.Each column should have a unique name•Duplicate names lead to confusion while accessing data4.The order in which data is stored does not matter•Using SQL, one can easily fetch data in any order5.There are no duplicated rows in the table•Primary key (PK) ensures: •Attributes that are part of PK are unique•Attributes that are part of PK are not null\nECE30030/ITP30010 Database Systems15\nFunctional Dependencies•There are usually a variety of constraints (rules) on the data in the real world•E.g., some of the constraints that are expected to hold in the university database are:•Students and instructors are uniquely identified by their ID•Each student and instructor has only one name•Each instructor and student is associated with only one department•Each department has only one value for its budget, and only one associated building•Relations require that the value for a certain set of attributes determines uniquely the value for another set of attributes•A functional dependency is a generalization of the notion of a key(= trivial dependency)\nECE30030/ITP30010 Database Systems16\nFunctional Dependencies•Let R be a relation schema, a and b be its attributes (a Í R and b Í R)•The functional dependency a ® b  holds on R if and only if, for any relations r(R), whenever any two tuples t1 and t2 of r agree on the attributes a, they also agree on the attributes b•That is,  t1[a] = t2 [a]    Þ    t1[b ] = t2 [b ]•E.g., Consider r(A,B) with the following instance of r\n•On this instance, B ® A hold;  A ® B does NOT hold (only the values of B are unique)ECE30030/ITP30010 Database Systems17\nA     B  1     4  1     5  3     7\nKeys and Functional Dependencies•Functional dependencies allow us to express constraints that cannot be expressed using super keys•E.g., consider the schema:             in_dep (ID, name, salary, dept_name, building, budget )•ID = instructor ID•dept_name = department of the instructor•We expect the following functional dependencies to hold:•dept_name ® building•ID ® buildingÞdept_name and ID are super keys = candidate keys* ID, dept_name, {ID, dept_name}•We would not expect the next to hold:•dept_name ® salary\nECE30030/ITP30010 Database Systems18\nFunctional Dependencies•For relation R = a1 a2 a3 a4\n•a1 is a part of the key•Functional dependency: a4 depends on its key, a1a2a3•b_id,  b_name, bd_detail_attrib1, , bd_detail_attrib2•Candidate keys: b_id, b_name, {b_id, b_name}•It should not be such that a4 depends on a1, and does not depend on a1a2a3 (a1 ➝ a4)  ⇒  partial dependency\nECE30030/ITP30010 Database Systems19\nCandidate key = a1, a2, a3, {a1, a2}, {a2,a3}, {a1, a3}, {a1,a2,a3}\nTrivial Functional Dependencies•A functional dependency is trivial if it is satisfied by all instances of a relation•Example:•ID, name ® ID•name ® name•In general, a ® b is trivial if b Í a\nECE30030/ITP30010 Database Systems20\nFunctional Dependencies•Example: student2(ID, name, tot_cred)•Hold•ID à name•ID à tot_cred•Not hold•tot_cred à name•name à tot_cred\nECE30030/ITP30010 Database Systems21\nFunctional Dependencies•score(score_id, student_id, subject_id, score)•{student_id, subject_id} à score\nECE30030/ITP30010 Database Systems22\nFirst Normal Form (1NF)•Example\nECE30030/ITP30010 Database Systems23\nstudent_idnamecourse21800999James InexistenteAlgorithm, OS21800998Mike InexistenteJava21800997Matt InexistenteAlgorithm, DB\nFirst Normal Form (1NF)•Example\nECE30030/ITP30010 Database Systems24\nstudent_idname21800999James Inexistente21800998Mike Inexistente21800997Matt Inexistentestudent_idcourse21800999Algorithm21800999OS21800998Java21800997Algorithm21800997DB\nFirst Normal Form (1NF)•Example\nECE30030/ITP30010 Database Systems25\nstudent_idname21800999James Inexistente21800998Mike Inexistente21800997Matt Inexistentestudent_idcourse21800999Algorithm21800999OS21800998Java21800997Algorithm21800997DB\nSecond Normal Form (2NF)•Requirements•A relation should be in 1NF (normal forms should be applied in order)•A relation should NOT have a non-PK that is functionally dependent on any subset of any candidate key = NO PARTIAL DEPENDENCIES!•Any attributes other than PK should be dependent on PK•It should not have partial dependencies•PK: Primary Key•An attribute or a set of attributes that uniquely identifies each tuple in a relation•A PK can fetch data from any specific data in a relation•E.g., get the department name of student_ID = 21800999\nECE30030/ITP30010 Database Systems26\nPartial Dependencies•For relation R = a1 a2 a3 a4\n•a1 is a part of the primary key•Partial dependency: a4 depends on a1, and does not depend on a1a2a3•Key: a1 a2 a3•Dependency: a1 ➝ a4\nECE30030/ITP30010 Database Systems27\nPrimary key (Composite)\nEliminating Partial Dependencies•Example: teaches2(ID, course_id, sec_id, semester, year, name)•ID à name\nECE30030/ITP30010 Database Systems28\nEliminating Partial Dependencies•Example: •teaches2a(ID, course_id, sec_id, semester, year)•teaches2b(ID, name)\nECE30030/ITP30010 Database Systems29\nEliminating Partial Dependencies•Example: score(score_id, student_id, subject_id, score, instructor)•subject_id à instructor : partial dependency\nECE30030/ITP30030Database Systems 30\nscore_idstudent_idsubject_idscoreinstructor1 10 1 82James Packer3 11 1 95James Packer2 10 2 77Cole Miller4 11 2 71Cole Miller5 11 4 96Adam Lee\nEliminating Partial Dependencies•Example: score_a(score_id, student_id, subject_id, score)                 score_b(subject_id, instructor)\nECE30030/ITP30030Database Systems 31\nscore_idstudent_idsubject_idscore1 10 1 823 11 1 952 10 2 774 11 2 715 11 4 96\nsubject_idinstructor1 James Packer2 Cole Miller4 Adam Lee\nThird Normal Form (3NF)•Requirements•A relation should be in 2NF •A relation should NOT have transitive dependencies•Transitive dependency: A non-PK attribute depends on another non-PK attribute or a set of non-PK attributes\nECE30030/ITP30010 Database Systems32\nTransitive Dependencies•For relation R = a1 a2 a3 a4\n•a1 is the primary key in R•a3 depends on a1 (a1 ➝ a3) -- OK•a4 depends on a3 (a1 ➝ a3 ➝ a4) … non-PK à non-PK\nECE30030/ITP30010 Database Systems33\nCandidate key = a1, a2, {a1,a2}\nEliminating Transitive Dependencies•Example\nECE30030/ITP30010 Database Systems34\nBookNoPatronAddressDueB1J. Fisher101 Main Street3/2/15B2L. Perez202 Market Street 2/28/15\nEliminating Transitive Dependencies•Example\n•PK: BookNo•Patron à Address\nECE30030/ITP30010 Database Systems35\nBookNoPatronAddressDueB1J. Fisher101 Main Street3/2/15B2L. Perez202 Market Street 2/28/15\nEliminating Transitive Dependencies•Example\nECE30030/ITP30010 Database Systems36\nBookNoPatronDueB1J. Fisher3/2/15B2L. Perez2/28/15PatronAddressJ. Fisher101 Main StreetL. Perez202 Market Street\nEliminating Transitive Dependencies•Example\n•PK: {Tournament, Year}•Winner à DOB\nECE30030/ITP30010 Database Systems37\nTournamentYearWinner DOBIndiana Invitational1998Al Fredrickson21 July 1975Cleveland Open1999Bob Albertson28 Sept. 1968Des Moines Masters1999Al Fredrickson21 July 1975\nEliminating Transitive Dependencies•Example: score2(id, student_id, subject_id, exam_name, exam_score)•{student_id, subject_id} --> FINAL or MIDTERM•{student_id, subject_id} --> 77   43 … from which ?•{student_id, subject_id} à exam_name à exam_score :: transitive dependency\nECE30030/ITP30010 Database Systems38\nEliminating Transitive Dependencies•Example: score2(id, student_id, subject_id, exam_name, exam_score)•student_id, subject_id à exam_name•student_id, subject_id à exam_name à exam_score\nECE30030/ITP30010 Database Systems39\nEliminating Transitive Dependencies•Example: score2a(id, student_id, subject_id, exam_id, exam_name)                 score2b(student_id, subject_id, exam_id, exam_score)\nECE30030/ITP30010 Database Systems40\nBoyce-Codd Normal Form (BCNF) = 3.5NF•Requirements•A relation should be in 3NF•For any dependency A à B, A should be a super key•For A à B, if A is non-PK, then it is NOT in BCNF\nECE30030/ITP30010 Database Systems41\nBoyce-Codd Normal Form (BCNF)•Example: takes2(student_id, subject, instructor)\n•(student, subject) à instructor•Instructor à subject•A non-PK identifies a member of PK: Not in BCNF\nECE30030/ITP30010 Database Systems42\nstudent_idsubjectinstructor21800999C++ Dr. Cpp21800999Java Dr. Java21800998C++ Dr. C21800997PythonDr. Python21800996C++ Dr. Cpp\nBoyce-Codd Normal Form (BCNF)•Example: takes2a(student_id, section_id),                  takes2b(section_id, subject, instructor)\nECE30030/ITP30010 Database Systems43\nstudent_idsection_id2180099910121800999103218009981022180099710421800996101section_idsubjectinstructor101 C++ Dr. Cpp103 Java Dr. Java102 C++ Dr. C104 PythonDr. Python\nBoyce-Codd Normal Form (BCNF)•Example: takes2a(student_id, section_id),                 takes2b(section_id, subject, instructor)\nECE30030/ITP30010 Database Systems44\nstudent_idsection_id2180099910121800999103218009981022180099710421800996101section_idsubjectinstructor101 C++ Dr. Cpp103 Java Dr. Java102 C++ Dr. C104 PythonDr. Python\nFourth Normal Form (4NF)•Requirements•A relation should be in BCNF•A relation should NOT have multi-valued dependency•Multi-valued dependency occurs due to a bad DB schema•Multi-valued dependency occurs when a relation has more than 3 attributes•For a relation with attributes A, B, C•having dependency, A à B, and•B and C are independent from each otherè Then, the relation may have a multi-valued dependency\nECE30030/ITP30010 Database Systems45\nMulti-valued Dependencies•Example•student_id à course•student_id à activity•course ⊥ activity (independent)\nECE30030/ITP30010 Database Systems46\nstudent_idcourseactivity21800999StatisticsSoccer21800999Linear algebraBasketball21800999StatisticsBasketball21800999Linear algebraSoccer\nMulti-valued Dependencies•Example\nECE30030/ITP30010 Database Systems47\nstudent_idcourse21800999Statistics21800999Linear algebra21800998Physics21800998Programming 101student_idactivity21800999Soccer21800999Basketball21800998Pool21800997Soccer\nSummary: Normal Forms•Theories – Normal forms\nECE30030/ITP30010 Database Systems48\nTheory Key IdeaNormal FormFunctional dependency(PK à non-PK)2NFPartial dependencyPart of PK à non-PK2NFTransitive dependencyNon-PK à non-PK3NF- Non-PK à PK BCNFMulti-valued dependency4NFJoin dependency5NF\nOverall DB Design Process•Let us assume schema R is given:(E-R Model)•R could have been generated when converting E-R diagram to a set of tables(Normalization)•R could have been a single relation containing all attributes that are of interest (called universal relation)•Normalization breaks R into smaller relations(Mixed)•R could have been the result of some ad-hoc design of relations, which we then test/convert to normal form\nECE30030/ITP30010 Database Systems49\nE-R Model and Normalization•When an E-R diagram is carefully designed, identifying all entities correctly, the tables generated from the E-R diagram should not need further normalization•However, in a real (imperfect) design, there can be functional dependencies from non-key attributes of an entity to other attributes of the entity•E.g., an employee entity with•attributesdepartment_name and building•functional dependencydepartment_name® building•Good design would have made department an entity•Functional dependencies from non-key attributes of a relationship set possible, but rare --- most relationships are binaryECE30030/ITP30010 Database Systems50\nDenormalization for Performance•We may want to use non-normalized schema for performance•For example, displaying prereqs along with course_id, and title requires join of course with prereq•Alternative 1: Use denormalized relation containing attributes of course as well as prereq with all above attributes•faster lookup•extra space and extra execution time for updates•extra coding work for programmer and possibility of error in extra code•Alternative 2: Use a materialized view defined a course ⋈ prereq•Benefits and drawbacks same as above, except no extra coding work for programmer and avoids possible errors\nECE30030/ITP30010 Database Systems51\nRemaining Issues•Some aspects of database design are not caught by normalization•Example (to be avoided)•earnings_2004, earnings_2005, earnings_2006, etc., all on the schema (company_id, earnings)•Above are well normalized (in BCNF), but make querying across years difficult and needs new table each year•company_year (company_id, earnings_2004, earnings_2005,  earnings_2006)•Above are well normalized (in BCNF), but makes querying across years difficult and requires new attribute each year•This is an example of a crosstab, where values for one attribute become column namesà Better schema: earnings (company_id, year, amount)ECE30030/ITP30010 Database Systems52\nAgenda•Motivating example•Normal forms•Normalization example•Appendix: Normalization theory\nECE30030/ITP30010 Database Systems53\nExample (taken from Wikipedia)•Provided:\n•Satisfying 1NF\nECE30030/ITP30010 Database Systems54\nExample (taken from Wikipedia)•Satisfying 1NF (cont’d – further improvement)\nECE30030/ITP30010 Database Systems55\nExample (taken from Wikipedia)•Provided:\n•Compound key {Title, Format}•Partial dependency: Title à Author, Author Nationality, Pages, Thickness, Genre ID, Genre Name, Publisher ID\nECE30030/ITP30010 Database Systems56\nExample (taken from Wikipedia)•Satisfying 2NF\nECE30030/ITP30010 Database Systems57\nExample (taken from Wikipedia)•Satisfying 3NF\n•Transitive dependency: Genre ID à Genre Name\nECE30030/ITP30010 Database Systems58\nExample (taken from Wikipedia)•Satisfying 3NF\nECE30030/ITP30010 Database Systems59\nExample (taken from Wikipedia)•Satisfying BCNF\n•Non-PK à Non-PK: Author à Author Nationality\nECE30030/ITP30010 Database Systems60\nExample (taken from Wikipedia)•Satisfying BCNF\nECE30030/ITP30010 Database Systems61\nExample (taken from Wikipedia)•Provided:•Assume the database is owned by a book retailer franchise that has several franchisees that own shops in different locations\nECE30030/ITP30010 Database Systems62\nExample (taken from Wikipedia)•Satisfying 4NF•If we assume that all available books are offered in each area, the Title is not unambiguously bound to a certain Locationà Does not satisfy 4NF\nECE30030/ITP30010 Database Systems63\n•Source: https://en.wikipedia.org/wiki/Database_normalization \nECE30030/ITP30030Database Systems 64\nAgenda•Motivating example•Normal forms•Normalization example•Appendix: Normalization theory\nECE30030/ITP30010 Database Systems65\nNormalization Theory•Decide whether a particular relation R is in “good form”•For a relation R is not in “good form”, decompose it into a set of relations {R1, R2, ..., Rn} such that•Each relation is in good form•The decomposition is a lossless decomposition•The normalization is based on a set of relevant theories:•Functional dependencies•Partial dependencies•Transitive dependencies•Multivalued dependencies\nECE30030/ITP30010 Database Systems66\nFunctional Dependencies•There are usually a variety of constraints (rules) on the data in the real world•E.g., some of the constraints that are expected to hold in a university database are:•Students and instructors are uniquely identified by their ID•Each student and instructor has only one name•Each instructor and student is (primarily) associated with only one department•Each department has only one value for its budget, and only one associated building•Relations require that the value for a certain set of attributes determines uniquely the value for another set of attributes•A functional dependency is a generalization of the notion of a key(= trivial dependency)\nECE30030/ITP30010 Database Systems67\nFunctional Dependencies•Let R be a relation schema, a and b be its attributes (a Í R and b Í R)•The functional dependency a ® b  holds on R if and only if, for any relations r(R), whenever any two tuples t1 and t2 of r agree on the attributes a, they also agree on the attributes b•That is,  t1[a] = t2 [a]    Þ    t1[b ] = t2 [b ]•E.g., Consider r(A,B) with the following instance of r\n•On this instance, B ® A hold;  A ® B does NOT hold (only the values of B are unique)ECE30030/ITP30010 Database Systems68\nA     B  1     4  1     5  3     7\nKeys and Functional Dependencies•Functional dependencies allow us to express constraints that cannot be expressed using super keys•E.g., consider the schema:             in_dep (ID, name, salary, dept_name, building, budget )•ID = instructor ID•dept_name = department of the instructor•We expect the following functional dependencies to hold:•dept_name® building•ID à buildingÞdept_name and ID are super keys = candidate keys* ID, dept_name, {ID, dept_name}•We would not expect the next to hold:•dept_name ® salary\nECE30030/ITP30010 Database Systems69\nFunctional Dependencies•For relation R = a1 a2 a3 a4\n•a1 is a part of the key•Functional dependency: a4 depends on its key, a1a2a3•b_id,  b_name, bd_detail_attrib1, , bd_detail_attrib2•Candidate keys: b_id, b_name, {b_id, b_name}•It should not be such that a4 depends on a1, and does not depend on a1a2a3 (a1 ➝ a4)  ⇒  partial dependency\nECE30030/ITP30010 Database Systems70\nCandidate key = a1, a2, a3, {a1, a2}, {a2,a3}, {a1, a3}, {a1,a2,a3}\nTrivial Functional Dependencies•A functional dependency is trivial if it is satisfied by all instances of a relation•Example:•ID, name ® ID•name ® name•In general, a ® b is trivial if b Í a\nECE30030/ITP30010 Database Systems71\nFunctional Dependencies•student2(ID, name, tot_cred)•ID à name•ID à tot_cred•tot_cred à name (X)\nECE30030/ITP30010 Database Systems72\nFunctional Dependencies•SCORE(score_id, student_id, subject_id, score)•{student_id, subject_id} à score\nECE30030/ITP30010 Database Systems73\nPartial Dependencies•For relation R = a1 a2 a3 a4\n•a1 is a part of the primary key•a4 depends on a1, and does not depend on a1a2a3 (a1 ➝ a4)•Key: a1 a2 a3•Dependency: a1 ➝ a4\nECE30030/ITP30010 Database Systems74\nPrimary key (Composite)\nPartial Dependencies•teaches2(ID, course_id, sec_id, semester, year, name)•ID à name•{course_id, sec_id, semester, year} à name\nECE30030/ITP30010 Database Systems75\nPartial Dependencies•SCORE(score_id, student_id, subject_id, score, instructor)•subject_id à instructor (partial dependency) :: WE DON’T WANT TO HAVE THIS\nECE30030/ITP30010 Database Systems76\nTransitive Dependencies•For relation R = a1 a2 a3 a4\n•a1 is the primary key in R•a3 depends on a1 (a1 ➝ a3) -- OK•a4 depends on a3 (a1 ➝ a3 ➝ a4) … non-PK à non-PK\nECE30030/ITP30010 Database Systems77\nCandidate key = a1, a2, {a1,a2}\nTransitive Dependencies•EXAM_SCORE(id, student_id, subject_id, exam_name, exam_score)•{student_id, subject_id} --> FINAL or MIDTERM•{student_id, subject_id} --> 77   43 … from which ?•{student_id, subject_id} à exam_name à exam_score :: transitive dependency\nECE30030/ITP30010 Database Systems78\nMulti-valued Dependencies (MVDs)•Suppose we record names of children, and phone numbers for instructors•inst_child(ID, child_name)•inst_phone(ID, phone_number)à If we combine these schemas to obtain: (multiple orthogonal values in single table à this causes redundancy)•inst_info(ID, child_name, phone_number)à Example tuples: ID=999999 à {David, William} & {x-x-1234, x-x-4321}  (99999, David, 512-555-1234)  (99999, David, 512-555-4321)  (99999, William, 512-555-1234)  (99999, William, 512-555-4321)•Any issues? \nECE30030/ITP40001 Database Systems79\nMulti-valued Dependencies (MVDs)•Let R be a relation schema and let a Í R and b Í R. •The multivalued dependency a ®® b holds on R if in any relation r(R), for all pairs for tuples t1 and t2 in r such that t1[a] = t2 [a], there exist tuples t3 and t4 in r such that:    t1[a] = t2 [a] = t3 [a] = t4 [a]           t3[b] =  t1 [b]           t3[R  – b] =  t2[R  – b]           t4 [b] =  t2[b]           t4[R  – b] =  t1[R  – b] \nECE30030/ITP40001 Database Systems80\nMulti-valued Dependencies (MVDs)•Let R be a relation schema with a set of attributes that are partitioned into 3 non-empty subsets Y, Z, W•We say that Y ®® Z (Y multidetermines Z )if and only if for all possible relations r(R)  < y1, z1, w1 > Î r and < y1, z2, w2 > Î rthen  < y1, z1, w2 > Î r and < y1, z2, w1 > Î r•Note that since the behavior of Z and W are identical it follows that Y ®® Z if Y ®® W\nECE30030/ITP40001 Database Systems81\nMulti-valued Dependencies (MVDs)•Tabular representation of a ®® b\nECE30030/ITP40001 Database Systems82\nMulti-valued Dependencies (MVDs)•FAV(student_id, course, activity)•21800999 - {statistics, Linear algebra} & {Soccer, basketball}•Favorite courses & favorite activities <= they are orthogonal\nECE30030/ITP40001 Database Systems83\nstudent_idcourseactivity21800999StatisticsSoccer21800999Linear algebraBasketball21800999StatisticsBasketball21800999Linear algebraSoccer\nUse of Functional Dependencies•We use functional dependencies to:•Test relations to see if they are legal under a given set of functional dependencies•We say that r satisfies F, if a relation r is legal under a set F of functional dependencies•To specify constraints on the set of legal relations•We say that F holds on R if all legal relations on R satisfy the set of functional dependencies F•Note:  A specific instance of a relation schema may satisfy a functional dependency even if the functional dependency does not hold on all legal instances•E.g., a specific instance of instructor may, by chance, satisfy:  name ® ID\nECE30030/ITP40001 Database Systems84\nUse of Multi\n-\nvalued Dependencies•We use multivalued dependencies in two ways:1.To test relations to determine whether they are legal under a given set of functional and multivalued dependencies2.To specify constraints on the set of legal relations. We shall concern ourselves only with relations that satisfy a given set of functional and multivalued dependencies•If a relation r fails to satisfy a given multivalued dependency, we can construct a relations r¢  that does satisfy the multivalued dependency by adding tuples to r\nECE30030/ITP40001 Database Systems85\nEOF•Coming next:•Advanced SQL\nECE30030/ITP30010 Database Systems86"
        }
      ],
      "notebook_title": "데이터베이스 정규화: 원리, 과정 및 적용",
      "holistic_chapters": [
        {
          "chapter_title": "데이터베이스 정규화 개요 및 필요성",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "데이터가 혼합될 때 발생하는 문제점(데이터 중복, 일관성 문제, 삽입/삭제/갱신 이상 현상)을 설명하고, 이러한 문제에 대한 해결책으로 데이터베이스 정규화의 필요성과 분해(Decomposition)의 개념, 그리고 손실 분해(Lossy Decomposition)와 무손실 분해(Lossless Decomposition)의 차이를 소개합니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems2\nWhen Data is Jumbled…•Suppose that we combine instructor and department •(Below represents the join on instructor and department)\nECE30030/ITP30010 Database Systems3\nWhen Data is Jumbled…•Key issues•Repetition of data à increases the size of database•Data consistency issues•Insertion anomaly: Inserting redundant data for every new record•Deletion anomaly: Loss of related data, when some data is deleted•Update anomaly: When updating certain information, every single record must be updated\nECE30030/ITP30010 Database Systems4\nSolution: Decomposition!•How to avoid the repetition-of-information problem?\n•A: Decompose it into two schemas (as they were)•Normalization = decomposition of relational schemas•Key idea: split relational schemas such that only directly related data composes a relation\nECE30030/ITP30010 Database Systems5\nDecomposition•Less redundancy à Uses smaller disk storage; Causes less issues associated with insertion, deletion, and update anomalies•Not all decompositions are good•E.g., Suppose we decompose   employee(ID, name, street, city, salary)into  employee1 (ID, name)  employee2 (name, street, city, salary)à Problem: What if there are two employees with the same name?•Lossy decomposition: a decomposition from which the original relation cannot be reconstructedECE30030/ITP30010 Database Systems6\nLossy Decomposition\nECE30030/ITP30010 Database Systems7\nLossless Decomposition•Let R be a relation schema and let R1 and R2 form a decomposition of R; that is, R = R1 U R2•A decomposition is a lossless decomposition if there is no loss of information by replacing R with the two relation schemas R1 U R2•Formally,\nÕR1(r)  ⋈  ÕR2(r) = r•C.f., Conversely, a decomposition is lossy if when the join of the projection results is computed, a proper superset of the original relation is returned     r  Ì  ÕR1(r)  ⋈  ÕR2(r)\nECE30030/ITP30010 Database Systems8\nExample: Lossless Decomposition•Decomposition of R = (A, B, C)  à  R1 = (A, B); R2 = (B, C)\nECE30030/ITP30010 Database Systems9\nNormalization•Database normalization: Process of structuring a database to reduce data redundancy and improve data integrity•In accordance with a series of normal forms (next topic)•Through the process:•One can decompose relations to suppress data anomalies•One can make sure the decomposition is lossless"
        },
        {
          "chapter_title": "데이터베이스 정규화 과정 및 일반 형식",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "데이터베이스 정규화가 관계형 데이터베이스 테이블을 더 높은 정규형으로 설계하는 과정임을 설명하고, 논리적으로 독립적인 데이터를 분리하여 키를 통해 연결하는 점진적인 프로세스를 소개합니다. 또한, UNF, 1NF, 2NF, 3NF, BCNF, 4NF 등 주요 정규형의 종류를 나열하고, 이들이 함수적 종속성 등의 이론적 기반을 가진다는 점을 강조합니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems11\nNormal Forms•Normalization process•Normalization is a database design technique, which is used to design a relational database table up to higher normal form•Procedurally separates logically independent (but related) data entities into multiple relations•Maintains the connections using keys•Progressive process•A higher level of database normalization cannot be achieved unless the previous levels have been satisfied•UNF: Unnormalized form•1NF: First normal form•2NF: Second normal form•3NF: Third normal form•BCNF: Boyce-Codd normal form (3.5NF)•4NF: Fourth normal form•…\nECE30030/ITP30010 Database Systems12\nNormal Forms•Normal forms are backed by a set of normalization theories•Functional dependencies•Partial dependencies•Transitive dependencies•Multi-valued dependencies•These theories decide whether a particular relation R is in “good form”•For a relation R is not in “good form”, decompose it into a set of relations {R1, R2, ..., Rn} such that•Each relation is in good form•The decomposition is a lossless decomposition"
        },
        {
          "chapter_title": "함수적 종속성 이해",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "함수적 종속성(Functional Dependency, FD)의 개념을 정의하고, 실제 데이터 제약 조건과의 연관성을 설명합니다. 릴레이션 스키마에서 속성 집합 간의 결정 관계를 예시를 통해 보여주며, 슈퍼 키와 후보 키와의 관계, 그리고 항상 만족되는 자명한 함수적 종속성(Trivial Functional Dependencies)에 대해 다룹니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems15\nFunctional Dependencies•There are usually a variety of constraints (rules) on the data in the real world•E.g., some of the constraints that are expected to hold in the university database are:•Students and instructors are uniquely identified by their ID•Each student and instructor has only one name•Each instructor and student is associated with only one department•Each department has only one value for its budget, and only one associated building•Relations require that the value for a certain set of attributes determines uniquely the value for another set of attributes•A functional dependency is a generalization of the notion of a key(= trivial dependency)\nECE30030/ITP30010 Database Systems16\nFunctional Dependencies•Let R be a relation schema, a and b be its attributes (a Í R and b Í R)•The functional dependency a ® b  holds on R if and only if, for any relations r(R), whenever any two tuples t1 and t2 of r agree on the attributes a, they also agree on the attributes b•That is,  t1[a] = t2 [a]    Þ    t1[b ] = t2 [b ]•E.g., Consider r(A,B) with the following instance of r\nA     B  1     4  1     5  3     7\n•On this instance, B ® A hold;  A ® B does NOT hold (only the values of B are unique)\nECE30030/ITP30010 Database Systems17\nKeys and Functional Dependencies•Functional dependencies allow us to express constraints that cannot be expressed using super keys•E.g., consider the schema:\nin_dep (ID, name, salary, dept_name, building, budget )•ID = instructor ID•dept_name = department of the instructor•We expect the following functional dependencies to hold:•dept_name ® building•ID ® buildingÞdept_name and ID are super keys = candidate keys* ID, dept_name, {ID, dept_name}•We would not expect the next to hold:•dept_name ® salary\nECE30030/ITP30010 Database Systems18\nFunctional Dependencies•For relation R = a1 a2 a3 a4\n•a1 is a part of the key•Functional dependency: a4 depends on its key, a1a2a3•b_id,  b_name, bd_detail_attrib1, , bd_detail_attrib2•Candidate keys: b_id, b_name, {b_id, b_name}•It should not be such that a4 depends on a1, and does not depend on a1a2a3 (a1 ➝ a4)  ⇒  partial dependency\nECE30030/ITP30010 Database Systems19\nCandidate key = a1, a2, a3, {a1, a2}, {a2,a3}, {a1, a3}, {a1,a2,a3}\nTrivial Functional Dependencies•A functional dependency is trivial if it is satisfied by all instances of a relation•Example:•ID, name ® ID•name ® name•In general, a ® b is trivial if b Í a\nECE30030/ITP30010 Database Systems20\nFunctional Dependencies•Example: student2(ID, name, tot_cred)•Hold•ID à name•ID à tot_cred•Not hold•tot_cred à name•name à tot_cred\nECE30030/ITP30010 Database Systems21\nFunctional Dependencies•score(score_id, student_id, subject_id, score)•{student_id, subject_id} à score\nECE30030/ITP30010 Database Systems22\nECE30030/ITP30010 Database Systems22\nECE30030/ITP30010 Database Systems67\nFunctional Dependencies•There are usually a variety of constraints (rules) on the data in the real world•E.g., some of the constraints that are expected to hold in a university database are:•Students and instructors are uniquely identified by their ID•Each student and instructor has only one name•Each instructor and student is (primarily) associated with only one department•Each department has only one value for its budget, and only one associated building•Relations require that the value for a certain set of attributes determines uniquely the value for another set of attributes•A functional dependency is a generalization of the notion of a key(= trivial dependency)\nECE30030/ITP30010 Database Systems68\nFunctional Dependencies•Let R be a relation schema, a and b be its attributes (a Í R and b Í R)•The functional dependency a ® b  holds on R if and only if, for any relations r(R), whenever any two tuples t1 and t2 of r agree on the attributes a, they also agree on the attributes b•That is,  t1[a] = t2 [a]    Þ    t1[b ] = t2 [b ]•E.g., Consider r(A,B) with the following instance of r\nA     B  1     4  1     5  3     7\n•On this instance, B ® A hold;  A ® B does NOT hold (only the values of B are unique)\nECE30030/ITP30010 Database Systems69\nKeys and Functional Dependencies•Functional dependencies allow us to express constraints that cannot be expressed using super keys•E.g., consider the schema:\nin_dep (ID, name, salary, dept_name, building, budget )•ID = instructor ID•dept_name = department of the instructor•We expect the following functional dependencies to hold:•dept_name® building•ID à buildingÞdept_name and ID are super keys = candidate keys* ID, dept_name, {ID, dept_name}•We would not expect the next to hold:•dept_name ® salary\nECE30030/ITP30010 Database Systems70\nFunctional Dependencies•For relation R = a1 a2 a3 a4\n•a1 is a part of the key•Functional dependency: a4 depends on its key, a1a2a3•b_id,  b_name, bd_detail_attrib1, , bd_detail_attrib2•Candidate keys: b_id, b_name, {b_id, b_name}•It should not be such that a4 depends on a1, and does not depend on a1a2a3 (a1 ➝ a4)  ⇒  partial dependency\nECE30030/ITP30010 Database Systems71\nCandidate key = a1, a2, a3, {a1, a2}, {a2,a3}, {a1, a3}, {a1,a2,a3}\nTrivial Functional Dependencies•A functional dependency is trivial if it is satisfied by all instances of a relation•Example:•ID, name ® ID•name ® name•In general, a ® b is trivial if b Í a\nECE30030/ITP30010 Database Systems72\nFunctional Dependencies•student2(ID, name, tot_cred)•ID à name•ID à tot_cred•tot_cred à name (X)\nECE30030/ITP30010 Database Systems73\nFunctional Dependencies•SCORE(score_id, student_id, subject_id, score)•{student_id, subject_id} à score"
        },
        {
          "chapter_title": "제1 정규형 (1NF): 원자성 및 고유성",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "제1 정규형(1NF)의 요구사항을 설명하며, 모든 속성 값이 원자적이어야 하고, 각 컬럼은 동일한 데이터 도메인 내의 값을 포함하며, 고유한 이름을 가져야 한다는 점을 강조합니다. 중복된 행이 없어야 하며, 기본 키(PK)가 고유성과 Not Null을 보장하는 역할을 설명하고, 실제 예시를 통해 1NF로의 변환 과정을 보여줍니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems13\nFirst Normal Form (1NF)•Requirements•A relation should consist of atomic values•Atomic value: a value that cannot be divided (≃primitive data types in JAVA)•Atomic - INT, FLOAT, DOUBLE, DECIMAL (NUMERIC), CHAR, VARCHAR, BLOB, TEXT•NOGO - Structure, List (array)•Attributes should have unique identifiers•Step 1 of the normalization process•“If the tables in your DB does not follow 1NF, stop using database”\nECE30030/ITP30010 Database Systems14\nFirst Normal Form (1NF)•1NF checklist1.Each column should contain an atomic value•Entries like (x, y) violate this rule2.Each column should contain values that are in the same data domain•Do not mix different types of values in a column3.Each column should have a unique name•Duplicate names lead to confusion while accessing data4.The order in which data is stored does not matter•Using SQL, one can easily fetch data in any order5.There are no duplicated rows in the table•Primary key (PK) ensures: •Attributes that are part of PK are unique•Attributes that are part of PK are not null\nECE30030/ITP30010 Database Systems23\nFirst Normal Form (1NF)•Example\nstudent_idnamecourse\n21800999James InexistenteAlgorithm, OS\n21800998Mike InexistenteJava\n21800997Matt InexistenteAlgorithm, DB\nECE30030/ITP30010 Database Systems24\nFirst Normal Form (1NF)•Example\nstudent_idname\n21800999James Inexistente\n21800998Mike Inexistente\n21800997Matt Inexistente\nstudent_idcourse\n21800999Algorithm\n21800999OS\n21800998Java\n21800997Algorithm\n21800997DB\nECE30030/ITP30010 Database Systems25\nFirst Normal Form (1NF)•Example\nstudent_idname\n21800999James Inexistente\n21800998Mike Inexistente\n21800997Matt Inexistente\nstudent_idcourse\n21800999Algorithm\n21800999OS\n21800998Java\n21800997Algorithm\n21800997DB"
        },
        {
          "chapter_title": "제2 정규형 (2NF): 부분 종속성 제거",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "제2 정규형(2NF)의 요구사항을 설명하며, 1NF를 만족하고 기본 키가 아닌 속성이 후보 키의 어떤 부분 집합에도 함수적으로 종속되지 않아야 함을 강조합니다. 부분 종속성(Partial Dependency)의 정의와 이를 제거하기 위한 관계 분해(Decomposition) 과정을 다양한 예시를 통해 구체적으로 설명합니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems26\nSecond Normal Form (2NF)•Requirements•A relation should be in 1NF (normal forms should be applied in order)•A relation should NOT have a non-PK that is functionally dependent on any subset of any candidate key = NO PARTIAL DEPENDENCIES!•Any attributes other than PK should be dependent on PK•It should not have partial dependencies•PK: Primary Key•An attribute or a set of attributes that uniquely identifies each tuple in a relation•A PK can fetch data from any specific data in a relation•E.g., get the department name of student_ID = 21800999\nECE30030/ITP30010 Database Systems27\nPartial Dependencies•For relation R = a1 a2 a3 a4\n•a1 is a part of the primary key•Partial dependency: a4 depends on a1, and does not depend on a1a2a3•Key: a1 a2 a3•Dependency: a1 ➝ a4\nPrimary key (Composite)\nECE30030/ITP30010 Database Systems28\nEliminating Partial Dependencies•Example: teaches2(ID, course_id, sec_id, semester, year, name)•ID à name\nECE30030/ITP30010 Database Systems29\nEliminating Partial Dependencies•Example: •teaches2a(ID, course_id, sec_id, semester, year)•teaches2b(ID, name)\nECE30030/ITP30030Database Systems 30\nEliminating Partial Dependencies•Example: score(score_id, student_id, subject_id, score, instructor)•subject_id à instructor : partial dependency\nscore_idstudent_idsubject_idscoreinstructor\n1 10 1 82James Packer\n3 11 1 95James Packer\n2 10 2 77Cole Miller\n4 11 2 71Cole Miller\n5 11 4 96Adam Lee\nECE30030/ITP30030Database Systems 31\nEliminating Partial Dependencies•Example: score_a(score_id, student_id, subject_id, score)                 score_b(subject_id, instructor)\nscore_idstudent_idsubject_idscore\n1 10 1 82\n3 11 1 95\n2 10 2 77\n4 11 2 71\n5 11 4 96\nsubject_idinstructor\n1 James Packer\n2 Cole Miller\n4 Adam Lee\nECE30030/ITP30010 Database Systems74\nPartial Dependencies•For relation R = a1 a2 a3 a4\n•a1 is a part of the primary key•a4 depends on a1, and does not depend on a1a2a3 (a1 ➝ a4)•Key: a1 a2 a3•Dependency: a1 ➝ a4\nPrimary key (Composite)\nECE30030/ITP30010 Database Systems75\nPartial Dependencies•teaches2(ID, course_id, sec_id, semester, year, name)•ID à name•{course_id, sec_id, semester, year} à name\nECE30030/ITP30010 Database Systems76\nPartial Dependencies•SCORE(score_id, student_id, subject_id, score, instructor)•subject_id à instructor (partial dependency) :: WE DON’T WANT TO HAVE THIS"
        },
        {
          "chapter_title": "제3 정규형 (3NF): 이행적 종속성 제거",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "제3 정규형(3NF)의 요구사항을 설명하며, 2NF를 만족하고 이행적 종속성(Transitive Dependency)이 없어야 함을 강조합니다. 이행적 종속성은 기본 키가 아닌 속성이 다른 기본 키가 아닌 속성에 종속되는 경우를 의미하며, 이를 제거하기 위한 관계 분해 과정을 다양한 도서 및 시험 점수 관리 예시를 통해 상세히 제시합니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems32\nThird Normal Form (3NF)•Requirements•A relation should be in 2NF •A relation should NOT have transitive dependencies•Transitive dependency: A non-PK attribute depends on another non-PK attribute or a set of non-PK attributes\nECE30030/ITP30010 Database Systems33\nTransitive Dependencies•For relation R = a1 a2 a3 a4\n•a1 is the primary key in R•a3 depends on a1 (a1 ➝ a3) -- OK•a4 depends on a3 (a1 ➝ a3 ➝ a4) … non-PK à non-PK\nCandidate key = a1, a2, {a1,a2}\nECE30030/ITP30010 Database Systems34\nEliminating Transitive Dependencies•Example\nBookNoPatronAddressDue\nB1J. Fisher101 Main Street3/2/15\nB2L. Perez202 Market Street 2/28/15\nECE30030/ITP30010 Database Systems35\nEliminating Transitive Dependencies•Example\n•PK: BookNo•Patron à Address\nBookNoPatronAddressDue\nB1J. Fisher101 Main Street3/2/15\nB2L. Perez202 Market Street 2/28/15\nECE30030/ITP30010 Database Systems36\nEliminating Transitive Dependencies•Example\nBookNoPatronDue\nB1J. Fisher3/2/15\nB2L. Perez2/28/15PatronAddressJ. Fisher101 Main StreetL. Perez202 Market Street\nECE30030/ITP30010 Database Systems37\nEliminating Transitive Dependencies•Example\n•PK: {Tournament, Year}•Winner à DOB\nTournamentYearWinner DOB\nIndiana Invitational1998Al Fredrickson21 July 1975\nCleveland Open1999Bob Albertson28 Sept. 1968\nDes Moines Masters1999Al Fredrickson21 July 1975\nECE30030/ITP30010 Database Systems38\nEliminating Transitive Dependencies•Example: score2(id, student_id, subject_id, exam_name, exam_score)•{student_id, subject_id} --> FINAL or MIDTERM•{student_id, subject_id} --> 77   43 … from which ?•{student_id, subject_id} à exam_name à exam_score :: transitive dependency\nECE30030/ITP30010 Database Systems39\nEliminating Transitive Dependencies•Example: score2(id, student_id, subject_id, exam_name, exam_score)•student_id, subject_id à exam_name•student_id, subject_id à exam_name à exam_score\nECE30030/ITP30010 Database Systems40\nEliminating Transitive Dependencies•Example: score2a(id, student_id, subject_id, exam_id, exam_name)                 score2b(student_id, subject_id, exam_id, exam_score)\nECE30030/ITP30010 Database Systems77\nTransitive Dependencies•For relation R = a1 a2 a3 a4\n•a1 is the primary key in R•a3 depends on a1 (a1 ➝ a3) -- OK•a4 depends on a3 (a1 ➝ a3 ➝ a4) … non-PK à non-PK\nCandidate key = a1, a2, {a1,a2}\nECE30030/ITP30010 Database Systems78\nTransitive Dependencies•EXAM_SCORE(id, student_id, subject_id, exam_name, exam_score)•{student_id, subject_id} --> FINAL or MIDTERM•{student_id, subject_id} --> 77   43 … from which ?•{student_id, subject_id} à exam_name à exam_score :: transitive dependency"
        },
        {
          "chapter_title": "보이스-코드 정규형 (BCNF): 강화된 제3 정규형",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "보이스-코드 정규형(BCNF)은 제3 정규형을 강화한 형태로, A → B 종속성이 있을 때 A가 반드시 슈퍼 키여야 한다는 요구사항을 설명합니다. 즉, 기본 키가 아닌 속성이 기본 키의 일부를 결정하는 경우가 없어야 하며, 이를 위반하는 사례와 BCNF를 만족하도록 관계를 분해하는 과정을 예시를 통해 보여줍니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems41\nBoyce-Codd Normal Form (BCNF) = 3.5NF•Requirements•A relation should be in 3NF•For any dependency A à B, A should be a super key•For A à B, if A is non-PK, then it is NOT in BCNF\nECE30030/ITP30010 Database Systems42\nBoyce-Codd Normal Form (BCNF)•Example: takes2(student_id, subject, instructor)\n•(student, subject) à instructor•Instructor à subject•A non-PK identifies a member of PK: Not in BCNF\nstudent_idsubjectinstructor\n21800999C++ Dr. Cpp\n21800999Java Dr. Java\n21800998C++ Dr. C\n21800997PythonDr. Python\n21800996C++ Dr. Cpp\nECE30030/ITP30010 Database Systems43\nBoyce-Codd Normal Form (BCNF)•Example: takes2a(student_id, section_id),\ntakes2b(section_id, subject, instructor)\nstudent_idsection_id\n21800999101\n21800999103\n21800998102\n21800997104\n21800996101section_idsubjectinstructor\n101 C++ Dr. Cpp\n103 Java Dr. Java\n102 C++ Dr. C\n104 PythonDr. Python\nECE30030/ITP30010 Database Systems44\nBoyce-Codd Normal Form (BCNF)•Example: takes2a(student_id, section_id),\ntakes2b(section_id, subject, instructor)\nstudent_idsection_id\n21800999101\n21800999103\n21800998102\n21800997104\n21800996101section_idsubjectinstructor\n101 C++ Dr. Cpp\n103 Java Dr. Java\n102 C++ Dr. C\n104 PythonDr. Python"
        },
        {
          "chapter_title": "제4 정규형 (4NF): 다치 종속성 제거",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "제4 정규형(4NF)의 요구사항을 설명하며, BCNF를 만족하고 다치 종속성(Multi-valued Dependency, MVD)이 없어야 함을 강조합니다. 다치 종속성은 릴레이션에 3개 이상의 속성이 있고, 서로 독립적인 다치 속성 집합이 존재할 때 발생할 수 있으며, 이를 제거하기 위한 관계 분해 과정을 학생의 수강 과목 및 활동 예시를 통해 설명합니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems45\nFourth Normal Form (4NF)•Requirements•A relation should be in BCNF•A relation should NOT have multi-valued dependency•Multi-valued dependency occurs due to a bad DB schema•Multi-valued dependency occurs when a relation has more than 3 attributes•For a relation with attributes A, B, C•having dependency, A à B, and•B and C are independent from each otherè Then, the relation may have a multi-valued dependency\nECE30030/ITP30010 Database Systems46\nMulti-valued Dependencies•Example•student_id à course•student_id à activity•course ⊥ activity (independent)\nstudent_idcourseactivity\n21800999StatisticsSoccer\n21800999Linear algebraBasketball\n21800999StatisticsBasketball\n21800999Linear algebraSoccer\nECE30030/ITP30010 Database Systems47\nMulti-valued Dependencies•Example\nstudent_idcourse\n21800999Statistics\n21800999Linear algebra\n21800998Physics\n21800998Programming 101student_idactivity\n21800999Soccer\n21800999Basketball\n21800998Pool\n21800997Soccer\nECE30030/ITP40001 Database Systems79\nMulti-valued Dependencies (MVDs)•Suppose we record names of children, and phone numbers for instructors•inst_child(ID, child_name)•inst_phone(ID, phone_number)à If we combine these schemas to obtain: (multiple orthogonal values in single table à this causes redundancy)•inst_info(ID, child_name, phone_number)à Example tuples: ID=999999 à {David, William} & {x-x-1234, x-x-4321}  (99999, David, 512-555-1234)  (99999, David, 512-555-4321)  (99999, William, 512-555-1234)  (99999, William, 512-555-4321)•Any issues?\nECE30030/ITP40001 Database Systems80\nMulti-valued Dependencies (MVDs)•Let R be a relation schema and let a Í R and b Í R. •The multivalued dependency a ®® b holds on R if in any relation r(R), for all pairs for tuples t1 and t2 in r such that t1[a] = t2 [a], there exist tuples t3 and t4 in r such that:    t1[a] = t2 [a] = t3 [a] = t4 [a]           t3[b] =  t1 [b]           t3[R  – b] =  t2[R  – b]           t4 [b] =  t2[b]           t4[R  – b] =  t1[R  – b]\nECE30030/ITP40001 Database Systems81\nMulti-valued Dependencies (MVDs)•Let R be a relation schema with a set of attributes that are partitioned into 3 non-empty subsets Y, Z, W•We say that Y ®® Z (Y multidetermines Z )if and only if for all possible relations r(R)  < y1, z1, w1 > Î r and < y1, z2, w2 > Î rthen  < y1, z1, w2 > Î r and < y1, z2, w1 > Î r•Note that since the behavior of Z and W are identical it follows that Y ®® Z if Y ®® W\nECE30030/ITP40001 Database Systems82\nMulti-valued Dependencies (MVDs)•Tabular representation of a ®® b\nECE30030/ITP40001 Database Systems83\nMulti-valued Dependencies (MVDs)•FAV(student_id, course, activity)•21800999 - {statistics, Linear algebra} & {Soccer, basketball}•Favorite courses & favorite activities <= they are orthogonal\nstudent_idcourseactivity\n21800999StatisticsSoccer\n21800999Linear algebraBasketball\n21800999StatisticsBasketball\n21800999Linear algebraSoccer"
        },
        {
          "chapter_title": "정규화 이론 및 종속성 요약",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "각 정규형(2NF, 3NF, BCNF, 4NF, 5NF)과 관련된 핵심 이론 및 종속성(함수적, 부분, 이행적, 다치, 조인 종속성)을 요약하여 제시합니다. 정규화 이론이 '좋은 형태'의 릴레이션을 결정하고 무손실 분해를 통해 이를 달성하는 데 사용됨을 강조하며, 함수적 종속성과 다치 종속성이 데이터베이스의 유효성 검사 및 제약 조건 지정에 어떻게 활용되는지 설명합니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems48\nSummary: Normal Forms•Theories – Normal forms\nTheory Key IdeaNormal Form\nFunctional dependency(PK à non-PK)2NF\nPartial dependencyPart of PK à non-PK2NF\nTransitive dependencyNon-PK à non-PK3NF\n- Non-PK à PK BCNF\nMulti-valued dependency4NF\nJoin dependency5NF\nECE30030/ITP30010 Database Systems65\nNormalization Theory•Decide whether a particular relation R is in “good form”•For a relation R is not in “good form”, decompose it into a set of relations {R1, R2, ..., Rn} such that•Each relation is in good form•The decomposition is a lossless decomposition\nECE30030/ITP30010 Database Systems66\nNormalization Theory•The normalization is based on a set of relevant theories:•Functional dependencies•Partial dependencies•Transitive dependencies•Multivalued dependencies\nECE30030/ITP40001 Database Systems84\nUse of Functional Dependencies•We use functional dependencies to:•Test relations to see if they are legal under a given set of functional dependencies•We say that r satisfies F, if a relation r is legal under a set F of functional dependencies•To specify constraints on the set of legal relations•We say that F holds on R if all legal relations on R satisfy the set of functional dependencies F•Note:  A specific instance of a relation schema may satisfy a functional dependency even if the functional dependency does not hold on all legal instances•E.g., a specific instance of instructor may, by chance, satisfy:  name ® ID\nECE30030/ITP40001 Database Systems85\nUse of Multi\n-\nvalued Dependencies•We use multivalued dependencies in two ways:1.To test relations to determine whether they are legal under a given set of functional and multivalued dependencies2.To specify constraints on the set of legal relations. We shall concern ourselves only with relations that satisfy a given set of functional and multivalued dependencies•If a relation r fails to satisfy a given multivalued dependency, we can construct a relations r¢  that does satisfy the multivalued dependency by adding tuples to r"
        },
        {
          "chapter_title": "정규화 실전 예시",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "위키피디아에서 가져온 서적 소매업 데이터베이스 예시를 통해 데이터베이스 정규화 과정을 단계별로 상세히 설명합니다. 1NF, 2NF, 3NF, BCNF, 그리고 4NF를 만족하도록 테이블을 분해하고 종속성을 제거하는 실제 적용 사례를 보여주며, 각 정규형의 요구사항이 어떻게 충족되는지 시각적으로 제시합니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems53\nExample (taken from Wikipedia)•Provided:\nECE30030/ITP30010 Database Systems54\nExample (taken from Wikipedia)•Satisfying 1NF\nECE30030/ITP30010 Database Systems55\nExample (taken from Wikipedia)•Satisfying 1NF (cont’d – further improvement)\nECE30030/ITP30010 Database Systems56\nExample (taken from Wikipedia)•Provided:\n•Compound key {Title, Format}•Partial dependency: Title à Author, Author Nationality, Pages, Thickness, Genre ID, Genre Name, Publisher ID\nECE30030/ITP30010 Database Systems57\nExample (taken from Wikipedia)•Satisfying 2NF\nECE30030/ITP30010 Database Systems58\nExample (taken from Wikipedia)•Satisfying 3NF\n•Transitive dependency: Genre ID à Genre Name\nECE30030/ITP30010 Database Systems59\nExample (taken from Wikipedia)•Satisfying 3NF\nECE30030/ITP30010 Database Systems60\nExample (taken from Wikipedia)•Satisfying BCNF\n•Non-PK à Non-PK: Author à Author Nationality\nECE30030/ITP30010 Database Systems61\nExample (taken from Wikipedia)•Satisfying BCNF\nECE30030/ITP30010 Database Systems62\nExample (taken from Wikipedia)•Provided:•Assume the database is owned by a book retailer franchise that has several franchisees that own shops in different locations\nECE30030/ITP30010 Database Systems63\nExample (taken from Wikipedia)•Satisfying 4NF•If we assume that all available books are offered in each area, the Title is not unambiguously bound to a certain Locationà Does not satisfy 4NF\nECE30030/ITP30030Database Systems 64\n•Source: https://en.wikipedia.org/wiki/Database_normalization"
        },
        {
          "chapter_title": "데이터베이스 설계 과정 및 비정규화",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "데이터베이스 설계 과정에서 정규화가 어떻게 통합되는지 설명합니다. E-R 모델 설계의 중요성과 정규화의 관계를 다루고, 성능 향상을 위해 의도적으로 정규화되지 않은 스키마를 사용하는 비정규화(Denormalization)의 개념과 그 장단점을 제시합니다. 또한, 연도별 수익 데이터와 같은 특정 설계 문제가 정규화만으로는 해결되지 않을 수 있음을 지적하며 더 나은 스키마 설계를 제안합니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems49\nOverall DB Design Process•Let us assume schema R is given:(E-R Model)•R could have been generated when converting E-R diagram to a set of tables(Normalization)•R could have been a single relation containing all attributes that are of interest (called universal relation)•Normalization breaks R into smaller relations(Mixed)•R could have been the result of some ad-hoc design of relations, which we then test/convert to normal form\nECE30030/ITP30010 Database Systems50\nE-R Model and Normalization•When an E-R diagram is carefully designed, identifying all entities correctly, the tables generated from the E-R diagram should not need further normalization•However, in a real (imperfect) design, there can be functional dependencies from non-key attributes of an entity to other attributes of the entity•E.g., an employee entity with•attributesdepartment_name and building•functional dependencydepartment_name® building•Good design would have made department an entity•Functional dependencies from non-key attributes of a relationship set possible, but rare --- most relationships are binary\nECE30030/ITP30010 Database Systems51\nDenormalization for Performance•We may want to use non-normalized schema for performance•For example, displaying prereqs along with course_id, and title requires join of course with prereq•Alternative 1: Use denormalized relation containing attributes of course as well as prereq with all above attributes•faster lookup•extra space and extra execution time for updates•extra coding work for programmer and possibility of error in extra code•Alternative 2: Use a materialized view defined a course ⋈ prereq•Benefits and drawbacks same as above, except no extra coding work for programmer and avoids possible errors\nECE30030/ITP30010 Database Systems52\nRemaining Issues•Some aspects of database design are not caught by normalization•Example (to be avoided)•earnings_2004, earnings_2005, earnings_2006, etc., all on the schema (company_id, earnings)•Above are well normalized (in BCNF), but make querying across years difficult and needs new table each year•company_year (company_id, earnings_2004, earnings_2005,  earnings_2006)•Above are well normalized (in BCNF), but makes querying across years difficult and requires new attribute each year•This is an example of a crosstab, where values for one attribute become column namesà Better schema: earnings (company_id, year, amount)"
        }
      ],
      "generated_content": [
        {
          "title": "데이터베이스 정규화 개요 및 필요성",
          "metadata": "Source: a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf, Text length: 1990 chars",
          "documentContent": [
            {
              "type": "heading",
              "content": "데이터 혼합 시 발생하는 문제점",
              "level": 1
            },
            {
              "type": "paragraph",
              "content": "강사(instructor)와 학과(department) 데이터를 결합하는 경우를 가정해 봅시다. 아래는 강사 및 학과에 대한 조인(join)을 나타냅니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "데이터가 혼합될 때 발생하는 주요 문제점들은 다음과 같습니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "데이터 중복: 데이터베이스 크기를 증가시킵니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "데이터 일관성 문제:",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "삽입 이상(Insertion anomaly): 새로운 레코드를 삽입할 때마다 중복된 데이터를 삽입해야 합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "삭제 이상(Deletion anomaly): 일부 데이터가 삭제될 때 관련 데이터가 손실됩니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "갱신 이상(Update anomaly): 특정 정보를 갱신할 때 모든 관련 레코드를 갱신해야 합니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "해결책: 분해(Decomposition)!",
              "level": 1
            },
            {
              "type": "paragraph",
              "content": "정보 중복 문제를 어떻게 피할 수 있을까요?",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "해답은 원래의 두 스키마로 분해하는 것입니다. 정규화(Normalization)는 관계형 스키마의 분해를 의미합니다. 핵심 아이디어는 직접적으로 관련된 데이터만 하나의 릴레이션을 구성하도록 관계형 스키마를 분할하는 것입니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "분해(Decomposition)",
              "level": 1
            },
            {
              "type": "paragraph",
              "content": "분해는 데이터 중복을 줄여 더 적은 디스크 저장 공간을 사용하게 하며, 삽입, 삭제, 갱신 이상과 관련된 문제를 감소시킵니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "하지만 모든 분해가 좋은 것은 아닙니다. 예를 들어, employee(ID, name, street, city, salary)를 employee1(ID, name)과 employee2(name, street, city, salary)로 분해한다고 가정해 봅시다. 만약 같은 이름을 가진 두 명의 직원이 있다면 문제가 발생합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "손실 분해(Lossy decomposition): 원본 릴레이션을 재구성할 수 없는 분해를 의미합니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "무손실 분해(Lossless Decomposition)",
              "level": 1
            },
            {
              "type": "paragraph",
              "content": "R을 관계형 스키마라고 하고, R1과 R2가 R의 분해를 형성한다고 합시다. 즉, R = R1 ∪ R2 입니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "분해가 무손실 분해(lossless decomposition)라는 것은 R을 두 관계형 스키마 R1 ∪ R2로 대체함으로써 정보 손실이 없음을 의미합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "공식적으로는 ÕR1(r) ⋈ ÕR2(r) = r 입니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "반대로, 투영 결과의 조인이 계산될 때 원본 릴레이션의 진부분 집합(proper superset)이 반환되는 경우 분해는 손실 분해(lossy decomposition)입니다. 즉, r ⊂ ÕR1(r) ⋈ ÕR2(r) 입니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "무손실 분해 예시",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "R = (A, B, C)를 R1 = (A, B)와 R2 = (B, C)로 분해하는 예시입니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "정규화(Normalization)",
              "level": 1
            },
            {
              "type": "paragraph",
              "content": "데이터베이스 정규화는 데이터 중복을 줄이고 데이터 무결성을 향상시키기 위해 데이터베이스를 구조화하는 과정입니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "이는 일련의 정규형(다음 주제)에 따라 수행됩니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "정규화 과정을 통해 릴레이션을 분해하여 데이터 이상(anomalies)을 억제할 수 있으며, 분해가 무손실임을 확인할 수 있습니다.",
              "level": null
            }
          ],
          "aiNotes": {
            "summary": "본 텍스트는 데이터베이스에서 데이터가 혼합될 때 발생하는 중복 및 일관성 문제, 특히 삽입, 삭제, 갱신 이상과 같은 '데이터 이상' 현상을 다룹니다. 이러한 문제의 해결책으로 '분해'와 '정규화' 개념을 소개하며, 관계형 스키마를 분할하여 데이터 중복을 줄이고 데이터 무결성을 높이는 방법을 설명합니다. 특히, 분해 과정에서 정보 손실이 발생하지 않도록 하는 '무손실 분해'의 중요성과 그 정의를 강조합니다. 정규화는 데이터 이상을 억제하고 분해가 무손실임을 보장하는 체계적인 과정으로 제시됩니다.",
            "keyConcepts": [
              {
                "term": "데이터 이상 (Data Anomalies)",
                "definition": {
                  "easy": "데이터가 엉망이 돼서 추가, 삭제, 수정할 때 문제가 생기는 거예요.",
                  "medium": "데이터베이스 내에 중복된 데이터로 인해 발생하는 비일관성 문제로, 삽입, 삭제, 갱신 시 예상치 못한 부작용을 초래합니다.",
                  "hard": "관계형 데이터베이스에서 릴레이션의 속성 간에 적절한 함수적 종속성이 확립되지 않아 발생하는 데이터 일관성 위반 문제로, 삽입 이상, 삭제 이상, 갱신 이상으로 구분되며 데이터 무결성을 저해합니다."
                }
              },
              {
                "term": "정규화 (Normalization)",
                "definition": {
                  "easy": "데이터를 깔끔하게 정리해서 중복을 줄이고 문제 없게 만드는 과정이에요.",
                  "medium": "데이터 중복을 최소화하고 데이터 무결성을 향상시키기 위해 관계형 데이터베이스 스키마를 체계적으로 분해하는 과정입니다.",
                  "hard": "관계형 데이터베이스 설계에서 데이터 중복성을 줄이고 삽입, 삭제, 갱신 이상과 같은 데이터 이상 현상을 방지하며 데이터 무결성을 보장하기 위해, 일련의 정규형 규칙에 따라 릴레이션 스키마를 분해하고 재구성하는 절차입니다."
                }
              },
              {
                "term": "분해 (Decomposition)",
                "definition": {
                  "easy": "큰 덩어리의 데이터를 작은 여러 덩어리로 나누는 거예요.",
                  "medium": "하나의 관계형 스키마를 두 개 이상의 작은 스키마로 나누는 과정으로, 데이터 중복을 줄이고 효율성을 높이는 데 사용됩니다.",
                  "hard": "관계형 데이터베이스에서 하나의 릴레이션 스키마를 둘 이상의 릴레이션 스키마로 분할하는 연산으로, 이 과정에서 원래의 릴레이션이 가지던 함수적 종속성 및 기타 제약 조건이 유지되도록 해야 하며, 특히 무손실 조인 분해가 중요하게 고려됩니다."
                }
              },
              {
                "term": "무손실 분해 (Lossless Decomposition)",
                "definition": {
                  "easy": "데이터를 나눴다가 다시 합쳐도 원래 데이터가 그대로 유지되는 분해예요.",
                  "medium": "릴레이션을 여러 개의 하위 릴레이션으로 분해한 후, 이 하위 릴레이션들을 다시 조인했을 때 원래의 릴레이션과 동일한 정보를 얻을 수 있는 분해 방식입니다.",
                  "hard": "관계형 스키마 R을 R1과 R2로 분해했을 때, 원래 릴레이션 r에 대한 R1과 R2의 투영(projection) 결과를 자연 조인(natural join)한 결과가 r과 정확히 일치하는 경우를 의미하며, 이는 정보 손실 없이 원래의 데이터를 재구성할 수 있음을 보장합니다."
                }
              }
            ],
            "importantTerms": [
              {
                "term": "삽입 이상 (Insertion anomaly)",
                "definition": "새로운 레코드를 추가할 때 원치 않는 중복 데이터가 함께 삽입되거나, 필요한 정보가 없어 삽입이 불가능해지는 문제."
              },
              {
                "term": "삭제 이상 (Deletion anomaly)",
                "definition": "레코드를 삭제할 때, 삭제하려는 정보 외에 다른 중요한 정보까지 함께 손실되는 문제."
              },
              {
                "term": "갱신 이상 (Update anomaly)",
                "definition": "중복된 데이터 중 일부만 갱신되어 데이터 불일치가 발생하는 문제."
              },
              {
                "term": "손실 분해 (Lossy Decomposition)",
                "definition": "릴레이션을 분해한 후 다시 조인했을 때, 원래 릴레이션의 정보가 손실되거나 불필요한 튜플이 생성되는 분해."
              },
              {
                "term": "관계형 스키마 (Relational Schema)",
                "definition": "관계형 데이터베이스에서 릴레이션의 이름과 속성(컬럼) 및 그들의 도메인(데이터 타입)을 정의하는 논리적 구조."
              },
              {
                "term": "데이터 무결성 (Data Integrity)",
                "definition": "데이터베이스 내의 데이터가 정확하고 일관되며 신뢰할 수 있는 상태를 유지하는 것."
              }
            ],
            "outline": [
              {
                "text": "데이터 혼합 시 발생하는 문제점",
                "id": "데이터-혼합-시-발생하는-문제점",
                "children": null
              },
              {
                "text": "해결책: 분해(Decomposition)!",
                "id": "해결책-분해-decomposition",
                "children": null
              },
              {
                "text": "분해(Decomposition)",
                "id": "분해-decomposition",
                "children": null
              },
              {
                "text": "무손실 분해(Lossless Decomposition)",
                "id": "무손실-분해-lossless-decomposition",
                "children": [
                  {
                    "text": "무손실 분해 예시",
                    "id": "무손실-분해-예시",
                    "children": null
                  }
                ]
              },
              {
                "text": "정규화(Normalization)",
                "id": "정규화-normalization",
                "children": null
              }
            ]
          },
          "quiz": [
            {
              "question": "데이터베이스에서 데이터가 혼합될 때 발생할 수 있는 주요 문제점이 아닌 것은 무엇입니까?",
              "options": [
                "데이터 중복 증가",
                "데이터 일관성 문제",
                "데이터 처리 속도 향상",
                "삽입, 삭제, 갱신 이상 발생"
              ],
              "answerIndex": 2,
              "explanation": "데이터가 혼합되면 데이터 중복과 일관성 문제가 발생하며, 이는 삽입, 삭제, 갱신 이상으로 이어져 데이터 처리 속도가 저하될 수 있습니다. 데이터 처리 속도 향상은 문제점이 아닙니다."
            },
            {
              "question": "다음 중 '원본 릴레이션을 재구성할 수 없는 분해'를 의미하는 용어는 무엇입니까?",
              "options": [
                "무손실 분해",
                "정규화",
                "손실 분해",
                "데이터 일관성"
              ],
              "answerIndex": 2,
              "explanation": "손실 분해(Lossy decomposition)는 분해 후 원본 릴레이션을 정확히 재구성할 수 없어 정보가 손실되거나 불필요한 정보가 추가되는 분해를 의미합니다."
            },
            {
              "question": "데이터베이스 정규화의 주요 목적 두 가지는 무엇입니까?",
              "options": [
                "디스크 저장 공간 증가, 데이터 처리 속도 감소",
                "데이터 중복 감소, 데이터 무결성 향상",
                "데이터 보안 강화, 사용자 인터페이스 개선",
                "보고서 생성 자동화, 백업 절차 간소화"
              ],
              "answerIndex": 1,
              "explanation": "데이터베이스 정규화의 주된 목적은 데이터 중복을 줄이고 데이터 일관성 및 정확성을 보장하는 데이터 무결성을 향상시키는 것입니다."
            }
          ]
        },
        {
          "title": "데이터베이스 정규화 과정 및 일반 형식",
          "metadata": "Source: a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf, Text length: 961 chars",
          "documentContent": [
            {
              "type": "heading",
              "content": "정규 형식 (Normal Forms)",
              "level": 1
            },
            {
              "type": "paragraph",
              "content": "정규화는 관계형 데이터베이스 테이블을 더 높은 정규 형식으로 설계하는 데 사용되는 데이터베이스 설계 기법입니다. 이 과정은 논리적으로 독립적이지만 상호 관련된 데이터 엔티티를 여러 릴레이션으로 절차적으로 분리하며, 키를 사용하여 연결을 유지합니다. 정규화는 점진적인 과정으로, 이전 단계가 충족되지 않으면 더 높은 수준의 데이터베이스 정규화를 달성할 수 없습니다. 일반적인 정규화 단계는 다음과 같습니다: UNF (비정규 형식), 1NF (제1 정규 형식), 2NF (제2 정규 형식), 3NF (제3 정규 형식), BCNF (보이스-코드 정규 형식, 3.5NF), 4NF (제4 정규 형식) 등이 있습니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "정규 형식은 일련의 정규화 이론에 의해 뒷받침됩니다. 이러한 이론에는 함수적 종속성, 부분 종속성, 이행 종속성, 다치 종속성 등이 포함됩니다. 이러한 이론들은 특정 릴레이션 R이 '좋은 형식'에 있는지 여부를 결정합니다. 만약 릴레이션 R이 '좋은 형식'이 아니라면, 각 릴레이션이 좋은 형식에 있고 분해가 손실 없는 분해(lossless decomposition)가 되도록 {R1, R2, ..., Rn}과 같은 릴레이션 집합으로 분해해야 합니다.",
              "level": null
            }
          ],
          "aiNotes": {
            "summary": "제공된 텍스트는 데이터베이스 정규화의 개념과 과정을 설명합니다. 정규화는 관계형 데이터베이스 설계 기법으로, 데이터 중복을 최소화하고 데이터 무결성을 유지하기 위해 논리적으로 독립된 데이터를 여러 릴레이션으로 분리하는 점진적인 과정입니다. UNF부터 4NF(BCNF 포함)까지의 다양한 정규 형식 단계를 소개하며, 정규화 이론이 함수적, 부분, 이행, 다치 종속성과 같은 개념에 기반을 두고 있음을 언급합니다. 또한, '좋은 형식'이 아닌 릴레이션은 손실 없는 분해를 통해 여러 '좋은 형식' 릴레이션으로 분해되어야 한다고 강조합니다.",
            "keyConcepts": [
              {
                "term": "데이터베이스 정규화 (Database Normalization)",
                "definition": {
                  "easy": "데이터를 잘 정리해서 중복을 줄이고 효율적으로 만드는 과정.",
                  "medium": "관계형 데이터베이스 설계 기법으로, 논리적으로 독립적인 데이터를 여러 관계로 분리하여 중복을 최소화하고 데이터 무결성을 유지하는 과정.",
                  "hard": "관계형 스키마 설계에서 데이터 중복을 제거하고 갱신 이상(update anomalies)을 방지하기 위해 릴레이션을 더 작은 릴레이션으로 분해하는 체계적인 과정으로, 함수적 종속성(functional dependencies)과 같은 이론적 기반을 바탕으로 한다."
                }
              },
              {
                "term": "정규 형식 (Normal Forms)",
                "definition": {
                  "easy": "데이터베이스가 얼마나 잘 정리되어 있는지 나타내는 단계.",
                  "medium": "관계형 데이터베이스 릴레이션이 특정 조건을 만족하는지 여부를 나타내는 단계로, 데이터 중복 및 이상 현상을 줄이는 데 사용된다.",
                  "hard": "관계형 데이터베이스 스키마 설계에서 릴레이션 스키마의 바람직한 속성을 정의하는 일련의 기준. 각 정규 형식은 특정 유형의 데이터 종속성(예: 부분 함수 종속, 이행 함수 종속)을 제거하여 갱신 이상을 방지하고 데이터 일관성을 향상시킨다."
                }
              },
              {
                "term": "손실 없는 분해 (Lossless Decomposition)",
                "definition": {
                  "easy": "데이터를 나눴다가 다시 합쳐도 원래 데이터가 그대로 유지되는 것.",
                  "medium": "릴레이션을 여러 개의 작은 릴레이션으로 분해할 때, 분해된 릴레이션들을 자연 조인(natural join)하여 원래의 릴레이션을 완벽하게 재구성할 수 있는 분해 방식.",
                  "hard": "관계형 데이터베이스에서 하나의 릴레이션 R을 R1, R2, ..., Rn으로 분해할 때, R = R1 ⋈ R2 ⋈ ... ⋈ Rn이 성립하여 정보 손실이 발생하지 않는 분해를 의미한다. 이는 무결성을 유지하며 중복을 제거하는 데 필수적이다."
                }
              }
            ],
            "importantTerms": [
              {
                "term": "관계형 데이터베이스 (Relational Database)",
                "definition": "데이터를 테이블(릴레이션) 형태로 저장하고 관리하는 데이터베이스 시스템."
              },
              {
                "term": "함수적 종속성 (Functional Dependency)",
                "definition": "릴레이션에서 어떤 속성 집합 X의 값이 다른 속성 집합 Y의 값을 유일하게 결정하는 관계 (X → Y)."
              },
              {
                "term": "부분 함수 종속성 (Partial Dependency)",
                "definition": "기본 키의 일부에 의해 결정되는 비기본 키 속성이 존재하는 경우."
              },
              {
                "term": "이행 함수 종속성 (Transitive Dependency)",
                "definition": "A → B이고 B → C가 성립할 때, A → C가 성립하며 B가 기본 키의 일부가 아닌 경우."
              },
              {
                "term": "다치 종속성 (Multi-valued Dependency)",
                "definition": "릴레이션에서 한 속성의 값이 다른 속성의 여러 값을 결정하는 경우."
              },
              {
                "term": "릴레이션 (Relation)",
                "definition": "관계형 데이터베이스에서 데이터를 저장하는 테이블."
              }
            ],
            "outline": [
              {
                "text": "정규 형식의 개요",
                "id": "정규-형식의-개요",
                "children": [
                  {
                    "text": "정규화 과정의 정의 및 목적",
                    "id": "정규화-과정의-정의-및-목적",
                    "children": null
                  },
                  {
                    "text": "정규화 단계",
                    "id": "정규화-단계",
                    "children": null
                  }
                ]
              },
              {
                "text": "정규 형식의 이론적 배경",
                "id": "정규-형식의-이론적-배경",
                "children": [
                  {
                    "text": "정규화 이론의 기초",
                    "id": "정규화-이론의-기초",
                    "children": null
                  },
                  {
                    "text": "릴레이션 분해의 원칙",
                    "id": "릴레이션-분해의-원칙",
                    "children": null
                  }
                ]
              }
            ]
          },
          "quiz": [
            {
              "question": "데이터베이스 정규화의 주요 목적은 무엇입니까?",
              "options": [
                "데이터 저장 공간 확장",
                "데이터 중복 최소화 및 무결성 유지",
                "데이터베이스 보안 강화",
                "쿼리 처리 속도 저하"
              ],
              "answerIndex": 1,
              "explanation": "정규화는 데이터 중복을 줄이고 논리적으로 독립적인 데이터를 분리하여 데이터 무결성을 유지하는 데 중점을 둡니다."
            },
            {
              "question": "다음 중 주어진 텍스트에서 데이터베이스 정규화의 단계로 명시적으로 언급되지 않은 것은 무엇입니까?",
              "options": [
                "1NF",
                "BCNF",
                "5NF",
                "UNF"
              ],
              "answerIndex": 2,
              "explanation": "주어진 텍스트에서 언급된 정규화 단계는 UNF, 1NF, 2NF, 3NF, BCNF, 4NF입니다. 5NF는 언급되지 않았습니다."
            },
            {
              "question": "릴레이션 R을 R1, R2, ..., Rn으로 분해할 때, 분해된 릴레이션들을 조인하여 원래의 R을 완벽하게 재구성할 수 있는 분해를 무엇이라고 합니까?",
              "options": [
                "손실 있는 분해",
                "부분 분해",
                "손실 없는 분해",
                "비정규 분해"
              ],
              "answerIndex": 2,
              "explanation": "텍스트에 따르면, '좋은 형식'이 아닌 릴레이션을 분해할 때, 'The decomposition is a lossless decomposition' 즉, 손실 없는 분해여야 한다고 명시되어 있습니다."
            }
          ]
        },
        {
          "title": "함수적 종속성 이해",
          "metadata": "Source: a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf, Text length: 3925 chars",
          "documentContent": [
            {
              "type": "heading",
              "content": "함수적 종속성 (Functional Dependencies)",
              "level": 1
            },
            {
              "type": "paragraph",
              "content": "데이터베이스 시스템에서 데이터는 일반적으로 현실 세계의 다양한 제약 조건(규칙)을 따릅니다. 예를 들어, 대학 데이터베이스에서 예상되는 몇 가지 제약 조건은 다음과 같습니다:",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "학생과 강사는 ID에 의해 고유하게 식별됩니다. 각 학생과 강사는 하나의 이름만 가집니다. 각 강사와 학생은 (주로) 하나의 학과에만 연결됩니다. 각 학과는 예산에 대해 하나의 값만 가지며, 하나의 건물과만 연결됩니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "릴레이션은 특정 속성 집합의 값이 다른 속성 집합의 값을 고유하게 결정해야 한다고 요구합니다. 함수적 종속성은 키의 개념을 일반화한 것입니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "함수적 종속성의 정의",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "R을 릴레이션 스키마라고 하고, a와 b를 R의 속성이라고 합시다 (a ⊆ R, b ⊆ R). 함수적 종속성 a → b는 릴레이션 r(R)의 어떤 두 튜플 t1과 t2가 속성 a에 대해 일치할 때마다 속성 b에 대해서도 일치하는 경우에만 R에서 성립합니다. 즉, t1[a] = t2[a] ⇒ t1[b] = t2[b] 입니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "예를 들어, 다음 인스턴스를 가진 릴레이션 r(A, B)를 고려해 봅시다:",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "A     B\n1     4\n1     5\n3     7",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "이 인스턴스에서 B → A는 성립합니다. 그러나 A → B는 성립하지 않습니다. (A 값이 1일 때 B 값이 4와 5로 다르기 때문입니다).",
              "level": null
            },
            {
              "type": "heading",
              "content": "키와 함수적 종속성",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "함수적 종속성은 슈퍼키를 사용하여 표현할 수 없는 제약 조건을 표현할 수 있게 합니다. 예를 들어, `in_dep (ID, name, salary, dept_name, building, budget)` 스키마를 고려해 봅시다. 여기서 ID는 강사 ID이고, dept_name은 강사의 학과입니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "우리는 다음 함수적 종속성이 성립할 것으로 예상합니다:",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "• `dept_name` → `building`\n• `ID` → `building`",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "`dept_name`과 `ID`는 슈퍼키이자 후보 키입니다. 하지만 `dept_name` → `salary`는 성립하지 않을 것으로 예상합니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "부분 종속성 (Partial Dependency)",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "릴레이션 R = a1 a2 a3 a4에서 a1이 키의 일부라고 가정해 봅시다. 함수적 종속성에서 a4가 키인 a1a2a3에 종속되는 것은 일반적입니다. 그러나 a4가 전체 키가 아닌 키의 일부인 a1에만 종속되고 a1a2a3에는 종속되지 않는 경우 (a1 → a4) 이를 부분 종속성이라고 합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "예를 들어, `b_id, b_name, bd_detail_attrib1, bd_detail_attrib2`와 같은 속성 집합에서 후보 키는 `b_id`, `b_name`, `{b_id, b_name}` 등이 될 수 있습니다. 여기서 `bd_detail_attrib1`이 `b_id`에만 종속되고 `{b_id, b_name}`에는 종속되지 않는다면 부분 종속성입니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "자명한 함수적 종속성 (Trivial Functional Dependencies)",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "함수적 종속성은 모든 릴레이션 인스턴스에서 항상 만족될 때 자명하다고 합니다. 예를 들어, `ID, name → ID` 또는 `name → name`과 같은 종속성은 자명합니다. 일반적으로, `a → b`는 b가 a의 부분집합(b ⊆ a)일 때 자명한 종속성입니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "함수적 종속성 예시",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "`student2(ID, name, tot_cred)` 릴레이션을 예로 들면:",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "• `ID → name` (성립)\n• `ID → tot_cred` (성립)\n• `tot_cred → name` (성립하지 않음)\n• `name → tot_cred` (성립하지 않음)",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "`SCORE(score_id, student_id, subject_id, score)` 릴레이션의 경우:",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "• `{student_id, subject_id} → score` (성립)",
              "level": null
            }
          ],
          "aiNotes": {
            "summary": "이 문서는 데이터베이스 시스템에서 중요한 개념인 함수적 종속성에 대해 설명합니다. 함수적 종속성은 현실 세계의 데이터 제약 조건을 표현하며, 특정 속성 집합이 다른 속성 집합의 값을 고유하게 결정하는 관계를 의미합니다. 문서에서는 함수적 종속성의 정의, 키와의 관계, 부분 종속성 및 자명한 종속성의 개념을 다루고, 다양한 예시를 통해 이해를 돕습니다.",
            "keyConcepts": [
              {
                "term": "함수적 종속성 (Functional Dependency)",
                "definition": {
                  "easy": "데이터베이스에서 한 데이터가 다른 데이터를 딱 하나로 정해주는 관계입니다. 예를 들어, 학생 ID를 알면 학생 이름을 알 수 있는 관계처럼요.",
                  "medium": "릴레이션 스키마 R에서 속성 집합 A의 값이 주어졌을 때 속성 집합 B의 값이 항상 고유하게 결정되는 경우, A는 B에 함수적으로 종속된다고 하며 A → B로 표기합니다.",
                  "hard": "데이터베이스 릴레이션 r(R)에서, 모든 튜플 t1, t2에 대해 t1[A] = t2[A]일 때 t1[B] = t2[B]가 성립하면 속성 집합 A는 속성 집합 B를 함수적으로 결정한다고 하며 A → B로 표현합니다. 이는 데이터의 일관성과 무결성을 보장하며 정규화 과정의 핵심 기반이 됩니다."
                }
              },
              {
                "term": "자명한 종속성 (Trivial Dependency)",
                "definition": {
                  "easy": "누구나 당연히 아는 관계입니다. 예를 들어, '이름과 나이를 알면 이름을 알 수 있다'는 식이죠.",
                  "medium": "함수적 종속성 A → B에서 B가 A의 부분집합(B ⊆ A)인 경우, 이 종속성은 자명한 종속성이라고 합니다. 이는 항상 참이며 데이터베이스의 특정 제약 조건을 나타내지 않습니다.",
                  "hard": "릴레이션의 모든 가능한 인스턴스에서 항상 만족되는 함수적 종속성을 의미합니다. 특히, 결정자(determinant) 속성 집합이 종속자(dependent) 속성 집합을 포함하거나 동일할 때 발생하며, 이는 새로운 정보를 제공하지 않는 내재적인 관계입니다."
                }
              },
              {
                "term": "부분 종속성 (Partial Dependency)",
                "definition": {
                  "easy": "키의 일부만 알아도 다른 데이터를 알 수 있는 관계입니다. 키 전체가 필요한데 일부만으로도 알 수 있으면 부분 종속성입니다.",
                  "medium": "릴레이션 R의 후보 키 X에 대해, 속성 A가 X에 함수적으로 종속되지만 X의 진부분집합(proper subset)에도 종속되는 경우 A는 X에 대해 부분 종속성을 가집니다.",
                  "hard": "릴레이션의 비키 속성(non-key attribute)이 후보 키 전체에 함수적으로 종속되는 것이 아니라, 후보 키의 진부분집합(proper subset)에 함수적으로 종속되는 현상을 말합니다. 이는 제2정규형(2NF) 위반의 원인이 되며 데이터 중복 및 갱신 이상을 유발할 수 있습니다."
                }
              },
              {
                "term": "후보 키 (Candidate Key)",
                "definition": {
                  "easy": "테이블의 각 행을 유일하게 구분할 수 있는 최소한의 정보입니다. 주민등록번호처럼요.",
                  "medium": "릴레이션의 모든 튜플을 유일하게 식별할 수 있는 속성(또는 속성 집합) 중, 더 이상 줄일 수 없는 최소한의 속성 집합입니다. 후보 키 중 하나가 기본 키로 선택됩니다.",
                  "hard": "릴레이션 스키마 R에서 모든 비키 속성을 함수적으로 결정할 수 있는 최소 슈퍼키를 의미합니다. 후보 키는 유일성(uniqueness)과 최소성(minimality)을 만족해야 하며, 릴레이션의 각 튜플을 고유하게 식별하는 데 사용될 수 있는 모든 속성 집합을 포함합니다."
                }
              }
            ],
            "importantTerms": [
              {
                "term": "릴레이션 스키마 (Relation Schema)",
                "definition": "릴레이션의 이름과 속성(컬럼)들의 정의를 포함하는 논리적 구조입니다."
              },
              {
                "term": "튜플 (Tuple)",
                "definition": "릴레이션의 한 행을 구성하는 값들의 집합으로, 객체의 특정 인스턴스를 나타냅니다."
              },
              {
                "term": "속성 (Attribute)",
                "definition": "릴레이션의 열(컬럼)을 의미하며, 특정 종류의 정보를 담는 데이터 항목입니다."
              },
              {
                "term": "슈퍼키 (Superkey)",
                "definition": "릴레이션의 모든 튜플을 유일하게 식별할 수 있는 하나 이상의 속성 집합입니다."
              },
              {
                "term": "제약 조건 (Constraint)",
                "definition": "데이터베이스에 저장될 수 있는 데이터의 규칙 또는 조건을 정의하는 것입니다."
              }
            ],
            "outline": [
              {
                "text": "함수적 종속성 개요",
                "id": "함수적-종속성-개요",
                "children": [
                  {
                    "text": "데이터 제약 조건",
                    "id": "데이터-제약-조건",
                    "children": null
                  },
                  {
                    "text": "함수적 종속성의 정의",
                    "id": "함수적-종속성의-정의",
                    "children": null
                  }
                ]
              },
              {
                "text": "함수적 종속성의 상세 이해",
                "id": "함수적-종속성의-상세-이해",
                "children": [
                  {
                    "text": "정의 및 예시",
                    "id": "정의-및-예시",
                    "children": null
                  },
                  {
                    "text": "키와 함수적 종속성",
                    "id": "키와-함수적-종속성",
                    "children": null
                  },
                  {
                    "text": "부분 종속성",
                    "id": "부분-종속성",
                    "children": null
                  },
                  {
                    "text": "자명한 함수적 종속성",
                    "id": "자명한-함수적-종속성",
                    "children": null
                  }
                ]
              },
              {
                "text": "함수적 종속성 예시",
                "id": "함수적-종속성-예시",
                "children": null
              }
            ]
          },
          "quiz": [
            {
              "question": "다음 중 함수적 종속성 A → B가 성립하는 조건으로 가장 정확한 것은 무엇입니까?",
              "options": [
                "릴레이션의 어떤 두 튜플 t1과 t2가 속성 A에 대해 일치할 때, 속성 B에 대해서도 일치하는 경우",
                "속성 A의 값이 변경되면 속성 B의 값도 항상 변경되는 경우",
                "속성 A와 속성 B가 동일한 데이터 타입을 가지는 경우",
                "속성 B가 속성 A의 부분집합인 경우"
              ],
              "answerIndex": 0,
              "explanation": "함수적 종속성 A → B는 A의 값이 같으면 B의 값도 항상 같아야 한다는 것을 의미합니다. 즉, t1[A] = t2[A]이면 t1[B] = t2[B]가 성립해야 합니다."
            },
            {
              "question": "다음 함수적 종속성 중 자명한 종속성(Trivial Functional Dependency)의 예시가 아닌 것은 무엇입니까?",
              "options": [
                "ID, Name → ID",
                "Name → Name",
                "ID → Name",
                "A, B, C → A"
              ],
              "answerIndex": 2,
              "explanation": "자명한 종속성은 종속자(오른쪽)가 결정자(왼쪽)의 부분집합인 경우를 말합니다. 'ID → Name'은 ID가 Name의 부분집합이 아니므로 자명한 종속성이 아닙니다. ID를 알면 Name을 알 수 있지만, Name은 ID에 포함되지 않습니다."
            },
            {
              "question": "릴레이션 `in_dep (ID, name, salary, dept_name, building, budget)`에서 `dept_name`이 `building`을 결정하고, `ID`가 `building`을 결정한다고 할 때, `dept_name`과 `ID`는 어떤 키에 해당됩니까?",
              "options": [
                "외래 키",
                "기본 키",
                "후보 키",
                "보조 키"
              ],
              "answerIndex": 2,
              "explanation": "텍스트에 따르면, `dept_name`과 `ID`는 `building`을 결정하는 속성이며, 이는 슈퍼키이자 후보 키에 해당합니다. 후보 키는 릴레이션의 각 튜플을 유일하게 식별할 수 있는 최소한의 속성 집합입니다."
            }
          ]
        },
        {
          "title": "제1 정규형 (1NF): 원자성 및 고유성",
          "metadata": "Source: a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf, Text length: 1478 chars",
          "documentContent": [
            {
              "type": "heading",
              "content": "제1 정규형 (1NF) 개요",
              "level": 1
            },
            {
              "type": "paragraph",
              "content": "데이터베이스 정규화의 첫 번째 단계인 제1 정규형(1NF)은 관계형 데이터베이스 설계의 기본 원칙을 제시합니다. 본문에서는 1NF의 핵심 요구사항과 체크리스트, 그리고 실제 적용 예시를 통해 1NF의 중요성을 설명합니다. 1NF를 따르지 않는 데이터베이스는 사용을 중단해야 할 만큼 중요하게 간주됩니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "1NF의 요구사항",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "제1 정규형은 다음의 주요 요구사항을 충족해야 합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "**원자성 값**: 릴레이션의 모든 속성은 원자적 값으로 구성되어야 합니다. 원자적 값은 더 이상 나눌 수 없는 단일 값을 의미하며, 자바의 기본 데이터 타입(INT, FLOAT, DOUBLE, DECIMAL (NUMERIC), CHAR, VARCHAR, BLOB, TEXT)과 유사합니다. 구조체나 리스트(배열)와 같이 여러 값을 포함하는 형태는 원자적이지 않아 허용되지 않습니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "**고유 식별자**: 각 속성(열)은 고유한 식별자를 가져야 합니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "1NF 체크리스트",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "제1 정규형을 만족하는지 확인하기 위한 체크리스트는 다음과 같습니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "1. 각 열은 원자적 값을 포함해야 합니다. (예: (x, y)와 같은 항목은 이 규칙을 위반합니다.)",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "2. 각 열은 동일한 데이터 도메인에 속하는 값을 포함해야 합니다. (다른 유형의 값을 한 열에 혼합하지 마십시오.)",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "3. 각 열은 고유한 이름을 가져야 합니다. (중복된 이름은 데이터 접근 시 혼란을 야기합니다.)",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "4. 데이터가 저장되는 순서는 중요하지 않습니다. (SQL을 사용하면 어떤 순서로든 데이터를 쉽게 가져올 수 있습니다.)",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "5. 테이블에 중복된 행이 없어야 합니다. 기본 키(PK)는 다음을 보장합니다:",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "    * 기본 키의 일부인 속성은 고유합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "    * 기본 키의 일부인 속성은 NULL이 될 수 없습니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "1NF 예시",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "다음은 제1 정규형을 만족하지 않는 테이블과 이를 만족하도록 정규화된 테이블의 예시입니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "초기 테이블 'student_id', 'name', 'course'에서 'course' 열이 'Algorithm, OS'와 같이 여러 값을 포함하여 1NF를 위반합니다. 이를 해결하기 위해 테이블을 'student_id', 'name'으로 구성된 학생 정보 테이블과 'student_id', 'course'로 구성된 수강 정보 테이블로 분리합니다. 이 과정을 통해 각 열이 원자적 값을 가지며 중복된 정보를 효과적으로 관리하여 1NF를 만족시킵니다.",
              "level": null
            }
          ],
          "aiNotes": {
            "summary": "제1 정규형(1NF)은 관계형 데이터베이스 정규화의 첫 번째 단계로, 테이블의 모든 속성이 원자적 값을 가져야 하고, 각 열이 고유한 이름을 가지며, 동일한 데이터 도메인에 속해야 함을 강조한다. 또한 테이블에 중복된 행이 없어야 하며, 이는 기본 키(PK)를 통해 보장된다. 비원자적 값을 포함하는 예시 테이블을 통해 1NF 준수 방법을 설명한다.",
            "keyConcepts": [
              {
                "term": "원자적 값 (Atomic Value)",
                "definition": {
                  "easy": "더 이상 나눌 수 없는 가장 작은 데이터 조각.",
                  "medium": "관계형 데이터베이스에서 하나의 속성(열)이 가질 수 있는 최소 단위의 값으로, 더 이상 의미 있는 단위로 분해될 수 없는 단일 값을 의미한다.",
                  "hard": "데이터베이스 릴레이션의 모든 속성에 대해 단일하고 불가분한 값을 요구하는 개념으로, 복합 값(예: 주소의 도시, 거리, 우편번호)이나 다중 값(예: 리스트, 배열)을 허용하지 않음으로써 데이터의 일관성과 무결성을 보장하는 제1 정규형의 핵심 조건이다."
                }
              },
              {
                "term": "제1 정규형 (First Normal Form, 1NF)",
                "definition": {
                  "easy": "데이터베이스 테이블을 깔끔하게 정리하는 첫 번째 규칙으로, 각 칸에 딱 하나의 정보만 들어가고, 같은 줄이 중복되지 않게 하는 것.",
                  "medium": "관계형 데이터베이스 정규화 과정의 첫 단계로, 모든 속성(열)이 원자적 값을 가져야 하고, 각 속성 이름이 고유해야 하며, 테이블 내에 중복된 행이 없어야 한다는 조건을 만족하는 형태이다.",
                  "hard": "관계형 스키마가 비원자적 도메인을 포함하지 않고, 각 릴레이션이 고유한 튜플(행)을 가지며, 모든 속성이 단일 값을 포함하도록 보장하여 데이터의 일관성과 질의 효율성을 높이는 데이터 모델링의 기초적인 요건이다."
                }
              },
              {
                "term": "기본 키 (Primary Key, PK)",
                "definition": {
                  "easy": "테이블에서 각 줄을 유일하게 구분해주는 중요한 값.",
                  "medium": "관계형 데이터베이스 테이블에서 각 행(튜플)을 고유하게 식별할 수 있는 하나 이상의 속성(열)들의 집합이다. 기본 키의 모든 속성은 고유하며 NULL 값을 가질 수 없다.",
                  "hard": "릴레이션 내의 모든 튜플을 고유하게 식별할 수 있는 최소 슈퍼키(Minimal Superkey)로서, 데이터 무결성 제약 조건의 핵심 구성 요소이다. 기본 키로 지정된 속성들은 반드시 고유성(Uniqueness)과 비NULL성(Non-nullability)을 만족해야 하며, 다른 테이블과의 관계 설정(외래 키)에 사용될 수 있다."
                }
              }
            ],
            "importantTerms": [
              {
                "term": "릴레이션 (Relation)",
                "definition": "데이터베이스에서 테이블을 지칭하는 용어."
              },
              {
                "term": "속성 (Attribute)",
                "definition": "테이블의 열(컬럼)을 지칭하는 용어."
              },
              {
                "term": "정규화 (Normalization)",
                "definition": "데이터 중복을 줄이고 무결성을 향상시키기 위해 테이블을 구조화하는 과정."
              },
              {
                "term": "데이터 도메인 (Data Domain)",
                "definition": "특정 열에 올 수 있는 값들의 집합."
              },
              {
                "term": "중복 행 (Duplicated Rows)",
                "definition": "테이블 내에 완전히 동일한 내용을 가진 두 개 이상의 행."
              }
            ],
            "outline": [
              {
                "text": "제1 정규형 (1NF) 개요",
                "id": "제1-정규형-1nf-개요",
                "children": null
              },
              {
                "text": "1NF의 요구사항",
                "id": "1nf의-요구사항",
                "children": null
              },
              {
                "text": "1NF 체크리스트",
                "id": "1nf-체크리스트",
                "children": null
              },
              {
                "text": "1NF 예시",
                "id": "1nf-예시",
                "children": null
              }
            ]
          },
          "quiz": [
            {
              "question": "제1 정규형(1NF)의 핵심 요구사항 중 하나는 무엇입니까?",
              "options": [
                "모든 속성 값이 원자적이어야 한다.",
                "데이터 중복을 허용한다.",
                "각 열의 이름이 중복될 수 있다.",
                "데이터 저장 순서가 중요해야 한다."
              ],
              "answerIndex": 0,
              "explanation": "제1 정규형의 가장 중요한 요구사항 중 하나는 릴레이션의 모든 속성 값이 더 이상 나눌 수 없는 원자적이어야 한다는 것입니다."
            },
            {
              "question": "다음 중 제1 정규형(1NF)을 위반하는 예시는 무엇입니까?",
              "options": [
                "열에 정수 값만 포함되어 있다.",
                "각 열이 고유한 이름을 가지고 있다.",
                "하나의 셀에 '사과, 바나나, 체리'와 같이 여러 값이 콤마로 구분되어 있다.",
                "테이블에 중복된 행이 없다."
              ],
              "answerIndex": 2,
              "explanation": "1NF는 각 열이 원자적 값, 즉 더 이상 나눌 수 없는 단일 값을 포함해야 한다고 명시합니다. '사과, 바나나, 체리'와 같이 콤마로 구분된 여러 값은 비원자적이므로 1NF를 위반합니다."
            },
            {
              "question": "제1 정규형(1NF) 원칙에 따라 기본 키(PK)가 테이블에서 보장하는 것은 무엇입니까?",
              "options": [
                "속성이 선택 사항일 수 있다.",
                "속성이 여러 값을 포함할 수 있다.",
                "속성이 고유하며 NULL 값을 가질 수 없다.",
                "속성이 중복될 수 있다."
              ],
              "answerIndex": 2,
              "explanation": "1NF 체크리스트에 따르면, 기본 키(PK)는 해당 속성들이 고유하며 NULL 값을 가질 수 없음을 보장하여 테이블에 중복된 행이 없도록 합니다."
            }
          ]
        },
        {
          "title": "제2 정규형 (2NF): 부분 종속성 제거",
          "metadata": "Source: a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf, Text length: 1851 chars",
          "documentContent": [
            {
              "type": "heading",
              "content": "제2 정규형 (2NF): 부분 종속성 제거",
              "level": 1
            },
            {
              "type": "heading",
              "content": "제2 정규형 (2NF)의 요구사항",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "제2 정규형(Second Normal Form, 2NF)은 데이터베이스 정규화의 한 단계로, 관계형 데이터베이스에서 데이터 중복을 줄이고 데이터 무결성을 향상시키기 위한 규칙 집합입니다. 2NF를 만족하기 위한 주요 요구사항은 다음과 같습니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "1.  **제1 정규형(1NF)을 만족해야 합니다.** 정규형은 순서대로 적용되어야 합니다. 즉, 2NF를 적용하기 전에 해당 릴레이션은 이미 1NF를 만족하고 있어야 합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "2.  **부분 종속성이 없어야 합니다.** 기본 키(Primary Key, PK)가 아닌 속성(Non-PK attribute)이 후보 키(Candidate Key)의 어떤 부분 집합에도 함수적으로 종속되어서는 안 됩니다. 이는 부분 종속성이 없어야 한다는 것을 의미합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "3.  **기본 키에 완전 함수 종속적이어야 합니다.** 기본 키가 아닌 모든 속성은 기본 키 전체에 함수적으로 종속되어야 합니다. 즉, 테이블의 모든 비기본 키 속성은 기본 키의 일부가 아니라 기본 키 전체에 의존해야 합니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "기본 키(PK)란?",
              "level": 3
            },
            {
              "type": "paragraph",
              "content": "기본 키는 릴레이션(테이블) 내의 각 튜플(행)을 고유하게 식별하는 하나 또는 여러 속성의 집합입니다. 기본 키를 통해 릴레이션 내의 특정 데이터를 가져올 수 있습니다. 예를 들어, `student_ID = 21800999`를 사용하여 학생의 학과 이름을 가져올 수 있습니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "부분 종속성",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "부분 종속성은 기본 키가 복합 키(두 개 이상의 속성으로 구성된 키)일 때 발생합니다. 릴레이션 R이 `a1 a2 a3 a4`로 구성되어 있고, 기본 키가 `a1 a2 a3`라고 가정해 봅시다. 만약 `a4`가 기본 키의 일부인 `a1`에만 종속되고 기본 키 전체인 `a1a2a3`에는 종속되지 않는다면(`a1 -> a4`), 이는 부분 종속성입니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "부분 종속성 제거",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "부분 종속성을 제거하기 위해서는 릴레이션을 두 개 이상의 새로운 릴레이션으로 분해해야 합니다. 각 새로운 릴레이션은 부분 종속성이 없는 형태로 구성됩니다. 다음은 예시를 통해 부분 종속성 제거 과정을 설명합니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "예시 1: teaches2 릴레이션",
              "level": 3
            },
            {
              "type": "paragraph",
              "content": "`teaches2(ID, course_id, sec_id, semester, year, name)` 릴레이션에서 기본 키는 `{ID, course_id, sec_id, semester, year}`로 가정합니다. 이 때, `ID`는 학생의 이름을 결정하는 `ID -> name`이라는 함수 종속성이 존재한다고 가정합시다. `name`은 기본 키의 일부인 `ID`에만 종속되므로, 이는 부분 종속성입니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "이 부분 종속성을 제거하기 위해 `teaches2` 릴레이션을 다음과 같이 분해할 수 있습니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "- `teaches2a(ID, course_id, sec_id, semester, year)`: 기본 키는 `{ID, course_id, sec_id, semester, year}`입니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "- `teaches2b(ID, name)`: 기본 키는 `ID`입니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "이렇게 분해함으로써 `name`은 `teaches2b` 릴레이션에서 `ID`에 완전 함수 종속적이게 되며, `teaches2a` 릴레이션에는 부분 종속성이 제거됩니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "예시 2: score 릴레이션",
              "level": 3
            },
            {
              "type": "paragraph",
              "content": "`score(score_id, student_id, subject_id, score, instructor)` 릴레이션을 살펴봅시다. 기본 키가 `{score_id, student_id, subject_id}`라고 가정했을 때, `subject_id`가 `instructor`를 결정하는 `subject_id -> instructor`라는 함수 종속성이 존재합니다. 이는 `instructor`가 기본 키의 일부인 `subject_id`에만 종속되므로 부분 종속성입니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "부분 종속성을 제거하기 위해 `score` 릴레이션을 다음과 같이 분해합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "- `score_a(score_id, student_id, subject_id, score)`: 기본 키는 `{score_id, student_id, subject_id}`입니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "- `score_b(subject_id, instructor)`: 기본 키는 `subject_id`입니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "이러한 분해를 통해 `score` 릴레이션의 부분 종속성이 제거되고 2NF를 만족하게 됩니다.",
              "level": null
            }
          ],
          "aiNotes": {
            "summary": "제2 정규형(2NF)은 데이터베이스 정규화의 한 단계로, 릴레이션이 제1 정규형을 만족하고 부분 종속성이 없어야 한다는 요구사항을 가집니다. 부분 종속성이란 기본 키가 복합 키일 때, 기본 키가 아닌 속성이 기본 키의 전체가 아닌 일부에만 함수적으로 종속되는 경우를 의미합니다. 부분 종속성을 제거하기 위해서는 해당 릴레이션을 두 개 이상의 새로운 릴레이션으로 분해하여 각 릴레이션이 2NF를 만족하도록 해야 합니다. `teaches2`와 `score` 릴레이션의 예시를 통해 부분 종속성을 식별하고 제거하는 과정을 설명합니다.",
            "keyConcepts": [
              {
                "term": "제2 정규형 (2NF)",
                "definition": {
                  "easy": "데이터베이스 테이블이 깔끔하게 정리되는 두 번째 단계로, 중복 데이터를 줄이기 위해 복합 키의 일부에만 의존하는 정보가 없어야 합니다.",
                  "medium": "릴레이션이 제1 정규형을 만족하면서, 기본 키가 아닌 모든 속성이 기본 키의 어떠한 부분 집합에도 함수적으로 종속되지 않는 형태를 의미합니다. 즉, 부분 종속성이 존재하지 않아야 합니다.",
                  "hard": "데이터 모델링에서 릴레이션 스키마가 제1 정규형의 조건을 충족하고, 추가적으로 모든 비기본(non-prime) 속성이 해당 릴레이션의 모든 후보 키(candidate key)에 대해 완전 함수 종속(fully functionally dependent)이어야 함을 명시하는 정규화 단계입니다. 이는 복합 키의 부분 집합에 대한 함수 종속성을 제거하여 갱신 이상(update anomalies)을 방지하는 데 기여합니다."
                }
              },
              {
                "term": "부분 종속성",
                "definition": {
                  "easy": "테이블의 기본 키가 여러 개로 이루어져 있을 때, 키가 아닌 다른 정보가 전체 기본 키가 아니라 그 일부에만 의존하는 경우입니다.",
                  "medium": "릴레이션의 기본 키가 복합 키일 때, 기본 키가 아닌 속성이 기본 키의 일부 속성 집합에만 함수적으로 종속되고 기본 키 전체에는 종속되지 않는 현상을 말합니다.",
                  "hard": "릴레이션 R의 스키마에서 X가 R의 후보 키이고, Y가 X의 진부분 집합(proper subset)이며, Z가 R의 비기본 속성(non-prime attribute)일 때, Y -> Z인 함수 종속성이 존재하고 Y가 Z를 완전하게 결정하지만 X는 Z를 완전하게 결정하지 않는 경우를 의미합니다. 이는 데이터 중복과 삽입, 삭제, 갱신 이상을 야기할 수 있습니다."
                }
              },
              {
                "term": "기본 키 (PK)",
                "definition": {
                  "easy": "테이블에서 각 줄(데이터)을 정확히 하나씩 구분할 수 있게 해주는 특별한 정보(예: 학번, 주민등록번호)입니다.",
                  "medium": "릴레이션(테이블) 내의 각 튜플(행)을 고유하게 식별할 수 있는 하나 또는 여러 속성의 집합입니다. 기본 키는 중복 값을 가질 수 없으며, NULL 값을 허용하지 않습니다.",
                  "hard": "관계형 데이터 모델에서 릴레이션의 각 튜플을 고유하게 식별하기 위해 선택된 후보 키입니다. 기본 키를 구성하는 속성들은 최소성(minimality), 고유성(uniqueness), 비NULL(not null) 속성을 만족해야 하며, 릴레이션의 무결성 제약 조건 중 개체 무결성(entity integrity)을 보장하는 핵심 요소입니다."
                }
              }
            ],
            "importantTerms": [
              {
                "term": "릴레이션",
                "definition": "관계형 데이터베이스에서 데이터를 저장하는 테이블을 의미합니다."
              },
              {
                "term": "튜플",
                "definition": "릴레이션(테이블)의 각 행을 의미하며, 하나의 레코드를 나타냅니다."
              },
              {
                "term": "속성",
                "definition": "릴레이션(테이블)의 각 열을 의미하며, 데이터의 특정 특성을 나타냅니다."
              },
              {
                "term": "함수 종속성",
                "definition": "릴레이션 R에서 속성 집합 X가 속성 Y를 함수적으로 결정하는 관계 (X -> Y)를 의미합니다. 즉, X의 값이 Y의 값을 고유하게 결정합니다."
              },
              {
                "term": "후보 키",
                "definition": "릴레이션 내의 각 튜플을 고유하게 식별할 수 있는 최소한의 속성 집합입니다. 후보 키 중 하나가 기본 키로 선택됩니다."
              },
              {
                "term": "복합 키",
                "definition": "두 개 이상의 속성(컬럼)으로 구성된 기본 키를 의미합니다."
              }
            ],
            "outline": [
              {
                "text": "제2 정규형 (2NF): 부분 종속성 제거",
                "id": "제2-정규형-2nf-부분-종속성-제거",
                "children": [
                  {
                    "text": "제2 정규형 (2NF)의 요구사항",
                    "id": "제2-정규형-2nf-의-요구사항",
                    "children": [
                      {
                        "text": "기본 키(PK)란?",
                        "id": "기본-키-pk-란",
                        "children": null
                      }
                    ]
                  },
                  {
                    "text": "부분 종속성",
                    "id": "부분-종속성",
                    "children": null
                  },
                  {
                    "text": "부분 종속성 제거",
                    "id": "부분-종속성-제거",
                    "children": [
                      {
                        "text": "예시 1: teaches2 릴레이션",
                        "id": "예시-1-teaches2-릴레이션",
                        "children": null
                      },
                      {
                        "text": "예시 2: score 릴레이션",
                        "id": "예시-2-score-릴레이션",
                        "children": null
                      }
                    ]
                  }
                ]
              }
            ]
          },
          "quiz": [
            {
              "question": "다음 중 제2 정규형(2NF)을 만족하기 위한 필수 요구사항이 아닌 것은 무엇입니까?",
              "options": [
                "릴레이션이 제1 정규형(1NF)을 만족해야 한다.",
                "기본 키가 아닌 속성이 후보 키의 어떤 부분 집합에도 함수적으로 종속되어서는 안 된다.",
                "모든 다중 값 속성이 제거되어야 한다.",
                "기본 키가 아닌 모든 속성은 기본 키 전체에 함수적으로 종속되어야 한다."
              ],
              "answerIndex": 2,
              "explanation": "다중 값 속성의 제거는 제1 정규형(1NF)의 요구사항 중 하나입니다. 제2 정규형은 1NF를 만족하는 것을 전제로 하며, 부분 종속성 제거에 중점을 둡니다."
            },
            {
              "question": "릴레이션 R(A, B, C, D)에서 기본 키가 {A, B}이고, D가 A에만 함수적으로 종속되는 경우 (A -> D)는 어떤 종류의 종속성에 해당합니까?",
              "options": [
                "완전 함수 종속성",
                "부분 종속성",
                "이행 종속성",
                "다치 종속성"
              ],
              "answerIndex": 1,
              "explanation": "D가 기본 키의 일부인 A에만 종속되고 기본 키 전체인 {A, B}에 종속되지 않는 경우를 부분 종속성이라고 합니다."
            },
            {
              "question": "teaches2(ID, course_id, sec_id, semester, year, name) 릴레이션에서 ID -> name이라는 부분 종속성을 제거하기 위해 분해된 두 개의 릴레이션 중 올바른 조합은 무엇입니까?",
              "options": [
                "teaches2a(ID, course_id, sec_id, semester, year)와 teaches2b(ID, name)",
                "teaches2a(ID, name)와 teaches2b(course_id, sec_id, semester, year)",
                "teaches2a(ID, course_id, name)와 teaches2b(sec_id, semester, year)",
                "teaches2a(ID, course_id, sec_id)와 teaches2b(semester, year, name)"
              ],
              "answerIndex": 0,
              "explanation": "부분 종속성 ID -> name을 제거하기 위해, name 속성과 그 결정자인 ID를 별도의 테이블로 분리하고, 나머지 속성들은 원래의 기본 키와 함께 새로운 테이블을 구성합니다."
            }
          ]
        },
        {
          "title": "제3 정규형 (3NF): 이행적 종속성 제거",
          "metadata": "Source: a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf, Text length: 1245 chars",
          "documentContent": [
            {
              "type": "heading",
              "content": "제3 정규형 (3NF)",
              "level": 1
            },
            {
              "type": "heading",
              "content": "요구사항",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "릴레이션은 2NF(제2 정규형)를 만족해야 한다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "릴레이션은 이행적 종속성을 가져서는 안 된다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "이행적 종속성 정의",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "이행적 종속성: 비기본 키 속성(non-PK attribute)이 다른 비기본 키 속성 또는 비기본 키 속성 집합에 종속되는 경우를 말한다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "이행적 종속성 상세 설명",
              "level": 1
            },
            {
              "type": "paragraph",
              "content": "릴레이션 R = a1 a2 a3 a4 에 대해 a1이 R의 기본 키일 때, a3이 a1에 종속되고(a1 ➝ a3) a4가 a3에 종속되는 경우(a1 ➝ a3 ➝ a4)는 비기본 키 속성(a4)이 다른 비기본 키 속성(a3)에 종속되는 이행적 종속성의 예시이다. 이러한 경우, a1은 a3을 결정하고 a3은 a4를 결정하지만, a4는 a1에 직접적으로 종속되지 않고 a3을 통해 간접적으로 종속된다. 여기서 후보 키는 a1, a2, {a1,a2}가 될 수 있다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "이행적 종속성 제거 예시",
              "level": 1
            },
            {
              "type": "heading",
              "content": "예제 1: 도서 대출 정보",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "원본 테이블: BookNo, Patron, Address, Due",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "기본 키(PK): BookNo",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "문제점: Patron(대출자)이 Address(주소)에 종속된다 (Patron → Address). BookNo는 Patron을 결정하지만, Patron이 Address를 결정하므로 BookNo → Patron → Address 형태의 이행적 종속성이 존재한다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "제거 방법: 테이블을 다음과 같이 분리한다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "BookNo, Patron, Due",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "Patron, Address",
              "level": null
            },
            {
              "type": "heading",
              "content": "예제 2: 토너먼트 우승자 정보",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "원본 테이블: Tournament, Year, Winner, DOB",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "기본 키(PK): {Tournament, Year}",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "문제점: Winner(우승자)가 DOB(생년월일)에 종속된다 (Winner → DOB). 기본 키 {Tournament, Year}가 Winner를 결정하고 Winner가 DOB를 결정하므로 {Tournament, Year} → Winner → DOB 형태의 이행적 종속성이 존재한다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "예제 3: 시험 점수 정보 (score2)",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "원본 테이블: score2(id, student_id, subject_id, exam_name, exam_score)",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "문제점: {student_id, subject_id}가 exam_name을 결정하고, exam_name이 exam_score를 결정하는 ({student_id, subject_id} → exam_name → exam_score) 형태의 이행적 종속성이 존재한다. 즉, 시험 점수는 학생-과목 조합에 직접 종속되기보다 시험 이름에 의해 결정되는 구조이다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "제거 방법: 테이블을 다음과 같이 분리한다. (여기서 exam_id는 exam_name을 고유하게 식별하는 새로운 키로 가정)",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "score2a(id, student_id, subject_id, exam_id, exam_name)",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "score2b(student_id, subject_id, exam_id, exam_score)",
              "level": null
            }
          ],
          "aiNotes": {
            "summary": "제3 정규형(3NF)은 데이터베이스 정규화의 한 단계로, 릴레이션이 2NF를 만족하고 이행적 종속성이 없어야 한다는 요구사항을 가진다. 이행적 종속성은 비기본 키 속성이 다른 비기본 키 속성에 종속되는 현상으로, 이는 데이터 중복을 야기하고 삽입, 삭제, 갱신 이상을 초래할 수 있다. 3NF는 이러한 이행적 종속성을 제거하여 데이터 일관성과 무결성을 높이는 것을 목표로 한다. 본문에서는 이행적 종속성의 개념과 이를 제거하기 위한 여러 예시를 통해 3NF의 적용 방법을 설명한다.",
            "keyConcepts": [
              {
                "term": "제3 정규형 (3NF)",
                "definition": {
                  "easy": "데이터베이스 테이블을 깔끔하게 만들어서 정보가 겹치지 않고 잘 정리되도록 하는 세 번째 규칙이에요. 특히, 중요한 정보가 아닌 것들이 다른 중요한 정보가 아닌 것에 의존하지 않게 해요.",
                  "medium": "릴레이션이 2NF를 만족하고, 기본 키가 아닌 속성(non-PK attribute)이 기본 키가 아닌 다른 속성에 이행적으로 종속되지 않는 상태를 의미합니다. 이는 데이터 중복을 줄이고 갱신 이상, 삽입 이상, 삭제 이상과 같은 이상 현상을 방지합니다.",
                  "hard": "릴레이션 R이 2NF를 만족하고, R의 모든 비기본 키 속성 A에 대해 A가 R의 어떤 후보 키 X에 대해 직접적으로 함수 종속(X → A)이 아닌, 다른 비기본 키 속성 B를 경유하는 이행적 함수 종속(X → B → A)이 존재하지 않는 상태를 말한다. 즉, 모든 비기본 키 속성은 오직 후보 키에만 직접적으로 함수 종속되어야 한다."
                }
              },
              {
                "term": "이행적 종속성 (Transitive Dependency)",
                "definition": {
                  "easy": "테이블에서 중요한 정보가 아닌 것(A)이 다른 중요한 정보가 아닌 것(B)에 따라 정해지는 관계를 말해요. 예를 들어, '학생 이름'이 '과목'에 따라 정해지고, '과목'이 '점수'에 따라 정해지는 식이죠.",
                  "medium": "릴레이션 R에서 A → B이고 B → C일 때, A → C가 성립하며 B가 후보 키가 아닌 경우, C는 A에 대해 이행적으로 종속된다고 합니다. 즉, 비기본 키 속성이 기본 키가 아닌 다른 속성을 통해 기본 키에 간접적으로 종속되는 현상입니다.",
                  "hard": "릴레이션 R의 속성 집합 A, B, C에 대해 A → B이고 B → C인 함수 종속성이 존재할 때, 만약 B가 R의 후보 키가 아니거나 A가 B에 함수 종속되지 않는다면 C는 A에 대해 이행적 종속성을 가진다고 한다. 이는 비기본 키 속성이 기본 키에 직접 종속되지 않고 중간의 다른 비기본 키 속성을 통해 종속되는 상황을 나타내며, 3NF 위반의 주된 원인이다."
                }
              },
              {
                "term": "정규화 (Normalization)",
                "definition": {
                  "easy": "데이터베이스를 더 효율적이고 오류 없이 사용할 수 있도록 테이블을 규칙에 따라 잘 정리하는 과정이에요.",
                  "medium": "데이터베이스의 테이블을 구조화하여 데이터 중복을 최소화하고, 삽입, 삭제, 갱신 이상과 같은 데이터 불일치 문제를 해결하며, 데이터 무결성을 유지하기 위한 일련의 과정입니다. 정규형(Normal Form)이라는 규칙을 단계별로 적용하여 수행됩니다.",
                  "hard": "관계형 데이터베이스 설계에서 데이터 중복을 제거하고 데이터 일관성 및 무결성을 보장하기 위해 릴레이션 스키마를 분해하는 체계적인 과정이다. 함수 종속성 및 다치 종속성과 같은 종속성 제약을 기반으로 특정 정규형 규칙을 만족하도록 테이블을 재구성하며, 이를 통해 이상(anomaly) 현상을 방지하고 질의 성능 및 유지보수성을 향상시키는 것을 목표로 한다."
                }
              }
            ],
            "importantTerms": [
              {
                "term": "기본 키 (Primary Key)",
                "definition": "릴레이션 내의 각 튜플(행)을 고유하게 식별할 수 있는 하나 이상의 속성(컬럼) 집합."
              },
              {
                "term": "비기본 키 속성 (Non-PK Attribute)",
                "definition": "기본 키를 구성하지 않는 릴레이션의 속성."
              },
              {
                "term": "후보 키 (Candidate Key)",
                "definition": "릴레이션에서 각 튜플을 고유하게 식별할 수 있는 최소한의 속성 집합. 기본 키로 선택될 수 있는 모든 키를 의미한다."
              },
              {
                "term": "릴레이션 (Relation)",
                "definition": "관계형 데이터베이스에서 데이터를 저장하는 테이블을 의미하며, 행(튜플)과 열(속성)로 구성된다."
              },
              {
                "term": "함수 종속성 (Functional Dependency)",
                "definition": "릴레이션에서 어떤 속성 집합 X의 값이 다른 속성 집합 Y의 값을 유일하게 결정하는 관계 (X → Y)."
              }
            ],
            "outline": [
              {
                "text": "제3 정규형 (3NF)",
                "id": "제3-정규형-3nf",
                "children": [
                  {
                    "text": "요구사항",
                    "id": "요구사항",
                    "children": null
                  },
                  {
                    "text": "이행적 종속성 정의",
                    "id": "이행적-종속성-정의",
                    "children": null
                  }
                ]
              },
              {
                "text": "이행적 종속성 상세 설명",
                "id": "이행적-종속성-상세-설명",
                "children": null
              },
              {
                "text": "이행적 종속성 제거 예시",
                "id": "이행적-종속성-제거-예시",
                "children": [
                  {
                    "text": "예제 1: 도서 대출 정보",
                    "id": "예제-1-도서-대출-정보",
                    "children": null
                  },
                  {
                    "text": "예제 2: 토너먼트 우승자 정보",
                    "id": "예제-2-토너먼트-우승자-정보",
                    "children": null
                  },
                  {
                    "text": "예제 3: 시험 점수 정보 (score2)",
                    "id": "예제-3-시험-점수-정보-score2",
                    "children": null
                  }
                ]
              }
            ]
          },
          "quiz": [
            {
              "question": "릴레이션이 제3 정규형(3NF)을 만족하기 위한 필수 요구사항 중 하나는 무엇입니까?",
              "options": [
                "부분 함수 종속성이 없어야 한다.",
                "기본 키가 없어야 한다.",
                "제2 정규형(2NF)을 만족해야 한다.",
                "모든 속성이 다치 종속성을 가져야 한다."
              ],
              "answerIndex": 2,
              "explanation": "제3 정규형(3NF)의 첫 번째 요구사항은 릴레이션이 제2 정규형(2NF)을 만족해야 한다는 것입니다. 또한, 이행적 종속성이 없어야 합니다."
            },
            {
              "question": "다음 중 이행적 종속성을 가장 잘 설명하는 것은 무엇입니까?",
              "options": [
                "비기본 키 속성이 기본 키에 직접 종속되는 경우",
                "기본 키가 다른 기본 키에 종속되는 경우",
                "비기본 키 속성이 다른 비기본 키 속성 또는 비기본 키 속성 집합에 종속되는 경우",
                "모든 속성이 서로 독립적인 경우"
              ],
              "answerIndex": 2,
              "explanation": "이행적 종속성은 비기본 키 속성이 기본 키가 아닌 다른 비기본 키 속성을 통해 기본 키에 간접적으로 종속되는 경우를 의미합니다. 즉, 비기본 키 속성이 다른 비기본 키 속성에 종속되는 관계를 말합니다."
            },
            {
              "question": "릴레이션 R = a1 a2 a3 a4에서 a1이 기본 키이고, a1 → a3 및 a3 → a4 관계가 성립할 때, a1 → a3 → a4는 어떤 종류의 종속성입니까?",
              "options": [
                "부분 함수 종속성",
                "완전 함수 종속성",
                "이행적 종속성",
                "자명한 종속성"
              ],
              "answerIndex": 2,
              "explanation": "a1 → a3이고 a3 → a4일 때, a3이 기본 키가 아닌 비기본 키 속성이므로, a4는 a1에 대해 이행적 종속성을 가집니다. 이는 비기본 키 속성이 다른 비기본 키 속성을 통해 기본 키에 종속되는 경우에 해당합니다."
            }
          ]
        },
        {
          "title": "보이스-코드 정규형 (BCNF): 강화된 제3 정규형",
          "metadata": "Source: a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf, Text length: 923 chars",
          "documentContent": [
            {
              "type": "heading",
              "content": "보이스-코드 정규형 (BCNF): 3.5NF",
              "level": 1
            },
            {
              "type": "paragraph",
              "content": "BCNF는 제3 정규형(3NF)보다 강화된 정규형으로, '3.5NF'라고도 불립니다. BCNF를 만족하기 위한 요구사항은 다음과 같습니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "1. 관계는 3NF여야 합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "2. 어떤 함수 종속성 A → B에 대해, A는 반드시 슈퍼키(Super Key)여야 합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "3. 만약 A → B에서 A가 비기본키(non-PK)라면, 해당 관계는 BCNF가 아닙니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "BCNF 예시: takes2 테이블",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "다음은 BCNF 위반의 예시를 보여주는 `takes2` 테이블입니다: `takes2(student_id, subject, instructor)`",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "이 테이블에는 두 가지 함수 종속성이 존재합니다:",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "1. `(student, subject) → instructor`: 학생과 과목이 강사를 유일하게 결정합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "2. `Instructor → subject`: 강사가 가르치는 과목을 유일하게 결정합니다. (예: Dr. Cpp는 C++만 가르치고, Dr. Java는 Java만 가르침)",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "여기서 문제가 되는 것은 `Instructor → subject` 종속성입니다. `Instructor`는 `takes2` 테이블의 기본키(또는 후보키)가 아니며, 슈퍼키도 아닙니다. 이처럼 비기본키가 다른 속성을 결정하는 경우, BCNF를 만족하지 못합니다. 즉, '비기본키가 기본키의 구성 요소를 식별'하는 상황이 발생하여 BCNF를 위반합니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "BCNF 분해 예시: takes2 테이블의 정규화",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "`takes2` 테이블의 BCNF 위반 문제를 해결하기 위해, 테이블을 다음과 같이 분해할 수 있습니다:",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "1. `takes2a(student_id, section_id)`",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "2. `takes2b(section_id, subject, instructor)`",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "이 분해를 통해 `Instructor → subject` 종속성은 `takes2b` 테이블 내에서 `section_id`가 `subject`와 `instructor`를 유일하게 결정하는 구조로 변경됩니다. `section_id`는 `takes2b`의 기본키(후보키이자 슈퍼키)이므로, 이제 모든 결정자가 슈퍼키인 조건을 만족하게 되어 BCNF를 만족합니다.",
              "level": null
            }
          ],
          "aiNotes": {
            "summary": "본 문서는 보이스-코드 정규형(BCNF)의 정의와 요구사항을 설명합니다. BCNF는 제3 정규형(3NF)보다 강화된 형태로, 모든 함수 종속성 A → B에서 결정자 A가 반드시 슈퍼키여야 한다고 명시합니다. 특히 A가 비기본키인 경우 BCNF를 위반한다고 강조합니다. `takes2(student_id, subject, instructor)` 예시를 통해 `Instructor → subject`와 같은 함수 종속성이 BCNF 위반을 초래하는 과정을 보여주고, 이를 `takes2a(student_id, section_id)`와 `takes2b(section_id, subject, instructor)`로 분해하여 BCNF를 만족시키는 해결책을 제시합니다.",
            "keyConcepts": [
              {
                "term": "Boyce-Codd Normal Form (BCNF)",
                "definition": {
                  "easy": "데이터베이스에서 중복을 줄이고 데이터를 더 잘 정리하는 방법 중 하나로, 3차 정규형보다 더 엄격한 규칙을 가지고 있어요.",
                  "medium": "관계형 데이터베이스에서 모든 비자명(non-trivial) 함수 종속성 A → B에 대해 결정자 A가 반드시 슈퍼키여야 하는 정규형이다. 이는 3차 정규형의 예외적인 문제를 해결한다.",
                  "hard": "릴레이션 R이 BCNF를 만족하려면, R의 모든 비자명 함수 종속성 X → Y에서 X가 R의 슈퍼키여야 한다. 이는 3NF가 후보 키의 부분 집합이 다른 속성을 결정하는 경우를 다루지 못하는 한계를 극복하며, 모든 결정자가 후보 키가 되도록 요구함으로써 데이터 중복을 최소화하고 갱신 이상을 방지하는 데 기여한다."
                }
              },
              {
                "term": "슈퍼키 (Super Key)",
                "definition": {
                  "easy": "테이블의 한 행을 유일하게 구별할 수 있는 하나 이상의 속성(컬럼)들의 조합이에요. 주민등록번호나 학번처럼 사람을 딱 한 명만 가리킬 수 있는 정보라고 생각하면 돼요.",
                  "medium": "릴레이션의 모든 튜플을 유일하게 식별할 수 있는 속성들의 집합이다. 후보키(Candidate Key)는 슈퍼키 중에서 최소성을 만족하는 키이다.",
                  "hard": "릴레이션 스키마 R에 대해, R의 모든 튜플을 유일하게 식별할 수 있는 속성 집합 K ⊆ R을 슈퍼키라고 한다. 즉, K의 값은 R의 어떤 두 튜플에서도 동일할 수 없다. 슈퍼키는 후보키를 포함하며, 후보키에 임의의 속성을 추가해도 여전히 슈퍼키이다."
                }
              },
              {
                "term": "함수 종속성 (Functional Dependency)",
                "definition": {
                  "easy": "한쪽 정보가 바뀌면 다른 쪽 정보도 따라서 바뀌어야 하는 관계를 말해요. 예를 들어, 학생의 학번이 정해지면 그 학생의 이름도 정해지는 관계처럼요.",
                  "medium": "릴레이션 R에서 속성 집합 A의 값이 속성 집합 B의 값을 유일하게 결정할 때, A → B로 표기하며, B는 A에 함수적으로 종속된다고 한다. A를 결정자(determinant), B를 종속자(dependent)라고 한다.",
                  "hard": "릴레이션 스키마 R에서, X와 Y가 R의 부분 집합일 때, 릴레이션 r(R)의 모든 튜플 t1, t2에 대해 t1[X] = t2[X]이면 t1[Y] = t2[Y]가 성립할 때, Y는 X에 함수적으로 종속된다고 하며 X → Y로 표기한다. 이는 데이터의 일관성과 무결성을 유지하는 데 필수적인 개념이며, 정규화 과정의 핵심이다."
                }
              }
            ],
            "importantTerms": [
              {
                "term": "3NF (제3 정규형)",
                "definition": "이행적 함수 종속성을 제거하여 중복을 줄이는 정규형. BCNF보다 덜 엄격하다."
              },
              {
                "term": "비기본키 (Non-PK)",
                "definition": "기본키 또는 후보키의 구성 요소가 아닌 속성."
              },
              {
                "term": "분해 (Decomposition)",
                "definition": "정규형을 만족시키기 위해 하나의 릴레이션(테이블)을 두 개 이상의 릴레이션으로 나누는 과정."
              },
              {
                "term": "결정자 (Determinant)",
                "definition": "함수 종속성 A → B에서 A에 해당하는 속성 집합으로, 종속자를 유일하게 결정하는 역할을 한다."
              }
            ],
            "outline": [
              {
                "text": "보이스-코드 정규형 (BCNF): 3.5NF",
                "id": "보이스-코드-정규형-bcnf-35nf",
                "children": null
              },
              {
                "text": "BCNF 예시: takes2 테이블",
                "id": "bcnf-예시-takes2-테이블",
                "children": null
              },
              {
                "text": "BCNF 분해 예시: takes2 테이블의 정규화",
                "id": "bcnf-분해-예시-takes2-테이블의-정규화",
                "children": null
              }
            ]
          },
          "quiz": [
            {
              "question": "보이스-코드 정규형(BCNF)의 핵심 요구사항으로 가장 올바른 것은 무엇입니까?",
              "options": [
                "모든 함수 종속성 A → B에서 A는 슈퍼키여야 한다.",
                "모든 비기본키 속성은 기본키에 이행적으로 종속되지 않아야 한다.",
                "모든 테이블은 최소한 세 개의 속성을 가져야 한다.",
                "모든 함수 종속성 A → B에서 B는 기본키의 부분 집합이어야 한다."
              ],
              "answerIndex": 0,
              "explanation": "BCNF의 핵심 요구사항은 '모든 함수 종속성 A → B에 대해 결정자 A가 반드시 슈퍼키여야 한다'는 것입니다. 이는 3NF보다 더 엄격한 조건입니다."
            },
            {
              "question": "본문에서 제시된 `takes2(student_id, subject, instructor)` 테이블에서 BCNF 위반을 발생시키는 함수 종속성은 무엇입니까?",
              "options": [
                "(student, subject) → instructor",
                "student_id → subject",
                "Instructor → subject",
                "subject → instructor"
              ],
              "answerIndex": 2,
              "explanation": "`Instructor → subject` 종속성이 BCNF 위반을 일으킵니다. `Instructor`는 `takes2` 테이블의 슈퍼키가 아니지만 `subject`를 결정하기 때문입니다."
            },
            {
              "question": "BCNF를 만족시키기 위해 `takes2` 테이블을 `takes2a(student_id, section_id)`와 `takes2b(section_id, subject, instructor)`로 분해한 주된 이유는 무엇입니까?",
              "options": [
                "테이블의 총 행 수를 줄이기 위해",
                "데이터 입력 속도를 향상시키기 위해",
                "`Instructor → subject` 함수 종속성으로 인한 BCNF 위반 문제를 해결하기 위해",
                "학생과 과목 간의 관계를 명확히 하기 위해"
              ],
              "answerIndex": 2,
              "explanation": "`takes2` 테이블은 `Instructor`가 슈퍼키가 아님에도 불구하고 `subject`를 결정하는 `Instructor → subject` 함수 종속성 때문에 BCNF를 위반했습니다. 테이블을 분해함으로써 이 문제가 해결됩니다."
            }
          ]
        },
        {
          "title": "제4 정규형 (4NF): 다치 종속성 제거",
          "metadata": "Source: a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf, Text length: 2282 chars",
          "documentContent": [
            {
              "type": "heading",
              "content": "제4 정규형 (4NF) 개요",
              "level": 1
            },
            {
              "type": "paragraph",
              "content": "제4 정규형(Fourth Normal Form, 4NF)은 데이터베이스 정규화의 한 단계로, 릴레이션이 BCNF(보이스-코드 정규형)를 만족하고 다치 종속성(Multi-valued Dependency)을 가지지 않아야 한다는 요구사항을 가집니다. 다치 종속성은 데이터베이스 스키마 설계가 부적절할 때 발생하며, 일반적으로 3개 이상의 속성을 가진 릴레이션에서 나타날 수 있습니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "예를 들어, 릴레이션에 A, B, C 세 가지 속성이 있고, A가 B를 함수적으로 결정(A → B)하면서 B와 C가 서로 독립적일 때 다치 종속성이 발생할 수 있습니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "다치 종속성 (MVD) 이해",
              "level": 1
            },
            {
              "type": "heading",
              "content": "예시 1: 학생-과목-활동 관계",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "다음과 같은 학생 관련 정보 릴레이션이 있다고 가정해 봅시다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "student_id → course (학생은 여러 과목을 수강)",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "student_id → activity (학생은 여러 활동에 참여)",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "course ⊥ activity (과목과 활동은 서로 독립적)",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "이 경우, 한 테이블에 student_id, course, activity를 모두 포함하면 다치 종속성이 발생합니다. 예를 들어, '21800999' 학생이 'Statistics', 'Linear algebra'를 수강하고 'Soccer', 'Basketball' 활동을 한다면, 모든 조합이 튜플로 저장되어 불필요한 중복이 발생합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "이러한 문제를 해결하기 위해, 릴레이션을 student_id와 course로 구성된 테이블과 student_id와 activity로 구성된 테이블로 분리할 수 있습니다. 이는 다치 종속성을 제거하여 데이터 중복을 줄이는 방법입니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "예시 2: 강사-자녀-전화번호 관계",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "강사의 자녀 이름(inst_child(ID, child_name))과 전화번호(inst_phone(ID, phone_number))를 기록한다고 가정해 봅시다. 이 두 스키마를 inst_info(ID, child_name, phone_number)로 결합하면 문제가 발생합니다. 특정 강사 ID(예: 999999)에 대해 여러 자녀 이름(David, William)과 여러 전화번호(x-x-1234, x-x-4321)가 독립적으로 존재할 때, 다음과 같은 튜플들이 생성되어 중복이 발생합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "(99999, David, 512-555-1234)",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "(99999, David, 512-555-4321)",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "(99999, William, 512-555-1234)",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "(99999, William, 512-555-4321)",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "이는 다치 종속성으로 인한 문제로, 자녀 이름과 전화번호가 서로 독립적임에도 불구하고 카테시안 곱 형태로 튜플이 증가하여 불필요한 중복을 야기합니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "다치 종속성의 공식적 정의",
              "level": 1
            },
            {
              "type": "paragraph",
              "content": "릴레이션 스키마 R에서 속성 집합 α와 β가 R의 부분 집합일 때, 다치 종속성 α →→ β는 릴레이션 r(R)의 모든 튜플 t1과 t2에 대해 t1[α] = t2[α]를 만족하면, 다음과 같은 튜플 t3와 t4가 r에 존재함을 의미합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "t1[α] = t2[α] = t3[α] = t4[α]",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "t3[β] = t1[β]",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "t3[R – β] = t2[R – β]",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "t4[β] = t2[β]",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "t4[R – β] = t1[R – β]",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "또 다른 정의는 릴레이션 스키마 R의 속성 집합이 세 개의 비어 있지 않은 부분 집합 Y, Z, W로 분할될 때, Y →→ Z (Y가 Z를 다중 결정)는 r(R)의 모든 가능한 릴레이션에서 <y1, z1, w1> ∈ r 이고 <y1, z2, w2> ∈ r 이면, <y1, z1, w2> ∈ r 이고 <y1, z2, w1> ∈ r 이라는 것입니다. Z와 W의 동작이 동일하므로 Y →→ Z이면 Y →→ W도 성립합니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "다치 종속성 해결의 필요성",
              "level": 1
            },
            {
              "type": "paragraph",
              "content": "FAV(student_id, course, activity) 릴레이션에서 21800999 학생이 {statistics, Linear algebra} 과목과 {Soccer, basketball} 활동을 가지고 있을 때, 이들은 서로 직교(orthogonal)하는 관계입니다. 즉, 과목과 활동은 학생 ID에 종속되지만 서로에게는 독립적입니다. 이러한 다치 종속성을 해결하지 않으면 데이터 중복과 갱신 이상이 발생하여 데이터베이스의 효율성과 무결성이 저해됩니다. 4NF는 이러한 다치 종속성을 제거하여 데이터베이스의 구조를 더욱 견고하게 만듭니다.",
              "level": null
            }
          ],
          "aiNotes": {
            "summary": "제4 정규형(4NF)은 관계형 데이터베이스 정규화의 한 단계로, BCNF를 만족하고 릴레이션 내의 다치 종속성(Multi-valued Dependency, MVD)을 제거하여 데이터 중복을 최소화하고 갱신 이상을 방지하는 것을 목표로 합니다. 다치 종속성은 일반적으로 3개 이상의 속성을 가진 테이블에서 특정 속성 집합이 다른 두 개 이상의 독립적인 속성 집합을 다중 결정할 때 발생하며, 이로 인해 불필요한 튜플 증가와 데이터 중복이 야기됩니다. 본문은 학생-과목-활동 및 강사-자녀-전화번호 예시를 통해 다치 종속성의 발생 원인과 그로 인한 문제점을 설명하고, 다치 종속성의 공식적인 정의를 제시하여 4NF의 중요성을 강조합니다.",
            "keyConcepts": [
              {
                "term": "제4 정규형 (4NF)",
                "definition": {
                  "easy": "데이터베이스에서 중복을 줄이기 위한 규칙 중 하나로, 한 테이블 안에 서로 관련 없는 여러 정보가 동시에 많아지는 것을 막는 것입니다.",
                  "medium": "관계형 데이터베이스에서 다치 종속성을 제거하여 데이터 중복을 최소화하고 갱신 이상을 방지하는 정규화 단계입니다. BCNF를 만족해야 하며, 비자명 다치 종속성이 없어야 합니다.",
                  "hard": "릴레이션 R이 BCNF를 만족하고, R의 모든 비자명 다치 종속성(A →→ B)이 함수 종속성(A → B)이거나 A가 R의 슈퍼키인 경우 R은 4NF를 만족합니다. 이는 특정 속성 집합이 다른 두 개 이상의 독립적인 속성 집합을 다중 결정하는 다치 종속성을 제거하여 불필요한 튜플 증가와 갱신 이상을 방지합니다."
                }
              },
              {
                "term": "다치 종속성 (MVD)",
                "definition": {
                  "easy": "한 가지 정보(예: 학생 ID)가 여러 가지 다른 정보(예: 듣는 과목들, 참여하는 활동들)를 동시에 가질 때, 이 다른 정보들끼리는 서로 관련이 없는 경우를 말합니다.",
                  "medium": "릴레이션 R에서 속성 집합 A가 속성 집합 B를 다중 결정한다는 것은, A의 특정 값에 대해 B의 여러 값들이 존재하고, 이 B 값들이 A의 다른 속성들과는 독립적으로 존재할 때 발생합니다. 이는 릴레이션 내에 불필요한 데이터 중복을 야기합니다.",
                  "hard": "릴레이션 R의 스키마에 대해, A, B, C가 R의 속성 집합의 분할이라고 할 때, A →→ B는 R의 모든 인스턴스에서 A의 특정 값에 대해 B의 값 집합이 독립적으로 존재하며, A의 동일한 값에 대한 C의 값 집합과 독립적으로 결합될 수 있음을 의미합니다. 즉, 튜플 t1과 t2가 A에 대해 동일한 값을 가질 때, t1[A]=t2[A]=t3[A]=t4[A], t3[B]=t1[B], t3[R-B]=t2[R-B], t4[B]=t2[B], t4[R-B]=t1[R-B]를 만족하는 t3와 t4가 존재할 때 발생합니다."
                }
              },
              {
                "term": "BCNF (보이스-코드 정규형)",
                "definition": {
                  "easy": "테이블의 모든 결정자가 후보 키인 상태를 말합니다. 즉, 어떤 한 정보가 다른 정보를 결정할 때, 그 결정하는 정보가 반드시 테이블의 주요 식별자여야 한다는 규칙입니다.",
                  "medium": "모든 함수 종속성 A → B에 대해, A가 슈퍼키인 경우 릴레이션은 BCNF를 만족합니다. 이는 3NF에서 발생할 수 있는 이상 현상을 제거하기 위해 더 엄격한 조건을 적용합니다.",
                  "hard": "릴레이션 스키마 R이 BCNF를 만족하려면, R에 존재하는 모든 비자명 함수 종속성 X → Y에 대해 X가 R의 슈퍼키여야 합니다. 이는 모든 결정자가 후보 키가 되도록 보장하여, 부분 함수 종속성 및 이행 함수 종속성과 같은 이상 현상을 근본적으로 제거합니다."
                }
              },
              {
                "term": "릴레이션 (Relation)",
                "definition": {
                  "easy": "데이터베이스에서 데이터를 표 형태로 저장하는 것을 말합니다. 행과 열로 이루어진 표라고 생각하면 됩니다.",
                  "medium": "관계형 데이터 모델에서, 속성(열)들의 집합과 해당 속성들의 도메인에서 가져온 값들로 구성된 튜플(행)들의 집합입니다. 데이터베이스 테이블과 동의어로 사용됩니다.",
                  "hard": "관계형 대수에서 정의된 수학적 관계의 인스턴스로, 고유한 속성 헤더(스키마)와 해당 속성 도메인에서 가져온 값들로 구성된 순서 없는 튜플(레코드) 집합입니다. 각 튜플은 유일하며, 속성의 순서는 중요하지 않습니다."
                }
              }
            ],
            "importantTerms": [
              {
                "term": "정규형 (Normal Form)",
                "definition": "데이터베이스 테이블의 중복을 줄이고 무결성을 유지하기 위한 구조적 규칙들의 집합."
              },
              {
                "term": "속성 (Attribute)",
                "definition": "릴레이션(테이블)의 열(column)을 의미하며, 특정 종류의 데이터를 저장한다."
              },
              {
                "term": "튜플 (Tuple)",
                "definition": "릴레이션(테이블)의 행(row)을 의미하며, 하나의 레코드를 구성하는 속성 값들의 집합."
              },
              {
                "term": "슈퍼키 (Superkey)",
                "definition": "릴레이션의 모든 튜플을 고유하게 식별할 수 있는 하나 이상의 속성 집합."
              },
              {
                "term": "직교 (Orthogonal)",
                "definition": "두 개 이상의 속성 집합이 서로 독립적으로 존재하며 영향을 주지 않는 관계."
              }
            ],
            "outline": [
              {
                "text": "제4 정규형 (4NF) 개요",
                "id": "제4-정규형-4nf-개요",
                "children": null
              },
              {
                "text": "다치 종속성 (MVD) 이해",
                "id": "다치-종속성-mvd-이해",
                "children": [
                  {
                    "text": "예시 1: 학생-과목-활동 관계",
                    "id": "예시-1-학생-과목-활동-관계",
                    "children": null
                  },
                  {
                    "text": "예시 2: 강사-자녀-전화번호 관계",
                    "id": "예시-2-강사-자녀-전화번호-관계",
                    "children": null
                  }
                ]
              },
              {
                "text": "다치 종속성의 공식적 정의",
                "id": "다치-종속성의-공식적-정의",
                "children": null
              },
              {
                "text": "다치 종속성 해결의 필요성",
                "id": "다치-종속성-해결의-필요성",
                "children": null
              }
            ]
          },
          "quiz": [
            {
              "question": "제4 정규형(4NF)이 만족해야 하는 선행 조건은 무엇인가요?",
              "options": [
                "1NF",
                "2NF",
                "3NF",
                "BCNF"
              ],
              "answerIndex": 3,
              "explanation": "제4 정규형(4NF)의 요구사항 중 하나는 릴레이션이 BCNF를 만족해야 한다는 것입니다."
            },
            {
              "question": "다음 중 다치 종속성(Multi-valued Dependency)이 발생할 수 있는 상황에 대한 설명으로 가장 적절한 것은?",
              "options": [
                "릴레이션에 2개 이하의 속성이 존재할 때",
                "릴레이션의 속성 A가 B를 함수적으로 결정하고 B가 C를 함수적으로 결정할 때",
                "릴레이션에 3개 이상의 속성(A, B, C)이 있고, A가 B를 결정하며, B와 C가 서로 독립적일 때",
                "모든 속성이 기본 키의 부분 집합에 종속될 때"
              ],
              "answerIndex": 2,
              "explanation": "다치 종속성은 릴레이션에 3개 이상의 속성이 존재하고, 어떤 속성(A)이 다른 속성(B)을 결정하지만, B와 또 다른 속성(C)이 서로 독립적일 때 발생할 수 있습니다."
            },
            {
              "question": "강사 정보(ID, 자녀 이름, 전화번호) 테이블에서 ID가 자녀 이름과 전화번호를 다중 결정할 때 발생하는 주요 문제점은?",
              "options": [
                "데이터 무결성 제약 조건 위반",
                "릴레이션의 크기가 줄어듦",
                "불필요한 데이터 중복 및 갱신 이상 발생",
                "함수 종속성 손실"
              ],
              "answerIndex": 2,
              "explanation": "다치 종속성으로 인해 ID에 따라 자녀 이름과 전화번호의 모든 가능한 조합이 튜플로 저장되어, 불필요한 데이터 중복과 삽입, 삭제, 갱신 시의 이상 현상이 발생합니다."
            }
          ]
        },
        {
          "title": "정규화 이론 및 종속성 요약",
          "metadata": "Source: a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf, Text length: 1600 chars",
          "documentContent": [
            {
              "type": "heading",
              "content": "정규형 요약",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "정규형 이론은 데이터베이스 설계에서 릴레이션의 '좋은 형태'를 정의하고, 데이터 중복 및 이상 현상을 줄이는 데 사용됩니다. 각 정규형은 특정 유형의 종속성과 관련이 있습니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "다음은 주요 정규형과 그와 관련된 핵심 아이디어 및 종속성입니다:",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "-   **2NF (제2정규형)**: 부분 종속성(Partial dependency)을 다룹니다. 이는 기본 키의 일부가 비기본 키 속성을 결정하는 경우에 해당합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "-   **3NF (제3정규형)**: 이행 종속성(Transitive dependency)을 다룹니다. 이는 비기본 키 속성이 다른 비기본 키 속성을 결정하는 경우에 해당합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "-   **BCNF (보이스-코드 정규형)**: 3NF보다 엄격한 형태로, 비기본 키가 기본 키를 결정하는 경우를 포함하여 모든 결정자가 후보 키여야 함을 요구합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "-   **4NF (제4정규형)**: 다치 종속성(Multi-valued dependency)을 다룹니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "-   **5NF (제5정규형)**: 조인 종속성(Join dependency)을 다룹니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "정규화 이론",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "정규화 이론은 특정 릴레이션 R이 '좋은 형태'에 해당하는지 여부를 결정하는 것을 목표로 합니다. 만약 릴레이션 R이 '좋은 형태'가 아니라면, 이를 {R1, R2, ..., Rn}과 같은 릴레이션 집합으로 분해합니다. 이때 다음 조건들을 만족해야 합니다:",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "-   각각의 분해된 릴레이션은 '좋은 형태'여야 합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "-   분해는 무손실 분해(lossless decomposition)여야 합니다. 즉, 분해 후 다시 조인했을 때 원래 정보가 손실되지 않아야 합니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "정규화 이론의 기반",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "정규화는 다음을 포함한 관련 이론 집합에 기반을 두고 있습니다:",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "-   함수 종속성 (Functional dependencies)\n-   부분 종속성 (Partial dependencies)\n-   이행 종속성 (Transitive dependencies)\n-   다치 종속성 (Multivalued dependencies)",
              "level": null
            },
            {
              "type": "heading",
              "content": "함수 종속성의 활용",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "함수 종속성은 두 가지 주요 방식으로 활용됩니다:",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "1.  **릴레이션의 유효성 테스트**: 주어진 함수 종속성 집합 하에서 특정 릴레이션이 유효한지 테스트하는 데 사용됩니다. 릴레이션 r이 함수 종속성 집합 F 하에서 유효하다면, 우리는 r이 F를 만족한다고 말합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "2.  **유효한 릴레이션 집합에 제약 조건 지정**: 릴레이션 R에 대한 모든 유효한 릴레이션이 함수 종속성 집합 F를 만족할 경우, R에 F가 성립한다고 말합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "참고: 릴레이션 스키마의 특정 인스턴스는 해당 함수 종속성이 모든 유효한 인스턴스에 성립하지 않더라도 우연히 함수 종속성을 만족할 수 있습니다. 예를 들어, 'instructor' 릴레이션의 특정 인스턴스는 우연히 'name → ID' 관계를 만족할 수 있습니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "다치 종속성의 활용",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "다치 종속성 또한 두 가지 방식으로 활용됩니다:",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "1.  **릴레이션의 유효성 테스트**: 주어진 함수 및 다치 종속성 집합 하에서 릴레이션이 유효한지 여부를 결정하는 데 사용됩니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "2.  **유효한 릴레이션 집합에 제약 조건 지정**: 우리는 주어진 함수 및 다치 종속성을 만족하는 릴레이션만 고려합니다. 만약 릴레이션 r이 주어진 다치 종속성을 만족하지 못한다면, r에 튜플을 추가하여 다치 종속성을 만족하는 r'를 구성할 수 있습니다.",
              "level": null
            }
          ],
          "aiNotes": {
            "summary": "제공된 텍스트는 데이터베이스 정규화 이론과 다양한 종속성(함수, 부분, 이행, 다치, 조인)이 각 정규형(2NF, 3NF, BCNF, 4NF, 5NF)과 어떻게 관련되는지 설명합니다. 또한, 정규화가 릴레이션을 '좋은 형태'로 분해하는 과정이며, 이 과정에서 무손실 분해가 중요함을 강조합니다. 마지막으로 함수 종속성 및 다치 종속성이 릴레이션의 유효성을 테스트하고 제약 조건을 지정하는 데 어떻게 활용되는지 상세히 설명합니다.",
            "keyConcepts": [
              {
                "term": "정규화 (Normalization)",
                "definition": {
                  "easy": "데이터베이스를 잘 정리해서 중복을 줄이고 문제를 없애는 과정이에요.",
                  "medium": "데이터 중복을 제거하고 데이터 일관성을 유지하기 위해 릴레이션 스키마를 더 작고 잘 정의된 릴레이션으로 분해하는 과정입니다.",
                  "hard": "관계형 데이터베이스 설계에서 데이터의 무결성을 보장하고 이상 현상(삽입, 삭제, 갱신 이상)을 최소화하기 위해 릴레이션 스키마를 특정 정규형 규칙에 따라 분해하는 체계적인 과정으로, 주로 함수 종속성과 다치 종속성 등의 제약 조건을 기반으로 합니다."
                }
              },
              {
                "term": "함수 종속성 (Functional Dependency)",
                "definition": {
                  "easy": "어떤 값(들)이 다른 어떤 값(들)을 항상 결정하는 관계를 말해요. 예를 들어, 학생 번호가 학생 이름을 결정하는 것처럼요.",
                  "medium": "릴레이션 R에서 속성 집합 A가 속성 집합 B를 함수적으로 결정한다는 것은, R의 어떤 두 튜플이 A에 대해 같은 값을 가지면 B에 대해서도 같은 값을 가져야 함을 의미합니다 (A → B).",
                  "hard": "관계형 스키마 R에서, 속성 집합 X의 값이 속성 집합 Y의 값을 유일하게 결정할 때 (X → Y), 이를 함수 종속성이라 합니다. 이는 릴레이션 인스턴스에 대한 제약 조건으로, 데이터의 의미론적 관계를 반영하며 정규화 과정에서 중요한 역할을 합니다."
                }
              },
              {
                "term": "무손실 분해 (Lossless Decomposition)",
                "definition": {
                  "easy": "테이블을 여러 개로 나눴다가 다시 합쳐도 원래 정보가 하나도 없어지지 않는 것을 말해요.",
                  "medium": "릴레이션 R을 R1과 R2로 분해했을 때, R1과 R2를 자연 조인(natural join)한 결과가 원래 릴레이션 R과 동일하게 되는 분해를 의미합니다. 정보 손실이 발생하지 않음을 보장합니다.",
                  "hard": "데이터베이스 릴레이션 R을 R1, R2, ..., Rn의 집합으로 분해할 때, 모든 R_i의 자연 조인(⋈ R_i)이 원래 릴레이션 R과 동일한 정보를 포함하는 것을 보장하는 분해 속성입니다. 이는 분해로 인해 데이터가 유실되거나 허위 튜플이 생성되지 않음을 의미하며, 정규화의 필수적인 목표 중 하나입니다."
                }
              }
            ],
            "importantTerms": [
              {
                "term": "정규형 (Normal Form)",
                "definition": "데이터베이스 릴레이션이 만족해야 하는 특정 조건들의 집합으로, 데이터 중복을 줄이고 이상 현상을 방지하기 위해 사용됩니다."
              },
              {
                "term": "부분 종속성 (Partial Dependency)",
                "definition": "기본 키의 일부 속성이 비기본 키 속성을 결정하는 함수 종속성으로, 2NF 위반의 원인이 됩니다."
              },
              {
                "term": "이행 종속성 (Transitive Dependency)",
                "definition": "비기본 키 속성이 다른 비기본 키 속성을 결정하는 함수 종속성으로, 3NF 위반의 원인이 됩니다."
              },
              {
                "term": "다치 종속성 (Multi-valued Dependency)",
                "definition": "한 속성의 값이 다른 속성 집합의 여러 값을 결정하는 상황으로, 4NF 위반의 원인이 됩니다."
              },
              {
                "term": "조인 종속성 (Join Dependency)",
                "definition": "릴레이션을 여러 개의 릴레이션으로 분해한 후 다시 조인했을 때 원래 릴레이션과 동일하게 되는 성질로, 5NF와 관련이 있습니다."
              },
              {
                "term": "BCNF (Boyce-Codd Normal Form)",
                "definition": "3NF보다 더 엄격한 정규형으로, 모든 결정자가 후보 키여야 한다는 조건을 요구합니다."
              },
              {
                "term": "릴레이션 (Relation)",
                "definition": "관계형 데이터베이스에서 데이터를 저장하는 테이블을 지칭하는 용어입니다."
              }
            ],
            "outline": [
              {
                "text": "정규형 및 종속성 요약",
                "id": "정규형-및-종속성-요약",
                "children": [
                  {
                    "text": "정규형별 핵심 아이디어 및 종속성",
                    "id": "정규형별-핵심-아이디어-및-종속성",
                    "children": [
                      {
                        "text": "2NF (부분 종속성)",
                        "id": "2nf-부분-종속성",
                        "children": null
                      },
                      {
                        "text": "3NF (이행 종속성)",
                        "id": "3nf-이행-종속성",
                        "children": null
                      },
                      {
                        "text": "BCNF (비PK -> PK)",
                        "id": "bcnf-비pk-pk",
                        "children": null
                      },
                      {
                        "text": "4NF (다치 종속성)",
                        "id": "4nf-다치-종속성",
                        "children": null
                      },
                      {
                        "text": "5NF (조인 종속성)",
                        "id": "5nf-조인-종속성",
                        "children": null
                      }
                    ]
                  }
                ]
              },
              {
                "text": "정규화 이론",
                "id": "정규화-이론",
                "children": [
                  {
                    "text": "‘좋은 형태’ 릴레이션 판단 및 분해",
                    "id": "좋은-형태-릴레이션-판단-및-분해",
                    "children": null
                  },
                  {
                    "text": "무손실 분해의 중요성",
                    "id": "무손실-분해의-중요성",
                    "children": null
                  },
                  {
                    "text": "정규화의 기반이 되는 이론들",
                    "id": "정규화의-기반이-되는-이론들",
                    "children": [
                      {
                        "text": "함수 종속성",
                        "id": "함수-종속성",
                        "children": null
                      },
                      {
                        "text": "부분 종속성",
                        "id": "부분-종속성",
                        "children": null
                      },
                      {
                        "text": "이행 종속성",
                        "id": "이행-종속성",
                        "children": null
                      },
                      {
                        "text": "다치 종속성",
                        "id": "다치-종속성",
                        "children": null
                      }
                    ]
                  }
                ]
              },
              {
                "text": "종속성의 활용",
                "id": "종속성의-활용",
                "children": [
                  {
                    "text": "함수 종속성의 활용",
                    "id": "함수-종속성의-활용",
                    "children": [
                      {
                        "text": "릴레이션의 유효성 테스트",
                        "id": "릴레이션의-유효성-테스트",
                        "children": null
                      },
                      {
                        "text": "유효한 릴레이션에 대한 제약 조건 지정",
                        "id": "유효한-릴레이션에-대한-제약-조건-지정",
                        "children": null
                      }
                    ]
                  },
                  {
                    "text": "다치 종속성의 활용",
                    "id": "다치-종속성의-활용",
                    "children": [
                      {
                        "text": "릴레이션의 유효성 테스트",
                        "id": "릴레이션의-유효성-테스트",
                        "children": null
                      },
                      {
                        "text": "유효한 릴레이션에 대한 제약 조건 지정",
                        "id": "유효한-릴레이션에-대한-제약-조건-지정",
                        "children": null
                      },
                      {
                        "text": "다치 종속성을 만족하지 못하는 경우 튜플 추가를 통한 만족",
                        "id": "다치-종속성을-만족하지-못하는-경우-튜플-추가를-통한-만족",
                        "children": null
                      }
                    ]
                  }
                ]
              }
            ]
          },
          "quiz": [
            {
              "question": "다음 중 부분 종속성(Partial dependency)과 관련된 정규형은 무엇인가요?",
              "options": [
                "1NF",
                "2NF",
                "3NF",
                "BCNF"
              ],
              "answerIndex": 1,
              "explanation": "부분 종속성은 기본 키의 일부가 비기본 키를 결정하는 경우를 의미하며, 이는 2NF를 위반하는 주된 원인입니다."
            },
            {
              "question": "데이터베이스 정규화의 주요 목적 중 하나가 아닌 것은 무엇인가요?",
              "options": [
                "데이터 중복 제거",
                "데이터 일관성 유지",
                "무손실 분해 보장",
                "데이터 검색 속도 최적화"
              ],
              "answerIndex": 3,
              "explanation": "정규화는 주로 데이터 중복 제거, 일관성 유지, 이상 현상 방지를 목적으로 하며, 반드시 검색 속도를 최적화하는 것은 아닙니다. 오히려 과도한 정규화는 조인 연산을 증가시켜 검색 성능을 저하시킬 수도 있습니다."
            },
            {
              "question": "릴레이션 R이 함수 종속성 집합 F 하에서 '유효하다'는 것의 의미로 가장 적절한 것은?",
              "options": [
                "R의 모든 속성이 기본 키에만 종속된다.",
                "R이 F에 있는 모든 함수 종속성을 만족한다.",
                "R에 허위 튜플이 존재하지 않는다.",
                "R이 2NF를 만족한다."
              ],
              "answerIndex": 1,
              "explanation": "텍스트에 따르면, 릴레이션 r이 주어진 함수 종속성 F 하에서 유효할 경우, r은 F를 만족한다고 명시되어 있습니다. 이는 R의 모든 인스턴스가 F에 정의된 모든 함수 종속성 제약을 따른다는 의미입니다."
            }
          ]
        },
        {
          "title": "데이터베이스 정규화 실전 예시",
          "metadata": "Source: a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf, Text length: 1335 chars",
          "documentContent": [
            {
              "type": "heading",
              "content": "데이터베이스 정규화 실전 예시",
              "level": 1
            },
            {
              "type": "paragraph",
              "content": "위키피디아에서 가져온 예시를 통해 데이터베이스 정규화 과정을 제1 정규형(1NF)부터 제4 정규형(4NF)까지 단계별로 설명합니다. 각 정규형이 어떤 함수 종속성을 해결하는지 구체적인 사례를 통해 살펴봅니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "초기 데이터 상태",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "제공된 초기 데이터는 특정 서적 정보들을 포함하고 있으며, 이후 정규화 과정을 통해 데이터 중복을 줄이고 무결성을 높이는 방법을 보여줍니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "제1 정규형 (1NF) 만족",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "제1 정규형을 만족시키기 위해 각 셀이 단일 값을 포함하도록 하고, 반복되는 그룹을 제거하여 테이블을 분리하거나 확장하는 과정이 필요합니다. 이를 통해 데이터의 원자성을 확보합니다. 예시에서는 초기 비정규형 상태에서 1NF를 만족하는 형태로 개선된 모습을 보여줍니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "제2 정규형 (2NF) 만족",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "제2 정규형은 제1 정규형을 만족하고, 부분 함수 종속성(Partial Dependency)이 없는 상태를 의미합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "예시의 초기 데이터는 `{Title, Format}`을 복합 키(Compound key)로 가집니다. 이때 `Title`이 `Author`, `Author Nationality`, `Pages`, `Thickness`, `Genre ID`, `Genre Name`, `Publisher ID`에 부분 함수 종속성을 가집니다. 즉, 복합 키의 일부인 `Title`만으로 다른 속성들이 결정되는 문제가 있습니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "제2 정규형을 만족시키기 위해 이러한 부분 함수 종속성을 제거하고, 종속된 속성들을 별도의 테이블로 분리하여 데이터 중복을 줄입니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "제3 정규형 (3NF) 만족",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "제3 정규형은 제2 정규형을 만족하고, 추이 함수 종속성(Transitive Dependency)이 없는 상태를 의미합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "예시에서는 `Genre ID`가 `Genre Name`을 결정하는 추이 함수 종속성(`Genre ID` → `Genre Name`)이 존재합니다. 이는 기본 키가 아닌 속성(`Genre ID`)이 다른 기본 키가 아닌 속성(`Genre Name`)을 결정하는 경우입니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "제3 정규형을 만족시키기 위해 `Genre ID`와 `Genre Name`을 포함하는 별도의 테이블을 생성하여 추이 함수 종속성을 제거합니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "보이스/코드 정규형 (BCNF) 만족",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "BCNF는 제3 정규형보다 엄격한 정규형으로, 모든 결정자(Determinant)가 후보 키(Candidate Key)여야 합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "예시에서는 `Author`가 `Author Nationality`를 결정하는 비기본 키 간의 함수 종속성(`Author` → `Author Nationality`)이 존재합니다. `Author`는 후보 키가 아니므로 BCNF를 위반합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "BCNF를 만족시키기 위해 `Author`와 `Author Nationality`를 포함하는 별도의 테이블을 분리하여 이러한 종속성을 제거합니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "제4 정규형 (4NF) 만족",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "제4 정규형은 BCNF를 만족하고, 다치 종속성(Multi-valued Dependency)이 없는 상태를 의미합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "이 예시는 서점 프랜차이즈가 여러 지역에 지점을 소유하고 있으며, 모든 가용 서적이 각 지역에서 제공된다는 가정을 합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "이 가정 하에 `Title`이 특정 `Location`에 명확하게 바인딩되지 않는 다치 종속성이 발생할 수 있습니다. 이는 제4 정규형을 만족하지 않는 경우를 보여주며, 다치 종속성을 제거하여 테이블을 추가로 분리할 필요가 있음을 시사합니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "출처",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "본 예시는 위키피디아의 데이터베이스 정규화 관련 페이지에서 발췌되었습니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "원문 출처: https://en.wikipedia.org/wiki/Database_normalization",
              "level": null
            }
          ],
          "aiNotes": {
            "summary": "이 문서는 데이터베이스 정규화 과정을 제1 정규형(1NF)부터 제4 정규형(4NF)까지 단계별로 설명하는 실전 예시를 제공합니다. 각 정규형이 어떤 종류의 함수 종속성(부분 함수 종속성, 추이 함수 종속성, 비기본 키 간의 함수 종속성, 다치 종속성)을 해결하는지 구체적인 시나리오와 함께 보여주며, 이를 통해 데이터 중복을 줄이고 데이터 무결성을 높이는 방법을 시연합니다.",
            "keyConcepts": [
              {
                "term": "정규화 (Normalization)",
                "definition": {
                  "easy": "데이터베이스를 잘 정리해서 중복을 줄이고 문제없이 데이터를 저장하는 방법입니다.",
                  "medium": "데이터베이스 설계에서 데이터 중복을 최소화하고 무결성을 유지하며 이상 현상(삽입, 삭제, 갱신 이상)을 방지하기 위해 릴레이션을 여러 개의 릴레이션으로 분해하는 과정입니다.",
                  "hard": "관계형 데이터베이스 설계에서 함수 종속성(Functional Dependency) 이론을 기반으로 릴레이션 스키마를 분해하여 데이터 중복성을 제거하고 데이터 무결성을 강화하며, 삽입, 삭제, 갱신 이상(Anomalies)을 최소화하기 위한 체계적인 과정입니다."
                }
              },
              {
                "term": "함수 종속성 (Functional Dependency)",
                "definition": {
                  "easy": "어떤 값(A)이 다른 값(B)을 결정할 때 A가 B에 함수 종속적이라고 합니다. 예를 들어, 책 제목이 저자를 결정하는 경우입니다.",
                  "medium": "릴레이션 R에서 속성 집합 X가 속성 집합 Y를 함수적으로 결정할 때, X → Y로 표기하며, Y가 X에 함수 종속적이라고 합니다. 즉, X의 각 값에 대해 Y의 값이 유일하게 결정되는 관계를 의미합니다.",
                  "hard": "관계형 스키마 R에서, 속성 집합 X와 Y에 대해, R의 어떤 유효한 릴레이션 인스턴스 r에서도 X의 두 튜플이 동일한 값을 가지면, 그 두 튜플은 Y에서도 동일한 값을 가질 때 Y는 X에 함수 종속적이라고 합니다. 이는 데이터 무결성 제약 조건의 한 형태로, 데이터 중복 및 이상 현상을 분석하고 제거하는 데 사용됩니다."
                }
              },
              {
                "term": "부분 함수 종속성 (Partial Dependency)",
                "definition": {
                  "easy": "복합 키의 일부만으로 다른 데이터가 결정될 때를 말합니다.",
                  "medium": "릴레이션에서 기본 키의 부분 집합이 기본 키가 아닌 속성을 결정하는 함수 종속성입니다. 제2 정규형에서 제거 대상입니다.",
                  "hard": "복합 기본 키를 가진 릴레이션 R에서, 기본 키의 적절한 부분 집합 X가 기본 키가 아닌 속성 Y를 함수적으로 결정하는 경우 (X → Y)입니다. 이는 R이 제2 정규형을 만족하지 못하게 하는 원인이며, 이 종속성을 제거함으로써 릴레이션의 중복성을 줄이고 업데이트 이상을 방지할 수 있습니다."
                }
              },
              {
                "term": "추이 함수 종속성 (Transitive Dependency)",
                "definition": {
                  "easy": "A가 B를 결정하고 B가 C를 결정할 때, A가 C를 결정하는 관계(A→B, B→C 이면 A→C)를 말합니다.",
                  "medium": "릴레이션에서 기본 키가 아닌 속성이 다른 기본 키가 아닌 속성을 결정하는 함수 종속성입니다. 제3 정규형에서 제거 대상입니다.",
                  "hard": "릴레이션 R에서, X, Y, Z가 R의 속성 집합일 때 X → Y이고 Y → Z이며 Y가 X의 부분 집합이 아니고 Z가 Y에 함수 종속적이지 않을 때 X → Z가 성립하는 함수 종속성입니다. 이는 기본 키가 아닌 속성 간의 종속성으로, 제3 정규형을 만족시키기 위해 제거되어야 합니다."
                }
              },
              {
                "term": "다치 종속성 (Multi-valued Dependency)",
                "definition": {
                  "easy": "하나의 데이터가 다른 여러 개의 데이터를 결정할 때 발생하며, 이 관계가 다른 데이터와 상관없을 때를 말합니다.",
                  "medium": "릴레이션 R에서 속성 집합 A가 속성 집합 B의 여러 값을 결정하고, 이 관계가 다른 속성 집합 C와 무관할 때 A가 B에 다치 종속적이라고 합니다. 제4 정규형에서 제거 대상입니다.",
                  "hard": "릴레이션 R에서, A, B, C가 R의 속성 집합일 때, A →→ B가 성립하는 경우입니다. 이는 A의 각 값에 대해 B의 값이 다중으로 존재하며, B의 집합이 C와 독립적일 때 발생합니다. 즉, A의 특정 값에 대해 B의 값들의 집합이 존재하고, 그 B의 값들의 집합이 R의 다른 속성들과 무관하게 결정될 때 발생하며, 제4 정규형에서 해결해야 할 대상입니다."
                }
              }
            ],
            "importantTerms": [
              {
                "term": "복합 키 (Compound Key)",
                "definition": "두 개 이상의 속성으로 구성된 기본 키입니다."
              },
              {
                "term": "제1 정규형 (1NF)",
                "definition": "모든 속성 값이 원자 값(Atomic Value)을 가지며, 반복되는 그룹이 없는 형태입니다."
              },
              {
                "term": "제2 정규형 (2NF)",
                "definition": "제1 정규형을 만족하고, 부분 함수 종속성이 없는 형태입니다."
              },
              {
                "term": "제3 정규형 (3NF)",
                "definition": "제2 정규형을 만족하고, 추이 함수 종속성이 없는 형태입니다."
              },
              {
                "term": "보이스/코드 정규형 (BCNF)",
                "definition": "제3 정규형보다 엄격하며, 모든 결정자가 후보 키인 형태입니다."
              },
              {
                "term": "제4 정규형 (4NF)",
                "definition": "BCNF를 만족하고, 다치 종속성(Multi-valued Dependency)이 없는 형태입니다."
              }
            ],
            "outline": [
              {
                "text": "데이터베이스 정규화 실전 예시",
                "id": "데이터베이스-정규화-실전-예시",
                "children": [
                  {
                    "text": "초기 데이터 상태",
                    "id": "초기-데이터-상태",
                    "children": null
                  },
                  {
                    "text": "제1 정규형 (1NF) 만족",
                    "id": "제1-정규형-1nf-만족",
                    "children": null
                  },
                  {
                    "text": "제2 정규형 (2NF) 만족",
                    "id": "제2-정규형-2nf-만족",
                    "children": null
                  },
                  {
                    "text": "제3 정규형 (3NF) 만족",
                    "id": "제3-정규형-3nf-만족",
                    "children": null
                  },
                  {
                    "text": "보이스/코드 정규형 (BCNF) 만족",
                    "id": "보이스코드-정규형-bcnf-만족",
                    "children": null
                  },
                  {
                    "text": "제4 정규형 (4NF) 만족",
                    "id": "제4-정규형-4nf-만족",
                    "children": null
                  },
                  {
                    "text": "출처",
                    "id": "출처",
                    "children": null
                  }
                ]
              }
            ]
          },
          "quiz": [
            {
              "question": "제2 정규형(2NF)이 해결하고자 하는 주요 함수 종속성은 무엇입니까?",
              "options": [
                "부분 함수 종속성",
                "추이 함수 종속성",
                "다치 종속성",
                "비기본 키 간의 함수 종속성"
              ],
              "answerIndex": 0,
              "explanation": "제2 정규형은 복합 키의 일부에만 종속되는 부분 함수 종속성을 제거하여 테이블을 분리하는 것을 목표로 합니다."
            },
            {
              "question": "제3 정규형(3NF)을 만족시키기 위해 제거해야 하는 함수 종속성은 무엇입니까?",
              "options": [
                "부분 함수 종속성",
                "추이 함수 종속성",
                "다치 종속성",
                "복합 키 종속성"
              ],
              "answerIndex": 1,
              "explanation": "제3 정규형은 기본 키가 아닌 속성이 다른 기본 키가 아닌 속성을 결정하는 추이 함수 종속성을 제거하는 데 중점을 둡니다."
            },
            {
              "question": "BCNF(보이스/코드 정규형)가 제3 정규형(3NF)보다 더 엄격하게 요구하는 조건은 무엇입입니까?",
              "options": [
                "모든 속성이 원자 값을 가져야 한다.",
                "모든 결정자가 후보 키여야 한다.",
                "테이블에 반복되는 그룹이 없어야 한다.",
                "다치 종속성이 없어야 한다."
              ],
              "answerIndex": 1,
              "explanation": "BCNF는 제3 정규형보다 엄격하며, 릴레이션 내의 모든 결정자(다른 속성을 결정하는 속성)가 반드시 후보 키여야 합니다. 이는 3NF에서 해결하지 못할 수 있는 비기본 키 간의 함수 종속성 문제까지 다룹니다."
            }
          ]
        },
        {
          "title": "데이터베이스 설계 과정 및 비정규화",
          "metadata": "Source: a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf, Text length: 2000 chars",
          "documentContent": [
            {
              "type": "heading",
              "content": "전반적인 데이터베이스 설계 과정",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "스키마 R이 주어졌다고 가정해 봅시다. 이 스키마 R은 E-R 다이어그램을 테이블 집합으로 변환하는 과정(정규화)에서 생성되었을 수 있습니다. 또는 관심 있는 모든 속성을 포함하는 단일 릴레이션(유니버설 릴레이션)이었을 수도 있습니다. 정규화는 R을 더 작은 릴레이션으로 분해합니다. 때로는 R이 임시적인 관계 설계의 결과일 수 있으며, 이 경우 우리는 그것을 정규형으로 테스트하거나 변환합니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "E-R 모델과 정규화",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "E-R 다이어그램이 모든 엔티티를 정확하게 식별하며 신중하게 설계되었다면, E-R 다이어그램에서 생성된 테이블은 추가적인 정규화가 필요 없을 것입니다. 그러나 실제(불완전한) 설계에서는 엔티티의 비키 속성에서 해당 엔티티의 다른 속성으로의 함수 종속성이 존재할 수 있습니다. 예를 들어, 'department_name'과 'building' 속성을 가진 'employee' 엔티티에서 'department_name'이 'building'을 함수적으로 종속시킨다면, 이는 좋은 설계였다면 'department'를 별도의 엔티티로 만들었을 것입니다. 관계 집합의 비키 속성에서 발생하는 함수 종속성도 가능하지만 드뭅니다. 대부분의 관계는 이진 관계이기 때문입니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "성능을 위한 비정규화",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "성능을 위해 비정규화된 스키마를 사용하고 싶을 수 있습니다. 예를 들어, 'course_id' 및 'title'과 함께 선수 과목을 표시하려면 'course' 테이블과 'prereq' 테이블의 조인이 필요합니다. 대안 1은 'course'와 'prereq'의 모든 속성을 포함하는 비정규화된 릴레이션을 사용하는 것입니다. 이는 더 빠른 조회를 가능하게 하지만, 추가적인 공간과 업데이트를 위한 추가 실행 시간, 그리고 프로그래머의 추가적인 코딩 작업과 코드 오류 가능성을 수반합니다. 대안 2는 'course'와 'prereq'의 조인으로 정의된 물리적 뷰(materialized view)를 사용하는 것입니다. 이는 위와 동일한 이점과 단점을 가지지만, 프로그래머의 추가 코딩 작업이 필요 없고 잠재적인 오류를 방지할 수 있습니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "남아있는 문제",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "데이터베이스 설계의 일부 측면은 정규화로 포착되지 않습니다. 예를 들어 (피해야 할 경우): 'earnings_2004, earnings_2005, earnings_2006' 등 모든 속성이 '(company_id, earnings)' 스키마에 있는 경우입니다. 위 예시는 BCNF(보이스-코드 정규형)에서 잘 정규화되어 있지만, 연도별 쿼리를 어렵게 만들고 매년 새 테이블이 필요합니다. 또 다른 예시로 'company_year (company_id, earnings_2004, earnings_2005, earnings_2006)' 스키마도 BCNF에서 잘 정규화되어 있지만, 연도별 쿼리를 어렵게 만들고 매년 새 속성이 필요합니다. 이는 한 속성의 값이 열 이름이 되는 교차 테이블(crosstab)의 예시입니다. 더 나은 스키마는 'earnings (company_id, year, amount)'입니다.",
              "level": null
            }
          ],
          "aiNotes": {
            "summary": "본 텍스트는 전반적인 데이터베이스 설계 과정을 다루며, E-R 모델링과 정규화의 관계를 설명합니다. 잘 설계된 E-R 다이어그램은 추가 정규화가 필요 없지만, 실제 설계에서는 비키 속성 간의 함수 종속성으로 인해 정규화가 필요할 수 있음을 지적합니다. 또한, 성능 향상을 위한 비정규화 전략과 그 대안(비정규화된 릴레이션, 물리적 뷰)을 제시하며, 정규화만으로는 해결하기 어려운 교차 테이블과 같은 설계 문제와 그에 대한 더 나은 스키마 방안을 논의합니다.",
            "keyConcepts": [
              {
                "term": "데이터베이스 설계 과정",
                "definition": {
                  "easy": "데이터베이스를 만들고 정리하는 단계들입니다.",
                  "medium": "요구사항을 분석하고, 개념적/논리적/물리적 모델링을 통해 데이터베이스 스키마를 정의하며, 이를 구현하고 유지보수하는 일련의 과정입니다.",
                  "hard": "데이터 모델링 기법(E-R 모델, 관계형 모델 등)과 정규화 원칙을 적용하여 데이터 무결성, 일관성, 효율성을 보장하는 데이터베이스 구조를 수립하는 체계적인 절차입니다."
                }
              },
              {
                "term": "정규화",
                "definition": {
                  "easy": "데이터를 중복 없이 잘 정리해서 문제가 생기지 않게 하는 과정입니다.",
                  "medium": "관계형 데이터베이스에서 데이터 중복을 줄이고 이상 현상(삽입, 삭제, 갱신 이상)을 방지하며 데이터 무결성을 확보하기 위해 테이블을 분해하는 과정입니다.",
                  "hard": "함수 종속성을 기반으로 릴레이션 스키마를 여러 개의 작은 릴레이션으로 분해하여 데이터 종속성 위반을 제거하고, 데이터 중복 및 갱신 이상을 최소화하여 데이터 모델의 일관성과 효율성을 높이는 구조화 기법입니다."
                }
              },
              {
                "term": "비정규화",
                "definition": {
                  "easy": "데이터베이스를 빠르게 만들려고 일부러 데이터를 겹치게 하는 것입니다.",
                  "medium": "정규화된 데이터베이스에서 성능 향상을 위해 의도적으로 중복을 허용하거나 테이블을 통합하는 과정입니다.",
                  "hard": "데이터 검색 성능을 최적화하기 위해 정규화 원칙을 일부 희생하고, 조인 연산의 오버헤드를 줄이기 위해 중복 데이터를 허용하거나 테이블을 결합하는 등의 방식으로 데이터 모델을 변형하는 과정입니다."
                }
              },
              {
                "term": "E-R 모델",
                "definition": {
                  "easy": "데이터베이스에 들어갈 정보들을 그림으로 보여주는 방법입니다.",
                  "medium": "엔티티(개체)와 이들 간의 관계를 사용하여 데이터베이스의 개념적 구조를 시각적으로 표현하는 모델링 기법입니다.",
                  "hard": "데이터베이스 시스템의 개념적 설계를 위한 상위 수준 데이터 모델로, 개체(Entity), 속성(Attribute), 관계(Relationship)의 세 가지 기본 요소를 사용하여 현실 세계의 정보를 추상화하고 도식화하는 방법론입니다."
                }
              },
              {
                "term": "함수 종속성",
                "definition": {
                  "easy": "어떤 데이터가 다른 데이터를 결정하는 관계입니다.",
                  "medium": "릴레이션 R에서 속성 집합 X의 값이 속성 집합 Y의 값을 유일하게 결정할 때, Y는 X에 함수적으로 종속된다고 하며 X → Y로 표기합니다.",
                  "hard": "관계형 스키마 R에서, 모든 튜플에 대해 X의 두 튜플이 동일한 값을 가지면 Y의 두 튜플도 동일한 값을 갖는 경우, Y는 X에 함수적으로 종속된다고 정의하며, 이는 정규화 과정의 핵심 원리입니다."
                }
              }
            ],
            "importantTerms": [
              {
                "term": "스키마",
                "definition": "데이터베이스의 구조와 제약 조건에 대한 정의입니다."
              },
              {
                "term": "유니버설 릴레이션",
                "definition": "관심 있는 모든 속성을 포함하는 단일 릴레이션입니다."
              },
              {
                "term": "BCNF (Boyce-Codd Normal Form)",
                "definition": "보이스-코드 정규형. 3차 정규형보다 엄격한 정규형으로, 모든 비자명 함수 종속성에서 결정자가 후보 키인 상태를 의미합니다."
              },
              {
                "term": "물리적 뷰 (Materialized View)",
                "definition": "미리 계산되어 데이터베이스에 저장된 뷰로, 쿼리 성능 향상에 사용됩니다."
              },
              {
                "term": "교차 테이블 (Crosstab)",
                "definition": "특정 속성의 값들이 테이블의 열 이름으로 사용되는 형태의 테이블입니다."
              }
            ],
            "outline": [
              {
                "text": "전반적인 데이터베이스 설계 과정",
                "id": "전반적인-데이터베이스-설계-과정",
                "children": null
              },
              {
                "text": "E-R 모델과 정규화",
                "id": "e-r-모델과-정규화",
                "children": null
              },
              {
                "text": "성능을 위한 비정규화",
                "id": "성능을-위한-비정규화",
                "children": null
              },
              {
                "text": "남아있는 문제",
                "id": "남아있는-문제",
                "children": null
              }
            ]
          },
          "quiz": [
            {
              "question": "다음 중 데이터베이스 정규화의 주된 목적은 무엇입니까?",
              "options": [
                "데이터 중복을 줄이고 이상 현상을 방지합니다.",
                "데이터베이스 쿼리 성능을 향상시킵니다.",
                "데이터베이스 보안을 강화합니다.",
                "사용자 인터페이스의 복잡성을 줄입니다."
              ],
              "answerIndex": 0,
              "explanation": "정규화의 주된 목적은 데이터 중복을 제거하고 삽입, 삭제, 갱신과 같은 이상 현상을 방지하여 데이터 무결성을 확보하는 것입니다."
            },
            {
              "question": "데이터베이스 성능 향상을 위해 의도적으로 중복을 허용하거나 테이블을 통합하는 과정을 무엇이라고 합니까?",
              "options": [
                "정규화",
                "비정규화",
                "인덱싱",
                "조인"
              ],
              "answerIndex": 1,
              "explanation": "비정규화는 정규화된 데이터베이스에서 쿼리 성능 향상을 위해 의도적으로 데이터 중복을 허용하거나 테이블을 통합하는 과정입니다."
            },
            {
              "question": "제시된 텍스트에서 정규화만으로는 해결하기 어려운 데이터베이스 설계 문제의 예시로 언급된 것은 무엇입니까?",
              "options": [
                "키 속성(Key Attribute)의 누락",
                "릴레이션 간의 잘못된 관계 설정",
                "연도별 수익 데이터를 열(Column)로 표현하는 교차 테이블(Crosstab) 구조",
                "외래 키(Foreign Key) 제약 조건의 위반"
              ],
              "answerIndex": 2,
              "explanation": "텍스트에서는 'earnings_2004, earnings_2005, earnings_2006'과 같이 연도별 수익 데이터를 열로 표현하는 교차 테이블 구조가 정규화되어 있지만, 연도별 쿼리를 어렵게 만드는 문제로 언급되었습니다."
            }
          ]
        }
      ],
      "final_result": ""
    }
  },
  {
    "node": "start_processing",
    "status": "completed",
    "state_snapshot": {
      "run_id": "a9d3b848-7887-4676-a9e0-4d590ff0b031",
      "pdf_file_paths": [
        "temp_pdf_uploads/a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf"
      ],
      "notebook_title": "",
      "holistic_chapters": [],
      "generated_content": [],
      "final_result": ""
    }
  },
  {
    "node": "start_processing",
    "status": "completed",
    "state_snapshot": {
      "run_id": "a9d3b848-7887-4676-a9e0-4d590ff0b031",
      "pdf_file_paths": [
        "temp_pdf_uploads/a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf"
      ],
      "notebook_title": "",
      "holistic_chapters": [],
      "generated_content": [],
      "final_result": ""
    }
  },
  {
    "node": "analyze_overall_structure",
    "status": "completed",
    "state_snapshot": {
      "run_id": "a9d3b848-7887-4676-a9e0-4d590ff0b031",
      "pdf_file_paths": [
        "temp_pdf_uploads/a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf"
      ],
      "notebook_title": "데이터베이스 정규화: 원리, 과정 및 적용",
      "holistic_chapters": [
        {
          "chapter_title": "데이터베이스 정규화 개요 및 필요성",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "데이터가 혼합될 때 발생하는 문제점(데이터 중복, 일관성 문제, 삽입/삭제/갱신 이상 현상)을 설명하고, 이러한 문제에 대한 해결책으로 데이터베이스 정규화의 필요성과 분해(Decomposition)의 개념, 그리고 손실 분해(Lossy Decomposition)와 무손실 분해(Lossless Decomposition)의 차이를 소개합니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems2\nWhen Data is Jumbled…•Suppose that we combine instructor and department •(Below represents the join on instructor and department)\nECE30030/ITP30010 Database Systems3\nWhen Data is Jumbled…•Key issues•Repetition of data à increases the size of database•Data consistency issues•Insertion anomaly: Inserting redundant data for every new record•Deletion anomaly: Loss of related data, when some data is deleted•Update anomaly: When updating certain information, every single record must be updated\nECE30030/ITP30010 Database Systems4\nSolution: Decomposition!•How to avoid the repetition-of-information problem?\n•A: Decompose it into two schemas (as they were)•Normalization = decomposition of relational schemas•Key idea: split relational schemas such that only directly related data composes a relation\nECE30030/ITP30010 Database Systems5\nDecomposition•Less redundancy à Uses smaller disk storage; Causes less issues associated with insertion, deletion, and update anomalies•Not all decompositions are good•E.g., Suppose we decompose   employee(ID, name, street, city, salary)into  employee1 (ID, name)  employee2 (name, street, city, salary)à Problem: What if there are two employees with the same name?•Lossy decomposition: a decomposition from which the original relation cannot be reconstructedECE30030/ITP30010 Database Systems6\nLossy Decomposition\nECE30030/ITP30010 Database Systems7\nLossless Decomposition•Let R be a relation schema and let R1 and R2 form a decomposition of R; that is, R = R1 U R2•A decomposition is a lossless decomposition if there is no loss of information by replacing R with the two relation schemas R1 U R2•Formally,\nÕR1(r)  ⋈  ÕR2(r) = r•C.f., Conversely, a decomposition is lossy if when the join of the projection results is computed, a proper superset of the original relation is returned     r  Ì  ÕR1(r)  ⋈  ÕR2(r)\nECE30030/ITP30010 Database Systems8\nExample: Lossless Decomposition•Decomposition of R = (A, B, C)  à  R1 = (A, B); R2 = (B, C)\nECE30030/ITP30010 Database Systems9\nNormalization•Database normalization: Process of structuring a database to reduce data redundancy and improve data integrity•In accordance with a series of normal forms (next topic)•Through the process:•One can decompose relations to suppress data anomalies•One can make sure the decomposition is lossless"
        },
        {
          "chapter_title": "데이터베이스 정규화 과정 및 일반 형식",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "데이터베이스 정규화가 관계형 데이터베이스 테이블을 더 높은 정규형으로 설계하는 과정임을 설명하고, 논리적으로 독립적인 데이터를 분리하여 키를 통해 연결하는 점진적인 프로세스를 소개합니다. 또한, UNF, 1NF, 2NF, 3NF, BCNF, 4NF 등 주요 정규형의 종류를 나열하고, 이들이 함수적 종속성 등의 이론적 기반을 가진다는 점을 강조합니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems11\nNormal Forms•Normalization process•Normalization is a database design technique, which is used to design a relational database table up to higher normal form•Procedurally separates logically independent (but related) data entities into multiple relations•Maintains the connections using keys•Progressive process•A higher level of database normalization cannot be achieved unless the previous levels have been satisfied•UNF: Unnormalized form•1NF: First normal form•2NF: Second normal form•3NF: Third normal form•BCNF: Boyce-Codd normal form (3.5NF)•4NF: Fourth normal form•…\nECE30030/ITP30010 Database Systems12\nNormal Forms•Normal forms are backed by a set of normalization theories•Functional dependencies•Partial dependencies•Transitive dependencies•Multi-valued dependencies•These theories decide whether a particular relation R is in “good form”•For a relation R is not in “good form”, decompose it into a set of relations {R1, R2, ..., Rn} such that•Each relation is in good form•The decomposition is a lossless decomposition"
        },
        {
          "chapter_title": "함수적 종속성 이해",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "함수적 종속성(Functional Dependency, FD)의 개념을 정의하고, 실제 데이터 제약 조건과의 연관성을 설명합니다. 릴레이션 스키마에서 속성 집합 간의 결정 관계를 예시를 통해 보여주며, 슈퍼 키와 후보 키와의 관계, 그리고 항상 만족되는 자명한 함수적 종속성(Trivial Functional Dependencies)에 대해 다룹니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems15\nFunctional Dependencies•There are usually a variety of constraints (rules) on the data in the real world•E.g., some of the constraints that are expected to hold in the university database are:•Students and instructors are uniquely identified by their ID•Each student and instructor has only one name•Each instructor and student is associated with only one department•Each department has only one value for its budget, and only one associated building•Relations require that the value for a certain set of attributes determines uniquely the value for another set of attributes•A functional dependency is a generalization of the notion of a key(= trivial dependency)\nECE30030/ITP30010 Database Systems16\nFunctional Dependencies•Let R be a relation schema, a and b be its attributes (a Í R and b Í R)•The functional dependency a ® b  holds on R if and only if, for any relations r(R), whenever any two tuples t1 and t2 of r agree on the attributes a, they also agree on the attributes b•That is,  t1[a] = t2 [a]    Þ    t1[b ] = t2 [b ]•E.g., Consider r(A,B) with the following instance of r\nA     B  1     4  1     5  3     7\n•On this instance, B ® A hold;  A ® B does NOT hold (only the values of B are unique)\nECE30030/ITP30010 Database Systems17\nKeys and Functional Dependencies•Functional dependencies allow us to express constraints that cannot be expressed using super keys•E.g., consider the schema:\nin_dep (ID, name, salary, dept_name, building, budget )•ID = instructor ID•dept_name = department of the instructor•We expect the following functional dependencies to hold:•dept_name ® building•ID ® buildingÞdept_name and ID are super keys = candidate keys* ID, dept_name, {ID, dept_name}•We would not expect the next to hold:•dept_name ® salary\nECE30030/ITP30010 Database Systems18\nFunctional Dependencies•For relation R = a1 a2 a3 a4\n•a1 is a part of the key•Functional dependency: a4 depends on its key, a1a2a3•b_id,  b_name, bd_detail_attrib1, , bd_detail_attrib2•Candidate keys: b_id, b_name, {b_id, b_name}•It should not be such that a4 depends on a1, and does not depend on a1a2a3 (a1 ➝ a4)  ⇒  partial dependency\nECE30030/ITP30010 Database Systems19\nCandidate key = a1, a2, a3, {a1, a2}, {a2,a3}, {a1, a3}, {a1,a2,a3}\nTrivial Functional Dependencies•A functional dependency is trivial if it is satisfied by all instances of a relation•Example:•ID, name ® ID•name ® name•In general, a ® b is trivial if b Í a\nECE30030/ITP30010 Database Systems20\nFunctional Dependencies•Example: student2(ID, name, tot_cred)•Hold•ID à name•ID à tot_cred•Not hold•tot_cred à name•name à tot_cred\nECE30030/ITP30010 Database Systems21\nFunctional Dependencies•score(score_id, student_id, subject_id, score)•{student_id, subject_id} à score\nECE30030/ITP30010 Database Systems22\nECE30030/ITP30010 Database Systems22\nECE30030/ITP30010 Database Systems67\nFunctional Dependencies•There are usually a variety of constraints (rules) on the data in the real world•E.g., some of the constraints that are expected to hold in a university database are:•Students and instructors are uniquely identified by their ID•Each student and instructor has only one name•Each instructor and student is (primarily) associated with only one department•Each department has only one value for its budget, and only one associated building•Relations require that the value for a certain set of attributes determines uniquely the value for another set of attributes•A functional dependency is a generalization of the notion of a key(= trivial dependency)\nECE30030/ITP30010 Database Systems68\nFunctional Dependencies•Let R be a relation schema, a and b be its attributes (a Í R and b Í R)•The functional dependency a ® b  holds on R if and only if, for any relations r(R), whenever any two tuples t1 and t2 of r agree on the attributes a, they also agree on the attributes b•That is,  t1[a] = t2 [a]    Þ    t1[b ] = t2 [b ]•E.g., Consider r(A,B) with the following instance of r\nA     B  1     4  1     5  3     7\n•On this instance, B ® A hold;  A ® B does NOT hold (only the values of B are unique)\nECE30030/ITP30010 Database Systems69\nKeys and Functional Dependencies•Functional dependencies allow us to express constraints that cannot be expressed using super keys•E.g., consider the schema:\nin_dep (ID, name, salary, dept_name, building, budget )•ID = instructor ID•dept_name = department of the instructor•We expect the following functional dependencies to hold:•dept_name® building•ID à buildingÞdept_name and ID are super keys = candidate keys* ID, dept_name, {ID, dept_name}•We would not expect the next to hold:•dept_name ® salary\nECE30030/ITP30010 Database Systems70\nFunctional Dependencies•For relation R = a1 a2 a3 a4\n•a1 is a part of the key•Functional dependency: a4 depends on its key, a1a2a3•b_id,  b_name, bd_detail_attrib1, , bd_detail_attrib2•Candidate keys: b_id, b_name, {b_id, b_name}•It should not be such that a4 depends on a1, and does not depend on a1a2a3 (a1 ➝ a4)  ⇒  partial dependency\nECE30030/ITP30010 Database Systems71\nCandidate key = a1, a2, a3, {a1, a2}, {a2,a3}, {a1, a3}, {a1,a2,a3}\nTrivial Functional Dependencies•A functional dependency is trivial if it is satisfied by all instances of a relation•Example:•ID, name ® ID•name ® name•In general, a ® b is trivial if b Í a\nECE30030/ITP30010 Database Systems72\nFunctional Dependencies•student2(ID, name, tot_cred)•ID à name•ID à tot_cred•tot_cred à name (X)\nECE30030/ITP30010 Database Systems73\nFunctional Dependencies•SCORE(score_id, student_id, subject_id, score)•{student_id, subject_id} à score"
        },
        {
          "chapter_title": "제1 정규형 (1NF): 원자성 및 고유성",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "제1 정규형(1NF)의 요구사항을 설명하며, 모든 속성 값이 원자적이어야 하고, 각 컬럼은 동일한 데이터 도메인 내의 값을 포함하며, 고유한 이름을 가져야 한다는 점을 강조합니다. 중복된 행이 없어야 하며, 기본 키(PK)가 고유성과 Not Null을 보장하는 역할을 설명하고, 실제 예시를 통해 1NF로의 변환 과정을 보여줍니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems13\nFirst Normal Form (1NF)•Requirements•A relation should consist of atomic values•Atomic value: a value that cannot be divided (≃primitive data types in JAVA)•Atomic - INT, FLOAT, DOUBLE, DECIMAL (NUMERIC), CHAR, VARCHAR, BLOB, TEXT•NOGO - Structure, List (array)•Attributes should have unique identifiers•Step 1 of the normalization process•“If the tables in your DB does not follow 1NF, stop using database”\nECE30030/ITP30010 Database Systems14\nFirst Normal Form (1NF)•1NF checklist1.Each column should contain an atomic value•Entries like (x, y) violate this rule2.Each column should contain values that are in the same data domain•Do not mix different types of values in a column3.Each column should have a unique name•Duplicate names lead to confusion while accessing data4.The order in which data is stored does not matter•Using SQL, one can easily fetch data in any order5.There are no duplicated rows in the table•Primary key (PK) ensures: •Attributes that are part of PK are unique•Attributes that are part of PK are not null\nECE30030/ITP30010 Database Systems23\nFirst Normal Form (1NF)•Example\nstudent_idnamecourse\n21800999James InexistenteAlgorithm, OS\n21800998Mike InexistenteJava\n21800997Matt InexistenteAlgorithm, DB\nECE30030/ITP30010 Database Systems24\nFirst Normal Form (1NF)•Example\nstudent_idname\n21800999James Inexistente\n21800998Mike Inexistente\n21800997Matt Inexistente\nstudent_idcourse\n21800999Algorithm\n21800999OS\n21800998Java\n21800997Algorithm\n21800997DB\nECE30030/ITP30010 Database Systems25\nFirst Normal Form (1NF)•Example\nstudent_idname\n21800999James Inexistente\n21800998Mike Inexistente\n21800997Matt Inexistente\nstudent_idcourse\n21800999Algorithm\n21800999OS\n21800998Java\n21800997Algorithm\n21800997DB"
        },
        {
          "chapter_title": "제2 정규형 (2NF): 부분 종속성 제거",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "제2 정규형(2NF)의 요구사항을 설명하며, 1NF를 만족하고 기본 키가 아닌 속성이 후보 키의 어떤 부분 집합에도 함수적으로 종속되지 않아야 함을 강조합니다. 부분 종속성(Partial Dependency)의 정의와 이를 제거하기 위한 관계 분해(Decomposition) 과정을 다양한 예시를 통해 구체적으로 설명합니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems26\nSecond Normal Form (2NF)•Requirements•A relation should be in 1NF (normal forms should be applied in order)•A relation should NOT have a non-PK that is functionally dependent on any subset of any candidate key = NO PARTIAL DEPENDENCIES!•Any attributes other than PK should be dependent on PK•It should not have partial dependencies•PK: Primary Key•An attribute or a set of attributes that uniquely identifies each tuple in a relation•A PK can fetch data from any specific data in a relation•E.g., get the department name of student_ID = 21800999\nECE30030/ITP30010 Database Systems27\nPartial Dependencies•For relation R = a1 a2 a3 a4\n•a1 is a part of the primary key•Partial dependency: a4 depends on a1, and does not depend on a1a2a3•Key: a1 a2 a3•Dependency: a1 ➝ a4\nPrimary key (Composite)\nECE30030/ITP30010 Database Systems28\nEliminating Partial Dependencies•Example: teaches2(ID, course_id, sec_id, semester, year, name)•ID à name\nECE30030/ITP30010 Database Systems29\nEliminating Partial Dependencies•Example: •teaches2a(ID, course_id, sec_id, semester, year)•teaches2b(ID, name)\nECE30030/ITP30030Database Systems 30\nEliminating Partial Dependencies•Example: score(score_id, student_id, subject_id, score, instructor)•subject_id à instructor : partial dependency\nscore_idstudent_idsubject_idscoreinstructor\n1 10 1 82James Packer\n3 11 1 95James Packer\n2 10 2 77Cole Miller\n4 11 2 71Cole Miller\n5 11 4 96Adam Lee\nECE30030/ITP30030Database Systems 31\nEliminating Partial Dependencies•Example: score_a(score_id, student_id, subject_id, score)                 score_b(subject_id, instructor)\nscore_idstudent_idsubject_idscore\n1 10 1 82\n3 11 1 95\n2 10 2 77\n4 11 2 71\n5 11 4 96\nsubject_idinstructor\n1 James Packer\n2 Cole Miller\n4 Adam Lee\nECE30030/ITP30010 Database Systems74\nPartial Dependencies•For relation R = a1 a2 a3 a4\n•a1 is a part of the primary key•a4 depends on a1, and does not depend on a1a2a3 (a1 ➝ a4)•Key: a1 a2 a3•Dependency: a1 ➝ a4\nPrimary key (Composite)\nECE30030/ITP30010 Database Systems75\nPartial Dependencies•teaches2(ID, course_id, sec_id, semester, year, name)•ID à name•{course_id, sec_id, semester, year} à name\nECE30030/ITP30010 Database Systems76\nPartial Dependencies•SCORE(score_id, student_id, subject_id, score, instructor)•subject_id à instructor (partial dependency) :: WE DON’T WANT TO HAVE THIS"
        },
        {
          "chapter_title": "제3 정규형 (3NF): 이행적 종속성 제거",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "제3 정규형(3NF)의 요구사항을 설명하며, 2NF를 만족하고 이행적 종속성(Transitive Dependency)이 없어야 함을 강조합니다. 이행적 종속성은 기본 키가 아닌 속성이 다른 기본 키가 아닌 속성에 종속되는 경우를 의미하며, 이를 제거하기 위한 관계 분해 과정을 다양한 도서 및 시험 점수 관리 예시를 통해 상세히 제시합니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems32\nThird Normal Form (3NF)•Requirements•A relation should be in 2NF •A relation should NOT have transitive dependencies•Transitive dependency: A non-PK attribute depends on another non-PK attribute or a set of non-PK attributes\nECE30030/ITP30010 Database Systems33\nTransitive Dependencies•For relation R = a1 a2 a3 a4\n•a1 is the primary key in R•a3 depends on a1 (a1 ➝ a3) -- OK•a4 depends on a3 (a1 ➝ a3 ➝ a4) … non-PK à non-PK\nCandidate key = a1, a2, {a1,a2}\nECE30030/ITP30010 Database Systems34\nEliminating Transitive Dependencies•Example\nBookNoPatronAddressDue\nB1J. Fisher101 Main Street3/2/15\nB2L. Perez202 Market Street 2/28/15\nECE30030/ITP30010 Database Systems35\nEliminating Transitive Dependencies•Example\n•PK: BookNo•Patron à Address\nBookNoPatronAddressDue\nB1J. Fisher101 Main Street3/2/15\nB2L. Perez202 Market Street 2/28/15\nECE30030/ITP30010 Database Systems36\nEliminating Transitive Dependencies•Example\nBookNoPatronDue\nB1J. Fisher3/2/15\nB2L. Perez2/28/15PatronAddressJ. Fisher101 Main StreetL. Perez202 Market Street\nECE30030/ITP30010 Database Systems37\nEliminating Transitive Dependencies•Example\n•PK: {Tournament, Year}•Winner à DOB\nTournamentYearWinner DOB\nIndiana Invitational1998Al Fredrickson21 July 1975\nCleveland Open1999Bob Albertson28 Sept. 1968\nDes Moines Masters1999Al Fredrickson21 July 1975\nECE30030/ITP30010 Database Systems38\nEliminating Transitive Dependencies•Example: score2(id, student_id, subject_id, exam_name, exam_score)•{student_id, subject_id} --> FINAL or MIDTERM•{student_id, subject_id} --> 77   43 … from which ?•{student_id, subject_id} à exam_name à exam_score :: transitive dependency\nECE30030/ITP30010 Database Systems39\nEliminating Transitive Dependencies•Example: score2(id, student_id, subject_id, exam_name, exam_score)•student_id, subject_id à exam_name•student_id, subject_id à exam_name à exam_score\nECE30030/ITP30010 Database Systems40\nEliminating Transitive Dependencies•Example: score2a(id, student_id, subject_id, exam_id, exam_name)                 score2b(student_id, subject_id, exam_id, exam_score)\nECE30030/ITP30010 Database Systems77\nTransitive Dependencies•For relation R = a1 a2 a3 a4\n•a1 is the primary key in R•a3 depends on a1 (a1 ➝ a3) -- OK•a4 depends on a3 (a1 ➝ a3 ➝ a4) … non-PK à non-PK\nCandidate key = a1, a2, {a1,a2}\nECE30030/ITP30010 Database Systems78\nTransitive Dependencies•EXAM_SCORE(id, student_id, subject_id, exam_name, exam_score)•{student_id, subject_id} --> FINAL or MIDTERM•{student_id, subject_id} --> 77   43 … from which ?•{student_id, subject_id} à exam_name à exam_score :: transitive dependency"
        },
        {
          "chapter_title": "보이스-코드 정규형 (BCNF): 강화된 제3 정규형",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "보이스-코드 정규형(BCNF)은 제3 정규형을 강화한 형태로, A → B 종속성이 있을 때 A가 반드시 슈퍼 키여야 한다는 요구사항을 설명합니다. 즉, 기본 키가 아닌 속성이 기본 키의 일부를 결정하는 경우가 없어야 하며, 이를 위반하는 사례와 BCNF를 만족하도록 관계를 분해하는 과정을 예시를 통해 보여줍니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems41\nBoyce-Codd Normal Form (BCNF) = 3.5NF•Requirements•A relation should be in 3NF•For any dependency A à B, A should be a super key•For A à B, if A is non-PK, then it is NOT in BCNF\nECE30030/ITP30010 Database Systems42\nBoyce-Codd Normal Form (BCNF)•Example: takes2(student_id, subject, instructor)\n•(student, subject) à instructor•Instructor à subject•A non-PK identifies a member of PK: Not in BCNF\nstudent_idsubjectinstructor\n21800999C++ Dr. Cpp\n21800999Java Dr. Java\n21800998C++ Dr. C\n21800997PythonDr. Python\n21800996C++ Dr. Cpp\nECE30030/ITP30010 Database Systems43\nBoyce-Codd Normal Form (BCNF)•Example: takes2a(student_id, section_id),\ntakes2b(section_id, subject, instructor)\nstudent_idsection_id\n21800999101\n21800999103\n21800998102\n21800997104\n21800996101section_idsubjectinstructor\n101 C++ Dr. Cpp\n103 Java Dr. Java\n102 C++ Dr. C\n104 PythonDr. Python\nECE30030/ITP30010 Database Systems44\nBoyce-Codd Normal Form (BCNF)•Example: takes2a(student_id, section_id),\ntakes2b(section_id, subject, instructor)\nstudent_idsection_id\n21800999101\n21800999103\n21800998102\n21800997104\n21800996101section_idsubjectinstructor\n101 C++ Dr. Cpp\n103 Java Dr. Java\n102 C++ Dr. C\n104 PythonDr. Python"
        },
        {
          "chapter_title": "제4 정규형 (4NF): 다치 종속성 제거",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "제4 정규형(4NF)의 요구사항을 설명하며, BCNF를 만족하고 다치 종속성(Multi-valued Dependency, MVD)이 없어야 함을 강조합니다. 다치 종속성은 릴레이션에 3개 이상의 속성이 있고, 서로 독립적인 다치 속성 집합이 존재할 때 발생할 수 있으며, 이를 제거하기 위한 관계 분해 과정을 학생의 수강 과목 및 활동 예시를 통해 설명합니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems45\nFourth Normal Form (4NF)•Requirements•A relation should be in BCNF•A relation should NOT have multi-valued dependency•Multi-valued dependency occurs due to a bad DB schema•Multi-valued dependency occurs when a relation has more than 3 attributes•For a relation with attributes A, B, C•having dependency, A à B, and•B and C are independent from each otherè Then, the relation may have a multi-valued dependency\nECE30030/ITP30010 Database Systems46\nMulti-valued Dependencies•Example•student_id à course•student_id à activity•course ⊥ activity (independent)\nstudent_idcourseactivity\n21800999StatisticsSoccer\n21800999Linear algebraBasketball\n21800999StatisticsBasketball\n21800999Linear algebraSoccer\nECE30030/ITP30010 Database Systems47\nMulti-valued Dependencies•Example\nstudent_idcourse\n21800999Statistics\n21800999Linear algebra\n21800998Physics\n21800998Programming 101student_idactivity\n21800999Soccer\n21800999Basketball\n21800998Pool\n21800997Soccer\nECE30030/ITP40001 Database Systems79\nMulti-valued Dependencies (MVDs)•Suppose we record names of children, and phone numbers for instructors•inst_child(ID, child_name)•inst_phone(ID, phone_number)à If we combine these schemas to obtain: (multiple orthogonal values in single table à this causes redundancy)•inst_info(ID, child_name, phone_number)à Example tuples: ID=999999 à {David, William} & {x-x-1234, x-x-4321}  (99999, David, 512-555-1234)  (99999, David, 512-555-4321)  (99999, William, 512-555-1234)  (99999, William, 512-555-4321)•Any issues?\nECE30030/ITP40001 Database Systems80\nMulti-valued Dependencies (MVDs)•Let R be a relation schema and let a Í R and b Í R. •The multivalued dependency a ®® b holds on R if in any relation r(R), for all pairs for tuples t1 and t2 in r such that t1[a] = t2 [a], there exist tuples t3 and t4 in r such that:    t1[a] = t2 [a] = t3 [a] = t4 [a]           t3[b] =  t1 [b]           t3[R  – b] =  t2[R  – b]           t4 [b] =  t2[b]           t4[R  – b] =  t1[R  – b]\nECE30030/ITP40001 Database Systems81\nMulti-valued Dependencies (MVDs)•Let R be a relation schema with a set of attributes that are partitioned into 3 non-empty subsets Y, Z, W•We say that Y ®® Z (Y multidetermines Z )if and only if for all possible relations r(R)  < y1, z1, w1 > Î r and < y1, z2, w2 > Î rthen  < y1, z1, w2 > Î r and < y1, z2, w1 > Î r•Note that since the behavior of Z and W are identical it follows that Y ®® Z if Y ®® W\nECE30030/ITP40001 Database Systems82\nMulti-valued Dependencies (MVDs)•Tabular representation of a ®® b\nECE30030/ITP40001 Database Systems83\nMulti-valued Dependencies (MVDs)•FAV(student_id, course, activity)•21800999 - {statistics, Linear algebra} & {Soccer, basketball}•Favorite courses & favorite activities <= they are orthogonal\nstudent_idcourseactivity\n21800999StatisticsSoccer\n21800999Linear algebraBasketball\n21800999StatisticsBasketball\n21800999Linear algebraSoccer"
        },
        {
          "chapter_title": "정규화 이론 및 종속성 요약",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "각 정규형(2NF, 3NF, BCNF, 4NF, 5NF)과 관련된 핵심 이론 및 종속성(함수적, 부분, 이행적, 다치, 조인 종속성)을 요약하여 제시합니다. 정규화 이론이 '좋은 형태'의 릴레이션을 결정하고 무손실 분해를 통해 이를 달성하는 데 사용됨을 강조하며, 함수적 종속성과 다치 종속성이 데이터베이스의 유효성 검사 및 제약 조건 지정에 어떻게 활용되는지 설명합니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems48\nSummary: Normal Forms•Theories – Normal forms\nTheory Key IdeaNormal Form\nFunctional dependency(PK à non-PK)2NF\nPartial dependencyPart of PK à non-PK2NF\nTransitive dependencyNon-PK à non-PK3NF\n- Non-PK à PK BCNF\nMulti-valued dependency4NF\nJoin dependency5NF\nECE30030/ITP30010 Database Systems65\nNormalization Theory•Decide whether a particular relation R is in “good form”•For a relation R is not in “good form”, decompose it into a set of relations {R1, R2, ..., Rn} such that•Each relation is in good form•The decomposition is a lossless decomposition\nECE30030/ITP30010 Database Systems66\nNormalization Theory•The normalization is based on a set of relevant theories:•Functional dependencies•Partial dependencies•Transitive dependencies•Multivalued dependencies\nECE30030/ITP40001 Database Systems84\nUse of Functional Dependencies•We use functional dependencies to:•Test relations to see if they are legal under a given set of functional dependencies•We say that r satisfies F, if a relation r is legal under a set F of functional dependencies•To specify constraints on the set of legal relations•We say that F holds on R if all legal relations on R satisfy the set of functional dependencies F•Note:  A specific instance of a relation schema may satisfy a functional dependency even if the functional dependency does not hold on all legal instances•E.g., a specific instance of instructor may, by chance, satisfy:  name ® ID\nECE30030/ITP40001 Database Systems85\nUse of Multi\n-\nvalued Dependencies•We use multivalued dependencies in two ways:1.To test relations to determine whether they are legal under a given set of functional and multivalued dependencies2.To specify constraints on the set of legal relations. We shall concern ourselves only with relations that satisfy a given set of functional and multivalued dependencies•If a relation r fails to satisfy a given multivalued dependency, we can construct a relations r¢  that does satisfy the multivalued dependency by adding tuples to r"
        },
        {
          "chapter_title": "정규화 실전 예시",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "위키피디아에서 가져온 서적 소매업 데이터베이스 예시를 통해 데이터베이스 정규화 과정을 단계별로 상세히 설명합니다. 1NF, 2NF, 3NF, BCNF, 그리고 4NF를 만족하도록 테이블을 분해하고 종속성을 제거하는 실제 적용 사례를 보여주며, 각 정규형의 요구사항이 어떻게 충족되는지 시각적으로 제시합니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems53\nExample (taken from Wikipedia)•Provided:\nECE30030/ITP30010 Database Systems54\nExample (taken from Wikipedia)•Satisfying 1NF\nECE30030/ITP30010 Database Systems55\nExample (taken from Wikipedia)•Satisfying 1NF (cont’d – further improvement)\nECE30030/ITP30010 Database Systems56\nExample (taken from Wikipedia)•Provided:\n•Compound key {Title, Format}•Partial dependency: Title à Author, Author Nationality, Pages, Thickness, Genre ID, Genre Name, Publisher ID\nECE30030/ITP30010 Database Systems57\nExample (taken from Wikipedia)•Satisfying 2NF\nECE30030/ITP30010 Database Systems58\nExample (taken from Wikipedia)•Satisfying 3NF\n•Transitive dependency: Genre ID à Genre Name\nECE30030/ITP30010 Database Systems59\nExample (taken from Wikipedia)•Satisfying 3NF\nECE30030/ITP30010 Database Systems60\nExample (taken from Wikipedia)•Satisfying BCNF\n•Non-PK à Non-PK: Author à Author Nationality\nECE30030/ITP30010 Database Systems61\nExample (taken from Wikipedia)•Satisfying BCNF\nECE30030/ITP30010 Database Systems62\nExample (taken from Wikipedia)•Provided:•Assume the database is owned by a book retailer franchise that has several franchisees that own shops in different locations\nECE30030/ITP30010 Database Systems63\nExample (taken from Wikipedia)•Satisfying 4NF•If we assume that all available books are offered in each area, the Title is not unambiguously bound to a certain Locationà Does not satisfy 4NF\nECE30030/ITP30030Database Systems 64\n•Source: https://en.wikipedia.org/wiki/Database_normalization"
        },
        {
          "chapter_title": "데이터베이스 설계 과정 및 비정규화",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "데이터베이스 설계 과정에서 정규화가 어떻게 통합되는지 설명합니다. E-R 모델 설계의 중요성과 정규화의 관계를 다루고, 성능 향상을 위해 의도적으로 정규화되지 않은 스키마를 사용하는 비정규화(Denormalization)의 개념과 그 장단점을 제시합니다. 또한, 연도별 수익 데이터와 같은 특정 설계 문제가 정규화만으로는 해결되지 않을 수 있음을 지적하며 더 나은 스키마 설계를 제안합니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems49\nOverall DB Design Process•Let us assume schema R is given:(E-R Model)•R could have been generated when converting E-R diagram to a set of tables(Normalization)•R could have been a single relation containing all attributes that are of interest (called universal relation)•Normalization breaks R into smaller relations(Mixed)•R could have been the result of some ad-hoc design of relations, which we then test/convert to normal form\nECE30030/ITP30010 Database Systems50\nE-R Model and Normalization•When an E-R diagram is carefully designed, identifying all entities correctly, the tables generated from the E-R diagram should not need further normalization•However, in a real (imperfect) design, there can be functional dependencies from non-key attributes of an entity to other attributes of the entity•E.g., an employee entity with•attributesdepartment_name and building•functional dependencydepartment_name® building•Good design would have made department an entity•Functional dependencies from non-key attributes of a relationship set possible, but rare --- most relationships are binary\nECE30030/ITP30010 Database Systems51\nDenormalization for Performance•We may want to use non-normalized schema for performance•For example, displaying prereqs along with course_id, and title requires join of course with prereq•Alternative 1: Use denormalized relation containing attributes of course as well as prereq with all above attributes•faster lookup•extra space and extra execution time for updates•extra coding work for programmer and possibility of error in extra code•Alternative 2: Use a materialized view defined a course ⋈ prereq•Benefits and drawbacks same as above, except no extra coding work for programmer and avoids possible errors\nECE30030/ITP30010 Database Systems52\nRemaining Issues•Some aspects of database design are not caught by normalization•Example (to be avoided)•earnings_2004, earnings_2005, earnings_2006, etc., all on the schema (company_id, earnings)•Above are well normalized (in BCNF), but make querying across years difficult and needs new table each year•company_year (company_id, earnings_2004, earnings_2005,  earnings_2006)•Above are well normalized (in BCNF), but makes querying across years difficult and requires new attribute each year•This is an example of a crosstab, where values for one attribute become column namesà Better schema: earnings (company_id, year, amount)"
        }
      ],
      "generated_content": [],
      "final_result": ""
    }
  },
  {
    "node": "start_processing",
    "status": "completed",
    "state_snapshot": {
      "run_id": "a9d3b848-7887-4676-a9e0-4d590ff0b031",
      "pdf_file_paths": [
        "temp_pdf_uploads/a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf"
      ],
      "notebook_title": "",
      "holistic_chapters": [],
      "generated_content": [],
      "final_result": ""
    }
  },
  {
    "node": "start_processing",
    "status": "completed",
    "state_snapshot": {
      "run_id": "a9d3b848-7887-4676-a9e0-4d590ff0b031",
      "pdf_file_paths": [
        "temp_pdf_uploads/a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf"
      ],
      "notebook_title": "",
      "holistic_chapters": [],
      "generated_content": [],
      "final_result": ""
    }
  },
  {
    "node": "analyze_overall_structure",
    "status": "completed",
    "state_snapshot": {
      "run_id": "a9d3b848-7887-4676-a9e0-4d590ff0b031",
      "pdf_file_paths": [
        "temp_pdf_uploads/a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf"
      ],
      "notebook_title": "데이터베이스 정규화: 원리, 과정 및 적용",
      "holistic_chapters": [
        {
          "chapter_title": "데이터베이스 정규화 개요 및 필요성",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "데이터가 혼합될 때 발생하는 문제점(데이터 중복, 일관성 문제, 삽입/삭제/갱신 이상 현상)을 설명하고, 이러한 문제에 대한 해결책으로 데이터베이스 정규화의 필요성과 분해(Decomposition)의 개념, 그리고 손실 분해(Lossy Decomposition)와 무손실 분해(Lossless Decomposition)의 차이를 소개합니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems2\nWhen Data is Jumbled…•Suppose that we combine instructor and department •(Below represents the join on instructor and department)\nECE30030/ITP30010 Database Systems3\nWhen Data is Jumbled…•Key issues•Repetition of data à increases the size of database•Data consistency issues•Insertion anomaly: Inserting redundant data for every new record•Deletion anomaly: Loss of related data, when some data is deleted•Update anomaly: When updating certain information, every single record must be updated\nECE30030/ITP30010 Database Systems4\nSolution: Decomposition!•How to avoid the repetition-of-information problem?\n•A: Decompose it into two schemas (as they were)•Normalization = decomposition of relational schemas•Key idea: split relational schemas such that only directly related data composes a relation\nECE30030/ITP30010 Database Systems5\nDecomposition•Less redundancy à Uses smaller disk storage; Causes less issues associated with insertion, deletion, and update anomalies•Not all decompositions are good•E.g., Suppose we decompose   employee(ID, name, street, city, salary)into  employee1 (ID, name)  employee2 (name, street, city, salary)à Problem: What if there are two employees with the same name?•Lossy decomposition: a decomposition from which the original relation cannot be reconstructedECE30030/ITP30010 Database Systems6\nLossy Decomposition\nECE30030/ITP30010 Database Systems7\nLossless Decomposition•Let R be a relation schema and let R1 and R2 form a decomposition of R; that is, R = R1 U R2•A decomposition is a lossless decomposition if there is no loss of information by replacing R with the two relation schemas R1 U R2•Formally,\nÕR1(r)  ⋈  ÕR2(r) = r•C.f., Conversely, a decomposition is lossy if when the join of the projection results is computed, a proper superset of the original relation is returned     r  Ì  ÕR1(r)  ⋈  ÕR2(r)\nECE30030/ITP30010 Database Systems8\nExample: Lossless Decomposition•Decomposition of R = (A, B, C)  à  R1 = (A, B); R2 = (B, C)\nECE30030/ITP30010 Database Systems9\nNormalization•Database normalization: Process of structuring a database to reduce data redundancy and improve data integrity•In accordance with a series of normal forms (next topic)•Through the process:•One can decompose relations to suppress data anomalies•One can make sure the decomposition is lossless"
        },
        {
          "chapter_title": "데이터베이스 정규화 과정 및 일반 형식",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "데이터베이스 정규화가 관계형 데이터베이스 테이블을 더 높은 정규형으로 설계하는 과정임을 설명하고, 논리적으로 독립적인 데이터를 분리하여 키를 통해 연결하는 점진적인 프로세스를 소개합니다. 또한, UNF, 1NF, 2NF, 3NF, BCNF, 4NF 등 주요 정규형의 종류를 나열하고, 이들이 함수적 종속성 등의 이론적 기반을 가진다는 점을 강조합니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems11\nNormal Forms•Normalization process•Normalization is a database design technique, which is used to design a relational database table up to higher normal form•Procedurally separates logically independent (but related) data entities into multiple relations•Maintains the connections using keys•Progressive process•A higher level of database normalization cannot be achieved unless the previous levels have been satisfied•UNF: Unnormalized form•1NF: First normal form•2NF: Second normal form•3NF: Third normal form•BCNF: Boyce-Codd normal form (3.5NF)•4NF: Fourth normal form•…\nECE30030/ITP30010 Database Systems12\nNormal Forms•Normal forms are backed by a set of normalization theories•Functional dependencies•Partial dependencies•Transitive dependencies•Multi-valued dependencies•These theories decide whether a particular relation R is in “good form”•For a relation R is not in “good form”, decompose it into a set of relations {R1, R2, ..., Rn} such that•Each relation is in good form•The decomposition is a lossless decomposition"
        },
        {
          "chapter_title": "함수적 종속성 이해",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "함수적 종속성(Functional Dependency, FD)의 개념을 정의하고, 실제 데이터 제약 조건과의 연관성을 설명합니다. 릴레이션 스키마에서 속성 집합 간의 결정 관계를 예시를 통해 보여주며, 슈퍼 키와 후보 키와의 관계, 그리고 항상 만족되는 자명한 함수적 종속성(Trivial Functional Dependencies)에 대해 다룹니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems15\nFunctional Dependencies•There are usually a variety of constraints (rules) on the data in the real world•E.g., some of the constraints that are expected to hold in the university database are:•Students and instructors are uniquely identified by their ID•Each student and instructor has only one name•Each instructor and student is associated with only one department•Each department has only one value for its budget, and only one associated building•Relations require that the value for a certain set of attributes determines uniquely the value for another set of attributes•A functional dependency is a generalization of the notion of a key(= trivial dependency)\nECE30030/ITP30010 Database Systems16\nFunctional Dependencies•Let R be a relation schema, a and b be its attributes (a Í R and b Í R)•The functional dependency a ® b  holds on R if and only if, for any relations r(R), whenever any two tuples t1 and t2 of r agree on the attributes a, they also agree on the attributes b•That is,  t1[a] = t2 [a]    Þ    t1[b ] = t2 [b ]•E.g., Consider r(A,B) with the following instance of r\nA     B  1     4  1     5  3     7\n•On this instance, B ® A hold;  A ® B does NOT hold (only the values of B are unique)\nECE30030/ITP30010 Database Systems17\nKeys and Functional Dependencies•Functional dependencies allow us to express constraints that cannot be expressed using super keys•E.g., consider the schema:\nin_dep (ID, name, salary, dept_name, building, budget )•ID = instructor ID•dept_name = department of the instructor•We expect the following functional dependencies to hold:•dept_name ® building•ID ® buildingÞdept_name and ID are super keys = candidate keys* ID, dept_name, {ID, dept_name}•We would not expect the next to hold:•dept_name ® salary\nECE30030/ITP30010 Database Systems18\nFunctional Dependencies•For relation R = a1 a2 a3 a4\n•a1 is a part of the key•Functional dependency: a4 depends on its key, a1a2a3•b_id,  b_name, bd_detail_attrib1, , bd_detail_attrib2•Candidate keys: b_id, b_name, {b_id, b_name}•It should not be such that a4 depends on a1, and does not depend on a1a2a3 (a1 ➝ a4)  ⇒  partial dependency\nECE30030/ITP30010 Database Systems19\nCandidate key = a1, a2, a3, {a1, a2}, {a2,a3}, {a1, a3}, {a1,a2,a3}\nTrivial Functional Dependencies•A functional dependency is trivial if it is satisfied by all instances of a relation•Example:•ID, name ® ID•name ® name•In general, a ® b is trivial if b Í a\nECE30030/ITP30010 Database Systems20\nFunctional Dependencies•Example: student2(ID, name, tot_cred)•Hold•ID à name•ID à tot_cred•Not hold•tot_cred à name•name à tot_cred\nECE30030/ITP30010 Database Systems21\nFunctional Dependencies•score(score_id, student_id, subject_id, score)•{student_id, subject_id} à score\nECE30030/ITP30010 Database Systems22\nECE30030/ITP30010 Database Systems22\nECE30030/ITP30010 Database Systems67\nFunctional Dependencies•There are usually a variety of constraints (rules) on the data in the real world•E.g., some of the constraints that are expected to hold in a university database are:•Students and instructors are uniquely identified by their ID•Each student and instructor has only one name•Each instructor and student is (primarily) associated with only one department•Each department has only one value for its budget, and only one associated building•Relations require that the value for a certain set of attributes determines uniquely the value for another set of attributes•A functional dependency is a generalization of the notion of a key(= trivial dependency)\nECE30030/ITP30010 Database Systems68\nFunctional Dependencies•Let R be a relation schema, a and b be its attributes (a Í R and b Í R)•The functional dependency a ® b  holds on R if and only if, for any relations r(R), whenever any two tuples t1 and t2 of r agree on the attributes a, they also agree on the attributes b•That is,  t1[a] = t2 [a]    Þ    t1[b ] = t2 [b ]•E.g., Consider r(A,B) with the following instance of r\nA     B  1     4  1     5  3     7\n•On this instance, B ® A hold;  A ® B does NOT hold (only the values of B are unique)\nECE30030/ITP30010 Database Systems69\nKeys and Functional Dependencies•Functional dependencies allow us to express constraints that cannot be expressed using super keys•E.g., consider the schema:\nin_dep (ID, name, salary, dept_name, building, budget )•ID = instructor ID•dept_name = department of the instructor•We expect the following functional dependencies to hold:•dept_name® building•ID à buildingÞdept_name and ID are super keys = candidate keys* ID, dept_name, {ID, dept_name}•We would not expect the next to hold:•dept_name ® salary\nECE30030/ITP30010 Database Systems70\nFunctional Dependencies•For relation R = a1 a2 a3 a4\n•a1 is a part of the key•Functional dependency: a4 depends on its key, a1a2a3•b_id,  b_name, bd_detail_attrib1, , bd_detail_attrib2•Candidate keys: b_id, b_name, {b_id, b_name}•It should not be such that a4 depends on a1, and does not depend on a1a2a3 (a1 ➝ a4)  ⇒  partial dependency\nECE30030/ITP30010 Database Systems71\nCandidate key = a1, a2, a3, {a1, a2}, {a2,a3}, {a1, a3}, {a1,a2,a3}\nTrivial Functional Dependencies•A functional dependency is trivial if it is satisfied by all instances of a relation•Example:•ID, name ® ID•name ® name•In general, a ® b is trivial if b Í a\nECE30030/ITP30010 Database Systems72\nFunctional Dependencies•student2(ID, name, tot_cred)•ID à name•ID à tot_cred•tot_cred à name (X)\nECE30030/ITP30010 Database Systems73\nFunctional Dependencies•SCORE(score_id, student_id, subject_id, score)•{student_id, subject_id} à score"
        },
        {
          "chapter_title": "제1 정규형 (1NF): 원자성 및 고유성",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "제1 정규형(1NF)의 요구사항을 설명하며, 모든 속성 값이 원자적이어야 하고, 각 컬럼은 동일한 데이터 도메인 내의 값을 포함하며, 고유한 이름을 가져야 한다는 점을 강조합니다. 중복된 행이 없어야 하며, 기본 키(PK)가 고유성과 Not Null을 보장하는 역할을 설명하고, 실제 예시를 통해 1NF로의 변환 과정을 보여줍니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems13\nFirst Normal Form (1NF)•Requirements•A relation should consist of atomic values•Atomic value: a value that cannot be divided (≃primitive data types in JAVA)•Atomic - INT, FLOAT, DOUBLE, DECIMAL (NUMERIC), CHAR, VARCHAR, BLOB, TEXT•NOGO - Structure, List (array)•Attributes should have unique identifiers•Step 1 of the normalization process•“If the tables in your DB does not follow 1NF, stop using database”\nECE30030/ITP30010 Database Systems14\nFirst Normal Form (1NF)•1NF checklist1.Each column should contain an atomic value•Entries like (x, y) violate this rule2.Each column should contain values that are in the same data domain•Do not mix different types of values in a column3.Each column should have a unique name•Duplicate names lead to confusion while accessing data4.The order in which data is stored does not matter•Using SQL, one can easily fetch data in any order5.There are no duplicated rows in the table•Primary key (PK) ensures: •Attributes that are part of PK are unique•Attributes that are part of PK are not null\nECE30030/ITP30010 Database Systems23\nFirst Normal Form (1NF)•Example\nstudent_idnamecourse\n21800999James InexistenteAlgorithm, OS\n21800998Mike InexistenteJava\n21800997Matt InexistenteAlgorithm, DB\nECE30030/ITP30010 Database Systems24\nFirst Normal Form (1NF)•Example\nstudent_idname\n21800999James Inexistente\n21800998Mike Inexistente\n21800997Matt Inexistente\nstudent_idcourse\n21800999Algorithm\n21800999OS\n21800998Java\n21800997Algorithm\n21800997DB\nECE30030/ITP30010 Database Systems25\nFirst Normal Form (1NF)•Example\nstudent_idname\n21800999James Inexistente\n21800998Mike Inexistente\n21800997Matt Inexistente\nstudent_idcourse\n21800999Algorithm\n21800999OS\n21800998Java\n21800997Algorithm\n21800997DB"
        },
        {
          "chapter_title": "제2 정규형 (2NF): 부분 종속성 제거",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "제2 정규형(2NF)의 요구사항을 설명하며, 1NF를 만족하고 기본 키가 아닌 속성이 후보 키의 어떤 부분 집합에도 함수적으로 종속되지 않아야 함을 강조합니다. 부분 종속성(Partial Dependency)의 정의와 이를 제거하기 위한 관계 분해(Decomposition) 과정을 다양한 예시를 통해 구체적으로 설명합니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems26\nSecond Normal Form (2NF)•Requirements•A relation should be in 1NF (normal forms should be applied in order)•A relation should NOT have a non-PK that is functionally dependent on any subset of any candidate key = NO PARTIAL DEPENDENCIES!•Any attributes other than PK should be dependent on PK•It should not have partial dependencies•PK: Primary Key•An attribute or a set of attributes that uniquely identifies each tuple in a relation•A PK can fetch data from any specific data in a relation•E.g., get the department name of student_ID = 21800999\nECE30030/ITP30010 Database Systems27\nPartial Dependencies•For relation R = a1 a2 a3 a4\n•a1 is a part of the primary key•Partial dependency: a4 depends on a1, and does not depend on a1a2a3•Key: a1 a2 a3•Dependency: a1 ➝ a4\nPrimary key (Composite)\nECE30030/ITP30010 Database Systems28\nEliminating Partial Dependencies•Example: teaches2(ID, course_id, sec_id, semester, year, name)•ID à name\nECE30030/ITP30010 Database Systems29\nEliminating Partial Dependencies•Example: •teaches2a(ID, course_id, sec_id, semester, year)•teaches2b(ID, name)\nECE30030/ITP30030Database Systems 30\nEliminating Partial Dependencies•Example: score(score_id, student_id, subject_id, score, instructor)•subject_id à instructor : partial dependency\nscore_idstudent_idsubject_idscoreinstructor\n1 10 1 82James Packer\n3 11 1 95James Packer\n2 10 2 77Cole Miller\n4 11 2 71Cole Miller\n5 11 4 96Adam Lee\nECE30030/ITP30030Database Systems 31\nEliminating Partial Dependencies•Example: score_a(score_id, student_id, subject_id, score)                 score_b(subject_id, instructor)\nscore_idstudent_idsubject_idscore\n1 10 1 82\n3 11 1 95\n2 10 2 77\n4 11 2 71\n5 11 4 96\nsubject_idinstructor\n1 James Packer\n2 Cole Miller\n4 Adam Lee\nECE30030/ITP30010 Database Systems74\nPartial Dependencies•For relation R = a1 a2 a3 a4\n•a1 is a part of the primary key•a4 depends on a1, and does not depend on a1a2a3 (a1 ➝ a4)•Key: a1 a2 a3•Dependency: a1 ➝ a4\nPrimary key (Composite)\nECE30030/ITP30010 Database Systems75\nPartial Dependencies•teaches2(ID, course_id, sec_id, semester, year, name)•ID à name•{course_id, sec_id, semester, year} à name\nECE30030/ITP30010 Database Systems76\nPartial Dependencies•SCORE(score_id, student_id, subject_id, score, instructor)•subject_id à instructor (partial dependency) :: WE DON’T WANT TO HAVE THIS"
        },
        {
          "chapter_title": "제3 정규형 (3NF): 이행적 종속성 제거",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "제3 정규형(3NF)의 요구사항을 설명하며, 2NF를 만족하고 이행적 종속성(Transitive Dependency)이 없어야 함을 강조합니다. 이행적 종속성은 기본 키가 아닌 속성이 다른 기본 키가 아닌 속성에 종속되는 경우를 의미하며, 이를 제거하기 위한 관계 분해 과정을 다양한 도서 및 시험 점수 관리 예시를 통해 상세히 제시합니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems32\nThird Normal Form (3NF)•Requirements•A relation should be in 2NF •A relation should NOT have transitive dependencies•Transitive dependency: A non-PK attribute depends on another non-PK attribute or a set of non-PK attributes\nECE30030/ITP30010 Database Systems33\nTransitive Dependencies•For relation R = a1 a2 a3 a4\n•a1 is the primary key in R•a3 depends on a1 (a1 ➝ a3) -- OK•a4 depends on a3 (a1 ➝ a3 ➝ a4) … non-PK à non-PK\nCandidate key = a1, a2, {a1,a2}\nECE30030/ITP30010 Database Systems34\nEliminating Transitive Dependencies•Example\nBookNoPatronAddressDue\nB1J. Fisher101 Main Street3/2/15\nB2L. Perez202 Market Street 2/28/15\nECE30030/ITP30010 Database Systems35\nEliminating Transitive Dependencies•Example\n•PK: BookNo•Patron à Address\nBookNoPatronAddressDue\nB1J. Fisher101 Main Street3/2/15\nB2L. Perez202 Market Street 2/28/15\nECE30030/ITP30010 Database Systems36\nEliminating Transitive Dependencies•Example\nBookNoPatronDue\nB1J. Fisher3/2/15\nB2L. Perez2/28/15PatronAddressJ. Fisher101 Main StreetL. Perez202 Market Street\nECE30030/ITP30010 Database Systems37\nEliminating Transitive Dependencies•Example\n•PK: {Tournament, Year}•Winner à DOB\nTournamentYearWinner DOB\nIndiana Invitational1998Al Fredrickson21 July 1975\nCleveland Open1999Bob Albertson28 Sept. 1968\nDes Moines Masters1999Al Fredrickson21 July 1975\nECE30030/ITP30010 Database Systems38\nEliminating Transitive Dependencies•Example: score2(id, student_id, subject_id, exam_name, exam_score)•{student_id, subject_id} --> FINAL or MIDTERM•{student_id, subject_id} --> 77   43 … from which ?•{student_id, subject_id} à exam_name à exam_score :: transitive dependency\nECE30030/ITP30010 Database Systems39\nEliminating Transitive Dependencies•Example: score2(id, student_id, subject_id, exam_name, exam_score)•student_id, subject_id à exam_name•student_id, subject_id à exam_name à exam_score\nECE30030/ITP30010 Database Systems40\nEliminating Transitive Dependencies•Example: score2a(id, student_id, subject_id, exam_id, exam_name)                 score2b(student_id, subject_id, exam_id, exam_score)\nECE30030/ITP30010 Database Systems77\nTransitive Dependencies•For relation R = a1 a2 a3 a4\n•a1 is the primary key in R•a3 depends on a1 (a1 ➝ a3) -- OK•a4 depends on a3 (a1 ➝ a3 ➝ a4) … non-PK à non-PK\nCandidate key = a1, a2, {a1,a2}\nECE30030/ITP30010 Database Systems78\nTransitive Dependencies•EXAM_SCORE(id, student_id, subject_id, exam_name, exam_score)•{student_id, subject_id} --> FINAL or MIDTERM•{student_id, subject_id} --> 77   43 … from which ?•{student_id, subject_id} à exam_name à exam_score :: transitive dependency"
        },
        {
          "chapter_title": "보이스-코드 정규형 (BCNF): 강화된 제3 정규형",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "보이스-코드 정규형(BCNF)은 제3 정규형을 강화한 형태로, A → B 종속성이 있을 때 A가 반드시 슈퍼 키여야 한다는 요구사항을 설명합니다. 즉, 기본 키가 아닌 속성이 기본 키의 일부를 결정하는 경우가 없어야 하며, 이를 위반하는 사례와 BCNF를 만족하도록 관계를 분해하는 과정을 예시를 통해 보여줍니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems41\nBoyce-Codd Normal Form (BCNF) = 3.5NF•Requirements•A relation should be in 3NF•For any dependency A à B, A should be a super key•For A à B, if A is non-PK, then it is NOT in BCNF\nECE30030/ITP30010 Database Systems42\nBoyce-Codd Normal Form (BCNF)•Example: takes2(student_id, subject, instructor)\n•(student, subject) à instructor•Instructor à subject•A non-PK identifies a member of PK: Not in BCNF\nstudent_idsubjectinstructor\n21800999C++ Dr. Cpp\n21800999Java Dr. Java\n21800998C++ Dr. C\n21800997PythonDr. Python\n21800996C++ Dr. Cpp\nECE30030/ITP30010 Database Systems43\nBoyce-Codd Normal Form (BCNF)•Example: takes2a(student_id, section_id),\ntakes2b(section_id, subject, instructor)\nstudent_idsection_id\n21800999101\n21800999103\n21800998102\n21800997104\n21800996101section_idsubjectinstructor\n101 C++ Dr. Cpp\n103 Java Dr. Java\n102 C++ Dr. C\n104 PythonDr. Python\nECE30030/ITP30010 Database Systems44\nBoyce-Codd Normal Form (BCNF)•Example: takes2a(student_id, section_id),\ntakes2b(section_id, subject, instructor)\nstudent_idsection_id\n21800999101\n21800999103\n21800998102\n21800997104\n21800996101section_idsubjectinstructor\n101 C++ Dr. Cpp\n103 Java Dr. Java\n102 C++ Dr. C\n104 PythonDr. Python"
        },
        {
          "chapter_title": "제4 정규형 (4NF): 다치 종속성 제거",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "제4 정규형(4NF)의 요구사항을 설명하며, BCNF를 만족하고 다치 종속성(Multi-valued Dependency, MVD)이 없어야 함을 강조합니다. 다치 종속성은 릴레이션에 3개 이상의 속성이 있고, 서로 독립적인 다치 속성 집합이 존재할 때 발생할 수 있으며, 이를 제거하기 위한 관계 분해 과정을 학생의 수강 과목 및 활동 예시를 통해 설명합니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems45\nFourth Normal Form (4NF)•Requirements•A relation should be in BCNF•A relation should NOT have multi-valued dependency•Multi-valued dependency occurs due to a bad DB schema•Multi-valued dependency occurs when a relation has more than 3 attributes•For a relation with attributes A, B, C•having dependency, A à B, and•B and C are independent from each otherè Then, the relation may have a multi-valued dependency\nECE30030/ITP30010 Database Systems46\nMulti-valued Dependencies•Example•student_id à course•student_id à activity•course ⊥ activity (independent)\nstudent_idcourseactivity\n21800999StatisticsSoccer\n21800999Linear algebraBasketball\n21800999StatisticsBasketball\n21800999Linear algebraSoccer\nECE30030/ITP30010 Database Systems47\nMulti-valued Dependencies•Example\nstudent_idcourse\n21800999Statistics\n21800999Linear algebra\n21800998Physics\n21800998Programming 101student_idactivity\n21800999Soccer\n21800999Basketball\n21800998Pool\n21800997Soccer\nECE30030/ITP40001 Database Systems79\nMulti-valued Dependencies (MVDs)•Suppose we record names of children, and phone numbers for instructors•inst_child(ID, child_name)•inst_phone(ID, phone_number)à If we combine these schemas to obtain: (multiple orthogonal values in single table à this causes redundancy)•inst_info(ID, child_name, phone_number)à Example tuples: ID=999999 à {David, William} & {x-x-1234, x-x-4321}  (99999, David, 512-555-1234)  (99999, David, 512-555-4321)  (99999, William, 512-555-1234)  (99999, William, 512-555-4321)•Any issues?\nECE30030/ITP40001 Database Systems80\nMulti-valued Dependencies (MVDs)•Let R be a relation schema and let a Í R and b Í R. •The multivalued dependency a ®® b holds on R if in any relation r(R), for all pairs for tuples t1 and t2 in r such that t1[a] = t2 [a], there exist tuples t3 and t4 in r such that:    t1[a] = t2 [a] = t3 [a] = t4 [a]           t3[b] =  t1 [b]           t3[R  – b] =  t2[R  – b]           t4 [b] =  t2[b]           t4[R  – b] =  t1[R  – b]\nECE30030/ITP40001 Database Systems81\nMulti-valued Dependencies (MVDs)•Let R be a relation schema with a set of attributes that are partitioned into 3 non-empty subsets Y, Z, W•We say that Y ®® Z (Y multidetermines Z )if and only if for all possible relations r(R)  < y1, z1, w1 > Î r and < y1, z2, w2 > Î rthen  < y1, z1, w2 > Î r and < y1, z2, w1 > Î r•Note that since the behavior of Z and W are identical it follows that Y ®® Z if Y ®® W\nECE30030/ITP40001 Database Systems82\nMulti-valued Dependencies (MVDs)•Tabular representation of a ®® b\nECE30030/ITP40001 Database Systems83\nMulti-valued Dependencies (MVDs)•FAV(student_id, course, activity)•21800999 - {statistics, Linear algebra} & {Soccer, basketball}•Favorite courses & favorite activities <= they are orthogonal\nstudent_idcourseactivity\n21800999StatisticsSoccer\n21800999Linear algebraBasketball\n21800999StatisticsBasketball\n21800999Linear algebraSoccer"
        },
        {
          "chapter_title": "정규화 이론 및 종속성 요약",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "각 정규형(2NF, 3NF, BCNF, 4NF, 5NF)과 관련된 핵심 이론 및 종속성(함수적, 부분, 이행적, 다치, 조인 종속성)을 요약하여 제시합니다. 정규화 이론이 '좋은 형태'의 릴레이션을 결정하고 무손실 분해를 통해 이를 달성하는 데 사용됨을 강조하며, 함수적 종속성과 다치 종속성이 데이터베이스의 유효성 검사 및 제약 조건 지정에 어떻게 활용되는지 설명합니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems48\nSummary: Normal Forms•Theories – Normal forms\nTheory Key IdeaNormal Form\nFunctional dependency(PK à non-PK)2NF\nPartial dependencyPart of PK à non-PK2NF\nTransitive dependencyNon-PK à non-PK3NF\n- Non-PK à PK BCNF\nMulti-valued dependency4NF\nJoin dependency5NF\nECE30030/ITP30010 Database Systems65\nNormalization Theory•Decide whether a particular relation R is in “good form”•For a relation R is not in “good form”, decompose it into a set of relations {R1, R2, ..., Rn} such that•Each relation is in good form•The decomposition is a lossless decomposition\nECE30030/ITP30010 Database Systems66\nNormalization Theory•The normalization is based on a set of relevant theories:•Functional dependencies•Partial dependencies•Transitive dependencies•Multivalued dependencies\nECE30030/ITP40001 Database Systems84\nUse of Functional Dependencies•We use functional dependencies to:•Test relations to see if they are legal under a given set of functional dependencies•We say that r satisfies F, if a relation r is legal under a set F of functional dependencies•To specify constraints on the set of legal relations•We say that F holds on R if all legal relations on R satisfy the set of functional dependencies F•Note:  A specific instance of a relation schema may satisfy a functional dependency even if the functional dependency does not hold on all legal instances•E.g., a specific instance of instructor may, by chance, satisfy:  name ® ID\nECE30030/ITP40001 Database Systems85\nUse of Multi\n-\nvalued Dependencies•We use multivalued dependencies in two ways:1.To test relations to determine whether they are legal under a given set of functional and multivalued dependencies2.To specify constraints on the set of legal relations. We shall concern ourselves only with relations that satisfy a given set of functional and multivalued dependencies•If a relation r fails to satisfy a given multivalued dependency, we can construct a relations r¢  that does satisfy the multivalued dependency by adding tuples to r"
        },
        {
          "chapter_title": "정규화 실전 예시",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "위키피디아에서 가져온 서적 소매업 데이터베이스 예시를 통해 데이터베이스 정규화 과정을 단계별로 상세히 설명합니다. 1NF, 2NF, 3NF, BCNF, 그리고 4NF를 만족하도록 테이블을 분해하고 종속성을 제거하는 실제 적용 사례를 보여주며, 각 정규형의 요구사항이 어떻게 충족되는지 시각적으로 제시합니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems53\nExample (taken from Wikipedia)•Provided:\nECE30030/ITP30010 Database Systems54\nExample (taken from Wikipedia)•Satisfying 1NF\nECE30030/ITP30010 Database Systems55\nExample (taken from Wikipedia)•Satisfying 1NF (cont’d – further improvement)\nECE30030/ITP30010 Database Systems56\nExample (taken from Wikipedia)•Provided:\n•Compound key {Title, Format}•Partial dependency: Title à Author, Author Nationality, Pages, Thickness, Genre ID, Genre Name, Publisher ID\nECE30030/ITP30010 Database Systems57\nExample (taken from Wikipedia)•Satisfying 2NF\nECE30030/ITP30010 Database Systems58\nExample (taken from Wikipedia)•Satisfying 3NF\n•Transitive dependency: Genre ID à Genre Name\nECE30030/ITP30010 Database Systems59\nExample (taken from Wikipedia)•Satisfying 3NF\nECE30030/ITP30010 Database Systems60\nExample (taken from Wikipedia)•Satisfying BCNF\n•Non-PK à Non-PK: Author à Author Nationality\nECE30030/ITP30010 Database Systems61\nExample (taken from Wikipedia)•Satisfying BCNF\nECE30030/ITP30010 Database Systems62\nExample (taken from Wikipedia)•Provided:•Assume the database is owned by a book retailer franchise that has several franchisees that own shops in different locations\nECE30030/ITP30010 Database Systems63\nExample (taken from Wikipedia)•Satisfying 4NF•If we assume that all available books are offered in each area, the Title is not unambiguously bound to a certain Locationà Does not satisfy 4NF\nECE30030/ITP30030Database Systems 64\n•Source: https://en.wikipedia.org/wiki/Database_normalization"
        },
        {
          "chapter_title": "데이터베이스 설계 과정 및 비정규화",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "데이터베이스 설계 과정에서 정규화가 어떻게 통합되는지 설명합니다. E-R 모델 설계의 중요성과 정규화의 관계를 다루고, 성능 향상을 위해 의도적으로 정규화되지 않은 스키마를 사용하는 비정규화(Denormalization)의 개념과 그 장단점을 제시합니다. 또한, 연도별 수익 데이터와 같은 특정 설계 문제가 정규화만으로는 해결되지 않을 수 있음을 지적하며 더 나은 스키마 설계를 제안합니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems49\nOverall DB Design Process•Let us assume schema R is given:(E-R Model)•R could have been generated when converting E-R diagram to a set of tables(Normalization)•R could have been a single relation containing all attributes that are of interest (called universal relation)•Normalization breaks R into smaller relations(Mixed)•R could have been the result of some ad-hoc design of relations, which we then test/convert to normal form\nECE30030/ITP30010 Database Systems50\nE-R Model and Normalization•When an E-R diagram is carefully designed, identifying all entities correctly, the tables generated from the E-R diagram should not need further normalization•However, in a real (imperfect) design, there can be functional dependencies from non-key attributes of an entity to other attributes of the entity•E.g., an employee entity with•attributesdepartment_name and building•functional dependencydepartment_name® building•Good design would have made department an entity•Functional dependencies from non-key attributes of a relationship set possible, but rare --- most relationships are binary\nECE30030/ITP30010 Database Systems51\nDenormalization for Performance•We may want to use non-normalized schema for performance•For example, displaying prereqs along with course_id, and title requires join of course with prereq•Alternative 1: Use denormalized relation containing attributes of course as well as prereq with all above attributes•faster lookup•extra space and extra execution time for updates•extra coding work for programmer and possibility of error in extra code•Alternative 2: Use a materialized view defined a course ⋈ prereq•Benefits and drawbacks same as above, except no extra coding work for programmer and avoids possible errors\nECE30030/ITP30010 Database Systems52\nRemaining Issues•Some aspects of database design are not caught by normalization•Example (to be avoided)•earnings_2004, earnings_2005, earnings_2006, etc., all on the schema (company_id, earnings)•Above are well normalized (in BCNF), but make querying across years difficult and needs new table each year•company_year (company_id, earnings_2004, earnings_2005,  earnings_2006)•Above are well normalized (in BCNF), but makes querying across years difficult and requires new attribute each year•This is an example of a crosstab, where values for one attribute become column namesà Better schema: earnings (company_id, year, amount)"
        }
      ],
      "generated_content": [],
      "final_result": ""
    }
  },
  {
    "node": "generate_chapter_content",
    "status": "completed",
    "state_snapshot": {
      "run_id": "a9d3b848-7887-4676-a9e0-4d590ff0b031",
      "pdf_file_paths": [
        "temp_pdf_uploads/a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf"
      ],
      "all_pdf_texts": [
        {
          "filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "text": "ECE30030/ITP30010 Database SystemsNormalizationReading: Chapter 7\nCharmgil Hongcharmgil@handong.eduSpring, 2025Handong Global University\n1\nAgenda•Motivating example•Normal forms•Normalization example•Appendix: Normalization theory\nECE30030/ITP30010 Database Systems2\nWhen Data is Jumbled…•Suppose that we combine instructor and department •(Below represents the join on instructor and department)\nECE30030/ITP30010 Database Systems3\nWhen Data is Jumbled…•Key issues•Repetition of data à increases the size of database•Data consistency issues•Insertion anomaly: Inserting redundant data for every new record•Deletion anomaly: Loss of related data, when some data is deleted•Update anomaly: When updating certain information, every single record must be updated\nECE30030/ITP30010 Database Systems4\nSolution: Decomposition!•How to avoid the repetition-of-information problem?\n•A: Decompose it into two schemas (as they were)•Normalization = decomposition of relational schemas•Key idea: split relational schemas such that only directly related data composes a relation\nECE30030/ITP30010 Database Systems5\nDecomposition•Less redundancy à Uses smaller disk storage;  Causes less issues associated with insertion, deletion, and update anomalies•Not all decompositions are good•E.g., Suppose we decompose   employee(ID, name, street, city, salary)into  employee1 (ID, name)  employee2 (name, street, city, salary)à Problem: What if there are two employees with the same name?•Lossy decomposition: a decomposition from which the original relation cannot be reconstructedECE30030/ITP30010 Database Systems6\nLossy Decomposition\nECE30030/ITP30010 Database Systems7\nLossless Decomposition•Let R be a relation schema and let R1 and R2 form a decomposition of R; that is, R = R1 U R2•A decomposition is a lossless decomposition if there is no loss of information by replacing R with the two relation schemas R1 U R2•Formally,    ÕR1(r)  ⋈  ÕR2(r) = r•C.f., Conversely, a decomposition is lossy if when the join of the projection results is computed, a proper superset of the original relation is returned     r  Ì  ÕR1(r)  ⋈  ÕR2(r) \nECE30030/ITP30010 Database Systems8\nExample: Lossless Decomposition•Decomposition of R = (A, B, C)  à  R1 = (A, B); R2 = (B, C)\nECE30030/ITP30010 Database Systems9\nNormalization•Database normalization: Process of structuring a database to reduce data redundancy and improve data integrity•In accordance with a series of normal forms (next topic)•Through the process:•One can decompose relations to suppress data anomalies•One can make sure the decomposition is lossless\nECE30030/ITP30010 Database Systems10\nAgenda•Motivating example•Normal forms•Normalization example•Appendix: Normalization theory\nECE30030/ITP30010 Database Systems11\nNormal Forms•Normalization process•Normalization is a database design technique, which is used to design a relational database table up to higher normal form•Procedurally separates logically independent (but related) data entities into multiple relations•Maintains the connections using keys•Progressive process•A higher level of database normalization cannot be achieved unless the previous levels have been satisfied•UNF: Unnormalized form•1NF: First normal form•2NF: Second normal form•3NF: Third normal form•BCNF: Boyce-Codd normal form (3.5NF)•4NF: Fourth normal form•…\nECE30030/ITP30010 Database Systems12\nNormal Forms•Normal forms are backed by a set of normalization theories•Functional dependencies•Partial dependencies•Transitive dependencies•Multi-valued dependencies•These theories decide whether a particular relation R is in “good form”•For a relation R is not in “good form”, decompose it into a set of relations {R1, R2, ..., Rn} such that•Each relation is in good form•The decomposition is a lossless decomposition\nECE30030/ITP30010 Database Systems13\nFirst Normal Form (1NF)•Requirements•A relation should consist of atomic values•Atomic value: a value that cannot be divided (≃primitive data types in JAVA)•Atomic - INT, FLOAT, DOUBLE, DECIMAL (NUMERIC), CHAR, VARCHAR, BLOB, TEXT•NOGO - Structure, List (array)•Attributes should have unique identifiers•Step 1 of the normalization process•“If the tables in your DB does not follow 1NF, stop using database”\nECE30030/ITP30010 Database Systems14\nFirst Normal Form (1NF)•1NF checklist1.Each column should contain an atomic value•Entries like (x, y) violate this rule2.Each column should contain values that are in the same data domain•Do not mix different types of values in a column3.Each column should have a unique name•Duplicate names lead to confusion while accessing data4.The order in which data is stored does not matter•Using SQL, one can easily fetch data in any order5.There are no duplicated rows in the table•Primary key (PK) ensures: •Attributes that are part of PK are unique•Attributes that are part of PK are not null\nECE30030/ITP30010 Database Systems15\nFunctional Dependencies•There are usually a variety of constraints (rules) on the data in the real world•E.g., some of the constraints that are expected to hold in the university database are:•Students and instructors are uniquely identified by their ID•Each student and instructor has only one name•Each instructor and student is associated with only one department•Each department has only one value for its budget, and only one associated building•Relations require that the value for a certain set of attributes determines uniquely the value for another set of attributes•A functional dependency is a generalization of the notion of a key(= trivial dependency)\nECE30030/ITP30010 Database Systems16\nFunctional Dependencies•Let R be a relation schema, a and b be its attributes (a Í R and b Í R)•The functional dependency a ® b  holds on R if and only if, for any relations r(R), whenever any two tuples t1 and t2 of r agree on the attributes a, they also agree on the attributes b•That is,  t1[a] = t2 [a]    Þ    t1[b ] = t2 [b ]•E.g., Consider r(A,B) with the following instance of r\n•On this instance, B ® A hold;  A ® B does NOT hold (only the values of B are unique)ECE30030/ITP30010 Database Systems17\nA     B  1     4  1     5  3     7\nKeys and Functional Dependencies•Functional dependencies allow us to express constraints that cannot be expressed using super keys•E.g., consider the schema:             in_dep (ID, name, salary, dept_name, building, budget )•ID = instructor ID•dept_name = department of the instructor•We expect the following functional dependencies to hold:•dept_name ® building•ID ® buildingÞdept_name and ID are super keys = candidate keys* ID, dept_name, {ID, dept_name}•We would not expect the next to hold:•dept_name ® salary\nECE30030/ITP30010 Database Systems18\nFunctional Dependencies•For relation R = a1 a2 a3 a4\n•a1 is a part of the key•Functional dependency: a4 depends on its key, a1a2a3•b_id,  b_name, bd_detail_attrib1, , bd_detail_attrib2•Candidate keys: b_id, b_name, {b_id, b_name}•It should not be such that a4 depends on a1, and does not depend on a1a2a3 (a1 ➝ a4)  ⇒  partial dependency\nECE30030/ITP30010 Database Systems19\nCandidate key = a1, a2, a3, {a1, a2}, {a2,a3}, {a1, a3}, {a1,a2,a3}\nTrivial Functional Dependencies•A functional dependency is trivial if it is satisfied by all instances of a relation•Example:•ID, name ® ID•name ® name•In general, a ® b is trivial if b Í a\nECE30030/ITP30010 Database Systems20\nFunctional Dependencies•Example: student2(ID, name, tot_cred)•Hold•ID à name•ID à tot_cred•Not hold•tot_cred à name•name à tot_cred\nECE30030/ITP30010 Database Systems21\nFunctional Dependencies•score(score_id, student_id, subject_id, score)•{student_id, subject_id} à score\nECE30030/ITP30010 Database Systems22\nFirst Normal Form (1NF)•Example\nECE30030/ITP30010 Database Systems23\nstudent_idnamecourse21800999James InexistenteAlgorithm, OS21800998Mike InexistenteJava21800997Matt InexistenteAlgorithm, DB\nFirst Normal Form (1NF)•Example\nECE30030/ITP30010 Database Systems24\nstudent_idname21800999James Inexistente21800998Mike Inexistente21800997Matt Inexistentestudent_idcourse21800999Algorithm21800999OS21800998Java21800997Algorithm21800997DB\nFirst Normal Form (1NF)•Example\nECE30030/ITP30010 Database Systems25\nstudent_idname21800999James Inexistente21800998Mike Inexistente21800997Matt Inexistentestudent_idcourse21800999Algorithm21800999OS21800998Java21800997Algorithm21800997DB\nSecond Normal Form (2NF)•Requirements•A relation should be in 1NF (normal forms should be applied in order)•A relation should NOT have a non-PK that is functionally dependent on any subset of any candidate key = NO PARTIAL DEPENDENCIES!•Any attributes other than PK should be dependent on PK•It should not have partial dependencies•PK: Primary Key•An attribute or a set of attributes that uniquely identifies each tuple in a relation•A PK can fetch data from any specific data in a relation•E.g., get the department name of student_ID = 21800999\nECE30030/ITP30010 Database Systems26\nPartial Dependencies•For relation R = a1 a2 a3 a4\n•a1 is a part of the primary key•Partial dependency: a4 depends on a1, and does not depend on a1a2a3•Key: a1 a2 a3•Dependency: a1 ➝ a4\nECE30030/ITP30010 Database Systems27\nPrimary key (Composite)\nEliminating Partial Dependencies•Example: teaches2(ID, course_id, sec_id, semester, year, name)•ID à name\nECE30030/ITP30010 Database Systems28\nEliminating Partial Dependencies•Example: •teaches2a(ID, course_id, sec_id, semester, year)•teaches2b(ID, name)\nECE30030/ITP30010 Database Systems29\nEliminating Partial Dependencies•Example: score(score_id, student_id, subject_id, score, instructor)•subject_id à instructor : partial dependency\nECE30030/ITP30030Database Systems 30\nscore_idstudent_idsubject_idscoreinstructor1 10 1 82James Packer3 11 1 95James Packer2 10 2 77Cole Miller4 11 2 71Cole Miller5 11 4 96Adam Lee\nEliminating Partial Dependencies•Example: score_a(score_id, student_id, subject_id, score)                 score_b(subject_id, instructor)\nECE30030/ITP30030Database Systems 31\nscore_idstudent_idsubject_idscore1 10 1 823 11 1 952 10 2 774 11 2 715 11 4 96\nsubject_idinstructor1 James Packer2 Cole Miller4 Adam Lee\nThird Normal Form (3NF)•Requirements•A relation should be in 2NF •A relation should NOT have transitive dependencies•Transitive dependency: A non-PK attribute depends on another non-PK attribute or a set of non-PK attributes\nECE30030/ITP30010 Database Systems32\nTransitive Dependencies•For relation R = a1 a2 a3 a4\n•a1 is the primary key in R•a3 depends on a1 (a1 ➝ a3) -- OK•a4 depends on a3 (a1 ➝ a3 ➝ a4) … non-PK à non-PK\nECE30030/ITP30010 Database Systems33\nCandidate key = a1, a2, {a1,a2}\nEliminating Transitive Dependencies•Example\nECE30030/ITP30010 Database Systems34\nBookNoPatronAddressDueB1J. Fisher101 Main Street3/2/15B2L. Perez202 Market Street 2/28/15\nEliminating Transitive Dependencies•Example\n•PK: BookNo•Patron à Address\nECE30030/ITP30010 Database Systems35\nBookNoPatronAddressDueB1J. Fisher101 Main Street3/2/15B2L. Perez202 Market Street 2/28/15\nEliminating Transitive Dependencies•Example\nECE30030/ITP30010 Database Systems36\nBookNoPatronDueB1J. Fisher3/2/15B2L. Perez2/28/15PatronAddressJ. Fisher101 Main StreetL. Perez202 Market Street\nEliminating Transitive Dependencies•Example\n•PK: {Tournament, Year}•Winner à DOB\nECE30030/ITP30010 Database Systems37\nTournamentYearWinner DOBIndiana Invitational1998Al Fredrickson21 July 1975Cleveland Open1999Bob Albertson28 Sept. 1968Des Moines Masters1999Al Fredrickson21 July 1975\nEliminating Transitive Dependencies•Example: score2(id, student_id, subject_id, exam_name, exam_score)•{student_id, subject_id} --> FINAL or MIDTERM•{student_id, subject_id} --> 77   43 … from which ?•{student_id, subject_id} à exam_name à exam_score :: transitive dependency\nECE30030/ITP30010 Database Systems38\nEliminating Transitive Dependencies•Example: score2(id, student_id, subject_id, exam_name, exam_score)•student_id, subject_id à exam_name•student_id, subject_id à exam_name à exam_score\nECE30030/ITP30010 Database Systems39\nEliminating Transitive Dependencies•Example: score2a(id, student_id, subject_id, exam_id, exam_name)                 score2b(student_id, subject_id, exam_id, exam_score)\nECE30030/ITP30010 Database Systems40\nBoyce-Codd Normal Form (BCNF) = 3.5NF•Requirements•A relation should be in 3NF•For any dependency A à B, A should be a super key•For A à B, if A is non-PK, then it is NOT in BCNF\nECE30030/ITP30010 Database Systems41\nBoyce-Codd Normal Form (BCNF)•Example: takes2(student_id, subject, instructor)\n•(student, subject) à instructor•Instructor à subject•A non-PK identifies a member of PK: Not in BCNF\nECE30030/ITP30010 Database Systems42\nstudent_idsubjectinstructor21800999C++ Dr. Cpp21800999Java Dr. Java21800998C++ Dr. C21800997PythonDr. Python21800996C++ Dr. Cpp\nBoyce-Codd Normal Form (BCNF)•Example: takes2a(student_id, section_id),                  takes2b(section_id, subject, instructor)\nECE30030/ITP30010 Database Systems43\nstudent_idsection_id2180099910121800999103218009981022180099710421800996101section_idsubjectinstructor101 C++ Dr. Cpp103 Java Dr. Java102 C++ Dr. C104 PythonDr. Python\nBoyce-Codd Normal Form (BCNF)•Example: takes2a(student_id, section_id),                 takes2b(section_id, subject, instructor)\nECE30030/ITP30010 Database Systems44\nstudent_idsection_id2180099910121800999103218009981022180099710421800996101section_idsubjectinstructor101 C++ Dr. Cpp103 Java Dr. Java102 C++ Dr. C104 PythonDr. Python\nFourth Normal Form (4NF)•Requirements•A relation should be in BCNF•A relation should NOT have multi-valued dependency•Multi-valued dependency occurs due to a bad DB schema•Multi-valued dependency occurs when a relation has more than 3 attributes•For a relation with attributes A, B, C•having dependency, A à B, and•B and C are independent from each otherè Then, the relation may have a multi-valued dependency\nECE30030/ITP30010 Database Systems45\nMulti-valued Dependencies•Example•student_id à course•student_id à activity•course ⊥ activity (independent)\nECE30030/ITP30010 Database Systems46\nstudent_idcourseactivity21800999StatisticsSoccer21800999Linear algebraBasketball21800999StatisticsBasketball21800999Linear algebraSoccer\nMulti-valued Dependencies•Example\nECE30030/ITP30010 Database Systems47\nstudent_idcourse21800999Statistics21800999Linear algebra21800998Physics21800998Programming 101student_idactivity21800999Soccer21800999Basketball21800998Pool21800997Soccer\nSummary: Normal Forms•Theories – Normal forms\nECE30030/ITP30010 Database Systems48\nTheory Key IdeaNormal FormFunctional dependency(PK à non-PK)2NFPartial dependencyPart of PK à non-PK2NFTransitive dependencyNon-PK à non-PK3NF- Non-PK à PK BCNFMulti-valued dependency4NFJoin dependency5NF\nOverall DB Design Process•Let us assume schema R is given:(E-R Model)•R could have been generated when converting E-R diagram to a set of tables(Normalization)•R could have been a single relation containing all attributes that are of interest (called universal relation)•Normalization breaks R into smaller relations(Mixed)•R could have been the result of some ad-hoc design of relations, which we then test/convert to normal form\nECE30030/ITP30010 Database Systems49\nE-R Model and Normalization•When an E-R diagram is carefully designed, identifying all entities correctly, the tables generated from the E-R diagram should not need further normalization•However, in a real (imperfect) design, there can be functional dependencies from non-key attributes of an entity to other attributes of the entity•E.g., an employee entity with•attributesdepartment_name and building•functional dependencydepartment_name® building•Good design would have made department an entity•Functional dependencies from non-key attributes of a relationship set possible, but rare --- most relationships are binaryECE30030/ITP30010 Database Systems50\nDenormalization for Performance•We may want to use non-normalized schema for performance•For example, displaying prereqs along with course_id, and title requires join of course with prereq•Alternative 1: Use denormalized relation containing attributes of course as well as prereq with all above attributes•faster lookup•extra space and extra execution time for updates•extra coding work for programmer and possibility of error in extra code•Alternative 2: Use a materialized view defined a course ⋈ prereq•Benefits and drawbacks same as above, except no extra coding work for programmer and avoids possible errors\nECE30030/ITP30010 Database Systems51\nRemaining Issues•Some aspects of database design are not caught by normalization•Example (to be avoided)•earnings_2004, earnings_2005, earnings_2006, etc., all on the schema (company_id, earnings)•Above are well normalized (in BCNF), but make querying across years difficult and needs new table each year•company_year (company_id, earnings_2004, earnings_2005,  earnings_2006)•Above are well normalized (in BCNF), but makes querying across years difficult and requires new attribute each year•This is an example of a crosstab, where values for one attribute become column namesà Better schema: earnings (company_id, year, amount)ECE30030/ITP30010 Database Systems52\nAgenda•Motivating example•Normal forms•Normalization example•Appendix: Normalization theory\nECE30030/ITP30010 Database Systems53\nExample (taken from Wikipedia)•Provided:\n•Satisfying 1NF\nECE30030/ITP30010 Database Systems54\nExample (taken from Wikipedia)•Satisfying 1NF (cont’d – further improvement)\nECE30030/ITP30010 Database Systems55\nExample (taken from Wikipedia)•Provided:\n•Compound key {Title, Format}•Partial dependency: Title à Author, Author Nationality, Pages, Thickness, Genre ID, Genre Name, Publisher ID\nECE30030/ITP30010 Database Systems56\nExample (taken from Wikipedia)•Satisfying 2NF\nECE30030/ITP30010 Database Systems57\nExample (taken from Wikipedia)•Satisfying 3NF\n•Transitive dependency: Genre ID à Genre Name\nECE30030/ITP30010 Database Systems58\nExample (taken from Wikipedia)•Satisfying 3NF\nECE30030/ITP30010 Database Systems59\nExample (taken from Wikipedia)•Satisfying BCNF\n•Non-PK à Non-PK: Author à Author Nationality\nECE30030/ITP30010 Database Systems60\nExample (taken from Wikipedia)•Satisfying BCNF\nECE30030/ITP30010 Database Systems61\nExample (taken from Wikipedia)•Provided:•Assume the database is owned by a book retailer franchise that has several franchisees that own shops in different locations\nECE30030/ITP30010 Database Systems62\nExample (taken from Wikipedia)•Satisfying 4NF•If we assume that all available books are offered in each area, the Title is not unambiguously bound to a certain Locationà Does not satisfy 4NF\nECE30030/ITP30010 Database Systems63\n•Source: https://en.wikipedia.org/wiki/Database_normalization \nECE30030/ITP30030Database Systems 64\nAgenda•Motivating example•Normal forms•Normalization example•Appendix: Normalization theory\nECE30030/ITP30010 Database Systems65\nNormalization Theory•Decide whether a particular relation R is in “good form”•For a relation R is not in “good form”, decompose it into a set of relations {R1, R2, ..., Rn} such that•Each relation is in good form•The decomposition is a lossless decomposition•The normalization is based on a set of relevant theories:•Functional dependencies•Partial dependencies•Transitive dependencies•Multivalued dependencies\nECE30030/ITP30010 Database Systems66\nFunctional Dependencies•There are usually a variety of constraints (rules) on the data in the real world•E.g., some of the constraints that are expected to hold in a university database are:•Students and instructors are uniquely identified by their ID•Each student and instructor has only one name•Each instructor and student is (primarily) associated with only one department•Each department has only one value for its budget, and only one associated building•Relations require that the value for a certain set of attributes determines uniquely the value for another set of attributes•A functional dependency is a generalization of the notion of a key(= trivial dependency)\nECE30030/ITP30010 Database Systems67\nFunctional Dependencies•Let R be a relation schema, a and b be its attributes (a Í R and b Í R)•The functional dependency a ® b  holds on R if and only if, for any relations r(R), whenever any two tuples t1 and t2 of r agree on the attributes a, they also agree on the attributes b•That is,  t1[a] = t2 [a]    Þ    t1[b ] = t2 [b ]•E.g., Consider r(A,B) with the following instance of r\n•On this instance, B ® A hold;  A ® B does NOT hold (only the values of B are unique)ECE30030/ITP30010 Database Systems68\nA     B  1     4  1     5  3     7\nKeys and Functional Dependencies•Functional dependencies allow us to express constraints that cannot be expressed using super keys•E.g., consider the schema:             in_dep (ID, name, salary, dept_name, building, budget )•ID = instructor ID•dept_name = department of the instructor•We expect the following functional dependencies to hold:•dept_name® building•ID à buildingÞdept_name and ID are super keys = candidate keys* ID, dept_name, {ID, dept_name}•We would not expect the next to hold:•dept_name ® salary\nECE30030/ITP30010 Database Systems69\nFunctional Dependencies•For relation R = a1 a2 a3 a4\n•a1 is a part of the key•Functional dependency: a4 depends on its key, a1a2a3•b_id,  b_name, bd_detail_attrib1, , bd_detail_attrib2•Candidate keys: b_id, b_name, {b_id, b_name}•It should not be such that a4 depends on a1, and does not depend on a1a2a3 (a1 ➝ a4)  ⇒  partial dependency\nECE30030/ITP30010 Database Systems70\nCandidate key = a1, a2, a3, {a1, a2}, {a2,a3}, {a1, a3}, {a1,a2,a3}\nTrivial Functional Dependencies•A functional dependency is trivial if it is satisfied by all instances of a relation•Example:•ID, name ® ID•name ® name•In general, a ® b is trivial if b Í a\nECE30030/ITP30010 Database Systems71\nFunctional Dependencies•student2(ID, name, tot_cred)•ID à name•ID à tot_cred•tot_cred à name (X)\nECE30030/ITP30010 Database Systems72\nFunctional Dependencies•SCORE(score_id, student_id, subject_id, score)•{student_id, subject_id} à score\nECE30030/ITP30010 Database Systems73\nPartial Dependencies•For relation R = a1 a2 a3 a4\n•a1 is a part of the primary key•a4 depends on a1, and does not depend on a1a2a3 (a1 ➝ a4)•Key: a1 a2 a3•Dependency: a1 ➝ a4\nECE30030/ITP30010 Database Systems74\nPrimary key (Composite)\nPartial Dependencies•teaches2(ID, course_id, sec_id, semester, year, name)•ID à name•{course_id, sec_id, semester, year} à name\nECE30030/ITP30010 Database Systems75\nPartial Dependencies•SCORE(score_id, student_id, subject_id, score, instructor)•subject_id à instructor (partial dependency) :: WE DON’T WANT TO HAVE THIS\nECE30030/ITP30010 Database Systems76\nTransitive Dependencies•For relation R = a1 a2 a3 a4\n•a1 is the primary key in R•a3 depends on a1 (a1 ➝ a3) -- OK•a4 depends on a3 (a1 ➝ a3 ➝ a4) … non-PK à non-PK\nECE30030/ITP30010 Database Systems77\nCandidate key = a1, a2, {a1,a2}\nTransitive Dependencies•EXAM_SCORE(id, student_id, subject_id, exam_name, exam_score)•{student_id, subject_id} --> FINAL or MIDTERM•{student_id, subject_id} --> 77   43 … from which ?•{student_id, subject_id} à exam_name à exam_score :: transitive dependency\nECE30030/ITP30010 Database Systems78\nMulti-valued Dependencies (MVDs)•Suppose we record names of children, and phone numbers for instructors•inst_child(ID, child_name)•inst_phone(ID, phone_number)à If we combine these schemas to obtain: (multiple orthogonal values in single table à this causes redundancy)•inst_info(ID, child_name, phone_number)à Example tuples: ID=999999 à {David, William} & {x-x-1234, x-x-4321}  (99999, David, 512-555-1234)  (99999, David, 512-555-4321)  (99999, William, 512-555-1234)  (99999, William, 512-555-4321)•Any issues? \nECE30030/ITP40001 Database Systems79\nMulti-valued Dependencies (MVDs)•Let R be a relation schema and let a Í R and b Í R. •The multivalued dependency a ®® b holds on R if in any relation r(R), for all pairs for tuples t1 and t2 in r such that t1[a] = t2 [a], there exist tuples t3 and t4 in r such that:    t1[a] = t2 [a] = t3 [a] = t4 [a]           t3[b] =  t1 [b]           t3[R  – b] =  t2[R  – b]           t4 [b] =  t2[b]           t4[R  – b] =  t1[R  – b] \nECE30030/ITP40001 Database Systems80\nMulti-valued Dependencies (MVDs)•Let R be a relation schema with a set of attributes that are partitioned into 3 non-empty subsets Y, Z, W•We say that Y ®® Z (Y multidetermines Z )if and only if for all possible relations r(R)  < y1, z1, w1 > Î r and < y1, z2, w2 > Î rthen  < y1, z1, w2 > Î r and < y1, z2, w1 > Î r•Note that since the behavior of Z and W are identical it follows that Y ®® Z if Y ®® W\nECE30030/ITP40001 Database Systems81\nMulti-valued Dependencies (MVDs)•Tabular representation of a ®® b\nECE30030/ITP40001 Database Systems82\nMulti-valued Dependencies (MVDs)•FAV(student_id, course, activity)•21800999 - {statistics, Linear algebra} & {Soccer, basketball}•Favorite courses & favorite activities <= they are orthogonal\nECE30030/ITP40001 Database Systems83\nstudent_idcourseactivity21800999StatisticsSoccer21800999Linear algebraBasketball21800999StatisticsBasketball21800999Linear algebraSoccer\nUse of Functional Dependencies•We use functional dependencies to:•Test relations to see if they are legal under a given set of functional dependencies•We say that r satisfies F, if a relation r is legal under a set F of functional dependencies•To specify constraints on the set of legal relations•We say that F holds on R if all legal relations on R satisfy the set of functional dependencies F•Note:  A specific instance of a relation schema may satisfy a functional dependency even if the functional dependency does not hold on all legal instances•E.g., a specific instance of instructor may, by chance, satisfy:  name ® ID\nECE30030/ITP40001 Database Systems84\nUse of Multi\n-\nvalued Dependencies•We use multivalued dependencies in two ways:1.To test relations to determine whether they are legal under a given set of functional and multivalued dependencies2.To specify constraints on the set of legal relations. We shall concern ourselves only with relations that satisfy a given set of functional and multivalued dependencies•If a relation r fails to satisfy a given multivalued dependency, we can construct a relations r¢  that does satisfy the multivalued dependency by adding tuples to r\nECE30030/ITP40001 Database Systems85\nEOF•Coming next:•Advanced SQL\nECE30030/ITP30010 Database Systems86"
        }
      ],
      "notebook_title": "데이터베이스 정규화: 원리, 과정 및 적용",
      "holistic_chapters": [
        {
          "chapter_title": "데이터베이스 정규화 개요 및 필요성",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "데이터가 혼합될 때 발생하는 문제점(데이터 중복, 일관성 문제, 삽입/삭제/갱신 이상 현상)을 설명하고, 이러한 문제에 대한 해결책으로 데이터베이스 정규화의 필요성과 분해(Decomposition)의 개념, 그리고 손실 분해(Lossy Decomposition)와 무손실 분해(Lossless Decomposition)의 차이를 소개합니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems2\nWhen Data is Jumbled…•Suppose that we combine instructor and department •(Below represents the join on instructor and department)\nECE30030/ITP30010 Database Systems3\nWhen Data is Jumbled…•Key issues•Repetition of data à increases the size of database•Data consistency issues•Insertion anomaly: Inserting redundant data for every new record•Deletion anomaly: Loss of related data, when some data is deleted•Update anomaly: When updating certain information, every single record must be updated\nECE30030/ITP30010 Database Systems4\nSolution: Decomposition!•How to avoid the repetition-of-information problem?\n•A: Decompose it into two schemas (as they were)•Normalization = decomposition of relational schemas•Key idea: split relational schemas such that only directly related data composes a relation\nECE30030/ITP30010 Database Systems5\nDecomposition•Less redundancy à Uses smaller disk storage; Causes less issues associated with insertion, deletion, and update anomalies•Not all decompositions are good•E.g., Suppose we decompose   employee(ID, name, street, city, salary)into  employee1 (ID, name)  employee2 (name, street, city, salary)à Problem: What if there are two employees with the same name?•Lossy decomposition: a decomposition from which the original relation cannot be reconstructedECE30030/ITP30010 Database Systems6\nLossy Decomposition\nECE30030/ITP30010 Database Systems7\nLossless Decomposition•Let R be a relation schema and let R1 and R2 form a decomposition of R; that is, R = R1 U R2•A decomposition is a lossless decomposition if there is no loss of information by replacing R with the two relation schemas R1 U R2•Formally,\nÕR1(r)  ⋈  ÕR2(r) = r•C.f., Conversely, a decomposition is lossy if when the join of the projection results is computed, a proper superset of the original relation is returned     r  Ì  ÕR1(r)  ⋈  ÕR2(r)\nECE30030/ITP30010 Database Systems8\nExample: Lossless Decomposition•Decomposition of R = (A, B, C)  à  R1 = (A, B); R2 = (B, C)\nECE30030/ITP30010 Database Systems9\nNormalization•Database normalization: Process of structuring a database to reduce data redundancy and improve data integrity•In accordance with a series of normal forms (next topic)•Through the process:•One can decompose relations to suppress data anomalies•One can make sure the decomposition is lossless"
        },
        {
          "chapter_title": "데이터베이스 정규화 과정 및 일반 형식",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "데이터베이스 정규화가 관계형 데이터베이스 테이블을 더 높은 정규형으로 설계하는 과정임을 설명하고, 논리적으로 독립적인 데이터를 분리하여 키를 통해 연결하는 점진적인 프로세스를 소개합니다. 또한, UNF, 1NF, 2NF, 3NF, BCNF, 4NF 등 주요 정규형의 종류를 나열하고, 이들이 함수적 종속성 등의 이론적 기반을 가진다는 점을 강조합니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems11\nNormal Forms•Normalization process•Normalization is a database design technique, which is used to design a relational database table up to higher normal form•Procedurally separates logically independent (but related) data entities into multiple relations•Maintains the connections using keys•Progressive process•A higher level of database normalization cannot be achieved unless the previous levels have been satisfied•UNF: Unnormalized form•1NF: First normal form•2NF: Second normal form•3NF: Third normal form•BCNF: Boyce-Codd normal form (3.5NF)•4NF: Fourth normal form•…\nECE30030/ITP30010 Database Systems12\nNormal Forms•Normal forms are backed by a set of normalization theories•Functional dependencies•Partial dependencies•Transitive dependencies•Multi-valued dependencies•These theories decide whether a particular relation R is in “good form”•For a relation R is not in “good form”, decompose it into a set of relations {R1, R2, ..., Rn} such that•Each relation is in good form•The decomposition is a lossless decomposition"
        },
        {
          "chapter_title": "함수적 종속성 이해",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "함수적 종속성(Functional Dependency, FD)의 개념을 정의하고, 실제 데이터 제약 조건과의 연관성을 설명합니다. 릴레이션 스키마에서 속성 집합 간의 결정 관계를 예시를 통해 보여주며, 슈퍼 키와 후보 키와의 관계, 그리고 항상 만족되는 자명한 함수적 종속성(Trivial Functional Dependencies)에 대해 다룹니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems15\nFunctional Dependencies•There are usually a variety of constraints (rules) on the data in the real world•E.g., some of the constraints that are expected to hold in the university database are:•Students and instructors are uniquely identified by their ID•Each student and instructor has only one name•Each instructor and student is associated with only one department•Each department has only one value for its budget, and only one associated building•Relations require that the value for a certain set of attributes determines uniquely the value for another set of attributes•A functional dependency is a generalization of the notion of a key(= trivial dependency)\nECE30030/ITP30010 Database Systems16\nFunctional Dependencies•Let R be a relation schema, a and b be its attributes (a Í R and b Í R)•The functional dependency a ® b  holds on R if and only if, for any relations r(R), whenever any two tuples t1 and t2 of r agree on the attributes a, they also agree on the attributes b•That is,  t1[a] = t2 [a]    Þ    t1[b ] = t2 [b ]•E.g., Consider r(A,B) with the following instance of r\nA     B  1     4  1     5  3     7\n•On this instance, B ® A hold;  A ® B does NOT hold (only the values of B are unique)\nECE30030/ITP30010 Database Systems17\nKeys and Functional Dependencies•Functional dependencies allow us to express constraints that cannot be expressed using super keys•E.g., consider the schema:\nin_dep (ID, name, salary, dept_name, building, budget )•ID = instructor ID•dept_name = department of the instructor•We expect the following functional dependencies to hold:•dept_name ® building•ID ® buildingÞdept_name and ID are super keys = candidate keys* ID, dept_name, {ID, dept_name}•We would not expect the next to hold:•dept_name ® salary\nECE30030/ITP30010 Database Systems18\nFunctional Dependencies•For relation R = a1 a2 a3 a4\n•a1 is a part of the key•Functional dependency: a4 depends on its key, a1a2a3•b_id,  b_name, bd_detail_attrib1, , bd_detail_attrib2•Candidate keys: b_id, b_name, {b_id, b_name}•It should not be such that a4 depends on a1, and does not depend on a1a2a3 (a1 ➝ a4)  ⇒  partial dependency\nECE30030/ITP30010 Database Systems19\nCandidate key = a1, a2, a3, {a1, a2}, {a2,a3}, {a1, a3}, {a1,a2,a3}\nTrivial Functional Dependencies•A functional dependency is trivial if it is satisfied by all instances of a relation•Example:•ID, name ® ID•name ® name•In general, a ® b is trivial if b Í a\nECE30030/ITP30010 Database Systems20\nFunctional Dependencies•Example: student2(ID, name, tot_cred)•Hold•ID à name•ID à tot_cred•Not hold•tot_cred à name•name à tot_cred\nECE30030/ITP30010 Database Systems21\nFunctional Dependencies•score(score_id, student_id, subject_id, score)•{student_id, subject_id} à score\nECE30030/ITP30010 Database Systems22\nECE30030/ITP30010 Database Systems22\nECE30030/ITP30010 Database Systems67\nFunctional Dependencies•There are usually a variety of constraints (rules) on the data in the real world•E.g., some of the constraints that are expected to hold in a university database are:•Students and instructors are uniquely identified by their ID•Each student and instructor has only one name•Each instructor and student is (primarily) associated with only one department•Each department has only one value for its budget, and only one associated building•Relations require that the value for a certain set of attributes determines uniquely the value for another set of attributes•A functional dependency is a generalization of the notion of a key(= trivial dependency)\nECE30030/ITP30010 Database Systems68\nFunctional Dependencies•Let R be a relation schema, a and b be its attributes (a Í R and b Í R)•The functional dependency a ® b  holds on R if and only if, for any relations r(R), whenever any two tuples t1 and t2 of r agree on the attributes a, they also agree on the attributes b•That is,  t1[a] = t2 [a]    Þ    t1[b ] = t2 [b ]•E.g., Consider r(A,B) with the following instance of r\nA     B  1     4  1     5  3     7\n•On this instance, B ® A hold;  A ® B does NOT hold (only the values of B are unique)\nECE30030/ITP30010 Database Systems69\nKeys and Functional Dependencies•Functional dependencies allow us to express constraints that cannot be expressed using super keys•E.g., consider the schema:\nin_dep (ID, name, salary, dept_name, building, budget )•ID = instructor ID•dept_name = department of the instructor•We expect the following functional dependencies to hold:•dept_name® building•ID à buildingÞdept_name and ID are super keys = candidate keys* ID, dept_name, {ID, dept_name}•We would not expect the next to hold:•dept_name ® salary\nECE30030/ITP30010 Database Systems70\nFunctional Dependencies•For relation R = a1 a2 a3 a4\n•a1 is a part of the key•Functional dependency: a4 depends on its key, a1a2a3•b_id,  b_name, bd_detail_attrib1, , bd_detail_attrib2•Candidate keys: b_id, b_name, {b_id, b_name}•It should not be such that a4 depends on a1, and does not depend on a1a2a3 (a1 ➝ a4)  ⇒  partial dependency\nECE30030/ITP30010 Database Systems71\nCandidate key = a1, a2, a3, {a1, a2}, {a2,a3}, {a1, a3}, {a1,a2,a3}\nTrivial Functional Dependencies•A functional dependency is trivial if it is satisfied by all instances of a relation•Example:•ID, name ® ID•name ® name•In general, a ® b is trivial if b Í a\nECE30030/ITP30010 Database Systems72\nFunctional Dependencies•student2(ID, name, tot_cred)•ID à name•ID à tot_cred•tot_cred à name (X)\nECE30030/ITP30010 Database Systems73\nFunctional Dependencies•SCORE(score_id, student_id, subject_id, score)•{student_id, subject_id} à score"
        },
        {
          "chapter_title": "제1 정규형 (1NF): 원자성 및 고유성",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "제1 정규형(1NF)의 요구사항을 설명하며, 모든 속성 값이 원자적이어야 하고, 각 컬럼은 동일한 데이터 도메인 내의 값을 포함하며, 고유한 이름을 가져야 한다는 점을 강조합니다. 중복된 행이 없어야 하며, 기본 키(PK)가 고유성과 Not Null을 보장하는 역할을 설명하고, 실제 예시를 통해 1NF로의 변환 과정을 보여줍니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems13\nFirst Normal Form (1NF)•Requirements•A relation should consist of atomic values•Atomic value: a value that cannot be divided (≃primitive data types in JAVA)•Atomic - INT, FLOAT, DOUBLE, DECIMAL (NUMERIC), CHAR, VARCHAR, BLOB, TEXT•NOGO - Structure, List (array)•Attributes should have unique identifiers•Step 1 of the normalization process•“If the tables in your DB does not follow 1NF, stop using database”\nECE30030/ITP30010 Database Systems14\nFirst Normal Form (1NF)•1NF checklist1.Each column should contain an atomic value•Entries like (x, y) violate this rule2.Each column should contain values that are in the same data domain•Do not mix different types of values in a column3.Each column should have a unique name•Duplicate names lead to confusion while accessing data4.The order in which data is stored does not matter•Using SQL, one can easily fetch data in any order5.There are no duplicated rows in the table•Primary key (PK) ensures: •Attributes that are part of PK are unique•Attributes that are part of PK are not null\nECE30030/ITP30010 Database Systems23\nFirst Normal Form (1NF)•Example\nstudent_idnamecourse\n21800999James InexistenteAlgorithm, OS\n21800998Mike InexistenteJava\n21800997Matt InexistenteAlgorithm, DB\nECE30030/ITP30010 Database Systems24\nFirst Normal Form (1NF)•Example\nstudent_idname\n21800999James Inexistente\n21800998Mike Inexistente\n21800997Matt Inexistente\nstudent_idcourse\n21800999Algorithm\n21800999OS\n21800998Java\n21800997Algorithm\n21800997DB\nECE30030/ITP30010 Database Systems25\nFirst Normal Form (1NF)•Example\nstudent_idname\n21800999James Inexistente\n21800998Mike Inexistente\n21800997Matt Inexistente\nstudent_idcourse\n21800999Algorithm\n21800999OS\n21800998Java\n21800997Algorithm\n21800997DB"
        },
        {
          "chapter_title": "제2 정규형 (2NF): 부분 종속성 제거",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "제2 정규형(2NF)의 요구사항을 설명하며, 1NF를 만족하고 기본 키가 아닌 속성이 후보 키의 어떤 부분 집합에도 함수적으로 종속되지 않아야 함을 강조합니다. 부분 종속성(Partial Dependency)의 정의와 이를 제거하기 위한 관계 분해(Decomposition) 과정을 다양한 예시를 통해 구체적으로 설명합니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems26\nSecond Normal Form (2NF)•Requirements•A relation should be in 1NF (normal forms should be applied in order)•A relation should NOT have a non-PK that is functionally dependent on any subset of any candidate key = NO PARTIAL DEPENDENCIES!•Any attributes other than PK should be dependent on PK•It should not have partial dependencies•PK: Primary Key•An attribute or a set of attributes that uniquely identifies each tuple in a relation•A PK can fetch data from any specific data in a relation•E.g., get the department name of student_ID = 21800999\nECE30030/ITP30010 Database Systems27\nPartial Dependencies•For relation R = a1 a2 a3 a4\n•a1 is a part of the primary key•Partial dependency: a4 depends on a1, and does not depend on a1a2a3•Key: a1 a2 a3•Dependency: a1 ➝ a4\nPrimary key (Composite)\nECE30030/ITP30010 Database Systems28\nEliminating Partial Dependencies•Example: teaches2(ID, course_id, sec_id, semester, year, name)•ID à name\nECE30030/ITP30010 Database Systems29\nEliminating Partial Dependencies•Example: •teaches2a(ID, course_id, sec_id, semester, year)•teaches2b(ID, name)\nECE30030/ITP30030Database Systems 30\nEliminating Partial Dependencies•Example: score(score_id, student_id, subject_id, score, instructor)•subject_id à instructor : partial dependency\nscore_idstudent_idsubject_idscoreinstructor\n1 10 1 82James Packer\n3 11 1 95James Packer\n2 10 2 77Cole Miller\n4 11 2 71Cole Miller\n5 11 4 96Adam Lee\nECE30030/ITP30030Database Systems 31\nEliminating Partial Dependencies•Example: score_a(score_id, student_id, subject_id, score)                 score_b(subject_id, instructor)\nscore_idstudent_idsubject_idscore\n1 10 1 82\n3 11 1 95\n2 10 2 77\n4 11 2 71\n5 11 4 96\nsubject_idinstructor\n1 James Packer\n2 Cole Miller\n4 Adam Lee\nECE30030/ITP30010 Database Systems74\nPartial Dependencies•For relation R = a1 a2 a3 a4\n•a1 is a part of the primary key•a4 depends on a1, and does not depend on a1a2a3 (a1 ➝ a4)•Key: a1 a2 a3•Dependency: a1 ➝ a4\nPrimary key (Composite)\nECE30030/ITP30010 Database Systems75\nPartial Dependencies•teaches2(ID, course_id, sec_id, semester, year, name)•ID à name•{course_id, sec_id, semester, year} à name\nECE30030/ITP30010 Database Systems76\nPartial Dependencies•SCORE(score_id, student_id, subject_id, score, instructor)•subject_id à instructor (partial dependency) :: WE DON’T WANT TO HAVE THIS"
        },
        {
          "chapter_title": "제3 정규형 (3NF): 이행적 종속성 제거",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "제3 정규형(3NF)의 요구사항을 설명하며, 2NF를 만족하고 이행적 종속성(Transitive Dependency)이 없어야 함을 강조합니다. 이행적 종속성은 기본 키가 아닌 속성이 다른 기본 키가 아닌 속성에 종속되는 경우를 의미하며, 이를 제거하기 위한 관계 분해 과정을 다양한 도서 및 시험 점수 관리 예시를 통해 상세히 제시합니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems32\nThird Normal Form (3NF)•Requirements•A relation should be in 2NF •A relation should NOT have transitive dependencies•Transitive dependency: A non-PK attribute depends on another non-PK attribute or a set of non-PK attributes\nECE30030/ITP30010 Database Systems33\nTransitive Dependencies•For relation R = a1 a2 a3 a4\n•a1 is the primary key in R•a3 depends on a1 (a1 ➝ a3) -- OK•a4 depends on a3 (a1 ➝ a3 ➝ a4) … non-PK à non-PK\nCandidate key = a1, a2, {a1,a2}\nECE30030/ITP30010 Database Systems34\nEliminating Transitive Dependencies•Example\nBookNoPatronAddressDue\nB1J. Fisher101 Main Street3/2/15\nB2L. Perez202 Market Street 2/28/15\nECE30030/ITP30010 Database Systems35\nEliminating Transitive Dependencies•Example\n•PK: BookNo•Patron à Address\nBookNoPatronAddressDue\nB1J. Fisher101 Main Street3/2/15\nB2L. Perez202 Market Street 2/28/15\nECE30030/ITP30010 Database Systems36\nEliminating Transitive Dependencies•Example\nBookNoPatronDue\nB1J. Fisher3/2/15\nB2L. Perez2/28/15PatronAddressJ. Fisher101 Main StreetL. Perez202 Market Street\nECE30030/ITP30010 Database Systems37\nEliminating Transitive Dependencies•Example\n•PK: {Tournament, Year}•Winner à DOB\nTournamentYearWinner DOB\nIndiana Invitational1998Al Fredrickson21 July 1975\nCleveland Open1999Bob Albertson28 Sept. 1968\nDes Moines Masters1999Al Fredrickson21 July 1975\nECE30030/ITP30010 Database Systems38\nEliminating Transitive Dependencies•Example: score2(id, student_id, subject_id, exam_name, exam_score)•{student_id, subject_id} --> FINAL or MIDTERM•{student_id, subject_id} --> 77   43 … from which ?•{student_id, subject_id} à exam_name à exam_score :: transitive dependency\nECE30030/ITP30010 Database Systems39\nEliminating Transitive Dependencies•Example: score2(id, student_id, subject_id, exam_name, exam_score)•student_id, subject_id à exam_name•student_id, subject_id à exam_name à exam_score\nECE30030/ITP30010 Database Systems40\nEliminating Transitive Dependencies•Example: score2a(id, student_id, subject_id, exam_id, exam_name)                 score2b(student_id, subject_id, exam_id, exam_score)\nECE30030/ITP30010 Database Systems77\nTransitive Dependencies•For relation R = a1 a2 a3 a4\n•a1 is the primary key in R•a3 depends on a1 (a1 ➝ a3) -- OK•a4 depends on a3 (a1 ➝ a3 ➝ a4) … non-PK à non-PK\nCandidate key = a1, a2, {a1,a2}\nECE30030/ITP30010 Database Systems78\nTransitive Dependencies•EXAM_SCORE(id, student_id, subject_id, exam_name, exam_score)•{student_id, subject_id} --> FINAL or MIDTERM•{student_id, subject_id} --> 77   43 … from which ?•{student_id, subject_id} à exam_name à exam_score :: transitive dependency"
        },
        {
          "chapter_title": "보이스-코드 정규형 (BCNF): 강화된 제3 정규형",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "보이스-코드 정규형(BCNF)은 제3 정규형을 강화한 형태로, A → B 종속성이 있을 때 A가 반드시 슈퍼 키여야 한다는 요구사항을 설명합니다. 즉, 기본 키가 아닌 속성이 기본 키의 일부를 결정하는 경우가 없어야 하며, 이를 위반하는 사례와 BCNF를 만족하도록 관계를 분해하는 과정을 예시를 통해 보여줍니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems41\nBoyce-Codd Normal Form (BCNF) = 3.5NF•Requirements•A relation should be in 3NF•For any dependency A à B, A should be a super key•For A à B, if A is non-PK, then it is NOT in BCNF\nECE30030/ITP30010 Database Systems42\nBoyce-Codd Normal Form (BCNF)•Example: takes2(student_id, subject, instructor)\n•(student, subject) à instructor•Instructor à subject•A non-PK identifies a member of PK: Not in BCNF\nstudent_idsubjectinstructor\n21800999C++ Dr. Cpp\n21800999Java Dr. Java\n21800998C++ Dr. C\n21800997PythonDr. Python\n21800996C++ Dr. Cpp\nECE30030/ITP30010 Database Systems43\nBoyce-Codd Normal Form (BCNF)•Example: takes2a(student_id, section_id),\ntakes2b(section_id, subject, instructor)\nstudent_idsection_id\n21800999101\n21800999103\n21800998102\n21800997104\n21800996101section_idsubjectinstructor\n101 C++ Dr. Cpp\n103 Java Dr. Java\n102 C++ Dr. C\n104 PythonDr. Python\nECE30030/ITP30010 Database Systems44\nBoyce-Codd Normal Form (BCNF)•Example: takes2a(student_id, section_id),\ntakes2b(section_id, subject, instructor)\nstudent_idsection_id\n21800999101\n21800999103\n21800998102\n21800997104\n21800996101section_idsubjectinstructor\n101 C++ Dr. Cpp\n103 Java Dr. Java\n102 C++ Dr. C\n104 PythonDr. Python"
        },
        {
          "chapter_title": "제4 정규형 (4NF): 다치 종속성 제거",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "제4 정규형(4NF)의 요구사항을 설명하며, BCNF를 만족하고 다치 종속성(Multi-valued Dependency, MVD)이 없어야 함을 강조합니다. 다치 종속성은 릴레이션에 3개 이상의 속성이 있고, 서로 독립적인 다치 속성 집합이 존재할 때 발생할 수 있으며, 이를 제거하기 위한 관계 분해 과정을 학생의 수강 과목 및 활동 예시를 통해 설명합니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems45\nFourth Normal Form (4NF)•Requirements•A relation should be in BCNF•A relation should NOT have multi-valued dependency•Multi-valued dependency occurs due to a bad DB schema•Multi-valued dependency occurs when a relation has more than 3 attributes•For a relation with attributes A, B, C•having dependency, A à B, and•B and C are independent from each otherè Then, the relation may have a multi-valued dependency\nECE30030/ITP30010 Database Systems46\nMulti-valued Dependencies•Example•student_id à course•student_id à activity•course ⊥ activity (independent)\nstudent_idcourseactivity\n21800999StatisticsSoccer\n21800999Linear algebraBasketball\n21800999StatisticsBasketball\n21800999Linear algebraSoccer\nECE30030/ITP30010 Database Systems47\nMulti-valued Dependencies•Example\nstudent_idcourse\n21800999Statistics\n21800999Linear algebra\n21800998Physics\n21800998Programming 101student_idactivity\n21800999Soccer\n21800999Basketball\n21800998Pool\n21800997Soccer\nECE30030/ITP40001 Database Systems79\nMulti-valued Dependencies (MVDs)•Suppose we record names of children, and phone numbers for instructors•inst_child(ID, child_name)•inst_phone(ID, phone_number)à If we combine these schemas to obtain: (multiple orthogonal values in single table à this causes redundancy)•inst_info(ID, child_name, phone_number)à Example tuples: ID=999999 à {David, William} & {x-x-1234, x-x-4321}  (99999, David, 512-555-1234)  (99999, David, 512-555-4321)  (99999, William, 512-555-1234)  (99999, William, 512-555-4321)•Any issues?\nECE30030/ITP40001 Database Systems80\nMulti-valued Dependencies (MVDs)•Let R be a relation schema and let a Í R and b Í R. •The multivalued dependency a ®® b holds on R if in any relation r(R), for all pairs for tuples t1 and t2 in r such that t1[a] = t2 [a], there exist tuples t3 and t4 in r such that:    t1[a] = t2 [a] = t3 [a] = t4 [a]           t3[b] =  t1 [b]           t3[R  – b] =  t2[R  – b]           t4 [b] =  t2[b]           t4[R  – b] =  t1[R  – b]\nECE30030/ITP40001 Database Systems81\nMulti-valued Dependencies (MVDs)•Let R be a relation schema with a set of attributes that are partitioned into 3 non-empty subsets Y, Z, W•We say that Y ®® Z (Y multidetermines Z )if and only if for all possible relations r(R)  < y1, z1, w1 > Î r and < y1, z2, w2 > Î rthen  < y1, z1, w2 > Î r and < y1, z2, w1 > Î r•Note that since the behavior of Z and W are identical it follows that Y ®® Z if Y ®® W\nECE30030/ITP40001 Database Systems82\nMulti-valued Dependencies (MVDs)•Tabular representation of a ®® b\nECE30030/ITP40001 Database Systems83\nMulti-valued Dependencies (MVDs)•FAV(student_id, course, activity)•21800999 - {statistics, Linear algebra} & {Soccer, basketball}•Favorite courses & favorite activities <= they are orthogonal\nstudent_idcourseactivity\n21800999StatisticsSoccer\n21800999Linear algebraBasketball\n21800999StatisticsBasketball\n21800999Linear algebraSoccer"
        },
        {
          "chapter_title": "정규화 이론 및 종속성 요약",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "각 정규형(2NF, 3NF, BCNF, 4NF, 5NF)과 관련된 핵심 이론 및 종속성(함수적, 부분, 이행적, 다치, 조인 종속성)을 요약하여 제시합니다. 정규화 이론이 '좋은 형태'의 릴레이션을 결정하고 무손실 분해를 통해 이를 달성하는 데 사용됨을 강조하며, 함수적 종속성과 다치 종속성이 데이터베이스의 유효성 검사 및 제약 조건 지정에 어떻게 활용되는지 설명합니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems48\nSummary: Normal Forms•Theories – Normal forms\nTheory Key IdeaNormal Form\nFunctional dependency(PK à non-PK)2NF\nPartial dependencyPart of PK à non-PK2NF\nTransitive dependencyNon-PK à non-PK3NF\n- Non-PK à PK BCNF\nMulti-valued dependency4NF\nJoin dependency5NF\nECE30030/ITP30010 Database Systems65\nNormalization Theory•Decide whether a particular relation R is in “good form”•For a relation R is not in “good form”, decompose it into a set of relations {R1, R2, ..., Rn} such that•Each relation is in good form•The decomposition is a lossless decomposition\nECE30030/ITP30010 Database Systems66\nNormalization Theory•The normalization is based on a set of relevant theories:•Functional dependencies•Partial dependencies•Transitive dependencies•Multivalued dependencies\nECE30030/ITP40001 Database Systems84\nUse of Functional Dependencies•We use functional dependencies to:•Test relations to see if they are legal under a given set of functional dependencies•We say that r satisfies F, if a relation r is legal under a set F of functional dependencies•To specify constraints on the set of legal relations•We say that F holds on R if all legal relations on R satisfy the set of functional dependencies F•Note:  A specific instance of a relation schema may satisfy a functional dependency even if the functional dependency does not hold on all legal instances•E.g., a specific instance of instructor may, by chance, satisfy:  name ® ID\nECE30030/ITP40001 Database Systems85\nUse of Multi\n-\nvalued Dependencies•We use multivalued dependencies in two ways:1.To test relations to determine whether they are legal under a given set of functional and multivalued dependencies2.To specify constraints on the set of legal relations. We shall concern ourselves only with relations that satisfy a given set of functional and multivalued dependencies•If a relation r fails to satisfy a given multivalued dependency, we can construct a relations r¢  that does satisfy the multivalued dependency by adding tuples to r"
        },
        {
          "chapter_title": "정규화 실전 예시",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "위키피디아에서 가져온 서적 소매업 데이터베이스 예시를 통해 데이터베이스 정규화 과정을 단계별로 상세히 설명합니다. 1NF, 2NF, 3NF, BCNF, 그리고 4NF를 만족하도록 테이블을 분해하고 종속성을 제거하는 실제 적용 사례를 보여주며, 각 정규형의 요구사항이 어떻게 충족되는지 시각적으로 제시합니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems53\nExample (taken from Wikipedia)•Provided:\nECE30030/ITP30010 Database Systems54\nExample (taken from Wikipedia)•Satisfying 1NF\nECE30030/ITP30010 Database Systems55\nExample (taken from Wikipedia)•Satisfying 1NF (cont’d – further improvement)\nECE30030/ITP30010 Database Systems56\nExample (taken from Wikipedia)•Provided:\n•Compound key {Title, Format}•Partial dependency: Title à Author, Author Nationality, Pages, Thickness, Genre ID, Genre Name, Publisher ID\nECE30030/ITP30010 Database Systems57\nExample (taken from Wikipedia)•Satisfying 2NF\nECE30030/ITP30010 Database Systems58\nExample (taken from Wikipedia)•Satisfying 3NF\n•Transitive dependency: Genre ID à Genre Name\nECE30030/ITP30010 Database Systems59\nExample (taken from Wikipedia)•Satisfying 3NF\nECE30030/ITP30010 Database Systems60\nExample (taken from Wikipedia)•Satisfying BCNF\n•Non-PK à Non-PK: Author à Author Nationality\nECE30030/ITP30010 Database Systems61\nExample (taken from Wikipedia)•Satisfying BCNF\nECE30030/ITP30010 Database Systems62\nExample (taken from Wikipedia)•Provided:•Assume the database is owned by a book retailer franchise that has several franchisees that own shops in different locations\nECE30030/ITP30010 Database Systems63\nExample (taken from Wikipedia)•Satisfying 4NF•If we assume that all available books are offered in each area, the Title is not unambiguously bound to a certain Locationà Does not satisfy 4NF\nECE30030/ITP30030Database Systems 64\n•Source: https://en.wikipedia.org/wiki/Database_normalization"
        },
        {
          "chapter_title": "데이터베이스 설계 과정 및 비정규화",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "데이터베이스 설계 과정에서 정규화가 어떻게 통합되는지 설명합니다. E-R 모델 설계의 중요성과 정규화의 관계를 다루고, 성능 향상을 위해 의도적으로 정규화되지 않은 스키마를 사용하는 비정규화(Denormalization)의 개념과 그 장단점을 제시합니다. 또한, 연도별 수익 데이터와 같은 특정 설계 문제가 정규화만으로는 해결되지 않을 수 있음을 지적하며 더 나은 스키마 설계를 제안합니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems49\nOverall DB Design Process•Let us assume schema R is given:(E-R Model)•R could have been generated when converting E-R diagram to a set of tables(Normalization)•R could have been a single relation containing all attributes that are of interest (called universal relation)•Normalization breaks R into smaller relations(Mixed)•R could have been the result of some ad-hoc design of relations, which we then test/convert to normal form\nECE30030/ITP30010 Database Systems50\nE-R Model and Normalization•When an E-R diagram is carefully designed, identifying all entities correctly, the tables generated from the E-R diagram should not need further normalization•However, in a real (imperfect) design, there can be functional dependencies from non-key attributes of an entity to other attributes of the entity•E.g., an employee entity with•attributesdepartment_name and building•functional dependencydepartment_name® building•Good design would have made department an entity•Functional dependencies from non-key attributes of a relationship set possible, but rare --- most relationships are binary\nECE30030/ITP30010 Database Systems51\nDenormalization for Performance•We may want to use non-normalized schema for performance•For example, displaying prereqs along with course_id, and title requires join of course with prereq•Alternative 1: Use denormalized relation containing attributes of course as well as prereq with all above attributes•faster lookup•extra space and extra execution time for updates•extra coding work for programmer and possibility of error in extra code•Alternative 2: Use a materialized view defined a course ⋈ prereq•Benefits and drawbacks same as above, except no extra coding work for programmer and avoids possible errors\nECE30030/ITP30010 Database Systems52\nRemaining Issues•Some aspects of database design are not caught by normalization•Example (to be avoided)•earnings_2004, earnings_2005, earnings_2006, etc., all on the schema (company_id, earnings)•Above are well normalized (in BCNF), but make querying across years difficult and needs new table each year•company_year (company_id, earnings_2004, earnings_2005,  earnings_2006)•Above are well normalized (in BCNF), but makes querying across years difficult and requires new attribute each year•This is an example of a crosstab, where values for one attribute become column namesà Better schema: earnings (company_id, year, amount)"
        }
      ],
      "generated_content": [
        {
          "title": "데이터베이스 정규화 개요 및 필요성",
          "metadata": "Source: a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf, Text length: 1990 chars",
          "documentContent": [
            {
              "type": "heading",
              "content": "데이터 혼합 시 발생하는 문제점",
              "level": 1
            },
            {
              "type": "paragraph",
              "content": "강사(instructor)와 학과(department) 데이터를 결합하는 경우를 가정해 봅시다. 아래는 강사 및 학과에 대한 조인(join)을 나타냅니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "데이터가 혼합될 때 발생하는 주요 문제점들은 다음과 같습니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "데이터 중복: 데이터베이스 크기를 증가시킵니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "데이터 일관성 문제:",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "삽입 이상(Insertion anomaly): 새로운 레코드를 삽입할 때마다 중복된 데이터를 삽입해야 합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "삭제 이상(Deletion anomaly): 일부 데이터가 삭제될 때 관련 데이터가 손실됩니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "갱신 이상(Update anomaly): 특정 정보를 갱신할 때 모든 관련 레코드를 갱신해야 합니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "해결책: 분해(Decomposition)!",
              "level": 1
            },
            {
              "type": "paragraph",
              "content": "정보 중복 문제를 어떻게 피할 수 있을까요?",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "해답은 원래의 두 스키마로 분해하는 것입니다. 정규화(Normalization)는 관계형 스키마의 분해를 의미합니다. 핵심 아이디어는 직접적으로 관련된 데이터만 하나의 릴레이션을 구성하도록 관계형 스키마를 분할하는 것입니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "분해(Decomposition)",
              "level": 1
            },
            {
              "type": "paragraph",
              "content": "분해는 데이터 중복을 줄여 더 적은 디스크 저장 공간을 사용하게 하며, 삽입, 삭제, 갱신 이상과 관련된 문제를 감소시킵니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "하지만 모든 분해가 좋은 것은 아닙니다. 예를 들어, employee(ID, name, street, city, salary)를 employee1(ID, name)과 employee2(name, street, city, salary)로 분해한다고 가정해 봅시다. 만약 같은 이름을 가진 두 명의 직원이 있다면 문제가 발생합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "손실 분해(Lossy decomposition): 원본 릴레이션을 재구성할 수 없는 분해를 의미합니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "무손실 분해(Lossless Decomposition)",
              "level": 1
            },
            {
              "type": "paragraph",
              "content": "R을 관계형 스키마라고 하고, R1과 R2가 R의 분해를 형성한다고 합시다. 즉, R = R1 ∪ R2 입니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "분해가 무손실 분해(lossless decomposition)라는 것은 R을 두 관계형 스키마 R1 ∪ R2로 대체함으로써 정보 손실이 없음을 의미합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "공식적으로는 ÕR1(r) ⋈ ÕR2(r) = r 입니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "반대로, 투영 결과의 조인이 계산될 때 원본 릴레이션의 진부분 집합(proper superset)이 반환되는 경우 분해는 손실 분해(lossy decomposition)입니다. 즉, r ⊂ ÕR1(r) ⋈ ÕR2(r) 입니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "무손실 분해 예시",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "R = (A, B, C)를 R1 = (A, B)와 R2 = (B, C)로 분해하는 예시입니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "정규화(Normalization)",
              "level": 1
            },
            {
              "type": "paragraph",
              "content": "데이터베이스 정규화는 데이터 중복을 줄이고 데이터 무결성을 향상시키기 위해 데이터베이스를 구조화하는 과정입니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "이는 일련의 정규형(다음 주제)에 따라 수행됩니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "정규화 과정을 통해 릴레이션을 분해하여 데이터 이상(anomalies)을 억제할 수 있으며, 분해가 무손실임을 확인할 수 있습니다.",
              "level": null
            }
          ],
          "aiNotes": {
            "summary": "본 텍스트는 데이터베이스에서 데이터가 혼합될 때 발생하는 중복 및 일관성 문제, 특히 삽입, 삭제, 갱신 이상과 같은 '데이터 이상' 현상을 다룹니다. 이러한 문제의 해결책으로 '분해'와 '정규화' 개념을 소개하며, 관계형 스키마를 분할하여 데이터 중복을 줄이고 데이터 무결성을 높이는 방법을 설명합니다. 특히, 분해 과정에서 정보 손실이 발생하지 않도록 하는 '무손실 분해'의 중요성과 그 정의를 강조합니다. 정규화는 데이터 이상을 억제하고 분해가 무손실임을 보장하는 체계적인 과정으로 제시됩니다.",
            "keyConcepts": [
              {
                "term": "데이터 이상 (Data Anomalies)",
                "definition": {
                  "easy": "데이터가 엉망이 돼서 추가, 삭제, 수정할 때 문제가 생기는 거예요.",
                  "medium": "데이터베이스 내에 중복된 데이터로 인해 발생하는 비일관성 문제로, 삽입, 삭제, 갱신 시 예상치 못한 부작용을 초래합니다.",
                  "hard": "관계형 데이터베이스에서 릴레이션의 속성 간에 적절한 함수적 종속성이 확립되지 않아 발생하는 데이터 일관성 위반 문제로, 삽입 이상, 삭제 이상, 갱신 이상으로 구분되며 데이터 무결성을 저해합니다."
                }
              },
              {
                "term": "정규화 (Normalization)",
                "definition": {
                  "easy": "데이터를 깔끔하게 정리해서 중복을 줄이고 문제 없게 만드는 과정이에요.",
                  "medium": "데이터 중복을 최소화하고 데이터 무결성을 향상시키기 위해 관계형 데이터베이스 스키마를 체계적으로 분해하는 과정입니다.",
                  "hard": "관계형 데이터베이스 설계에서 데이터 중복성을 줄이고 삽입, 삭제, 갱신 이상과 같은 데이터 이상 현상을 방지하며 데이터 무결성을 보장하기 위해, 일련의 정규형 규칙에 따라 릴레이션 스키마를 분해하고 재구성하는 절차입니다."
                }
              },
              {
                "term": "분해 (Decomposition)",
                "definition": {
                  "easy": "큰 덩어리의 데이터를 작은 여러 덩어리로 나누는 거예요.",
                  "medium": "하나의 관계형 스키마를 두 개 이상의 작은 스키마로 나누는 과정으로, 데이터 중복을 줄이고 효율성을 높이는 데 사용됩니다.",
                  "hard": "관계형 데이터베이스에서 하나의 릴레이션 스키마를 둘 이상의 릴레이션 스키마로 분할하는 연산으로, 이 과정에서 원래의 릴레이션이 가지던 함수적 종속성 및 기타 제약 조건이 유지되도록 해야 하며, 특히 무손실 조인 분해가 중요하게 고려됩니다."
                }
              },
              {
                "term": "무손실 분해 (Lossless Decomposition)",
                "definition": {
                  "easy": "데이터를 나눴다가 다시 합쳐도 원래 데이터가 그대로 유지되는 분해예요.",
                  "medium": "릴레이션을 여러 개의 하위 릴레이션으로 분해한 후, 이 하위 릴레이션들을 다시 조인했을 때 원래의 릴레이션과 동일한 정보를 얻을 수 있는 분해 방식입니다.",
                  "hard": "관계형 스키마 R을 R1과 R2로 분해했을 때, 원래 릴레이션 r에 대한 R1과 R2의 투영(projection) 결과를 자연 조인(natural join)한 결과가 r과 정확히 일치하는 경우를 의미하며, 이는 정보 손실 없이 원래의 데이터를 재구성할 수 있음을 보장합니다."
                }
              }
            ],
            "importantTerms": [
              {
                "term": "삽입 이상 (Insertion anomaly)",
                "definition": "새로운 레코드를 추가할 때 원치 않는 중복 데이터가 함께 삽입되거나, 필요한 정보가 없어 삽입이 불가능해지는 문제."
              },
              {
                "term": "삭제 이상 (Deletion anomaly)",
                "definition": "레코드를 삭제할 때, 삭제하려는 정보 외에 다른 중요한 정보까지 함께 손실되는 문제."
              },
              {
                "term": "갱신 이상 (Update anomaly)",
                "definition": "중복된 데이터 중 일부만 갱신되어 데이터 불일치가 발생하는 문제."
              },
              {
                "term": "손실 분해 (Lossy Decomposition)",
                "definition": "릴레이션을 분해한 후 다시 조인했을 때, 원래 릴레이션의 정보가 손실되거나 불필요한 튜플이 생성되는 분해."
              },
              {
                "term": "관계형 스키마 (Relational Schema)",
                "definition": "관계형 데이터베이스에서 릴레이션의 이름과 속성(컬럼) 및 그들의 도메인(데이터 타입)을 정의하는 논리적 구조."
              },
              {
                "term": "데이터 무결성 (Data Integrity)",
                "definition": "데이터베이스 내의 데이터가 정확하고 일관되며 신뢰할 수 있는 상태를 유지하는 것."
              }
            ],
            "outline": [
              {
                "text": "데이터 혼합 시 발생하는 문제점",
                "id": "데이터-혼합-시-발생하는-문제점",
                "children": null
              },
              {
                "text": "해결책: 분해(Decomposition)!",
                "id": "해결책-분해-decomposition",
                "children": null
              },
              {
                "text": "분해(Decomposition)",
                "id": "분해-decomposition",
                "children": null
              },
              {
                "text": "무손실 분해(Lossless Decomposition)",
                "id": "무손실-분해-lossless-decomposition",
                "children": [
                  {
                    "text": "무손실 분해 예시",
                    "id": "무손실-분해-예시",
                    "children": null
                  }
                ]
              },
              {
                "text": "정규화(Normalization)",
                "id": "정규화-normalization",
                "children": null
              }
            ]
          },
          "quiz": [
            {
              "question": "데이터베이스에서 데이터가 혼합될 때 발생할 수 있는 주요 문제점이 아닌 것은 무엇입니까?",
              "options": [
                "데이터 중복 증가",
                "데이터 일관성 문제",
                "데이터 처리 속도 향상",
                "삽입, 삭제, 갱신 이상 발생"
              ],
              "answerIndex": 2,
              "explanation": "데이터가 혼합되면 데이터 중복과 일관성 문제가 발생하며, 이는 삽입, 삭제, 갱신 이상으로 이어져 데이터 처리 속도가 저하될 수 있습니다. 데이터 처리 속도 향상은 문제점이 아닙니다."
            },
            {
              "question": "다음 중 '원본 릴레이션을 재구성할 수 없는 분해'를 의미하는 용어는 무엇입니까?",
              "options": [
                "무손실 분해",
                "정규화",
                "손실 분해",
                "데이터 일관성"
              ],
              "answerIndex": 2,
              "explanation": "손실 분해(Lossy decomposition)는 분해 후 원본 릴레이션을 정확히 재구성할 수 없어 정보가 손실되거나 불필요한 정보가 추가되는 분해를 의미합니다."
            },
            {
              "question": "데이터베이스 정규화의 주요 목적 두 가지는 무엇입니까?",
              "options": [
                "디스크 저장 공간 증가, 데이터 처리 속도 감소",
                "데이터 중복 감소, 데이터 무결성 향상",
                "데이터 보안 강화, 사용자 인터페이스 개선",
                "보고서 생성 자동화, 백업 절차 간소화"
              ],
              "answerIndex": 1,
              "explanation": "데이터베이스 정규화의 주된 목적은 데이터 중복을 줄이고 데이터 일관성 및 정확성을 보장하는 데이터 무결성을 향상시키는 것입니다."
            }
          ]
        },
        {
          "title": "데이터베이스 정규화 과정 및 일반 형식",
          "metadata": "Source: a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf, Text length: 961 chars",
          "documentContent": [
            {
              "type": "heading",
              "content": "정규 형식 (Normal Forms)",
              "level": 1
            },
            {
              "type": "paragraph",
              "content": "정규화는 관계형 데이터베이스 테이블을 더 높은 정규 형식으로 설계하는 데 사용되는 데이터베이스 설계 기법입니다. 이 과정은 논리적으로 독립적이지만 상호 관련된 데이터 엔티티를 여러 릴레이션으로 절차적으로 분리하며, 키를 사용하여 연결을 유지합니다. 정규화는 점진적인 과정으로, 이전 단계가 충족되지 않으면 더 높은 수준의 데이터베이스 정규화를 달성할 수 없습니다. 일반적인 정규화 단계는 다음과 같습니다: UNF (비정규 형식), 1NF (제1 정규 형식), 2NF (제2 정규 형식), 3NF (제3 정규 형식), BCNF (보이스-코드 정규 형식, 3.5NF), 4NF (제4 정규 형식) 등이 있습니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "정규 형식은 일련의 정규화 이론에 의해 뒷받침됩니다. 이러한 이론에는 함수적 종속성, 부분 종속성, 이행 종속성, 다치 종속성 등이 포함됩니다. 이러한 이론들은 특정 릴레이션 R이 '좋은 형식'에 있는지 여부를 결정합니다. 만약 릴레이션 R이 '좋은 형식'이 아니라면, 각 릴레이션이 좋은 형식에 있고 분해가 손실 없는 분해(lossless decomposition)가 되도록 {R1, R2, ..., Rn}과 같은 릴레이션 집합으로 분해해야 합니다.",
              "level": null
            }
          ],
          "aiNotes": {
            "summary": "제공된 텍스트는 데이터베이스 정규화의 개념과 과정을 설명합니다. 정규화는 관계형 데이터베이스 설계 기법으로, 데이터 중복을 최소화하고 데이터 무결성을 유지하기 위해 논리적으로 독립된 데이터를 여러 릴레이션으로 분리하는 점진적인 과정입니다. UNF부터 4NF(BCNF 포함)까지의 다양한 정규 형식 단계를 소개하며, 정규화 이론이 함수적, 부분, 이행, 다치 종속성과 같은 개념에 기반을 두고 있음을 언급합니다. 또한, '좋은 형식'이 아닌 릴레이션은 손실 없는 분해를 통해 여러 '좋은 형식' 릴레이션으로 분해되어야 한다고 강조합니다.",
            "keyConcepts": [
              {
                "term": "데이터베이스 정규화 (Database Normalization)",
                "definition": {
                  "easy": "데이터를 잘 정리해서 중복을 줄이고 효율적으로 만드는 과정.",
                  "medium": "관계형 데이터베이스 설계 기법으로, 논리적으로 독립적인 데이터를 여러 관계로 분리하여 중복을 최소화하고 데이터 무결성을 유지하는 과정.",
                  "hard": "관계형 스키마 설계에서 데이터 중복을 제거하고 갱신 이상(update anomalies)을 방지하기 위해 릴레이션을 더 작은 릴레이션으로 분해하는 체계적인 과정으로, 함수적 종속성(functional dependencies)과 같은 이론적 기반을 바탕으로 한다."
                }
              },
              {
                "term": "정규 형식 (Normal Forms)",
                "definition": {
                  "easy": "데이터베이스가 얼마나 잘 정리되어 있는지 나타내는 단계.",
                  "medium": "관계형 데이터베이스 릴레이션이 특정 조건을 만족하는지 여부를 나타내는 단계로, 데이터 중복 및 이상 현상을 줄이는 데 사용된다.",
                  "hard": "관계형 데이터베이스 스키마 설계에서 릴레이션 스키마의 바람직한 속성을 정의하는 일련의 기준. 각 정규 형식은 특정 유형의 데이터 종속성(예: 부분 함수 종속, 이행 함수 종속)을 제거하여 갱신 이상을 방지하고 데이터 일관성을 향상시킨다."
                }
              },
              {
                "term": "손실 없는 분해 (Lossless Decomposition)",
                "definition": {
                  "easy": "데이터를 나눴다가 다시 합쳐도 원래 데이터가 그대로 유지되는 것.",
                  "medium": "릴레이션을 여러 개의 작은 릴레이션으로 분해할 때, 분해된 릴레이션들을 자연 조인(natural join)하여 원래의 릴레이션을 완벽하게 재구성할 수 있는 분해 방식.",
                  "hard": "관계형 데이터베이스에서 하나의 릴레이션 R을 R1, R2, ..., Rn으로 분해할 때, R = R1 ⋈ R2 ⋈ ... ⋈ Rn이 성립하여 정보 손실이 발생하지 않는 분해를 의미한다. 이는 무결성을 유지하며 중복을 제거하는 데 필수적이다."
                }
              }
            ],
            "importantTerms": [
              {
                "term": "관계형 데이터베이스 (Relational Database)",
                "definition": "데이터를 테이블(릴레이션) 형태로 저장하고 관리하는 데이터베이스 시스템."
              },
              {
                "term": "함수적 종속성 (Functional Dependency)",
                "definition": "릴레이션에서 어떤 속성 집합 X의 값이 다른 속성 집합 Y의 값을 유일하게 결정하는 관계 (X → Y)."
              },
              {
                "term": "부분 함수 종속성 (Partial Dependency)",
                "definition": "기본 키의 일부에 의해 결정되는 비기본 키 속성이 존재하는 경우."
              },
              {
                "term": "이행 함수 종속성 (Transitive Dependency)",
                "definition": "A → B이고 B → C가 성립할 때, A → C가 성립하며 B가 기본 키의 일부가 아닌 경우."
              },
              {
                "term": "다치 종속성 (Multi-valued Dependency)",
                "definition": "릴레이션에서 한 속성의 값이 다른 속성의 여러 값을 결정하는 경우."
              },
              {
                "term": "릴레이션 (Relation)",
                "definition": "관계형 데이터베이스에서 데이터를 저장하는 테이블."
              }
            ],
            "outline": [
              {
                "text": "정규 형식의 개요",
                "id": "정규-형식의-개요",
                "children": [
                  {
                    "text": "정규화 과정의 정의 및 목적",
                    "id": "정규화-과정의-정의-및-목적",
                    "children": null
                  },
                  {
                    "text": "정규화 단계",
                    "id": "정규화-단계",
                    "children": null
                  }
                ]
              },
              {
                "text": "정규 형식의 이론적 배경",
                "id": "정규-형식의-이론적-배경",
                "children": [
                  {
                    "text": "정규화 이론의 기초",
                    "id": "정규화-이론의-기초",
                    "children": null
                  },
                  {
                    "text": "릴레이션 분해의 원칙",
                    "id": "릴레이션-분해의-원칙",
                    "children": null
                  }
                ]
              }
            ]
          },
          "quiz": [
            {
              "question": "데이터베이스 정규화의 주요 목적은 무엇입니까?",
              "options": [
                "데이터 저장 공간 확장",
                "데이터 중복 최소화 및 무결성 유지",
                "데이터베이스 보안 강화",
                "쿼리 처리 속도 저하"
              ],
              "answerIndex": 1,
              "explanation": "정규화는 데이터 중복을 줄이고 논리적으로 독립적인 데이터를 분리하여 데이터 무결성을 유지하는 데 중점을 둡니다."
            },
            {
              "question": "다음 중 주어진 텍스트에서 데이터베이스 정규화의 단계로 명시적으로 언급되지 않은 것은 무엇입니까?",
              "options": [
                "1NF",
                "BCNF",
                "5NF",
                "UNF"
              ],
              "answerIndex": 2,
              "explanation": "주어진 텍스트에서 언급된 정규화 단계는 UNF, 1NF, 2NF, 3NF, BCNF, 4NF입니다. 5NF는 언급되지 않았습니다."
            },
            {
              "question": "릴레이션 R을 R1, R2, ..., Rn으로 분해할 때, 분해된 릴레이션들을 조인하여 원래의 R을 완벽하게 재구성할 수 있는 분해를 무엇이라고 합니까?",
              "options": [
                "손실 있는 분해",
                "부분 분해",
                "손실 없는 분해",
                "비정규 분해"
              ],
              "answerIndex": 2,
              "explanation": "텍스트에 따르면, '좋은 형식'이 아닌 릴레이션을 분해할 때, 'The decomposition is a lossless decomposition' 즉, 손실 없는 분해여야 한다고 명시되어 있습니다."
            }
          ]
        },
        {
          "title": "함수적 종속성 이해",
          "metadata": "Source: a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf, Text length: 3925 chars",
          "documentContent": [
            {
              "type": "heading",
              "content": "함수적 종속성 (Functional Dependencies)",
              "level": 1
            },
            {
              "type": "paragraph",
              "content": "데이터베이스 시스템에서 데이터는 일반적으로 현실 세계의 다양한 제약 조건(규칙)을 따릅니다. 예를 들어, 대학 데이터베이스에서 예상되는 몇 가지 제약 조건은 다음과 같습니다:",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "학생과 강사는 ID에 의해 고유하게 식별됩니다. 각 학생과 강사는 하나의 이름만 가집니다. 각 강사와 학생은 (주로) 하나의 학과에만 연결됩니다. 각 학과는 예산에 대해 하나의 값만 가지며, 하나의 건물과만 연결됩니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "릴레이션은 특정 속성 집합의 값이 다른 속성 집합의 값을 고유하게 결정해야 한다고 요구합니다. 함수적 종속성은 키의 개념을 일반화한 것입니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "함수적 종속성의 정의",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "R을 릴레이션 스키마라고 하고, a와 b를 R의 속성이라고 합시다 (a ⊆ R, b ⊆ R). 함수적 종속성 a → b는 릴레이션 r(R)의 어떤 두 튜플 t1과 t2가 속성 a에 대해 일치할 때마다 속성 b에 대해서도 일치하는 경우에만 R에서 성립합니다. 즉, t1[a] = t2[a] ⇒ t1[b] = t2[b] 입니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "예를 들어, 다음 인스턴스를 가진 릴레이션 r(A, B)를 고려해 봅시다:",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "A     B\n1     4\n1     5\n3     7",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "이 인스턴스에서 B → A는 성립합니다. 그러나 A → B는 성립하지 않습니다. (A 값이 1일 때 B 값이 4와 5로 다르기 때문입니다).",
              "level": null
            },
            {
              "type": "heading",
              "content": "키와 함수적 종속성",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "함수적 종속성은 슈퍼키를 사용하여 표현할 수 없는 제약 조건을 표현할 수 있게 합니다. 예를 들어, `in_dep (ID, name, salary, dept_name, building, budget)` 스키마를 고려해 봅시다. 여기서 ID는 강사 ID이고, dept_name은 강사의 학과입니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "우리는 다음 함수적 종속성이 성립할 것으로 예상합니다:",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "• `dept_name` → `building`\n• `ID` → `building`",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "`dept_name`과 `ID`는 슈퍼키이자 후보 키입니다. 하지만 `dept_name` → `salary`는 성립하지 않을 것으로 예상합니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "부분 종속성 (Partial Dependency)",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "릴레이션 R = a1 a2 a3 a4에서 a1이 키의 일부라고 가정해 봅시다. 함수적 종속성에서 a4가 키인 a1a2a3에 종속되는 것은 일반적입니다. 그러나 a4가 전체 키가 아닌 키의 일부인 a1에만 종속되고 a1a2a3에는 종속되지 않는 경우 (a1 → a4) 이를 부분 종속성이라고 합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "예를 들어, `b_id, b_name, bd_detail_attrib1, bd_detail_attrib2`와 같은 속성 집합에서 후보 키는 `b_id`, `b_name`, `{b_id, b_name}` 등이 될 수 있습니다. 여기서 `bd_detail_attrib1`이 `b_id`에만 종속되고 `{b_id, b_name}`에는 종속되지 않는다면 부분 종속성입니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "자명한 함수적 종속성 (Trivial Functional Dependencies)",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "함수적 종속성은 모든 릴레이션 인스턴스에서 항상 만족될 때 자명하다고 합니다. 예를 들어, `ID, name → ID` 또는 `name → name`과 같은 종속성은 자명합니다. 일반적으로, `a → b`는 b가 a의 부분집합(b ⊆ a)일 때 자명한 종속성입니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "함수적 종속성 예시",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "`student2(ID, name, tot_cred)` 릴레이션을 예로 들면:",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "• `ID → name` (성립)\n• `ID → tot_cred` (성립)\n• `tot_cred → name` (성립하지 않음)\n• `name → tot_cred` (성립하지 않음)",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "`SCORE(score_id, student_id, subject_id, score)` 릴레이션의 경우:",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "• `{student_id, subject_id} → score` (성립)",
              "level": null
            }
          ],
          "aiNotes": {
            "summary": "이 문서는 데이터베이스 시스템에서 중요한 개념인 함수적 종속성에 대해 설명합니다. 함수적 종속성은 현실 세계의 데이터 제약 조건을 표현하며, 특정 속성 집합이 다른 속성 집합의 값을 고유하게 결정하는 관계를 의미합니다. 문서에서는 함수적 종속성의 정의, 키와의 관계, 부분 종속성 및 자명한 종속성의 개념을 다루고, 다양한 예시를 통해 이해를 돕습니다.",
            "keyConcepts": [
              {
                "term": "함수적 종속성 (Functional Dependency)",
                "definition": {
                  "easy": "데이터베이스에서 한 데이터가 다른 데이터를 딱 하나로 정해주는 관계입니다. 예를 들어, 학생 ID를 알면 학생 이름을 알 수 있는 관계처럼요.",
                  "medium": "릴레이션 스키마 R에서 속성 집합 A의 값이 주어졌을 때 속성 집합 B의 값이 항상 고유하게 결정되는 경우, A는 B에 함수적으로 종속된다고 하며 A → B로 표기합니다.",
                  "hard": "데이터베이스 릴레이션 r(R)에서, 모든 튜플 t1, t2에 대해 t1[A] = t2[A]일 때 t1[B] = t2[B]가 성립하면 속성 집합 A는 속성 집합 B를 함수적으로 결정한다고 하며 A → B로 표현합니다. 이는 데이터의 일관성과 무결성을 보장하며 정규화 과정의 핵심 기반이 됩니다."
                }
              },
              {
                "term": "자명한 종속성 (Trivial Dependency)",
                "definition": {
                  "easy": "누구나 당연히 아는 관계입니다. 예를 들어, '이름과 나이를 알면 이름을 알 수 있다'는 식이죠.",
                  "medium": "함수적 종속성 A → B에서 B가 A의 부분집합(B ⊆ A)인 경우, 이 종속성은 자명한 종속성이라고 합니다. 이는 항상 참이며 데이터베이스의 특정 제약 조건을 나타내지 않습니다.",
                  "hard": "릴레이션의 모든 가능한 인스턴스에서 항상 만족되는 함수적 종속성을 의미합니다. 특히, 결정자(determinant) 속성 집합이 종속자(dependent) 속성 집합을 포함하거나 동일할 때 발생하며, 이는 새로운 정보를 제공하지 않는 내재적인 관계입니다."
                }
              },
              {
                "term": "부분 종속성 (Partial Dependency)",
                "definition": {
                  "easy": "키의 일부만 알아도 다른 데이터를 알 수 있는 관계입니다. 키 전체가 필요한데 일부만으로도 알 수 있으면 부분 종속성입니다.",
                  "medium": "릴레이션 R의 후보 키 X에 대해, 속성 A가 X에 함수적으로 종속되지만 X의 진부분집합(proper subset)에도 종속되는 경우 A는 X에 대해 부분 종속성을 가집니다.",
                  "hard": "릴레이션의 비키 속성(non-key attribute)이 후보 키 전체에 함수적으로 종속되는 것이 아니라, 후보 키의 진부분집합(proper subset)에 함수적으로 종속되는 현상을 말합니다. 이는 제2정규형(2NF) 위반의 원인이 되며 데이터 중복 및 갱신 이상을 유발할 수 있습니다."
                }
              },
              {
                "term": "후보 키 (Candidate Key)",
                "definition": {
                  "easy": "테이블의 각 행을 유일하게 구분할 수 있는 최소한의 정보입니다. 주민등록번호처럼요.",
                  "medium": "릴레이션의 모든 튜플을 유일하게 식별할 수 있는 속성(또는 속성 집합) 중, 더 이상 줄일 수 없는 최소한의 속성 집합입니다. 후보 키 중 하나가 기본 키로 선택됩니다.",
                  "hard": "릴레이션 스키마 R에서 모든 비키 속성을 함수적으로 결정할 수 있는 최소 슈퍼키를 의미합니다. 후보 키는 유일성(uniqueness)과 최소성(minimality)을 만족해야 하며, 릴레이션의 각 튜플을 고유하게 식별하는 데 사용될 수 있는 모든 속성 집합을 포함합니다."
                }
              }
            ],
            "importantTerms": [
              {
                "term": "릴레이션 스키마 (Relation Schema)",
                "definition": "릴레이션의 이름과 속성(컬럼)들의 정의를 포함하는 논리적 구조입니다."
              },
              {
                "term": "튜플 (Tuple)",
                "definition": "릴레이션의 한 행을 구성하는 값들의 집합으로, 객체의 특정 인스턴스를 나타냅니다."
              },
              {
                "term": "속성 (Attribute)",
                "definition": "릴레이션의 열(컬럼)을 의미하며, 특정 종류의 정보를 담는 데이터 항목입니다."
              },
              {
                "term": "슈퍼키 (Superkey)",
                "definition": "릴레이션의 모든 튜플을 유일하게 식별할 수 있는 하나 이상의 속성 집합입니다."
              },
              {
                "term": "제약 조건 (Constraint)",
                "definition": "데이터베이스에 저장될 수 있는 데이터의 규칙 또는 조건을 정의하는 것입니다."
              }
            ],
            "outline": [
              {
                "text": "함수적 종속성 개요",
                "id": "함수적-종속성-개요",
                "children": [
                  {
                    "text": "데이터 제약 조건",
                    "id": "데이터-제약-조건",
                    "children": null
                  },
                  {
                    "text": "함수적 종속성의 정의",
                    "id": "함수적-종속성의-정의",
                    "children": null
                  }
                ]
              },
              {
                "text": "함수적 종속성의 상세 이해",
                "id": "함수적-종속성의-상세-이해",
                "children": [
                  {
                    "text": "정의 및 예시",
                    "id": "정의-및-예시",
                    "children": null
                  },
                  {
                    "text": "키와 함수적 종속성",
                    "id": "키와-함수적-종속성",
                    "children": null
                  },
                  {
                    "text": "부분 종속성",
                    "id": "부분-종속성",
                    "children": null
                  },
                  {
                    "text": "자명한 함수적 종속성",
                    "id": "자명한-함수적-종속성",
                    "children": null
                  }
                ]
              },
              {
                "text": "함수적 종속성 예시",
                "id": "함수적-종속성-예시",
                "children": null
              }
            ]
          },
          "quiz": [
            {
              "question": "다음 중 함수적 종속성 A → B가 성립하는 조건으로 가장 정확한 것은 무엇입니까?",
              "options": [
                "릴레이션의 어떤 두 튜플 t1과 t2가 속성 A에 대해 일치할 때, 속성 B에 대해서도 일치하는 경우",
                "속성 A의 값이 변경되면 속성 B의 값도 항상 변경되는 경우",
                "속성 A와 속성 B가 동일한 데이터 타입을 가지는 경우",
                "속성 B가 속성 A의 부분집합인 경우"
              ],
              "answerIndex": 0,
              "explanation": "함수적 종속성 A → B는 A의 값이 같으면 B의 값도 항상 같아야 한다는 것을 의미합니다. 즉, t1[A] = t2[A]이면 t1[B] = t2[B]가 성립해야 합니다."
            },
            {
              "question": "다음 함수적 종속성 중 자명한 종속성(Trivial Functional Dependency)의 예시가 아닌 것은 무엇입니까?",
              "options": [
                "ID, Name → ID",
                "Name → Name",
                "ID → Name",
                "A, B, C → A"
              ],
              "answerIndex": 2,
              "explanation": "자명한 종속성은 종속자(오른쪽)가 결정자(왼쪽)의 부분집합인 경우를 말합니다. 'ID → Name'은 ID가 Name의 부분집합이 아니므로 자명한 종속성이 아닙니다. ID를 알면 Name을 알 수 있지만, Name은 ID에 포함되지 않습니다."
            },
            {
              "question": "릴레이션 `in_dep (ID, name, salary, dept_name, building, budget)`에서 `dept_name`이 `building`을 결정하고, `ID`가 `building`을 결정한다고 할 때, `dept_name`과 `ID`는 어떤 키에 해당됩니까?",
              "options": [
                "외래 키",
                "기본 키",
                "후보 키",
                "보조 키"
              ],
              "answerIndex": 2,
              "explanation": "텍스트에 따르면, `dept_name`과 `ID`는 `building`을 결정하는 속성이며, 이는 슈퍼키이자 후보 키에 해당합니다. 후보 키는 릴레이션의 각 튜플을 유일하게 식별할 수 있는 최소한의 속성 집합입니다."
            }
          ]
        },
        {
          "title": "제1 정규형 (1NF): 원자성 및 고유성",
          "metadata": "Source: a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf, Text length: 1478 chars",
          "documentContent": [
            {
              "type": "heading",
              "content": "제1 정규형 (1NF) 개요",
              "level": 1
            },
            {
              "type": "paragraph",
              "content": "데이터베이스 정규화의 첫 번째 단계인 제1 정규형(1NF)은 관계형 데이터베이스 설계의 기본 원칙을 제시합니다. 본문에서는 1NF의 핵심 요구사항과 체크리스트, 그리고 실제 적용 예시를 통해 1NF의 중요성을 설명합니다. 1NF를 따르지 않는 데이터베이스는 사용을 중단해야 할 만큼 중요하게 간주됩니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "1NF의 요구사항",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "제1 정규형은 다음의 주요 요구사항을 충족해야 합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "**원자성 값**: 릴레이션의 모든 속성은 원자적 값으로 구성되어야 합니다. 원자적 값은 더 이상 나눌 수 없는 단일 값을 의미하며, 자바의 기본 데이터 타입(INT, FLOAT, DOUBLE, DECIMAL (NUMERIC), CHAR, VARCHAR, BLOB, TEXT)과 유사합니다. 구조체나 리스트(배열)와 같이 여러 값을 포함하는 형태는 원자적이지 않아 허용되지 않습니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "**고유 식별자**: 각 속성(열)은 고유한 식별자를 가져야 합니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "1NF 체크리스트",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "제1 정규형을 만족하는지 확인하기 위한 체크리스트는 다음과 같습니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "1. 각 열은 원자적 값을 포함해야 합니다. (예: (x, y)와 같은 항목은 이 규칙을 위반합니다.)",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "2. 각 열은 동일한 데이터 도메인에 속하는 값을 포함해야 합니다. (다른 유형의 값을 한 열에 혼합하지 마십시오.)",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "3. 각 열은 고유한 이름을 가져야 합니다. (중복된 이름은 데이터 접근 시 혼란을 야기합니다.)",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "4. 데이터가 저장되는 순서는 중요하지 않습니다. (SQL을 사용하면 어떤 순서로든 데이터를 쉽게 가져올 수 있습니다.)",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "5. 테이블에 중복된 행이 없어야 합니다. 기본 키(PK)는 다음을 보장합니다:",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "    * 기본 키의 일부인 속성은 고유합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "    * 기본 키의 일부인 속성은 NULL이 될 수 없습니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "1NF 예시",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "다음은 제1 정규형을 만족하지 않는 테이블과 이를 만족하도록 정규화된 테이블의 예시입니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "초기 테이블 'student_id', 'name', 'course'에서 'course' 열이 'Algorithm, OS'와 같이 여러 값을 포함하여 1NF를 위반합니다. 이를 해결하기 위해 테이블을 'student_id', 'name'으로 구성된 학생 정보 테이블과 'student_id', 'course'로 구성된 수강 정보 테이블로 분리합니다. 이 과정을 통해 각 열이 원자적 값을 가지며 중복된 정보를 효과적으로 관리하여 1NF를 만족시킵니다.",
              "level": null
            }
          ],
          "aiNotes": {
            "summary": "제1 정규형(1NF)은 관계형 데이터베이스 정규화의 첫 번째 단계로, 테이블의 모든 속성이 원자적 값을 가져야 하고, 각 열이 고유한 이름을 가지며, 동일한 데이터 도메인에 속해야 함을 강조한다. 또한 테이블에 중복된 행이 없어야 하며, 이는 기본 키(PK)를 통해 보장된다. 비원자적 값을 포함하는 예시 테이블을 통해 1NF 준수 방법을 설명한다.",
            "keyConcepts": [
              {
                "term": "원자적 값 (Atomic Value)",
                "definition": {
                  "easy": "더 이상 나눌 수 없는 가장 작은 데이터 조각.",
                  "medium": "관계형 데이터베이스에서 하나의 속성(열)이 가질 수 있는 최소 단위의 값으로, 더 이상 의미 있는 단위로 분해될 수 없는 단일 값을 의미한다.",
                  "hard": "데이터베이스 릴레이션의 모든 속성에 대해 단일하고 불가분한 값을 요구하는 개념으로, 복합 값(예: 주소의 도시, 거리, 우편번호)이나 다중 값(예: 리스트, 배열)을 허용하지 않음으로써 데이터의 일관성과 무결성을 보장하는 제1 정규형의 핵심 조건이다."
                }
              },
              {
                "term": "제1 정규형 (First Normal Form, 1NF)",
                "definition": {
                  "easy": "데이터베이스 테이블을 깔끔하게 정리하는 첫 번째 규칙으로, 각 칸에 딱 하나의 정보만 들어가고, 같은 줄이 중복되지 않게 하는 것.",
                  "medium": "관계형 데이터베이스 정규화 과정의 첫 단계로, 모든 속성(열)이 원자적 값을 가져야 하고, 각 속성 이름이 고유해야 하며, 테이블 내에 중복된 행이 없어야 한다는 조건을 만족하는 형태이다.",
                  "hard": "관계형 스키마가 비원자적 도메인을 포함하지 않고, 각 릴레이션이 고유한 튜플(행)을 가지며, 모든 속성이 단일 값을 포함하도록 보장하여 데이터의 일관성과 질의 효율성을 높이는 데이터 모델링의 기초적인 요건이다."
                }
              },
              {
                "term": "기본 키 (Primary Key, PK)",
                "definition": {
                  "easy": "테이블에서 각 줄을 유일하게 구분해주는 중요한 값.",
                  "medium": "관계형 데이터베이스 테이블에서 각 행(튜플)을 고유하게 식별할 수 있는 하나 이상의 속성(열)들의 집합이다. 기본 키의 모든 속성은 고유하며 NULL 값을 가질 수 없다.",
                  "hard": "릴레이션 내의 모든 튜플을 고유하게 식별할 수 있는 최소 슈퍼키(Minimal Superkey)로서, 데이터 무결성 제약 조건의 핵심 구성 요소이다. 기본 키로 지정된 속성들은 반드시 고유성(Uniqueness)과 비NULL성(Non-nullability)을 만족해야 하며, 다른 테이블과의 관계 설정(외래 키)에 사용될 수 있다."
                }
              }
            ],
            "importantTerms": [
              {
                "term": "릴레이션 (Relation)",
                "definition": "데이터베이스에서 테이블을 지칭하는 용어."
              },
              {
                "term": "속성 (Attribute)",
                "definition": "테이블의 열(컬럼)을 지칭하는 용어."
              },
              {
                "term": "정규화 (Normalization)",
                "definition": "데이터 중복을 줄이고 무결성을 향상시키기 위해 테이블을 구조화하는 과정."
              },
              {
                "term": "데이터 도메인 (Data Domain)",
                "definition": "특정 열에 올 수 있는 값들의 집합."
              },
              {
                "term": "중복 행 (Duplicated Rows)",
                "definition": "테이블 내에 완전히 동일한 내용을 가진 두 개 이상의 행."
              }
            ],
            "outline": [
              {
                "text": "제1 정규형 (1NF) 개요",
                "id": "제1-정규형-1nf-개요",
                "children": null
              },
              {
                "text": "1NF의 요구사항",
                "id": "1nf의-요구사항",
                "children": null
              },
              {
                "text": "1NF 체크리스트",
                "id": "1nf-체크리스트",
                "children": null
              },
              {
                "text": "1NF 예시",
                "id": "1nf-예시",
                "children": null
              }
            ]
          },
          "quiz": [
            {
              "question": "제1 정규형(1NF)의 핵심 요구사항 중 하나는 무엇입니까?",
              "options": [
                "모든 속성 값이 원자적이어야 한다.",
                "데이터 중복을 허용한다.",
                "각 열의 이름이 중복될 수 있다.",
                "데이터 저장 순서가 중요해야 한다."
              ],
              "answerIndex": 0,
              "explanation": "제1 정규형의 가장 중요한 요구사항 중 하나는 릴레이션의 모든 속성 값이 더 이상 나눌 수 없는 원자적이어야 한다는 것입니다."
            },
            {
              "question": "다음 중 제1 정규형(1NF)을 위반하는 예시는 무엇입니까?",
              "options": [
                "열에 정수 값만 포함되어 있다.",
                "각 열이 고유한 이름을 가지고 있다.",
                "하나의 셀에 '사과, 바나나, 체리'와 같이 여러 값이 콤마로 구분되어 있다.",
                "테이블에 중복된 행이 없다."
              ],
              "answerIndex": 2,
              "explanation": "1NF는 각 열이 원자적 값, 즉 더 이상 나눌 수 없는 단일 값을 포함해야 한다고 명시합니다. '사과, 바나나, 체리'와 같이 콤마로 구분된 여러 값은 비원자적이므로 1NF를 위반합니다."
            },
            {
              "question": "제1 정규형(1NF) 원칙에 따라 기본 키(PK)가 테이블에서 보장하는 것은 무엇입니까?",
              "options": [
                "속성이 선택 사항일 수 있다.",
                "속성이 여러 값을 포함할 수 있다.",
                "속성이 고유하며 NULL 값을 가질 수 없다.",
                "속성이 중복될 수 있다."
              ],
              "answerIndex": 2,
              "explanation": "1NF 체크리스트에 따르면, 기본 키(PK)는 해당 속성들이 고유하며 NULL 값을 가질 수 없음을 보장하여 테이블에 중복된 행이 없도록 합니다."
            }
          ]
        },
        {
          "title": "제2 정규형 (2NF): 부분 종속성 제거",
          "metadata": "Source: a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf, Text length: 1851 chars",
          "documentContent": [
            {
              "type": "heading",
              "content": "제2 정규형 (2NF): 부분 종속성 제거",
              "level": 1
            },
            {
              "type": "heading",
              "content": "제2 정규형 (2NF)의 요구사항",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "제2 정규형(Second Normal Form, 2NF)은 데이터베이스 정규화의 한 단계로, 관계형 데이터베이스에서 데이터 중복을 줄이고 데이터 무결성을 향상시키기 위한 규칙 집합입니다. 2NF를 만족하기 위한 주요 요구사항은 다음과 같습니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "1.  **제1 정규형(1NF)을 만족해야 합니다.** 정규형은 순서대로 적용되어야 합니다. 즉, 2NF를 적용하기 전에 해당 릴레이션은 이미 1NF를 만족하고 있어야 합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "2.  **부분 종속성이 없어야 합니다.** 기본 키(Primary Key, PK)가 아닌 속성(Non-PK attribute)이 후보 키(Candidate Key)의 어떤 부분 집합에도 함수적으로 종속되어서는 안 됩니다. 이는 부분 종속성이 없어야 한다는 것을 의미합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "3.  **기본 키에 완전 함수 종속적이어야 합니다.** 기본 키가 아닌 모든 속성은 기본 키 전체에 함수적으로 종속되어야 합니다. 즉, 테이블의 모든 비기본 키 속성은 기본 키의 일부가 아니라 기본 키 전체에 의존해야 합니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "기본 키(PK)란?",
              "level": 3
            },
            {
              "type": "paragraph",
              "content": "기본 키는 릴레이션(테이블) 내의 각 튜플(행)을 고유하게 식별하는 하나 또는 여러 속성의 집합입니다. 기본 키를 통해 릴레이션 내의 특정 데이터를 가져올 수 있습니다. 예를 들어, `student_ID = 21800999`를 사용하여 학생의 학과 이름을 가져올 수 있습니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "부분 종속성",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "부분 종속성은 기본 키가 복합 키(두 개 이상의 속성으로 구성된 키)일 때 발생합니다. 릴레이션 R이 `a1 a2 a3 a4`로 구성되어 있고, 기본 키가 `a1 a2 a3`라고 가정해 봅시다. 만약 `a4`가 기본 키의 일부인 `a1`에만 종속되고 기본 키 전체인 `a1a2a3`에는 종속되지 않는다면(`a1 -> a4`), 이는 부분 종속성입니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "부분 종속성 제거",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "부분 종속성을 제거하기 위해서는 릴레이션을 두 개 이상의 새로운 릴레이션으로 분해해야 합니다. 각 새로운 릴레이션은 부분 종속성이 없는 형태로 구성됩니다. 다음은 예시를 통해 부분 종속성 제거 과정을 설명합니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "예시 1: teaches2 릴레이션",
              "level": 3
            },
            {
              "type": "paragraph",
              "content": "`teaches2(ID, course_id, sec_id, semester, year, name)` 릴레이션에서 기본 키는 `{ID, course_id, sec_id, semester, year}`로 가정합니다. 이 때, `ID`는 학생의 이름을 결정하는 `ID -> name`이라는 함수 종속성이 존재한다고 가정합시다. `name`은 기본 키의 일부인 `ID`에만 종속되므로, 이는 부분 종속성입니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "이 부분 종속성을 제거하기 위해 `teaches2` 릴레이션을 다음과 같이 분해할 수 있습니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "- `teaches2a(ID, course_id, sec_id, semester, year)`: 기본 키는 `{ID, course_id, sec_id, semester, year}`입니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "- `teaches2b(ID, name)`: 기본 키는 `ID`입니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "이렇게 분해함으로써 `name`은 `teaches2b` 릴레이션에서 `ID`에 완전 함수 종속적이게 되며, `teaches2a` 릴레이션에는 부분 종속성이 제거됩니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "예시 2: score 릴레이션",
              "level": 3
            },
            {
              "type": "paragraph",
              "content": "`score(score_id, student_id, subject_id, score, instructor)` 릴레이션을 살펴봅시다. 기본 키가 `{score_id, student_id, subject_id}`라고 가정했을 때, `subject_id`가 `instructor`를 결정하는 `subject_id -> instructor`라는 함수 종속성이 존재합니다. 이는 `instructor`가 기본 키의 일부인 `subject_id`에만 종속되므로 부분 종속성입니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "부분 종속성을 제거하기 위해 `score` 릴레이션을 다음과 같이 분해합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "- `score_a(score_id, student_id, subject_id, score)`: 기본 키는 `{score_id, student_id, subject_id}`입니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "- `score_b(subject_id, instructor)`: 기본 키는 `subject_id`입니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "이러한 분해를 통해 `score` 릴레이션의 부분 종속성이 제거되고 2NF를 만족하게 됩니다.",
              "level": null
            }
          ],
          "aiNotes": {
            "summary": "제2 정규형(2NF)은 데이터베이스 정규화의 한 단계로, 릴레이션이 제1 정규형을 만족하고 부분 종속성이 없어야 한다는 요구사항을 가집니다. 부분 종속성이란 기본 키가 복합 키일 때, 기본 키가 아닌 속성이 기본 키의 전체가 아닌 일부에만 함수적으로 종속되는 경우를 의미합니다. 부분 종속성을 제거하기 위해서는 해당 릴레이션을 두 개 이상의 새로운 릴레이션으로 분해하여 각 릴레이션이 2NF를 만족하도록 해야 합니다. `teaches2`와 `score` 릴레이션의 예시를 통해 부분 종속성을 식별하고 제거하는 과정을 설명합니다.",
            "keyConcepts": [
              {
                "term": "제2 정규형 (2NF)",
                "definition": {
                  "easy": "데이터베이스 테이블이 깔끔하게 정리되는 두 번째 단계로, 중복 데이터를 줄이기 위해 복합 키의 일부에만 의존하는 정보가 없어야 합니다.",
                  "medium": "릴레이션이 제1 정규형을 만족하면서, 기본 키가 아닌 모든 속성이 기본 키의 어떠한 부분 집합에도 함수적으로 종속되지 않는 형태를 의미합니다. 즉, 부분 종속성이 존재하지 않아야 합니다.",
                  "hard": "데이터 모델링에서 릴레이션 스키마가 제1 정규형의 조건을 충족하고, 추가적으로 모든 비기본(non-prime) 속성이 해당 릴레이션의 모든 후보 키(candidate key)에 대해 완전 함수 종속(fully functionally dependent)이어야 함을 명시하는 정규화 단계입니다. 이는 복합 키의 부분 집합에 대한 함수 종속성을 제거하여 갱신 이상(update anomalies)을 방지하는 데 기여합니다."
                }
              },
              {
                "term": "부분 종속성",
                "definition": {
                  "easy": "테이블의 기본 키가 여러 개로 이루어져 있을 때, 키가 아닌 다른 정보가 전체 기본 키가 아니라 그 일부에만 의존하는 경우입니다.",
                  "medium": "릴레이션의 기본 키가 복합 키일 때, 기본 키가 아닌 속성이 기본 키의 일부 속성 집합에만 함수적으로 종속되고 기본 키 전체에는 종속되지 않는 현상을 말합니다.",
                  "hard": "릴레이션 R의 스키마에서 X가 R의 후보 키이고, Y가 X의 진부분 집합(proper subset)이며, Z가 R의 비기본 속성(non-prime attribute)일 때, Y -> Z인 함수 종속성이 존재하고 Y가 Z를 완전하게 결정하지만 X는 Z를 완전하게 결정하지 않는 경우를 의미합니다. 이는 데이터 중복과 삽입, 삭제, 갱신 이상을 야기할 수 있습니다."
                }
              },
              {
                "term": "기본 키 (PK)",
                "definition": {
                  "easy": "테이블에서 각 줄(데이터)을 정확히 하나씩 구분할 수 있게 해주는 특별한 정보(예: 학번, 주민등록번호)입니다.",
                  "medium": "릴레이션(테이블) 내의 각 튜플(행)을 고유하게 식별할 수 있는 하나 또는 여러 속성의 집합입니다. 기본 키는 중복 값을 가질 수 없으며, NULL 값을 허용하지 않습니다.",
                  "hard": "관계형 데이터 모델에서 릴레이션의 각 튜플을 고유하게 식별하기 위해 선택된 후보 키입니다. 기본 키를 구성하는 속성들은 최소성(minimality), 고유성(uniqueness), 비NULL(not null) 속성을 만족해야 하며, 릴레이션의 무결성 제약 조건 중 개체 무결성(entity integrity)을 보장하는 핵심 요소입니다."
                }
              }
            ],
            "importantTerms": [
              {
                "term": "릴레이션",
                "definition": "관계형 데이터베이스에서 데이터를 저장하는 테이블을 의미합니다."
              },
              {
                "term": "튜플",
                "definition": "릴레이션(테이블)의 각 행을 의미하며, 하나의 레코드를 나타냅니다."
              },
              {
                "term": "속성",
                "definition": "릴레이션(테이블)의 각 열을 의미하며, 데이터의 특정 특성을 나타냅니다."
              },
              {
                "term": "함수 종속성",
                "definition": "릴레이션 R에서 속성 집합 X가 속성 Y를 함수적으로 결정하는 관계 (X -> Y)를 의미합니다. 즉, X의 값이 Y의 값을 고유하게 결정합니다."
              },
              {
                "term": "후보 키",
                "definition": "릴레이션 내의 각 튜플을 고유하게 식별할 수 있는 최소한의 속성 집합입니다. 후보 키 중 하나가 기본 키로 선택됩니다."
              },
              {
                "term": "복합 키",
                "definition": "두 개 이상의 속성(컬럼)으로 구성된 기본 키를 의미합니다."
              }
            ],
            "outline": [
              {
                "text": "제2 정규형 (2NF): 부분 종속성 제거",
                "id": "제2-정규형-2nf-부분-종속성-제거",
                "children": [
                  {
                    "text": "제2 정규형 (2NF)의 요구사항",
                    "id": "제2-정규형-2nf-의-요구사항",
                    "children": [
                      {
                        "text": "기본 키(PK)란?",
                        "id": "기본-키-pk-란",
                        "children": null
                      }
                    ]
                  },
                  {
                    "text": "부분 종속성",
                    "id": "부분-종속성",
                    "children": null
                  },
                  {
                    "text": "부분 종속성 제거",
                    "id": "부분-종속성-제거",
                    "children": [
                      {
                        "text": "예시 1: teaches2 릴레이션",
                        "id": "예시-1-teaches2-릴레이션",
                        "children": null
                      },
                      {
                        "text": "예시 2: score 릴레이션",
                        "id": "예시-2-score-릴레이션",
                        "children": null
                      }
                    ]
                  }
                ]
              }
            ]
          },
          "quiz": [
            {
              "question": "다음 중 제2 정규형(2NF)을 만족하기 위한 필수 요구사항이 아닌 것은 무엇입니까?",
              "options": [
                "릴레이션이 제1 정규형(1NF)을 만족해야 한다.",
                "기본 키가 아닌 속성이 후보 키의 어떤 부분 집합에도 함수적으로 종속되어서는 안 된다.",
                "모든 다중 값 속성이 제거되어야 한다.",
                "기본 키가 아닌 모든 속성은 기본 키 전체에 함수적으로 종속되어야 한다."
              ],
              "answerIndex": 2,
              "explanation": "다중 값 속성의 제거는 제1 정규형(1NF)의 요구사항 중 하나입니다. 제2 정규형은 1NF를 만족하는 것을 전제로 하며, 부분 종속성 제거에 중점을 둡니다."
            },
            {
              "question": "릴레이션 R(A, B, C, D)에서 기본 키가 {A, B}이고, D가 A에만 함수적으로 종속되는 경우 (A -> D)는 어떤 종류의 종속성에 해당합니까?",
              "options": [
                "완전 함수 종속성",
                "부분 종속성",
                "이행 종속성",
                "다치 종속성"
              ],
              "answerIndex": 1,
              "explanation": "D가 기본 키의 일부인 A에만 종속되고 기본 키 전체인 {A, B}에 종속되지 않는 경우를 부분 종속성이라고 합니다."
            },
            {
              "question": "teaches2(ID, course_id, sec_id, semester, year, name) 릴레이션에서 ID -> name이라는 부분 종속성을 제거하기 위해 분해된 두 개의 릴레이션 중 올바른 조합은 무엇입니까?",
              "options": [
                "teaches2a(ID, course_id, sec_id, semester, year)와 teaches2b(ID, name)",
                "teaches2a(ID, name)와 teaches2b(course_id, sec_id, semester, year)",
                "teaches2a(ID, course_id, name)와 teaches2b(sec_id, semester, year)",
                "teaches2a(ID, course_id, sec_id)와 teaches2b(semester, year, name)"
              ],
              "answerIndex": 0,
              "explanation": "부분 종속성 ID -> name을 제거하기 위해, name 속성과 그 결정자인 ID를 별도의 테이블로 분리하고, 나머지 속성들은 원래의 기본 키와 함께 새로운 테이블을 구성합니다."
            }
          ]
        },
        {
          "title": "제3 정규형 (3NF): 이행적 종속성 제거",
          "metadata": "Source: a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf, Text length: 1245 chars",
          "documentContent": [
            {
              "type": "heading",
              "content": "제3 정규형 (3NF)",
              "level": 1
            },
            {
              "type": "heading",
              "content": "요구사항",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "릴레이션은 2NF(제2 정규형)를 만족해야 한다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "릴레이션은 이행적 종속성을 가져서는 안 된다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "이행적 종속성 정의",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "이행적 종속성: 비기본 키 속성(non-PK attribute)이 다른 비기본 키 속성 또는 비기본 키 속성 집합에 종속되는 경우를 말한다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "이행적 종속성 상세 설명",
              "level": 1
            },
            {
              "type": "paragraph",
              "content": "릴레이션 R = a1 a2 a3 a4 에 대해 a1이 R의 기본 키일 때, a3이 a1에 종속되고(a1 ➝ a3) a4가 a3에 종속되는 경우(a1 ➝ a3 ➝ a4)는 비기본 키 속성(a4)이 다른 비기본 키 속성(a3)에 종속되는 이행적 종속성의 예시이다. 이러한 경우, a1은 a3을 결정하고 a3은 a4를 결정하지만, a4는 a1에 직접적으로 종속되지 않고 a3을 통해 간접적으로 종속된다. 여기서 후보 키는 a1, a2, {a1,a2}가 될 수 있다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "이행적 종속성 제거 예시",
              "level": 1
            },
            {
              "type": "heading",
              "content": "예제 1: 도서 대출 정보",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "원본 테이블: BookNo, Patron, Address, Due",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "기본 키(PK): BookNo",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "문제점: Patron(대출자)이 Address(주소)에 종속된다 (Patron → Address). BookNo는 Patron을 결정하지만, Patron이 Address를 결정하므로 BookNo → Patron → Address 형태의 이행적 종속성이 존재한다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "제거 방법: 테이블을 다음과 같이 분리한다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "BookNo, Patron, Due",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "Patron, Address",
              "level": null
            },
            {
              "type": "heading",
              "content": "예제 2: 토너먼트 우승자 정보",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "원본 테이블: Tournament, Year, Winner, DOB",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "기본 키(PK): {Tournament, Year}",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "문제점: Winner(우승자)가 DOB(생년월일)에 종속된다 (Winner → DOB). 기본 키 {Tournament, Year}가 Winner를 결정하고 Winner가 DOB를 결정하므로 {Tournament, Year} → Winner → DOB 형태의 이행적 종속성이 존재한다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "예제 3: 시험 점수 정보 (score2)",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "원본 테이블: score2(id, student_id, subject_id, exam_name, exam_score)",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "문제점: {student_id, subject_id}가 exam_name을 결정하고, exam_name이 exam_score를 결정하는 ({student_id, subject_id} → exam_name → exam_score) 형태의 이행적 종속성이 존재한다. 즉, 시험 점수는 학생-과목 조합에 직접 종속되기보다 시험 이름에 의해 결정되는 구조이다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "제거 방법: 테이블을 다음과 같이 분리한다. (여기서 exam_id는 exam_name을 고유하게 식별하는 새로운 키로 가정)",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "score2a(id, student_id, subject_id, exam_id, exam_name)",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "score2b(student_id, subject_id, exam_id, exam_score)",
              "level": null
            }
          ],
          "aiNotes": {
            "summary": "제3 정규형(3NF)은 데이터베이스 정규화의 한 단계로, 릴레이션이 2NF를 만족하고 이행적 종속성이 없어야 한다는 요구사항을 가진다. 이행적 종속성은 비기본 키 속성이 다른 비기본 키 속성에 종속되는 현상으로, 이는 데이터 중복을 야기하고 삽입, 삭제, 갱신 이상을 초래할 수 있다. 3NF는 이러한 이행적 종속성을 제거하여 데이터 일관성과 무결성을 높이는 것을 목표로 한다. 본문에서는 이행적 종속성의 개념과 이를 제거하기 위한 여러 예시를 통해 3NF의 적용 방법을 설명한다.",
            "keyConcepts": [
              {
                "term": "제3 정규형 (3NF)",
                "definition": {
                  "easy": "데이터베이스 테이블을 깔끔하게 만들어서 정보가 겹치지 않고 잘 정리되도록 하는 세 번째 규칙이에요. 특히, 중요한 정보가 아닌 것들이 다른 중요한 정보가 아닌 것에 의존하지 않게 해요.",
                  "medium": "릴레이션이 2NF를 만족하고, 기본 키가 아닌 속성(non-PK attribute)이 기본 키가 아닌 다른 속성에 이행적으로 종속되지 않는 상태를 의미합니다. 이는 데이터 중복을 줄이고 갱신 이상, 삽입 이상, 삭제 이상과 같은 이상 현상을 방지합니다.",
                  "hard": "릴레이션 R이 2NF를 만족하고, R의 모든 비기본 키 속성 A에 대해 A가 R의 어떤 후보 키 X에 대해 직접적으로 함수 종속(X → A)이 아닌, 다른 비기본 키 속성 B를 경유하는 이행적 함수 종속(X → B → A)이 존재하지 않는 상태를 말한다. 즉, 모든 비기본 키 속성은 오직 후보 키에만 직접적으로 함수 종속되어야 한다."
                }
              },
              {
                "term": "이행적 종속성 (Transitive Dependency)",
                "definition": {
                  "easy": "테이블에서 중요한 정보가 아닌 것(A)이 다른 중요한 정보가 아닌 것(B)에 따라 정해지는 관계를 말해요. 예를 들어, '학생 이름'이 '과목'에 따라 정해지고, '과목'이 '점수'에 따라 정해지는 식이죠.",
                  "medium": "릴레이션 R에서 A → B이고 B → C일 때, A → C가 성립하며 B가 후보 키가 아닌 경우, C는 A에 대해 이행적으로 종속된다고 합니다. 즉, 비기본 키 속성이 기본 키가 아닌 다른 속성을 통해 기본 키에 간접적으로 종속되는 현상입니다.",
                  "hard": "릴레이션 R의 속성 집합 A, B, C에 대해 A → B이고 B → C인 함수 종속성이 존재할 때, 만약 B가 R의 후보 키가 아니거나 A가 B에 함수 종속되지 않는다면 C는 A에 대해 이행적 종속성을 가진다고 한다. 이는 비기본 키 속성이 기본 키에 직접 종속되지 않고 중간의 다른 비기본 키 속성을 통해 종속되는 상황을 나타내며, 3NF 위반의 주된 원인이다."
                }
              },
              {
                "term": "정규화 (Normalization)",
                "definition": {
                  "easy": "데이터베이스를 더 효율적이고 오류 없이 사용할 수 있도록 테이블을 규칙에 따라 잘 정리하는 과정이에요.",
                  "medium": "데이터베이스의 테이블을 구조화하여 데이터 중복을 최소화하고, 삽입, 삭제, 갱신 이상과 같은 데이터 불일치 문제를 해결하며, 데이터 무결성을 유지하기 위한 일련의 과정입니다. 정규형(Normal Form)이라는 규칙을 단계별로 적용하여 수행됩니다.",
                  "hard": "관계형 데이터베이스 설계에서 데이터 중복을 제거하고 데이터 일관성 및 무결성을 보장하기 위해 릴레이션 스키마를 분해하는 체계적인 과정이다. 함수 종속성 및 다치 종속성과 같은 종속성 제약을 기반으로 특정 정규형 규칙을 만족하도록 테이블을 재구성하며, 이를 통해 이상(anomaly) 현상을 방지하고 질의 성능 및 유지보수성을 향상시키는 것을 목표로 한다."
                }
              }
            ],
            "importantTerms": [
              {
                "term": "기본 키 (Primary Key)",
                "definition": "릴레이션 내의 각 튜플(행)을 고유하게 식별할 수 있는 하나 이상의 속성(컬럼) 집합."
              },
              {
                "term": "비기본 키 속성 (Non-PK Attribute)",
                "definition": "기본 키를 구성하지 않는 릴레이션의 속성."
              },
              {
                "term": "후보 키 (Candidate Key)",
                "definition": "릴레이션에서 각 튜플을 고유하게 식별할 수 있는 최소한의 속성 집합. 기본 키로 선택될 수 있는 모든 키를 의미한다."
              },
              {
                "term": "릴레이션 (Relation)",
                "definition": "관계형 데이터베이스에서 데이터를 저장하는 테이블을 의미하며, 행(튜플)과 열(속성)로 구성된다."
              },
              {
                "term": "함수 종속성 (Functional Dependency)",
                "definition": "릴레이션에서 어떤 속성 집합 X의 값이 다른 속성 집합 Y의 값을 유일하게 결정하는 관계 (X → Y)."
              }
            ],
            "outline": [
              {
                "text": "제3 정규형 (3NF)",
                "id": "제3-정규형-3nf",
                "children": [
                  {
                    "text": "요구사항",
                    "id": "요구사항",
                    "children": null
                  },
                  {
                    "text": "이행적 종속성 정의",
                    "id": "이행적-종속성-정의",
                    "children": null
                  }
                ]
              },
              {
                "text": "이행적 종속성 상세 설명",
                "id": "이행적-종속성-상세-설명",
                "children": null
              },
              {
                "text": "이행적 종속성 제거 예시",
                "id": "이행적-종속성-제거-예시",
                "children": [
                  {
                    "text": "예제 1: 도서 대출 정보",
                    "id": "예제-1-도서-대출-정보",
                    "children": null
                  },
                  {
                    "text": "예제 2: 토너먼트 우승자 정보",
                    "id": "예제-2-토너먼트-우승자-정보",
                    "children": null
                  },
                  {
                    "text": "예제 3: 시험 점수 정보 (score2)",
                    "id": "예제-3-시험-점수-정보-score2",
                    "children": null
                  }
                ]
              }
            ]
          },
          "quiz": [
            {
              "question": "릴레이션이 제3 정규형(3NF)을 만족하기 위한 필수 요구사항 중 하나는 무엇입니까?",
              "options": [
                "부분 함수 종속성이 없어야 한다.",
                "기본 키가 없어야 한다.",
                "제2 정규형(2NF)을 만족해야 한다.",
                "모든 속성이 다치 종속성을 가져야 한다."
              ],
              "answerIndex": 2,
              "explanation": "제3 정규형(3NF)의 첫 번째 요구사항은 릴레이션이 제2 정규형(2NF)을 만족해야 한다는 것입니다. 또한, 이행적 종속성이 없어야 합니다."
            },
            {
              "question": "다음 중 이행적 종속성을 가장 잘 설명하는 것은 무엇입니까?",
              "options": [
                "비기본 키 속성이 기본 키에 직접 종속되는 경우",
                "기본 키가 다른 기본 키에 종속되는 경우",
                "비기본 키 속성이 다른 비기본 키 속성 또는 비기본 키 속성 집합에 종속되는 경우",
                "모든 속성이 서로 독립적인 경우"
              ],
              "answerIndex": 2,
              "explanation": "이행적 종속성은 비기본 키 속성이 기본 키가 아닌 다른 비기본 키 속성을 통해 기본 키에 간접적으로 종속되는 경우를 의미합니다. 즉, 비기본 키 속성이 다른 비기본 키 속성에 종속되는 관계를 말합니다."
            },
            {
              "question": "릴레이션 R = a1 a2 a3 a4에서 a1이 기본 키이고, a1 → a3 및 a3 → a4 관계가 성립할 때, a1 → a3 → a4는 어떤 종류의 종속성입니까?",
              "options": [
                "부분 함수 종속성",
                "완전 함수 종속성",
                "이행적 종속성",
                "자명한 종속성"
              ],
              "answerIndex": 2,
              "explanation": "a1 → a3이고 a3 → a4일 때, a3이 기본 키가 아닌 비기본 키 속성이므로, a4는 a1에 대해 이행적 종속성을 가집니다. 이는 비기본 키 속성이 다른 비기본 키 속성을 통해 기본 키에 종속되는 경우에 해당합니다."
            }
          ]
        },
        {
          "title": "보이스-코드 정규형 (BCNF): 강화된 제3 정규형",
          "metadata": "Source: a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf, Text length: 923 chars",
          "documentContent": [
            {
              "type": "heading",
              "content": "보이스-코드 정규형 (BCNF): 3.5NF",
              "level": 1
            },
            {
              "type": "paragraph",
              "content": "BCNF는 제3 정규형(3NF)보다 강화된 정규형으로, '3.5NF'라고도 불립니다. BCNF를 만족하기 위한 요구사항은 다음과 같습니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "1. 관계는 3NF여야 합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "2. 어떤 함수 종속성 A → B에 대해, A는 반드시 슈퍼키(Super Key)여야 합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "3. 만약 A → B에서 A가 비기본키(non-PK)라면, 해당 관계는 BCNF가 아닙니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "BCNF 예시: takes2 테이블",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "다음은 BCNF 위반의 예시를 보여주는 `takes2` 테이블입니다: `takes2(student_id, subject, instructor)`",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "이 테이블에는 두 가지 함수 종속성이 존재합니다:",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "1. `(student, subject) → instructor`: 학생과 과목이 강사를 유일하게 결정합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "2. `Instructor → subject`: 강사가 가르치는 과목을 유일하게 결정합니다. (예: Dr. Cpp는 C++만 가르치고, Dr. Java는 Java만 가르침)",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "여기서 문제가 되는 것은 `Instructor → subject` 종속성입니다. `Instructor`는 `takes2` 테이블의 기본키(또는 후보키)가 아니며, 슈퍼키도 아닙니다. 이처럼 비기본키가 다른 속성을 결정하는 경우, BCNF를 만족하지 못합니다. 즉, '비기본키가 기본키의 구성 요소를 식별'하는 상황이 발생하여 BCNF를 위반합니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "BCNF 분해 예시: takes2 테이블의 정규화",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "`takes2` 테이블의 BCNF 위반 문제를 해결하기 위해, 테이블을 다음과 같이 분해할 수 있습니다:",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "1. `takes2a(student_id, section_id)`",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "2. `takes2b(section_id, subject, instructor)`",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "이 분해를 통해 `Instructor → subject` 종속성은 `takes2b` 테이블 내에서 `section_id`가 `subject`와 `instructor`를 유일하게 결정하는 구조로 변경됩니다. `section_id`는 `takes2b`의 기본키(후보키이자 슈퍼키)이므로, 이제 모든 결정자가 슈퍼키인 조건을 만족하게 되어 BCNF를 만족합니다.",
              "level": null
            }
          ],
          "aiNotes": {
            "summary": "본 문서는 보이스-코드 정규형(BCNF)의 정의와 요구사항을 설명합니다. BCNF는 제3 정규형(3NF)보다 강화된 형태로, 모든 함수 종속성 A → B에서 결정자 A가 반드시 슈퍼키여야 한다고 명시합니다. 특히 A가 비기본키인 경우 BCNF를 위반한다고 강조합니다. `takes2(student_id, subject, instructor)` 예시를 통해 `Instructor → subject`와 같은 함수 종속성이 BCNF 위반을 초래하는 과정을 보여주고, 이를 `takes2a(student_id, section_id)`와 `takes2b(section_id, subject, instructor)`로 분해하여 BCNF를 만족시키는 해결책을 제시합니다.",
            "keyConcepts": [
              {
                "term": "Boyce-Codd Normal Form (BCNF)",
                "definition": {
                  "easy": "데이터베이스에서 중복을 줄이고 데이터를 더 잘 정리하는 방법 중 하나로, 3차 정규형보다 더 엄격한 규칙을 가지고 있어요.",
                  "medium": "관계형 데이터베이스에서 모든 비자명(non-trivial) 함수 종속성 A → B에 대해 결정자 A가 반드시 슈퍼키여야 하는 정규형이다. 이는 3차 정규형의 예외적인 문제를 해결한다.",
                  "hard": "릴레이션 R이 BCNF를 만족하려면, R의 모든 비자명 함수 종속성 X → Y에서 X가 R의 슈퍼키여야 한다. 이는 3NF가 후보 키의 부분 집합이 다른 속성을 결정하는 경우를 다루지 못하는 한계를 극복하며, 모든 결정자가 후보 키가 되도록 요구함으로써 데이터 중복을 최소화하고 갱신 이상을 방지하는 데 기여한다."
                }
              },
              {
                "term": "슈퍼키 (Super Key)",
                "definition": {
                  "easy": "테이블의 한 행을 유일하게 구별할 수 있는 하나 이상의 속성(컬럼)들의 조합이에요. 주민등록번호나 학번처럼 사람을 딱 한 명만 가리킬 수 있는 정보라고 생각하면 돼요.",
                  "medium": "릴레이션의 모든 튜플을 유일하게 식별할 수 있는 속성들의 집합이다. 후보키(Candidate Key)는 슈퍼키 중에서 최소성을 만족하는 키이다.",
                  "hard": "릴레이션 스키마 R에 대해, R의 모든 튜플을 유일하게 식별할 수 있는 속성 집합 K ⊆ R을 슈퍼키라고 한다. 즉, K의 값은 R의 어떤 두 튜플에서도 동일할 수 없다. 슈퍼키는 후보키를 포함하며, 후보키에 임의의 속성을 추가해도 여전히 슈퍼키이다."
                }
              },
              {
                "term": "함수 종속성 (Functional Dependency)",
                "definition": {
                  "easy": "한쪽 정보가 바뀌면 다른 쪽 정보도 따라서 바뀌어야 하는 관계를 말해요. 예를 들어, 학생의 학번이 정해지면 그 학생의 이름도 정해지는 관계처럼요.",
                  "medium": "릴레이션 R에서 속성 집합 A의 값이 속성 집합 B의 값을 유일하게 결정할 때, A → B로 표기하며, B는 A에 함수적으로 종속된다고 한다. A를 결정자(determinant), B를 종속자(dependent)라고 한다.",
                  "hard": "릴레이션 스키마 R에서, X와 Y가 R의 부분 집합일 때, 릴레이션 r(R)의 모든 튜플 t1, t2에 대해 t1[X] = t2[X]이면 t1[Y] = t2[Y]가 성립할 때, Y는 X에 함수적으로 종속된다고 하며 X → Y로 표기한다. 이는 데이터의 일관성과 무결성을 유지하는 데 필수적인 개념이며, 정규화 과정의 핵심이다."
                }
              }
            ],
            "importantTerms": [
              {
                "term": "3NF (제3 정규형)",
                "definition": "이행적 함수 종속성을 제거하여 중복을 줄이는 정규형. BCNF보다 덜 엄격하다."
              },
              {
                "term": "비기본키 (Non-PK)",
                "definition": "기본키 또는 후보키의 구성 요소가 아닌 속성."
              },
              {
                "term": "분해 (Decomposition)",
                "definition": "정규형을 만족시키기 위해 하나의 릴레이션(테이블)을 두 개 이상의 릴레이션으로 나누는 과정."
              },
              {
                "term": "결정자 (Determinant)",
                "definition": "함수 종속성 A → B에서 A에 해당하는 속성 집합으로, 종속자를 유일하게 결정하는 역할을 한다."
              }
            ],
            "outline": [
              {
                "text": "보이스-코드 정규형 (BCNF): 3.5NF",
                "id": "보이스-코드-정규형-bcnf-35nf",
                "children": null
              },
              {
                "text": "BCNF 예시: takes2 테이블",
                "id": "bcnf-예시-takes2-테이블",
                "children": null
              },
              {
                "text": "BCNF 분해 예시: takes2 테이블의 정규화",
                "id": "bcnf-분해-예시-takes2-테이블의-정규화",
                "children": null
              }
            ]
          },
          "quiz": [
            {
              "question": "보이스-코드 정규형(BCNF)의 핵심 요구사항으로 가장 올바른 것은 무엇입니까?",
              "options": [
                "모든 함수 종속성 A → B에서 A는 슈퍼키여야 한다.",
                "모든 비기본키 속성은 기본키에 이행적으로 종속되지 않아야 한다.",
                "모든 테이블은 최소한 세 개의 속성을 가져야 한다.",
                "모든 함수 종속성 A → B에서 B는 기본키의 부분 집합이어야 한다."
              ],
              "answerIndex": 0,
              "explanation": "BCNF의 핵심 요구사항은 '모든 함수 종속성 A → B에 대해 결정자 A가 반드시 슈퍼키여야 한다'는 것입니다. 이는 3NF보다 더 엄격한 조건입니다."
            },
            {
              "question": "본문에서 제시된 `takes2(student_id, subject, instructor)` 테이블에서 BCNF 위반을 발생시키는 함수 종속성은 무엇입니까?",
              "options": [
                "(student, subject) → instructor",
                "student_id → subject",
                "Instructor → subject",
                "subject → instructor"
              ],
              "answerIndex": 2,
              "explanation": "`Instructor → subject` 종속성이 BCNF 위반을 일으킵니다. `Instructor`는 `takes2` 테이블의 슈퍼키가 아니지만 `subject`를 결정하기 때문입니다."
            },
            {
              "question": "BCNF를 만족시키기 위해 `takes2` 테이블을 `takes2a(student_id, section_id)`와 `takes2b(section_id, subject, instructor)`로 분해한 주된 이유는 무엇입니까?",
              "options": [
                "테이블의 총 행 수를 줄이기 위해",
                "데이터 입력 속도를 향상시키기 위해",
                "`Instructor → subject` 함수 종속성으로 인한 BCNF 위반 문제를 해결하기 위해",
                "학생과 과목 간의 관계를 명확히 하기 위해"
              ],
              "answerIndex": 2,
              "explanation": "`takes2` 테이블은 `Instructor`가 슈퍼키가 아님에도 불구하고 `subject`를 결정하는 `Instructor → subject` 함수 종속성 때문에 BCNF를 위반했습니다. 테이블을 분해함으로써 이 문제가 해결됩니다."
            }
          ]
        },
        {
          "title": "제4 정규형 (4NF): 다치 종속성 제거",
          "metadata": "Source: a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf, Text length: 2282 chars",
          "documentContent": [
            {
              "type": "heading",
              "content": "제4 정규형 (4NF) 개요",
              "level": 1
            },
            {
              "type": "paragraph",
              "content": "제4 정규형(Fourth Normal Form, 4NF)은 데이터베이스 정규화의 한 단계로, 릴레이션이 BCNF(보이스-코드 정규형)를 만족하고 다치 종속성(Multi-valued Dependency)을 가지지 않아야 한다는 요구사항을 가집니다. 다치 종속성은 데이터베이스 스키마 설계가 부적절할 때 발생하며, 일반적으로 3개 이상의 속성을 가진 릴레이션에서 나타날 수 있습니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "예를 들어, 릴레이션에 A, B, C 세 가지 속성이 있고, A가 B를 함수적으로 결정(A → B)하면서 B와 C가 서로 독립적일 때 다치 종속성이 발생할 수 있습니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "다치 종속성 (MVD) 이해",
              "level": 1
            },
            {
              "type": "heading",
              "content": "예시 1: 학생-과목-활동 관계",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "다음과 같은 학생 관련 정보 릴레이션이 있다고 가정해 봅시다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "student_id → course (학생은 여러 과목을 수강)",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "student_id → activity (학생은 여러 활동에 참여)",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "course ⊥ activity (과목과 활동은 서로 독립적)",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "이 경우, 한 테이블에 student_id, course, activity를 모두 포함하면 다치 종속성이 발생합니다. 예를 들어, '21800999' 학생이 'Statistics', 'Linear algebra'를 수강하고 'Soccer', 'Basketball' 활동을 한다면, 모든 조합이 튜플로 저장되어 불필요한 중복이 발생합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "이러한 문제를 해결하기 위해, 릴레이션을 student_id와 course로 구성된 테이블과 student_id와 activity로 구성된 테이블로 분리할 수 있습니다. 이는 다치 종속성을 제거하여 데이터 중복을 줄이는 방법입니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "예시 2: 강사-자녀-전화번호 관계",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "강사의 자녀 이름(inst_child(ID, child_name))과 전화번호(inst_phone(ID, phone_number))를 기록한다고 가정해 봅시다. 이 두 스키마를 inst_info(ID, child_name, phone_number)로 결합하면 문제가 발생합니다. 특정 강사 ID(예: 999999)에 대해 여러 자녀 이름(David, William)과 여러 전화번호(x-x-1234, x-x-4321)가 독립적으로 존재할 때, 다음과 같은 튜플들이 생성되어 중복이 발생합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "(99999, David, 512-555-1234)",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "(99999, David, 512-555-4321)",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "(99999, William, 512-555-1234)",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "(99999, William, 512-555-4321)",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "이는 다치 종속성으로 인한 문제로, 자녀 이름과 전화번호가 서로 독립적임에도 불구하고 카테시안 곱 형태로 튜플이 증가하여 불필요한 중복을 야기합니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "다치 종속성의 공식적 정의",
              "level": 1
            },
            {
              "type": "paragraph",
              "content": "릴레이션 스키마 R에서 속성 집합 α와 β가 R의 부분 집합일 때, 다치 종속성 α →→ β는 릴레이션 r(R)의 모든 튜플 t1과 t2에 대해 t1[α] = t2[α]를 만족하면, 다음과 같은 튜플 t3와 t4가 r에 존재함을 의미합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "t1[α] = t2[α] = t3[α] = t4[α]",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "t3[β] = t1[β]",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "t3[R – β] = t2[R – β]",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "t4[β] = t2[β]",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "t4[R – β] = t1[R – β]",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "또 다른 정의는 릴레이션 스키마 R의 속성 집합이 세 개의 비어 있지 않은 부분 집합 Y, Z, W로 분할될 때, Y →→ Z (Y가 Z를 다중 결정)는 r(R)의 모든 가능한 릴레이션에서 <y1, z1, w1> ∈ r 이고 <y1, z2, w2> ∈ r 이면, <y1, z1, w2> ∈ r 이고 <y1, z2, w1> ∈ r 이라는 것입니다. Z와 W의 동작이 동일하므로 Y →→ Z이면 Y →→ W도 성립합니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "다치 종속성 해결의 필요성",
              "level": 1
            },
            {
              "type": "paragraph",
              "content": "FAV(student_id, course, activity) 릴레이션에서 21800999 학생이 {statistics, Linear algebra} 과목과 {Soccer, basketball} 활동을 가지고 있을 때, 이들은 서로 직교(orthogonal)하는 관계입니다. 즉, 과목과 활동은 학생 ID에 종속되지만 서로에게는 독립적입니다. 이러한 다치 종속성을 해결하지 않으면 데이터 중복과 갱신 이상이 발생하여 데이터베이스의 효율성과 무결성이 저해됩니다. 4NF는 이러한 다치 종속성을 제거하여 데이터베이스의 구조를 더욱 견고하게 만듭니다.",
              "level": null
            }
          ],
          "aiNotes": {
            "summary": "제4 정규형(4NF)은 관계형 데이터베이스 정규화의 한 단계로, BCNF를 만족하고 릴레이션 내의 다치 종속성(Multi-valued Dependency, MVD)을 제거하여 데이터 중복을 최소화하고 갱신 이상을 방지하는 것을 목표로 합니다. 다치 종속성은 일반적으로 3개 이상의 속성을 가진 테이블에서 특정 속성 집합이 다른 두 개 이상의 독립적인 속성 집합을 다중 결정할 때 발생하며, 이로 인해 불필요한 튜플 증가와 데이터 중복이 야기됩니다. 본문은 학생-과목-활동 및 강사-자녀-전화번호 예시를 통해 다치 종속성의 발생 원인과 그로 인한 문제점을 설명하고, 다치 종속성의 공식적인 정의를 제시하여 4NF의 중요성을 강조합니다.",
            "keyConcepts": [
              {
                "term": "제4 정규형 (4NF)",
                "definition": {
                  "easy": "데이터베이스에서 중복을 줄이기 위한 규칙 중 하나로, 한 테이블 안에 서로 관련 없는 여러 정보가 동시에 많아지는 것을 막는 것입니다.",
                  "medium": "관계형 데이터베이스에서 다치 종속성을 제거하여 데이터 중복을 최소화하고 갱신 이상을 방지하는 정규화 단계입니다. BCNF를 만족해야 하며, 비자명 다치 종속성이 없어야 합니다.",
                  "hard": "릴레이션 R이 BCNF를 만족하고, R의 모든 비자명 다치 종속성(A →→ B)이 함수 종속성(A → B)이거나 A가 R의 슈퍼키인 경우 R은 4NF를 만족합니다. 이는 특정 속성 집합이 다른 두 개 이상의 독립적인 속성 집합을 다중 결정하는 다치 종속성을 제거하여 불필요한 튜플 증가와 갱신 이상을 방지합니다."
                }
              },
              {
                "term": "다치 종속성 (MVD)",
                "definition": {
                  "easy": "한 가지 정보(예: 학생 ID)가 여러 가지 다른 정보(예: 듣는 과목들, 참여하는 활동들)를 동시에 가질 때, 이 다른 정보들끼리는 서로 관련이 없는 경우를 말합니다.",
                  "medium": "릴레이션 R에서 속성 집합 A가 속성 집합 B를 다중 결정한다는 것은, A의 특정 값에 대해 B의 여러 값들이 존재하고, 이 B 값들이 A의 다른 속성들과는 독립적으로 존재할 때 발생합니다. 이는 릴레이션 내에 불필요한 데이터 중복을 야기합니다.",
                  "hard": "릴레이션 R의 스키마에 대해, A, B, C가 R의 속성 집합의 분할이라고 할 때, A →→ B는 R의 모든 인스턴스에서 A의 특정 값에 대해 B의 값 집합이 독립적으로 존재하며, A의 동일한 값에 대한 C의 값 집합과 독립적으로 결합될 수 있음을 의미합니다. 즉, 튜플 t1과 t2가 A에 대해 동일한 값을 가질 때, t1[A]=t2[A]=t3[A]=t4[A], t3[B]=t1[B], t3[R-B]=t2[R-B], t4[B]=t2[B], t4[R-B]=t1[R-B]를 만족하는 t3와 t4가 존재할 때 발생합니다."
                }
              },
              {
                "term": "BCNF (보이스-코드 정규형)",
                "definition": {
                  "easy": "테이블의 모든 결정자가 후보 키인 상태를 말합니다. 즉, 어떤 한 정보가 다른 정보를 결정할 때, 그 결정하는 정보가 반드시 테이블의 주요 식별자여야 한다는 규칙입니다.",
                  "medium": "모든 함수 종속성 A → B에 대해, A가 슈퍼키인 경우 릴레이션은 BCNF를 만족합니다. 이는 3NF에서 발생할 수 있는 이상 현상을 제거하기 위해 더 엄격한 조건을 적용합니다.",
                  "hard": "릴레이션 스키마 R이 BCNF를 만족하려면, R에 존재하는 모든 비자명 함수 종속성 X → Y에 대해 X가 R의 슈퍼키여야 합니다. 이는 모든 결정자가 후보 키가 되도록 보장하여, 부분 함수 종속성 및 이행 함수 종속성과 같은 이상 현상을 근본적으로 제거합니다."
                }
              },
              {
                "term": "릴레이션 (Relation)",
                "definition": {
                  "easy": "데이터베이스에서 데이터를 표 형태로 저장하는 것을 말합니다. 행과 열로 이루어진 표라고 생각하면 됩니다.",
                  "medium": "관계형 데이터 모델에서, 속성(열)들의 집합과 해당 속성들의 도메인에서 가져온 값들로 구성된 튜플(행)들의 집합입니다. 데이터베이스 테이블과 동의어로 사용됩니다.",
                  "hard": "관계형 대수에서 정의된 수학적 관계의 인스턴스로, 고유한 속성 헤더(스키마)와 해당 속성 도메인에서 가져온 값들로 구성된 순서 없는 튜플(레코드) 집합입니다. 각 튜플은 유일하며, 속성의 순서는 중요하지 않습니다."
                }
              }
            ],
            "importantTerms": [
              {
                "term": "정규형 (Normal Form)",
                "definition": "데이터베이스 테이블의 중복을 줄이고 무결성을 유지하기 위한 구조적 규칙들의 집합."
              },
              {
                "term": "속성 (Attribute)",
                "definition": "릴레이션(테이블)의 열(column)을 의미하며, 특정 종류의 데이터를 저장한다."
              },
              {
                "term": "튜플 (Tuple)",
                "definition": "릴레이션(테이블)의 행(row)을 의미하며, 하나의 레코드를 구성하는 속성 값들의 집합."
              },
              {
                "term": "슈퍼키 (Superkey)",
                "definition": "릴레이션의 모든 튜플을 고유하게 식별할 수 있는 하나 이상의 속성 집합."
              },
              {
                "term": "직교 (Orthogonal)",
                "definition": "두 개 이상의 속성 집합이 서로 독립적으로 존재하며 영향을 주지 않는 관계."
              }
            ],
            "outline": [
              {
                "text": "제4 정규형 (4NF) 개요",
                "id": "제4-정규형-4nf-개요",
                "children": null
              },
              {
                "text": "다치 종속성 (MVD) 이해",
                "id": "다치-종속성-mvd-이해",
                "children": [
                  {
                    "text": "예시 1: 학생-과목-활동 관계",
                    "id": "예시-1-학생-과목-활동-관계",
                    "children": null
                  },
                  {
                    "text": "예시 2: 강사-자녀-전화번호 관계",
                    "id": "예시-2-강사-자녀-전화번호-관계",
                    "children": null
                  }
                ]
              },
              {
                "text": "다치 종속성의 공식적 정의",
                "id": "다치-종속성의-공식적-정의",
                "children": null
              },
              {
                "text": "다치 종속성 해결의 필요성",
                "id": "다치-종속성-해결의-필요성",
                "children": null
              }
            ]
          },
          "quiz": [
            {
              "question": "제4 정규형(4NF)이 만족해야 하는 선행 조건은 무엇인가요?",
              "options": [
                "1NF",
                "2NF",
                "3NF",
                "BCNF"
              ],
              "answerIndex": 3,
              "explanation": "제4 정규형(4NF)의 요구사항 중 하나는 릴레이션이 BCNF를 만족해야 한다는 것입니다."
            },
            {
              "question": "다음 중 다치 종속성(Multi-valued Dependency)이 발생할 수 있는 상황에 대한 설명으로 가장 적절한 것은?",
              "options": [
                "릴레이션에 2개 이하의 속성이 존재할 때",
                "릴레이션의 속성 A가 B를 함수적으로 결정하고 B가 C를 함수적으로 결정할 때",
                "릴레이션에 3개 이상의 속성(A, B, C)이 있고, A가 B를 결정하며, B와 C가 서로 독립적일 때",
                "모든 속성이 기본 키의 부분 집합에 종속될 때"
              ],
              "answerIndex": 2,
              "explanation": "다치 종속성은 릴레이션에 3개 이상의 속성이 존재하고, 어떤 속성(A)이 다른 속성(B)을 결정하지만, B와 또 다른 속성(C)이 서로 독립적일 때 발생할 수 있습니다."
            },
            {
              "question": "강사 정보(ID, 자녀 이름, 전화번호) 테이블에서 ID가 자녀 이름과 전화번호를 다중 결정할 때 발생하는 주요 문제점은?",
              "options": [
                "데이터 무결성 제약 조건 위반",
                "릴레이션의 크기가 줄어듦",
                "불필요한 데이터 중복 및 갱신 이상 발생",
                "함수 종속성 손실"
              ],
              "answerIndex": 2,
              "explanation": "다치 종속성으로 인해 ID에 따라 자녀 이름과 전화번호의 모든 가능한 조합이 튜플로 저장되어, 불필요한 데이터 중복과 삽입, 삭제, 갱신 시의 이상 현상이 발생합니다."
            }
          ]
        },
        {
          "title": "정규화 이론 및 종속성 요약",
          "metadata": "Source: a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf, Text length: 1600 chars",
          "documentContent": [
            {
              "type": "heading",
              "content": "정규형 요약",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "정규형 이론은 데이터베이스 설계에서 릴레이션의 '좋은 형태'를 정의하고, 데이터 중복 및 이상 현상을 줄이는 데 사용됩니다. 각 정규형은 특정 유형의 종속성과 관련이 있습니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "다음은 주요 정규형과 그와 관련된 핵심 아이디어 및 종속성입니다:",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "-   **2NF (제2정규형)**: 부분 종속성(Partial dependency)을 다룹니다. 이는 기본 키의 일부가 비기본 키 속성을 결정하는 경우에 해당합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "-   **3NF (제3정규형)**: 이행 종속성(Transitive dependency)을 다룹니다. 이는 비기본 키 속성이 다른 비기본 키 속성을 결정하는 경우에 해당합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "-   **BCNF (보이스-코드 정규형)**: 3NF보다 엄격한 형태로, 비기본 키가 기본 키를 결정하는 경우를 포함하여 모든 결정자가 후보 키여야 함을 요구합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "-   **4NF (제4정규형)**: 다치 종속성(Multi-valued dependency)을 다룹니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "-   **5NF (제5정규형)**: 조인 종속성(Join dependency)을 다룹니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "정규화 이론",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "정규화 이론은 특정 릴레이션 R이 '좋은 형태'에 해당하는지 여부를 결정하는 것을 목표로 합니다. 만약 릴레이션 R이 '좋은 형태'가 아니라면, 이를 {R1, R2, ..., Rn}과 같은 릴레이션 집합으로 분해합니다. 이때 다음 조건들을 만족해야 합니다:",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "-   각각의 분해된 릴레이션은 '좋은 형태'여야 합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "-   분해는 무손실 분해(lossless decomposition)여야 합니다. 즉, 분해 후 다시 조인했을 때 원래 정보가 손실되지 않아야 합니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "정규화 이론의 기반",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "정규화는 다음을 포함한 관련 이론 집합에 기반을 두고 있습니다:",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "-   함수 종속성 (Functional dependencies)\n-   부분 종속성 (Partial dependencies)\n-   이행 종속성 (Transitive dependencies)\n-   다치 종속성 (Multivalued dependencies)",
              "level": null
            },
            {
              "type": "heading",
              "content": "함수 종속성의 활용",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "함수 종속성은 두 가지 주요 방식으로 활용됩니다:",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "1.  **릴레이션의 유효성 테스트**: 주어진 함수 종속성 집합 하에서 특정 릴레이션이 유효한지 테스트하는 데 사용됩니다. 릴레이션 r이 함수 종속성 집합 F 하에서 유효하다면, 우리는 r이 F를 만족한다고 말합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "2.  **유효한 릴레이션 집합에 제약 조건 지정**: 릴레이션 R에 대한 모든 유효한 릴레이션이 함수 종속성 집합 F를 만족할 경우, R에 F가 성립한다고 말합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "참고: 릴레이션 스키마의 특정 인스턴스는 해당 함수 종속성이 모든 유효한 인스턴스에 성립하지 않더라도 우연히 함수 종속성을 만족할 수 있습니다. 예를 들어, 'instructor' 릴레이션의 특정 인스턴스는 우연히 'name → ID' 관계를 만족할 수 있습니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "다치 종속성의 활용",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "다치 종속성 또한 두 가지 방식으로 활용됩니다:",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "1.  **릴레이션의 유효성 테스트**: 주어진 함수 및 다치 종속성 집합 하에서 릴레이션이 유효한지 여부를 결정하는 데 사용됩니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "2.  **유효한 릴레이션 집합에 제약 조건 지정**: 우리는 주어진 함수 및 다치 종속성을 만족하는 릴레이션만 고려합니다. 만약 릴레이션 r이 주어진 다치 종속성을 만족하지 못한다면, r에 튜플을 추가하여 다치 종속성을 만족하는 r'를 구성할 수 있습니다.",
              "level": null
            }
          ],
          "aiNotes": {
            "summary": "제공된 텍스트는 데이터베이스 정규화 이론과 다양한 종속성(함수, 부분, 이행, 다치, 조인)이 각 정규형(2NF, 3NF, BCNF, 4NF, 5NF)과 어떻게 관련되는지 설명합니다. 또한, 정규화가 릴레이션을 '좋은 형태'로 분해하는 과정이며, 이 과정에서 무손실 분해가 중요함을 강조합니다. 마지막으로 함수 종속성 및 다치 종속성이 릴레이션의 유효성을 테스트하고 제약 조건을 지정하는 데 어떻게 활용되는지 상세히 설명합니다.",
            "keyConcepts": [
              {
                "term": "정규화 (Normalization)",
                "definition": {
                  "easy": "데이터베이스를 잘 정리해서 중복을 줄이고 문제를 없애는 과정이에요.",
                  "medium": "데이터 중복을 제거하고 데이터 일관성을 유지하기 위해 릴레이션 스키마를 더 작고 잘 정의된 릴레이션으로 분해하는 과정입니다.",
                  "hard": "관계형 데이터베이스 설계에서 데이터의 무결성을 보장하고 이상 현상(삽입, 삭제, 갱신 이상)을 최소화하기 위해 릴레이션 스키마를 특정 정규형 규칙에 따라 분해하는 체계적인 과정으로, 주로 함수 종속성과 다치 종속성 등의 제약 조건을 기반으로 합니다."
                }
              },
              {
                "term": "함수 종속성 (Functional Dependency)",
                "definition": {
                  "easy": "어떤 값(들)이 다른 어떤 값(들)을 항상 결정하는 관계를 말해요. 예를 들어, 학생 번호가 학생 이름을 결정하는 것처럼요.",
                  "medium": "릴레이션 R에서 속성 집합 A가 속성 집합 B를 함수적으로 결정한다는 것은, R의 어떤 두 튜플이 A에 대해 같은 값을 가지면 B에 대해서도 같은 값을 가져야 함을 의미합니다 (A → B).",
                  "hard": "관계형 스키마 R에서, 속성 집합 X의 값이 속성 집합 Y의 값을 유일하게 결정할 때 (X → Y), 이를 함수 종속성이라 합니다. 이는 릴레이션 인스턴스에 대한 제약 조건으로, 데이터의 의미론적 관계를 반영하며 정규화 과정에서 중요한 역할을 합니다."
                }
              },
              {
                "term": "무손실 분해 (Lossless Decomposition)",
                "definition": {
                  "easy": "테이블을 여러 개로 나눴다가 다시 합쳐도 원래 정보가 하나도 없어지지 않는 것을 말해요.",
                  "medium": "릴레이션 R을 R1과 R2로 분해했을 때, R1과 R2를 자연 조인(natural join)한 결과가 원래 릴레이션 R과 동일하게 되는 분해를 의미합니다. 정보 손실이 발생하지 않음을 보장합니다.",
                  "hard": "데이터베이스 릴레이션 R을 R1, R2, ..., Rn의 집합으로 분해할 때, 모든 R_i의 자연 조인(⋈ R_i)이 원래 릴레이션 R과 동일한 정보를 포함하는 것을 보장하는 분해 속성입니다. 이는 분해로 인해 데이터가 유실되거나 허위 튜플이 생성되지 않음을 의미하며, 정규화의 필수적인 목표 중 하나입니다."
                }
              }
            ],
            "importantTerms": [
              {
                "term": "정규형 (Normal Form)",
                "definition": "데이터베이스 릴레이션이 만족해야 하는 특정 조건들의 집합으로, 데이터 중복을 줄이고 이상 현상을 방지하기 위해 사용됩니다."
              },
              {
                "term": "부분 종속성 (Partial Dependency)",
                "definition": "기본 키의 일부 속성이 비기본 키 속성을 결정하는 함수 종속성으로, 2NF 위반의 원인이 됩니다."
              },
              {
                "term": "이행 종속성 (Transitive Dependency)",
                "definition": "비기본 키 속성이 다른 비기본 키 속성을 결정하는 함수 종속성으로, 3NF 위반의 원인이 됩니다."
              },
              {
                "term": "다치 종속성 (Multi-valued Dependency)",
                "definition": "한 속성의 값이 다른 속성 집합의 여러 값을 결정하는 상황으로, 4NF 위반의 원인이 됩니다."
              },
              {
                "term": "조인 종속성 (Join Dependency)",
                "definition": "릴레이션을 여러 개의 릴레이션으로 분해한 후 다시 조인했을 때 원래 릴레이션과 동일하게 되는 성질로, 5NF와 관련이 있습니다."
              },
              {
                "term": "BCNF (Boyce-Codd Normal Form)",
                "definition": "3NF보다 더 엄격한 정규형으로, 모든 결정자가 후보 키여야 한다는 조건을 요구합니다."
              },
              {
                "term": "릴레이션 (Relation)",
                "definition": "관계형 데이터베이스에서 데이터를 저장하는 테이블을 지칭하는 용어입니다."
              }
            ],
            "outline": [
              {
                "text": "정규형 및 종속성 요약",
                "id": "정규형-및-종속성-요약",
                "children": [
                  {
                    "text": "정규형별 핵심 아이디어 및 종속성",
                    "id": "정규형별-핵심-아이디어-및-종속성",
                    "children": [
                      {
                        "text": "2NF (부분 종속성)",
                        "id": "2nf-부분-종속성",
                        "children": null
                      },
                      {
                        "text": "3NF (이행 종속성)",
                        "id": "3nf-이행-종속성",
                        "children": null
                      },
                      {
                        "text": "BCNF (비PK -> PK)",
                        "id": "bcnf-비pk-pk",
                        "children": null
                      },
                      {
                        "text": "4NF (다치 종속성)",
                        "id": "4nf-다치-종속성",
                        "children": null
                      },
                      {
                        "text": "5NF (조인 종속성)",
                        "id": "5nf-조인-종속성",
                        "children": null
                      }
                    ]
                  }
                ]
              },
              {
                "text": "정규화 이론",
                "id": "정규화-이론",
                "children": [
                  {
                    "text": "‘좋은 형태’ 릴레이션 판단 및 분해",
                    "id": "좋은-형태-릴레이션-판단-및-분해",
                    "children": null
                  },
                  {
                    "text": "무손실 분해의 중요성",
                    "id": "무손실-분해의-중요성",
                    "children": null
                  },
                  {
                    "text": "정규화의 기반이 되는 이론들",
                    "id": "정규화의-기반이-되는-이론들",
                    "children": [
                      {
                        "text": "함수 종속성",
                        "id": "함수-종속성",
                        "children": null
                      },
                      {
                        "text": "부분 종속성",
                        "id": "부분-종속성",
                        "children": null
                      },
                      {
                        "text": "이행 종속성",
                        "id": "이행-종속성",
                        "children": null
                      },
                      {
                        "text": "다치 종속성",
                        "id": "다치-종속성",
                        "children": null
                      }
                    ]
                  }
                ]
              },
              {
                "text": "종속성의 활용",
                "id": "종속성의-활용",
                "children": [
                  {
                    "text": "함수 종속성의 활용",
                    "id": "함수-종속성의-활용",
                    "children": [
                      {
                        "text": "릴레이션의 유효성 테스트",
                        "id": "릴레이션의-유효성-테스트",
                        "children": null
                      },
                      {
                        "text": "유효한 릴레이션에 대한 제약 조건 지정",
                        "id": "유효한-릴레이션에-대한-제약-조건-지정",
                        "children": null
                      }
                    ]
                  },
                  {
                    "text": "다치 종속성의 활용",
                    "id": "다치-종속성의-활용",
                    "children": [
                      {
                        "text": "릴레이션의 유효성 테스트",
                        "id": "릴레이션의-유효성-테스트",
                        "children": null
                      },
                      {
                        "text": "유효한 릴레이션에 대한 제약 조건 지정",
                        "id": "유효한-릴레이션에-대한-제약-조건-지정",
                        "children": null
                      },
                      {
                        "text": "다치 종속성을 만족하지 못하는 경우 튜플 추가를 통한 만족",
                        "id": "다치-종속성을-만족하지-못하는-경우-튜플-추가를-통한-만족",
                        "children": null
                      }
                    ]
                  }
                ]
              }
            ]
          },
          "quiz": [
            {
              "question": "다음 중 부분 종속성(Partial dependency)과 관련된 정규형은 무엇인가요?",
              "options": [
                "1NF",
                "2NF",
                "3NF",
                "BCNF"
              ],
              "answerIndex": 1,
              "explanation": "부분 종속성은 기본 키의 일부가 비기본 키를 결정하는 경우를 의미하며, 이는 2NF를 위반하는 주된 원인입니다."
            },
            {
              "question": "데이터베이스 정규화의 주요 목적 중 하나가 아닌 것은 무엇인가요?",
              "options": [
                "데이터 중복 제거",
                "데이터 일관성 유지",
                "무손실 분해 보장",
                "데이터 검색 속도 최적화"
              ],
              "answerIndex": 3,
              "explanation": "정규화는 주로 데이터 중복 제거, 일관성 유지, 이상 현상 방지를 목적으로 하며, 반드시 검색 속도를 최적화하는 것은 아닙니다. 오히려 과도한 정규화는 조인 연산을 증가시켜 검색 성능을 저하시킬 수도 있습니다."
            },
            {
              "question": "릴레이션 R이 함수 종속성 집합 F 하에서 '유효하다'는 것의 의미로 가장 적절한 것은?",
              "options": [
                "R의 모든 속성이 기본 키에만 종속된다.",
                "R이 F에 있는 모든 함수 종속성을 만족한다.",
                "R에 허위 튜플이 존재하지 않는다.",
                "R이 2NF를 만족한다."
              ],
              "answerIndex": 1,
              "explanation": "텍스트에 따르면, 릴레이션 r이 주어진 함수 종속성 F 하에서 유효할 경우, r은 F를 만족한다고 명시되어 있습니다. 이는 R의 모든 인스턴스가 F에 정의된 모든 함수 종속성 제약을 따른다는 의미입니다."
            }
          ]
        },
        {
          "title": "데이터베이스 정규화 실전 예시",
          "metadata": "Source: a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf, Text length: 1335 chars",
          "documentContent": [
            {
              "type": "heading",
              "content": "데이터베이스 정규화 실전 예시",
              "level": 1
            },
            {
              "type": "paragraph",
              "content": "위키피디아에서 가져온 예시를 통해 데이터베이스 정규화 과정을 제1 정규형(1NF)부터 제4 정규형(4NF)까지 단계별로 설명합니다. 각 정규형이 어떤 함수 종속성을 해결하는지 구체적인 사례를 통해 살펴봅니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "초기 데이터 상태",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "제공된 초기 데이터는 특정 서적 정보들을 포함하고 있으며, 이후 정규화 과정을 통해 데이터 중복을 줄이고 무결성을 높이는 방법을 보여줍니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "제1 정규형 (1NF) 만족",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "제1 정규형을 만족시키기 위해 각 셀이 단일 값을 포함하도록 하고, 반복되는 그룹을 제거하여 테이블을 분리하거나 확장하는 과정이 필요합니다. 이를 통해 데이터의 원자성을 확보합니다. 예시에서는 초기 비정규형 상태에서 1NF를 만족하는 형태로 개선된 모습을 보여줍니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "제2 정규형 (2NF) 만족",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "제2 정규형은 제1 정규형을 만족하고, 부분 함수 종속성(Partial Dependency)이 없는 상태를 의미합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "예시의 초기 데이터는 `{Title, Format}`을 복합 키(Compound key)로 가집니다. 이때 `Title`이 `Author`, `Author Nationality`, `Pages`, `Thickness`, `Genre ID`, `Genre Name`, `Publisher ID`에 부분 함수 종속성을 가집니다. 즉, 복합 키의 일부인 `Title`만으로 다른 속성들이 결정되는 문제가 있습니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "제2 정규형을 만족시키기 위해 이러한 부분 함수 종속성을 제거하고, 종속된 속성들을 별도의 테이블로 분리하여 데이터 중복을 줄입니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "제3 정규형 (3NF) 만족",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "제3 정규형은 제2 정규형을 만족하고, 추이 함수 종속성(Transitive Dependency)이 없는 상태를 의미합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "예시에서는 `Genre ID`가 `Genre Name`을 결정하는 추이 함수 종속성(`Genre ID` → `Genre Name`)이 존재합니다. 이는 기본 키가 아닌 속성(`Genre ID`)이 다른 기본 키가 아닌 속성(`Genre Name`)을 결정하는 경우입니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "제3 정규형을 만족시키기 위해 `Genre ID`와 `Genre Name`을 포함하는 별도의 테이블을 생성하여 추이 함수 종속성을 제거합니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "보이스/코드 정규형 (BCNF) 만족",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "BCNF는 제3 정규형보다 엄격한 정규형으로, 모든 결정자(Determinant)가 후보 키(Candidate Key)여야 합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "예시에서는 `Author`가 `Author Nationality`를 결정하는 비기본 키 간의 함수 종속성(`Author` → `Author Nationality`)이 존재합니다. `Author`는 후보 키가 아니므로 BCNF를 위반합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "BCNF를 만족시키기 위해 `Author`와 `Author Nationality`를 포함하는 별도의 테이블을 분리하여 이러한 종속성을 제거합니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "제4 정규형 (4NF) 만족",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "제4 정규형은 BCNF를 만족하고, 다치 종속성(Multi-valued Dependency)이 없는 상태를 의미합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "이 예시는 서점 프랜차이즈가 여러 지역에 지점을 소유하고 있으며, 모든 가용 서적이 각 지역에서 제공된다는 가정을 합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "이 가정 하에 `Title`이 특정 `Location`에 명확하게 바인딩되지 않는 다치 종속성이 발생할 수 있습니다. 이는 제4 정규형을 만족하지 않는 경우를 보여주며, 다치 종속성을 제거하여 테이블을 추가로 분리할 필요가 있음을 시사합니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "출처",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "본 예시는 위키피디아의 데이터베이스 정규화 관련 페이지에서 발췌되었습니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "원문 출처: https://en.wikipedia.org/wiki/Database_normalization",
              "level": null
            }
          ],
          "aiNotes": {
            "summary": "이 문서는 데이터베이스 정규화 과정을 제1 정규형(1NF)부터 제4 정규형(4NF)까지 단계별로 설명하는 실전 예시를 제공합니다. 각 정규형이 어떤 종류의 함수 종속성(부분 함수 종속성, 추이 함수 종속성, 비기본 키 간의 함수 종속성, 다치 종속성)을 해결하는지 구체적인 시나리오와 함께 보여주며, 이를 통해 데이터 중복을 줄이고 데이터 무결성을 높이는 방법을 시연합니다.",
            "keyConcepts": [
              {
                "term": "정규화 (Normalization)",
                "definition": {
                  "easy": "데이터베이스를 잘 정리해서 중복을 줄이고 문제없이 데이터를 저장하는 방법입니다.",
                  "medium": "데이터베이스 설계에서 데이터 중복을 최소화하고 무결성을 유지하며 이상 현상(삽입, 삭제, 갱신 이상)을 방지하기 위해 릴레이션을 여러 개의 릴레이션으로 분해하는 과정입니다.",
                  "hard": "관계형 데이터베이스 설계에서 함수 종속성(Functional Dependency) 이론을 기반으로 릴레이션 스키마를 분해하여 데이터 중복성을 제거하고 데이터 무결성을 강화하며, 삽입, 삭제, 갱신 이상(Anomalies)을 최소화하기 위한 체계적인 과정입니다."
                }
              },
              {
                "term": "함수 종속성 (Functional Dependency)",
                "definition": {
                  "easy": "어떤 값(A)이 다른 값(B)을 결정할 때 A가 B에 함수 종속적이라고 합니다. 예를 들어, 책 제목이 저자를 결정하는 경우입니다.",
                  "medium": "릴레이션 R에서 속성 집합 X가 속성 집합 Y를 함수적으로 결정할 때, X → Y로 표기하며, Y가 X에 함수 종속적이라고 합니다. 즉, X의 각 값에 대해 Y의 값이 유일하게 결정되는 관계를 의미합니다.",
                  "hard": "관계형 스키마 R에서, 속성 집합 X와 Y에 대해, R의 어떤 유효한 릴레이션 인스턴스 r에서도 X의 두 튜플이 동일한 값을 가지면, 그 두 튜플은 Y에서도 동일한 값을 가질 때 Y는 X에 함수 종속적이라고 합니다. 이는 데이터 무결성 제약 조건의 한 형태로, 데이터 중복 및 이상 현상을 분석하고 제거하는 데 사용됩니다."
                }
              },
              {
                "term": "부분 함수 종속성 (Partial Dependency)",
                "definition": {
                  "easy": "복합 키의 일부만으로 다른 데이터가 결정될 때를 말합니다.",
                  "medium": "릴레이션에서 기본 키의 부분 집합이 기본 키가 아닌 속성을 결정하는 함수 종속성입니다. 제2 정규형에서 제거 대상입니다.",
                  "hard": "복합 기본 키를 가진 릴레이션 R에서, 기본 키의 적절한 부분 집합 X가 기본 키가 아닌 속성 Y를 함수적으로 결정하는 경우 (X → Y)입니다. 이는 R이 제2 정규형을 만족하지 못하게 하는 원인이며, 이 종속성을 제거함으로써 릴레이션의 중복성을 줄이고 업데이트 이상을 방지할 수 있습니다."
                }
              },
              {
                "term": "추이 함수 종속성 (Transitive Dependency)",
                "definition": {
                  "easy": "A가 B를 결정하고 B가 C를 결정할 때, A가 C를 결정하는 관계(A→B, B→C 이면 A→C)를 말합니다.",
                  "medium": "릴레이션에서 기본 키가 아닌 속성이 다른 기본 키가 아닌 속성을 결정하는 함수 종속성입니다. 제3 정규형에서 제거 대상입니다.",
                  "hard": "릴레이션 R에서, X, Y, Z가 R의 속성 집합일 때 X → Y이고 Y → Z이며 Y가 X의 부분 집합이 아니고 Z가 Y에 함수 종속적이지 않을 때 X → Z가 성립하는 함수 종속성입니다. 이는 기본 키가 아닌 속성 간의 종속성으로, 제3 정규형을 만족시키기 위해 제거되어야 합니다."
                }
              },
              {
                "term": "다치 종속성 (Multi-valued Dependency)",
                "definition": {
                  "easy": "하나의 데이터가 다른 여러 개의 데이터를 결정할 때 발생하며, 이 관계가 다른 데이터와 상관없을 때를 말합니다.",
                  "medium": "릴레이션 R에서 속성 집합 A가 속성 집합 B의 여러 값을 결정하고, 이 관계가 다른 속성 집합 C와 무관할 때 A가 B에 다치 종속적이라고 합니다. 제4 정규형에서 제거 대상입니다.",
                  "hard": "릴레이션 R에서, A, B, C가 R의 속성 집합일 때, A →→ B가 성립하는 경우입니다. 이는 A의 각 값에 대해 B의 값이 다중으로 존재하며, B의 집합이 C와 독립적일 때 발생합니다. 즉, A의 특정 값에 대해 B의 값들의 집합이 존재하고, 그 B의 값들의 집합이 R의 다른 속성들과 무관하게 결정될 때 발생하며, 제4 정규형에서 해결해야 할 대상입니다."
                }
              }
            ],
            "importantTerms": [
              {
                "term": "복합 키 (Compound Key)",
                "definition": "두 개 이상의 속성으로 구성된 기본 키입니다."
              },
              {
                "term": "제1 정규형 (1NF)",
                "definition": "모든 속성 값이 원자 값(Atomic Value)을 가지며, 반복되는 그룹이 없는 형태입니다."
              },
              {
                "term": "제2 정규형 (2NF)",
                "definition": "제1 정규형을 만족하고, 부분 함수 종속성이 없는 형태입니다."
              },
              {
                "term": "제3 정규형 (3NF)",
                "definition": "제2 정규형을 만족하고, 추이 함수 종속성이 없는 형태입니다."
              },
              {
                "term": "보이스/코드 정규형 (BCNF)",
                "definition": "제3 정규형보다 엄격하며, 모든 결정자가 후보 키인 형태입니다."
              },
              {
                "term": "제4 정규형 (4NF)",
                "definition": "BCNF를 만족하고, 다치 종속성(Multi-valued Dependency)이 없는 형태입니다."
              }
            ],
            "outline": [
              {
                "text": "데이터베이스 정규화 실전 예시",
                "id": "데이터베이스-정규화-실전-예시",
                "children": [
                  {
                    "text": "초기 데이터 상태",
                    "id": "초기-데이터-상태",
                    "children": null
                  },
                  {
                    "text": "제1 정규형 (1NF) 만족",
                    "id": "제1-정규형-1nf-만족",
                    "children": null
                  },
                  {
                    "text": "제2 정규형 (2NF) 만족",
                    "id": "제2-정규형-2nf-만족",
                    "children": null
                  },
                  {
                    "text": "제3 정규형 (3NF) 만족",
                    "id": "제3-정규형-3nf-만족",
                    "children": null
                  },
                  {
                    "text": "보이스/코드 정규형 (BCNF) 만족",
                    "id": "보이스코드-정규형-bcnf-만족",
                    "children": null
                  },
                  {
                    "text": "제4 정규형 (4NF) 만족",
                    "id": "제4-정규형-4nf-만족",
                    "children": null
                  },
                  {
                    "text": "출처",
                    "id": "출처",
                    "children": null
                  }
                ]
              }
            ]
          },
          "quiz": [
            {
              "question": "제2 정규형(2NF)이 해결하고자 하는 주요 함수 종속성은 무엇입니까?",
              "options": [
                "부분 함수 종속성",
                "추이 함수 종속성",
                "다치 종속성",
                "비기본 키 간의 함수 종속성"
              ],
              "answerIndex": 0,
              "explanation": "제2 정규형은 복합 키의 일부에만 종속되는 부분 함수 종속성을 제거하여 테이블을 분리하는 것을 목표로 합니다."
            },
            {
              "question": "제3 정규형(3NF)을 만족시키기 위해 제거해야 하는 함수 종속성은 무엇입니까?",
              "options": [
                "부분 함수 종속성",
                "추이 함수 종속성",
                "다치 종속성",
                "복합 키 종속성"
              ],
              "answerIndex": 1,
              "explanation": "제3 정규형은 기본 키가 아닌 속성이 다른 기본 키가 아닌 속성을 결정하는 추이 함수 종속성을 제거하는 데 중점을 둡니다."
            },
            {
              "question": "BCNF(보이스/코드 정규형)가 제3 정규형(3NF)보다 더 엄격하게 요구하는 조건은 무엇입입니까?",
              "options": [
                "모든 속성이 원자 값을 가져야 한다.",
                "모든 결정자가 후보 키여야 한다.",
                "테이블에 반복되는 그룹이 없어야 한다.",
                "다치 종속성이 없어야 한다."
              ],
              "answerIndex": 1,
              "explanation": "BCNF는 제3 정규형보다 엄격하며, 릴레이션 내의 모든 결정자(다른 속성을 결정하는 속성)가 반드시 후보 키여야 합니다. 이는 3NF에서 해결하지 못할 수 있는 비기본 키 간의 함수 종속성 문제까지 다룹니다."
            }
          ]
        },
        {
          "title": "데이터베이스 설계 과정 및 비정규화",
          "metadata": "Source: a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf, Text length: 2000 chars",
          "documentContent": [
            {
              "type": "heading",
              "content": "전반적인 데이터베이스 설계 과정",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "스키마 R이 주어졌다고 가정해 봅시다. 이 스키마 R은 E-R 다이어그램을 테이블 집합으로 변환하는 과정(정규화)에서 생성되었을 수 있습니다. 또는 관심 있는 모든 속성을 포함하는 단일 릴레이션(유니버설 릴레이션)이었을 수도 있습니다. 정규화는 R을 더 작은 릴레이션으로 분해합니다. 때로는 R이 임시적인 관계 설계의 결과일 수 있으며, 이 경우 우리는 그것을 정규형으로 테스트하거나 변환합니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "E-R 모델과 정규화",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "E-R 다이어그램이 모든 엔티티를 정확하게 식별하며 신중하게 설계되었다면, E-R 다이어그램에서 생성된 테이블은 추가적인 정규화가 필요 없을 것입니다. 그러나 실제(불완전한) 설계에서는 엔티티의 비키 속성에서 해당 엔티티의 다른 속성으로의 함수 종속성이 존재할 수 있습니다. 예를 들어, 'department_name'과 'building' 속성을 가진 'employee' 엔티티에서 'department_name'이 'building'을 함수적으로 종속시킨다면, 이는 좋은 설계였다면 'department'를 별도의 엔티티로 만들었을 것입니다. 관계 집합의 비키 속성에서 발생하는 함수 종속성도 가능하지만 드뭅니다. 대부분의 관계는 이진 관계이기 때문입니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "성능을 위한 비정규화",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "성능을 위해 비정규화된 스키마를 사용하고 싶을 수 있습니다. 예를 들어, 'course_id' 및 'title'과 함께 선수 과목을 표시하려면 'course' 테이블과 'prereq' 테이블의 조인이 필요합니다. 대안 1은 'course'와 'prereq'의 모든 속성을 포함하는 비정규화된 릴레이션을 사용하는 것입니다. 이는 더 빠른 조회를 가능하게 하지만, 추가적인 공간과 업데이트를 위한 추가 실행 시간, 그리고 프로그래머의 추가적인 코딩 작업과 코드 오류 가능성을 수반합니다. 대안 2는 'course'와 'prereq'의 조인으로 정의된 물리적 뷰(materialized view)를 사용하는 것입니다. 이는 위와 동일한 이점과 단점을 가지지만, 프로그래머의 추가 코딩 작업이 필요 없고 잠재적인 오류를 방지할 수 있습니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "남아있는 문제",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "데이터베이스 설계의 일부 측면은 정규화로 포착되지 않습니다. 예를 들어 (피해야 할 경우): 'earnings_2004, earnings_2005, earnings_2006' 등 모든 속성이 '(company_id, earnings)' 스키마에 있는 경우입니다. 위 예시는 BCNF(보이스-코드 정규형)에서 잘 정규화되어 있지만, 연도별 쿼리를 어렵게 만들고 매년 새 테이블이 필요합니다. 또 다른 예시로 'company_year (company_id, earnings_2004, earnings_2005, earnings_2006)' 스키마도 BCNF에서 잘 정규화되어 있지만, 연도별 쿼리를 어렵게 만들고 매년 새 속성이 필요합니다. 이는 한 속성의 값이 열 이름이 되는 교차 테이블(crosstab)의 예시입니다. 더 나은 스키마는 'earnings (company_id, year, amount)'입니다.",
              "level": null
            }
          ],
          "aiNotes": {
            "summary": "본 텍스트는 전반적인 데이터베이스 설계 과정을 다루며, E-R 모델링과 정규화의 관계를 설명합니다. 잘 설계된 E-R 다이어그램은 추가 정규화가 필요 없지만, 실제 설계에서는 비키 속성 간의 함수 종속성으로 인해 정규화가 필요할 수 있음을 지적합니다. 또한, 성능 향상을 위한 비정규화 전략과 그 대안(비정규화된 릴레이션, 물리적 뷰)을 제시하며, 정규화만으로는 해결하기 어려운 교차 테이블과 같은 설계 문제와 그에 대한 더 나은 스키마 방안을 논의합니다.",
            "keyConcepts": [
              {
                "term": "데이터베이스 설계 과정",
                "definition": {
                  "easy": "데이터베이스를 만들고 정리하는 단계들입니다.",
                  "medium": "요구사항을 분석하고, 개념적/논리적/물리적 모델링을 통해 데이터베이스 스키마를 정의하며, 이를 구현하고 유지보수하는 일련의 과정입니다.",
                  "hard": "데이터 모델링 기법(E-R 모델, 관계형 모델 등)과 정규화 원칙을 적용하여 데이터 무결성, 일관성, 효율성을 보장하는 데이터베이스 구조를 수립하는 체계적인 절차입니다."
                }
              },
              {
                "term": "정규화",
                "definition": {
                  "easy": "데이터를 중복 없이 잘 정리해서 문제가 생기지 않게 하는 과정입니다.",
                  "medium": "관계형 데이터베이스에서 데이터 중복을 줄이고 이상 현상(삽입, 삭제, 갱신 이상)을 방지하며 데이터 무결성을 확보하기 위해 테이블을 분해하는 과정입니다.",
                  "hard": "함수 종속성을 기반으로 릴레이션 스키마를 여러 개의 작은 릴레이션으로 분해하여 데이터 종속성 위반을 제거하고, 데이터 중복 및 갱신 이상을 최소화하여 데이터 모델의 일관성과 효율성을 높이는 구조화 기법입니다."
                }
              },
              {
                "term": "비정규화",
                "definition": {
                  "easy": "데이터베이스를 빠르게 만들려고 일부러 데이터를 겹치게 하는 것입니다.",
                  "medium": "정규화된 데이터베이스에서 성능 향상을 위해 의도적으로 중복을 허용하거나 테이블을 통합하는 과정입니다.",
                  "hard": "데이터 검색 성능을 최적화하기 위해 정규화 원칙을 일부 희생하고, 조인 연산의 오버헤드를 줄이기 위해 중복 데이터를 허용하거나 테이블을 결합하는 등의 방식으로 데이터 모델을 변형하는 과정입니다."
                }
              },
              {
                "term": "E-R 모델",
                "definition": {
                  "easy": "데이터베이스에 들어갈 정보들을 그림으로 보여주는 방법입니다.",
                  "medium": "엔티티(개체)와 이들 간의 관계를 사용하여 데이터베이스의 개념적 구조를 시각적으로 표현하는 모델링 기법입니다.",
                  "hard": "데이터베이스 시스템의 개념적 설계를 위한 상위 수준 데이터 모델로, 개체(Entity), 속성(Attribute), 관계(Relationship)의 세 가지 기본 요소를 사용하여 현실 세계의 정보를 추상화하고 도식화하는 방법론입니다."
                }
              },
              {
                "term": "함수 종속성",
                "definition": {
                  "easy": "어떤 데이터가 다른 데이터를 결정하는 관계입니다.",
                  "medium": "릴레이션 R에서 속성 집합 X의 값이 속성 집합 Y의 값을 유일하게 결정할 때, Y는 X에 함수적으로 종속된다고 하며 X → Y로 표기합니다.",
                  "hard": "관계형 스키마 R에서, 모든 튜플에 대해 X의 두 튜플이 동일한 값을 가지면 Y의 두 튜플도 동일한 값을 갖는 경우, Y는 X에 함수적으로 종속된다고 정의하며, 이는 정규화 과정의 핵심 원리입니다."
                }
              }
            ],
            "importantTerms": [
              {
                "term": "스키마",
                "definition": "데이터베이스의 구조와 제약 조건에 대한 정의입니다."
              },
              {
                "term": "유니버설 릴레이션",
                "definition": "관심 있는 모든 속성을 포함하는 단일 릴레이션입니다."
              },
              {
                "term": "BCNF (Boyce-Codd Normal Form)",
                "definition": "보이스-코드 정규형. 3차 정규형보다 엄격한 정규형으로, 모든 비자명 함수 종속성에서 결정자가 후보 키인 상태를 의미합니다."
              },
              {
                "term": "물리적 뷰 (Materialized View)",
                "definition": "미리 계산되어 데이터베이스에 저장된 뷰로, 쿼리 성능 향상에 사용됩니다."
              },
              {
                "term": "교차 테이블 (Crosstab)",
                "definition": "특정 속성의 값들이 테이블의 열 이름으로 사용되는 형태의 테이블입니다."
              }
            ],
            "outline": [
              {
                "text": "전반적인 데이터베이스 설계 과정",
                "id": "전반적인-데이터베이스-설계-과정",
                "children": null
              },
              {
                "text": "E-R 모델과 정규화",
                "id": "e-r-모델과-정규화",
                "children": null
              },
              {
                "text": "성능을 위한 비정규화",
                "id": "성능을-위한-비정규화",
                "children": null
              },
              {
                "text": "남아있는 문제",
                "id": "남아있는-문제",
                "children": null
              }
            ]
          },
          "quiz": [
            {
              "question": "다음 중 데이터베이스 정규화의 주된 목적은 무엇입니까?",
              "options": [
                "데이터 중복을 줄이고 이상 현상을 방지합니다.",
                "데이터베이스 쿼리 성능을 향상시킵니다.",
                "데이터베이스 보안을 강화합니다.",
                "사용자 인터페이스의 복잡성을 줄입니다."
              ],
              "answerIndex": 0,
              "explanation": "정규화의 주된 목적은 데이터 중복을 제거하고 삽입, 삭제, 갱신과 같은 이상 현상을 방지하여 데이터 무결성을 확보하는 것입니다."
            },
            {
              "question": "데이터베이스 성능 향상을 위해 의도적으로 중복을 허용하거나 테이블을 통합하는 과정을 무엇이라고 합니까?",
              "options": [
                "정규화",
                "비정규화",
                "인덱싱",
                "조인"
              ],
              "answerIndex": 1,
              "explanation": "비정규화는 정규화된 데이터베이스에서 쿼리 성능 향상을 위해 의도적으로 데이터 중복을 허용하거나 테이블을 통합하는 과정입니다."
            },
            {
              "question": "제시된 텍스트에서 정규화만으로는 해결하기 어려운 데이터베이스 설계 문제의 예시로 언급된 것은 무엇입니까?",
              "options": [
                "키 속성(Key Attribute)의 누락",
                "릴레이션 간의 잘못된 관계 설정",
                "연도별 수익 데이터를 열(Column)로 표현하는 교차 테이블(Crosstab) 구조",
                "외래 키(Foreign Key) 제약 조건의 위반"
              ],
              "answerIndex": 2,
              "explanation": "텍스트에서는 'earnings_2004, earnings_2005, earnings_2006'과 같이 연도별 수익 데이터를 열로 표현하는 교차 테이블 구조가 정규화되어 있지만, 연도별 쿼리를 어렵게 만드는 문제로 언급되었습니다."
            }
          ]
        }
      ],
      "final_result": ""
    }
  },
  {
    "node": "finish_processing",
    "status": "completed",
    "state_snapshot": {
      "run_id": "a9d3b848-7887-4676-a9e0-4d590ff0b031",
      "pdf_file_paths": [
        "temp_pdf_uploads/a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf"
      ],
      "notebook_title": "데이터베이스 정규화: 원리, 과정 및 적용",
      "holistic_chapters": [
        {
          "chapter_title": "데이터베이스 정규화 개요 및 필요성",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "데이터가 혼합될 때 발생하는 문제점(데이터 중복, 일관성 문제, 삽입/삭제/갱신 이상 현상)을 설명하고, 이러한 문제에 대한 해결책으로 데이터베이스 정규화의 필요성과 분해(Decomposition)의 개념, 그리고 손실 분해(Lossy Decomposition)와 무손실 분해(Lossless Decomposition)의 차이를 소개합니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems2\nWhen Data is Jumbled…•Suppose that we combine instructor and department •(Below represents the join on instructor and department)\nECE30030/ITP30010 Database Systems3\nWhen Data is Jumbled…•Key issues•Repetition of data à increases the size of database•Data consistency issues•Insertion anomaly: Inserting redundant data for every new record•Deletion anomaly: Loss of related data, when some data is deleted•Update anomaly: When updating certain information, every single record must be updated\nECE30030/ITP30010 Database Systems4\nSolution: Decomposition!•How to avoid the repetition-of-information problem?\n•A: Decompose it into two schemas (as they were)•Normalization = decomposition of relational schemas•Key idea: split relational schemas such that only directly related data composes a relation\nECE30030/ITP30010 Database Systems5\nDecomposition•Less redundancy à Uses smaller disk storage; Causes less issues associated with insertion, deletion, and update anomalies•Not all decompositions are good•E.g., Suppose we decompose   employee(ID, name, street, city, salary)into  employee1 (ID, name)  employee2 (name, street, city, salary)à Problem: What if there are two employees with the same name?•Lossy decomposition: a decomposition from which the original relation cannot be reconstructedECE30030/ITP30010 Database Systems6\nLossy Decomposition\nECE30030/ITP30010 Database Systems7\nLossless Decomposition•Let R be a relation schema and let R1 and R2 form a decomposition of R; that is, R = R1 U R2•A decomposition is a lossless decomposition if there is no loss of information by replacing R with the two relation schemas R1 U R2•Formally,\nÕR1(r)  ⋈  ÕR2(r) = r•C.f., Conversely, a decomposition is lossy if when the join of the projection results is computed, a proper superset of the original relation is returned     r  Ì  ÕR1(r)  ⋈  ÕR2(r)\nECE30030/ITP30010 Database Systems8\nExample: Lossless Decomposition•Decomposition of R = (A, B, C)  à  R1 = (A, B); R2 = (B, C)\nECE30030/ITP30010 Database Systems9\nNormalization•Database normalization: Process of structuring a database to reduce data redundancy and improve data integrity•In accordance with a series of normal forms (next topic)•Through the process:•One can decompose relations to suppress data anomalies•One can make sure the decomposition is lossless"
        },
        {
          "chapter_title": "데이터베이스 정규화 과정 및 일반 형식",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "데이터베이스 정규화가 관계형 데이터베이스 테이블을 더 높은 정규형으로 설계하는 과정임을 설명하고, 논리적으로 독립적인 데이터를 분리하여 키를 통해 연결하는 점진적인 프로세스를 소개합니다. 또한, UNF, 1NF, 2NF, 3NF, BCNF, 4NF 등 주요 정규형의 종류를 나열하고, 이들이 함수적 종속성 등의 이론적 기반을 가진다는 점을 강조합니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems11\nNormal Forms•Normalization process•Normalization is a database design technique, which is used to design a relational database table up to higher normal form•Procedurally separates logically independent (but related) data entities into multiple relations•Maintains the connections using keys•Progressive process•A higher level of database normalization cannot be achieved unless the previous levels have been satisfied•UNF: Unnormalized form•1NF: First normal form•2NF: Second normal form•3NF: Third normal form•BCNF: Boyce-Codd normal form (3.5NF)•4NF: Fourth normal form•…\nECE30030/ITP30010 Database Systems12\nNormal Forms•Normal forms are backed by a set of normalization theories•Functional dependencies•Partial dependencies•Transitive dependencies•Multi-valued dependencies•These theories decide whether a particular relation R is in “good form”•For a relation R is not in “good form”, decompose it into a set of relations {R1, R2, ..., Rn} such that•Each relation is in good form•The decomposition is a lossless decomposition"
        },
        {
          "chapter_title": "함수적 종속성 이해",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "함수적 종속성(Functional Dependency, FD)의 개념을 정의하고, 실제 데이터 제약 조건과의 연관성을 설명합니다. 릴레이션 스키마에서 속성 집합 간의 결정 관계를 예시를 통해 보여주며, 슈퍼 키와 후보 키와의 관계, 그리고 항상 만족되는 자명한 함수적 종속성(Trivial Functional Dependencies)에 대해 다룹니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems15\nFunctional Dependencies•There are usually a variety of constraints (rules) on the data in the real world•E.g., some of the constraints that are expected to hold in the university database are:•Students and instructors are uniquely identified by their ID•Each student and instructor has only one name•Each instructor and student is associated with only one department•Each department has only one value for its budget, and only one associated building•Relations require that the value for a certain set of attributes determines uniquely the value for another set of attributes•A functional dependency is a generalization of the notion of a key(= trivial dependency)\nECE30030/ITP30010 Database Systems16\nFunctional Dependencies•Let R be a relation schema, a and b be its attributes (a Í R and b Í R)•The functional dependency a ® b  holds on R if and only if, for any relations r(R), whenever any two tuples t1 and t2 of r agree on the attributes a, they also agree on the attributes b•That is,  t1[a] = t2 [a]    Þ    t1[b ] = t2 [b ]•E.g., Consider r(A,B) with the following instance of r\nA     B  1     4  1     5  3     7\n•On this instance, B ® A hold;  A ® B does NOT hold (only the values of B are unique)\nECE30030/ITP30010 Database Systems17\nKeys and Functional Dependencies•Functional dependencies allow us to express constraints that cannot be expressed using super keys•E.g., consider the schema:\nin_dep (ID, name, salary, dept_name, building, budget )•ID = instructor ID•dept_name = department of the instructor•We expect the following functional dependencies to hold:•dept_name ® building•ID ® buildingÞdept_name and ID are super keys = candidate keys* ID, dept_name, {ID, dept_name}•We would not expect the next to hold:•dept_name ® salary\nECE30030/ITP30010 Database Systems18\nFunctional Dependencies•For relation R = a1 a2 a3 a4\n•a1 is a part of the key•Functional dependency: a4 depends on its key, a1a2a3•b_id,  b_name, bd_detail_attrib1, , bd_detail_attrib2•Candidate keys: b_id, b_name, {b_id, b_name}•It should not be such that a4 depends on a1, and does not depend on a1a2a3 (a1 ➝ a4)  ⇒  partial dependency\nECE30030/ITP30010 Database Systems19\nCandidate key = a1, a2, a3, {a1, a2}, {a2,a3}, {a1, a3}, {a1,a2,a3}\nTrivial Functional Dependencies•A functional dependency is trivial if it is satisfied by all instances of a relation•Example:•ID, name ® ID•name ® name•In general, a ® b is trivial if b Í a\nECE30030/ITP30010 Database Systems20\nFunctional Dependencies•Example: student2(ID, name, tot_cred)•Hold•ID à name•ID à tot_cred•Not hold•tot_cred à name•name à tot_cred\nECE30030/ITP30010 Database Systems21\nFunctional Dependencies•score(score_id, student_id, subject_id, score)•{student_id, subject_id} à score\nECE30030/ITP30010 Database Systems22\nECE30030/ITP30010 Database Systems22\nECE30030/ITP30010 Database Systems67\nFunctional Dependencies•There are usually a variety of constraints (rules) on the data in the real world•E.g., some of the constraints that are expected to hold in a university database are:•Students and instructors are uniquely identified by their ID•Each student and instructor has only one name•Each instructor and student is (primarily) associated with only one department•Each department has only one value for its budget, and only one associated building•Relations require that the value for a certain set of attributes determines uniquely the value for another set of attributes•A functional dependency is a generalization of the notion of a key(= trivial dependency)\nECE30030/ITP30010 Database Systems68\nFunctional Dependencies•Let R be a relation schema, a and b be its attributes (a Í R and b Í R)•The functional dependency a ® b  holds on R if and only if, for any relations r(R), whenever any two tuples t1 and t2 of r agree on the attributes a, they also agree on the attributes b•That is,  t1[a] = t2 [a]    Þ    t1[b ] = t2 [b ]•E.g., Consider r(A,B) with the following instance of r\nA     B  1     4  1     5  3     7\n•On this instance, B ® A hold;  A ® B does NOT hold (only the values of B are unique)\nECE30030/ITP30010 Database Systems69\nKeys and Functional Dependencies•Functional dependencies allow us to express constraints that cannot be expressed using super keys•E.g., consider the schema:\nin_dep (ID, name, salary, dept_name, building, budget )•ID = instructor ID•dept_name = department of the instructor•We expect the following functional dependencies to hold:•dept_name® building•ID à buildingÞdept_name and ID are super keys = candidate keys* ID, dept_name, {ID, dept_name}•We would not expect the next to hold:•dept_name ® salary\nECE30030/ITP30010 Database Systems70\nFunctional Dependencies•For relation R = a1 a2 a3 a4\n•a1 is a part of the key•Functional dependency: a4 depends on its key, a1a2a3•b_id,  b_name, bd_detail_attrib1, , bd_detail_attrib2•Candidate keys: b_id, b_name, {b_id, b_name}•It should not be such that a4 depends on a1, and does not depend on a1a2a3 (a1 ➝ a4)  ⇒  partial dependency\nECE30030/ITP30010 Database Systems71\nCandidate key = a1, a2, a3, {a1, a2}, {a2,a3}, {a1, a3}, {a1,a2,a3}\nTrivial Functional Dependencies•A functional dependency is trivial if it is satisfied by all instances of a relation•Example:•ID, name ® ID•name ® name•In general, a ® b is trivial if b Í a\nECE30030/ITP30010 Database Systems72\nFunctional Dependencies•student2(ID, name, tot_cred)•ID à name•ID à tot_cred•tot_cred à name (X)\nECE30030/ITP30010 Database Systems73\nFunctional Dependencies•SCORE(score_id, student_id, subject_id, score)•{student_id, subject_id} à score"
        },
        {
          "chapter_title": "제1 정규형 (1NF): 원자성 및 고유성",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "제1 정규형(1NF)의 요구사항을 설명하며, 모든 속성 값이 원자적이어야 하고, 각 컬럼은 동일한 데이터 도메인 내의 값을 포함하며, 고유한 이름을 가져야 한다는 점을 강조합니다. 중복된 행이 없어야 하며, 기본 키(PK)가 고유성과 Not Null을 보장하는 역할을 설명하고, 실제 예시를 통해 1NF로의 변환 과정을 보여줍니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems13\nFirst Normal Form (1NF)•Requirements•A relation should consist of atomic values•Atomic value: a value that cannot be divided (≃primitive data types in JAVA)•Atomic - INT, FLOAT, DOUBLE, DECIMAL (NUMERIC), CHAR, VARCHAR, BLOB, TEXT•NOGO - Structure, List (array)•Attributes should have unique identifiers•Step 1 of the normalization process•“If the tables in your DB does not follow 1NF, stop using database”\nECE30030/ITP30010 Database Systems14\nFirst Normal Form (1NF)•1NF checklist1.Each column should contain an atomic value•Entries like (x, y) violate this rule2.Each column should contain values that are in the same data domain•Do not mix different types of values in a column3.Each column should have a unique name•Duplicate names lead to confusion while accessing data4.The order in which data is stored does not matter•Using SQL, one can easily fetch data in any order5.There are no duplicated rows in the table•Primary key (PK) ensures: •Attributes that are part of PK are unique•Attributes that are part of PK are not null\nECE30030/ITP30010 Database Systems23\nFirst Normal Form (1NF)•Example\nstudent_idnamecourse\n21800999James InexistenteAlgorithm, OS\n21800998Mike InexistenteJava\n21800997Matt InexistenteAlgorithm, DB\nECE30030/ITP30010 Database Systems24\nFirst Normal Form (1NF)•Example\nstudent_idname\n21800999James Inexistente\n21800998Mike Inexistente\n21800997Matt Inexistente\nstudent_idcourse\n21800999Algorithm\n21800999OS\n21800998Java\n21800997Algorithm\n21800997DB\nECE30030/ITP30010 Database Systems25\nFirst Normal Form (1NF)•Example\nstudent_idname\n21800999James Inexistente\n21800998Mike Inexistente\n21800997Matt Inexistente\nstudent_idcourse\n21800999Algorithm\n21800999OS\n21800998Java\n21800997Algorithm\n21800997DB"
        },
        {
          "chapter_title": "제2 정규형 (2NF): 부분 종속성 제거",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "제2 정규형(2NF)의 요구사항을 설명하며, 1NF를 만족하고 기본 키가 아닌 속성이 후보 키의 어떤 부분 집합에도 함수적으로 종속되지 않아야 함을 강조합니다. 부분 종속성(Partial Dependency)의 정의와 이를 제거하기 위한 관계 분해(Decomposition) 과정을 다양한 예시를 통해 구체적으로 설명합니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems26\nSecond Normal Form (2NF)•Requirements•A relation should be in 1NF (normal forms should be applied in order)•A relation should NOT have a non-PK that is functionally dependent on any subset of any candidate key = NO PARTIAL DEPENDENCIES!•Any attributes other than PK should be dependent on PK•It should not have partial dependencies•PK: Primary Key•An attribute or a set of attributes that uniquely identifies each tuple in a relation•A PK can fetch data from any specific data in a relation•E.g., get the department name of student_ID = 21800999\nECE30030/ITP30010 Database Systems27\nPartial Dependencies•For relation R = a1 a2 a3 a4\n•a1 is a part of the primary key•Partial dependency: a4 depends on a1, and does not depend on a1a2a3•Key: a1 a2 a3•Dependency: a1 ➝ a4\nPrimary key (Composite)\nECE30030/ITP30010 Database Systems28\nEliminating Partial Dependencies•Example: teaches2(ID, course_id, sec_id, semester, year, name)•ID à name\nECE30030/ITP30010 Database Systems29\nEliminating Partial Dependencies•Example: •teaches2a(ID, course_id, sec_id, semester, year)•teaches2b(ID, name)\nECE30030/ITP30030Database Systems 30\nEliminating Partial Dependencies•Example: score(score_id, student_id, subject_id, score, instructor)•subject_id à instructor : partial dependency\nscore_idstudent_idsubject_idscoreinstructor\n1 10 1 82James Packer\n3 11 1 95James Packer\n2 10 2 77Cole Miller\n4 11 2 71Cole Miller\n5 11 4 96Adam Lee\nECE30030/ITP30030Database Systems 31\nEliminating Partial Dependencies•Example: score_a(score_id, student_id, subject_id, score)                 score_b(subject_id, instructor)\nscore_idstudent_idsubject_idscore\n1 10 1 82\n3 11 1 95\n2 10 2 77\n4 11 2 71\n5 11 4 96\nsubject_idinstructor\n1 James Packer\n2 Cole Miller\n4 Adam Lee\nECE30030/ITP30010 Database Systems74\nPartial Dependencies•For relation R = a1 a2 a3 a4\n•a1 is a part of the primary key•a4 depends on a1, and does not depend on a1a2a3 (a1 ➝ a4)•Key: a1 a2 a3•Dependency: a1 ➝ a4\nPrimary key (Composite)\nECE30030/ITP30010 Database Systems75\nPartial Dependencies•teaches2(ID, course_id, sec_id, semester, year, name)•ID à name•{course_id, sec_id, semester, year} à name\nECE30030/ITP30010 Database Systems76\nPartial Dependencies•SCORE(score_id, student_id, subject_id, score, instructor)•subject_id à instructor (partial dependency) :: WE DON’T WANT TO HAVE THIS"
        },
        {
          "chapter_title": "제3 정규형 (3NF): 이행적 종속성 제거",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "제3 정규형(3NF)의 요구사항을 설명하며, 2NF를 만족하고 이행적 종속성(Transitive Dependency)이 없어야 함을 강조합니다. 이행적 종속성은 기본 키가 아닌 속성이 다른 기본 키가 아닌 속성에 종속되는 경우를 의미하며, 이를 제거하기 위한 관계 분해 과정을 다양한 도서 및 시험 점수 관리 예시를 통해 상세히 제시합니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems32\nThird Normal Form (3NF)•Requirements•A relation should be in 2NF •A relation should NOT have transitive dependencies•Transitive dependency: A non-PK attribute depends on another non-PK attribute or a set of non-PK attributes\nECE30030/ITP30010 Database Systems33\nTransitive Dependencies•For relation R = a1 a2 a3 a4\n•a1 is the primary key in R•a3 depends on a1 (a1 ➝ a3) -- OK•a4 depends on a3 (a1 ➝ a3 ➝ a4) … non-PK à non-PK\nCandidate key = a1, a2, {a1,a2}\nECE30030/ITP30010 Database Systems34\nEliminating Transitive Dependencies•Example\nBookNoPatronAddressDue\nB1J. Fisher101 Main Street3/2/15\nB2L. Perez202 Market Street 2/28/15\nECE30030/ITP30010 Database Systems35\nEliminating Transitive Dependencies•Example\n•PK: BookNo•Patron à Address\nBookNoPatronAddressDue\nB1J. Fisher101 Main Street3/2/15\nB2L. Perez202 Market Street 2/28/15\nECE30030/ITP30010 Database Systems36\nEliminating Transitive Dependencies•Example\nBookNoPatronDue\nB1J. Fisher3/2/15\nB2L. Perez2/28/15PatronAddressJ. Fisher101 Main StreetL. Perez202 Market Street\nECE30030/ITP30010 Database Systems37\nEliminating Transitive Dependencies•Example\n•PK: {Tournament, Year}•Winner à DOB\nTournamentYearWinner DOB\nIndiana Invitational1998Al Fredrickson21 July 1975\nCleveland Open1999Bob Albertson28 Sept. 1968\nDes Moines Masters1999Al Fredrickson21 July 1975\nECE30030/ITP30010 Database Systems38\nEliminating Transitive Dependencies•Example: score2(id, student_id, subject_id, exam_name, exam_score)•{student_id, subject_id} --> FINAL or MIDTERM•{student_id, subject_id} --> 77   43 … from which ?•{student_id, subject_id} à exam_name à exam_score :: transitive dependency\nECE30030/ITP30010 Database Systems39\nEliminating Transitive Dependencies•Example: score2(id, student_id, subject_id, exam_name, exam_score)•student_id, subject_id à exam_name•student_id, subject_id à exam_name à exam_score\nECE30030/ITP30010 Database Systems40\nEliminating Transitive Dependencies•Example: score2a(id, student_id, subject_id, exam_id, exam_name)                 score2b(student_id, subject_id, exam_id, exam_score)\nECE30030/ITP30010 Database Systems77\nTransitive Dependencies•For relation R = a1 a2 a3 a4\n•a1 is the primary key in R•a3 depends on a1 (a1 ➝ a3) -- OK•a4 depends on a3 (a1 ➝ a3 ➝ a4) … non-PK à non-PK\nCandidate key = a1, a2, {a1,a2}\nECE30030/ITP30010 Database Systems78\nTransitive Dependencies•EXAM_SCORE(id, student_id, subject_id, exam_name, exam_score)•{student_id, subject_id} --> FINAL or MIDTERM•{student_id, subject_id} --> 77   43 … from which ?•{student_id, subject_id} à exam_name à exam_score :: transitive dependency"
        },
        {
          "chapter_title": "보이스-코드 정규형 (BCNF): 강화된 제3 정규형",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "보이스-코드 정규형(BCNF)은 제3 정규형을 강화한 형태로, A → B 종속성이 있을 때 A가 반드시 슈퍼 키여야 한다는 요구사항을 설명합니다. 즉, 기본 키가 아닌 속성이 기본 키의 일부를 결정하는 경우가 없어야 하며, 이를 위반하는 사례와 BCNF를 만족하도록 관계를 분해하는 과정을 예시를 통해 보여줍니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems41\nBoyce-Codd Normal Form (BCNF) = 3.5NF•Requirements•A relation should be in 3NF•For any dependency A à B, A should be a super key•For A à B, if A is non-PK, then it is NOT in BCNF\nECE30030/ITP30010 Database Systems42\nBoyce-Codd Normal Form (BCNF)•Example: takes2(student_id, subject, instructor)\n•(student, subject) à instructor•Instructor à subject•A non-PK identifies a member of PK: Not in BCNF\nstudent_idsubjectinstructor\n21800999C++ Dr. Cpp\n21800999Java Dr. Java\n21800998C++ Dr. C\n21800997PythonDr. Python\n21800996C++ Dr. Cpp\nECE30030/ITP30010 Database Systems43\nBoyce-Codd Normal Form (BCNF)•Example: takes2a(student_id, section_id),\ntakes2b(section_id, subject, instructor)\nstudent_idsection_id\n21800999101\n21800999103\n21800998102\n21800997104\n21800996101section_idsubjectinstructor\n101 C++ Dr. Cpp\n103 Java Dr. Java\n102 C++ Dr. C\n104 PythonDr. Python\nECE30030/ITP30010 Database Systems44\nBoyce-Codd Normal Form (BCNF)•Example: takes2a(student_id, section_id),\ntakes2b(section_id, subject, instructor)\nstudent_idsection_id\n21800999101\n21800999103\n21800998102\n21800997104\n21800996101section_idsubjectinstructor\n101 C++ Dr. Cpp\n103 Java Dr. Java\n102 C++ Dr. C\n104 PythonDr. Python"
        },
        {
          "chapter_title": "제4 정규형 (4NF): 다치 종속성 제거",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "제4 정규형(4NF)의 요구사항을 설명하며, BCNF를 만족하고 다치 종속성(Multi-valued Dependency, MVD)이 없어야 함을 강조합니다. 다치 종속성은 릴레이션에 3개 이상의 속성이 있고, 서로 독립적인 다치 속성 집합이 존재할 때 발생할 수 있으며, 이를 제거하기 위한 관계 분해 과정을 학생의 수강 과목 및 활동 예시를 통해 설명합니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems45\nFourth Normal Form (4NF)•Requirements•A relation should be in BCNF•A relation should NOT have multi-valued dependency•Multi-valued dependency occurs due to a bad DB schema•Multi-valued dependency occurs when a relation has more than 3 attributes•For a relation with attributes A, B, C•having dependency, A à B, and•B and C are independent from each otherè Then, the relation may have a multi-valued dependency\nECE30030/ITP30010 Database Systems46\nMulti-valued Dependencies•Example•student_id à course•student_id à activity•course ⊥ activity (independent)\nstudent_idcourseactivity\n21800999StatisticsSoccer\n21800999Linear algebraBasketball\n21800999StatisticsBasketball\n21800999Linear algebraSoccer\nECE30030/ITP30010 Database Systems47\nMulti-valued Dependencies•Example\nstudent_idcourse\n21800999Statistics\n21800999Linear algebra\n21800998Physics\n21800998Programming 101student_idactivity\n21800999Soccer\n21800999Basketball\n21800998Pool\n21800997Soccer\nECE30030/ITP40001 Database Systems79\nMulti-valued Dependencies (MVDs)•Suppose we record names of children, and phone numbers for instructors•inst_child(ID, child_name)•inst_phone(ID, phone_number)à If we combine these schemas to obtain: (multiple orthogonal values in single table à this causes redundancy)•inst_info(ID, child_name, phone_number)à Example tuples: ID=999999 à {David, William} & {x-x-1234, x-x-4321}  (99999, David, 512-555-1234)  (99999, David, 512-555-4321)  (99999, William, 512-555-1234)  (99999, William, 512-555-4321)•Any issues?\nECE30030/ITP40001 Database Systems80\nMulti-valued Dependencies (MVDs)•Let R be a relation schema and let a Í R and b Í R. •The multivalued dependency a ®® b holds on R if in any relation r(R), for all pairs for tuples t1 and t2 in r such that t1[a] = t2 [a], there exist tuples t3 and t4 in r such that:    t1[a] = t2 [a] = t3 [a] = t4 [a]           t3[b] =  t1 [b]           t3[R  – b] =  t2[R  – b]           t4 [b] =  t2[b]           t4[R  – b] =  t1[R  – b]\nECE30030/ITP40001 Database Systems81\nMulti-valued Dependencies (MVDs)•Let R be a relation schema with a set of attributes that are partitioned into 3 non-empty subsets Y, Z, W•We say that Y ®® Z (Y multidetermines Z )if and only if for all possible relations r(R)  < y1, z1, w1 > Î r and < y1, z2, w2 > Î rthen  < y1, z1, w2 > Î r and < y1, z2, w1 > Î r•Note that since the behavior of Z and W are identical it follows that Y ®® Z if Y ®® W\nECE30030/ITP40001 Database Systems82\nMulti-valued Dependencies (MVDs)•Tabular representation of a ®® b\nECE30030/ITP40001 Database Systems83\nMulti-valued Dependencies (MVDs)•FAV(student_id, course, activity)•21800999 - {statistics, Linear algebra} & {Soccer, basketball}•Favorite courses & favorite activities <= they are orthogonal\nstudent_idcourseactivity\n21800999StatisticsSoccer\n21800999Linear algebraBasketball\n21800999StatisticsBasketball\n21800999Linear algebraSoccer"
        },
        {
          "chapter_title": "정규화 이론 및 종속성 요약",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "각 정규형(2NF, 3NF, BCNF, 4NF, 5NF)과 관련된 핵심 이론 및 종속성(함수적, 부분, 이행적, 다치, 조인 종속성)을 요약하여 제시합니다. 정규화 이론이 '좋은 형태'의 릴레이션을 결정하고 무손실 분해를 통해 이를 달성하는 데 사용됨을 강조하며, 함수적 종속성과 다치 종속성이 데이터베이스의 유효성 검사 및 제약 조건 지정에 어떻게 활용되는지 설명합니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems48\nSummary: Normal Forms•Theories – Normal forms\nTheory Key IdeaNormal Form\nFunctional dependency(PK à non-PK)2NF\nPartial dependencyPart of PK à non-PK2NF\nTransitive dependencyNon-PK à non-PK3NF\n- Non-PK à PK BCNF\nMulti-valued dependency4NF\nJoin dependency5NF\nECE30030/ITP30010 Database Systems65\nNormalization Theory•Decide whether a particular relation R is in “good form”•For a relation R is not in “good form”, decompose it into a set of relations {R1, R2, ..., Rn} such that•Each relation is in good form•The decomposition is a lossless decomposition\nECE30030/ITP30010 Database Systems66\nNormalization Theory•The normalization is based on a set of relevant theories:•Functional dependencies•Partial dependencies•Transitive dependencies•Multivalued dependencies\nECE30030/ITP40001 Database Systems84\nUse of Functional Dependencies•We use functional dependencies to:•Test relations to see if they are legal under a given set of functional dependencies•We say that r satisfies F, if a relation r is legal under a set F of functional dependencies•To specify constraints on the set of legal relations•We say that F holds on R if all legal relations on R satisfy the set of functional dependencies F•Note:  A specific instance of a relation schema may satisfy a functional dependency even if the functional dependency does not hold on all legal instances•E.g., a specific instance of instructor may, by chance, satisfy:  name ® ID\nECE30030/ITP40001 Database Systems85\nUse of Multi\n-\nvalued Dependencies•We use multivalued dependencies in two ways:1.To test relations to determine whether they are legal under a given set of functional and multivalued dependencies2.To specify constraints on the set of legal relations. We shall concern ourselves only with relations that satisfy a given set of functional and multivalued dependencies•If a relation r fails to satisfy a given multivalued dependency, we can construct a relations r¢  that does satisfy the multivalued dependency by adding tuples to r"
        },
        {
          "chapter_title": "정규화 실전 예시",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "위키피디아에서 가져온 서적 소매업 데이터베이스 예시를 통해 데이터베이스 정규화 과정을 단계별로 상세히 설명합니다. 1NF, 2NF, 3NF, BCNF, 그리고 4NF를 만족하도록 테이블을 분해하고 종속성을 제거하는 실제 적용 사례를 보여주며, 각 정규형의 요구사항이 어떻게 충족되는지 시각적으로 제시합니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems53\nExample (taken from Wikipedia)•Provided:\nECE30030/ITP30010 Database Systems54\nExample (taken from Wikipedia)•Satisfying 1NF\nECE30030/ITP30010 Database Systems55\nExample (taken from Wikipedia)•Satisfying 1NF (cont’d – further improvement)\nECE30030/ITP30010 Database Systems56\nExample (taken from Wikipedia)•Provided:\n•Compound key {Title, Format}•Partial dependency: Title à Author, Author Nationality, Pages, Thickness, Genre ID, Genre Name, Publisher ID\nECE30030/ITP30010 Database Systems57\nExample (taken from Wikipedia)•Satisfying 2NF\nECE30030/ITP30010 Database Systems58\nExample (taken from Wikipedia)•Satisfying 3NF\n•Transitive dependency: Genre ID à Genre Name\nECE30030/ITP30010 Database Systems59\nExample (taken from Wikipedia)•Satisfying 3NF\nECE30030/ITP30010 Database Systems60\nExample (taken from Wikipedia)•Satisfying BCNF\n•Non-PK à Non-PK: Author à Author Nationality\nECE30030/ITP30010 Database Systems61\nExample (taken from Wikipedia)•Satisfying BCNF\nECE30030/ITP30010 Database Systems62\nExample (taken from Wikipedia)•Provided:•Assume the database is owned by a book retailer franchise that has several franchisees that own shops in different locations\nECE30030/ITP30010 Database Systems63\nExample (taken from Wikipedia)•Satisfying 4NF•If we assume that all available books are offered in each area, the Title is not unambiguously bound to a certain Locationà Does not satisfy 4NF\nECE30030/ITP30030Database Systems 64\n•Source: https://en.wikipedia.org/wiki/Database_normalization"
        },
        {
          "chapter_title": "데이터베이스 설계 과정 및 비정규화",
          "source_pdf_filename": "a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf",
          "chapter_content_summary": "데이터베이스 설계 과정에서 정규화가 어떻게 통합되는지 설명합니다. E-R 모델 설계의 중요성과 정규화의 관계를 다루고, 성능 향상을 위해 의도적으로 정규화되지 않은 스키마를 사용하는 비정규화(Denormalization)의 개념과 그 장단점을 제시합니다. 또한, 연도별 수익 데이터와 같은 특정 설계 문제가 정규화만으로는 해결되지 않을 수 있음을 지적하며 더 나은 스키마 설계를 제안합니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems49\nOverall DB Design Process•Let us assume schema R is given:(E-R Model)•R could have been generated when converting E-R diagram to a set of tables(Normalization)•R could have been a single relation containing all attributes that are of interest (called universal relation)•Normalization breaks R into smaller relations(Mixed)•R could have been the result of some ad-hoc design of relations, which we then test/convert to normal form\nECE30030/ITP30010 Database Systems50\nE-R Model and Normalization•When an E-R diagram is carefully designed, identifying all entities correctly, the tables generated from the E-R diagram should not need further normalization•However, in a real (imperfect) design, there can be functional dependencies from non-key attributes of an entity to other attributes of the entity•E.g., an employee entity with•attributesdepartment_name and building•functional dependencydepartment_name® building•Good design would have made department an entity•Functional dependencies from non-key attributes of a relationship set possible, but rare --- most relationships are binary\nECE30030/ITP30010 Database Systems51\nDenormalization for Performance•We may want to use non-normalized schema for performance•For example, displaying prereqs along with course_id, and title requires join of course with prereq•Alternative 1: Use denormalized relation containing attributes of course as well as prereq with all above attributes•faster lookup•extra space and extra execution time for updates•extra coding work for programmer and possibility of error in extra code•Alternative 2: Use a materialized view defined a course ⋈ prereq•Benefits and drawbacks same as above, except no extra coding work for programmer and avoids possible errors\nECE30030/ITP30010 Database Systems52\nRemaining Issues•Some aspects of database design are not caught by normalization•Example (to be avoided)•earnings_2004, earnings_2005, earnings_2006, etc., all on the schema (company_id, earnings)•Above are well normalized (in BCNF), but make querying across years difficult and needs new table each year•company_year (company_id, earnings_2004, earnings_2005,  earnings_2006)•Above are well normalized (in BCNF), but makes querying across years difficult and requires new attribute each year•This is an example of a crosstab, where values for one attribute become column namesà Better schema: earnings (company_id, year, amount)"
        }
      ],
      "generated_content": [
        {
          "title": "데이터베이스 정규화 개요 및 필요성",
          "metadata": "Source: a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf, Text length: 1990 chars",
          "documentContent": [
            {
              "type": "heading",
              "content": "데이터 혼합 시 발생하는 문제점",
              "level": 1
            },
            {
              "type": "paragraph",
              "content": "강사(instructor)와 학과(department) 데이터를 결합하는 경우를 가정해 봅시다. 아래는 강사 및 학과에 대한 조인(join)을 나타냅니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "데이터가 혼합될 때 발생하는 주요 문제점들은 다음과 같습니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "데이터 중복: 데이터베이스 크기를 증가시킵니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "데이터 일관성 문제:",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "삽입 이상(Insertion anomaly): 새로운 레코드를 삽입할 때마다 중복된 데이터를 삽입해야 합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "삭제 이상(Deletion anomaly): 일부 데이터가 삭제될 때 관련 데이터가 손실됩니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "갱신 이상(Update anomaly): 특정 정보를 갱신할 때 모든 관련 레코드를 갱신해야 합니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "해결책: 분해(Decomposition)!",
              "level": 1
            },
            {
              "type": "paragraph",
              "content": "정보 중복 문제를 어떻게 피할 수 있을까요?",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "해답은 원래의 두 스키마로 분해하는 것입니다. 정규화(Normalization)는 관계형 스키마의 분해를 의미합니다. 핵심 아이디어는 직접적으로 관련된 데이터만 하나의 릴레이션을 구성하도록 관계형 스키마를 분할하는 것입니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "분해(Decomposition)",
              "level": 1
            },
            {
              "type": "paragraph",
              "content": "분해는 데이터 중복을 줄여 더 적은 디스크 저장 공간을 사용하게 하며, 삽입, 삭제, 갱신 이상과 관련된 문제를 감소시킵니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "하지만 모든 분해가 좋은 것은 아닙니다. 예를 들어, employee(ID, name, street, city, salary)를 employee1(ID, name)과 employee2(name, street, city, salary)로 분해한다고 가정해 봅시다. 만약 같은 이름을 가진 두 명의 직원이 있다면 문제가 발생합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "손실 분해(Lossy decomposition): 원본 릴레이션을 재구성할 수 없는 분해를 의미합니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "무손실 분해(Lossless Decomposition)",
              "level": 1
            },
            {
              "type": "paragraph",
              "content": "R을 관계형 스키마라고 하고, R1과 R2가 R의 분해를 형성한다고 합시다. 즉, R = R1 ∪ R2 입니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "분해가 무손실 분해(lossless decomposition)라는 것은 R을 두 관계형 스키마 R1 ∪ R2로 대체함으로써 정보 손실이 없음을 의미합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "공식적으로는 ÕR1(r) ⋈ ÕR2(r) = r 입니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "반대로, 투영 결과의 조인이 계산될 때 원본 릴레이션의 진부분 집합(proper superset)이 반환되는 경우 분해는 손실 분해(lossy decomposition)입니다. 즉, r ⊂ ÕR1(r) ⋈ ÕR2(r) 입니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "무손실 분해 예시",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "R = (A, B, C)를 R1 = (A, B)와 R2 = (B, C)로 분해하는 예시입니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "정규화(Normalization)",
              "level": 1
            },
            {
              "type": "paragraph",
              "content": "데이터베이스 정규화는 데이터 중복을 줄이고 데이터 무결성을 향상시키기 위해 데이터베이스를 구조화하는 과정입니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "이는 일련의 정규형(다음 주제)에 따라 수행됩니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "정규화 과정을 통해 릴레이션을 분해하여 데이터 이상(anomalies)을 억제할 수 있으며, 분해가 무손실임을 확인할 수 있습니다.",
              "level": null
            }
          ],
          "aiNotes": {
            "summary": "본 텍스트는 데이터베이스에서 데이터가 혼합될 때 발생하는 중복 및 일관성 문제, 특히 삽입, 삭제, 갱신 이상과 같은 '데이터 이상' 현상을 다룹니다. 이러한 문제의 해결책으로 '분해'와 '정규화' 개념을 소개하며, 관계형 스키마를 분할하여 데이터 중복을 줄이고 데이터 무결성을 높이는 방법을 설명합니다. 특히, 분해 과정에서 정보 손실이 발생하지 않도록 하는 '무손실 분해'의 중요성과 그 정의를 강조합니다. 정규화는 데이터 이상을 억제하고 분해가 무손실임을 보장하는 체계적인 과정으로 제시됩니다.",
            "keyConcepts": [
              {
                "term": "데이터 이상 (Data Anomalies)",
                "definition": {
                  "easy": "데이터가 엉망이 돼서 추가, 삭제, 수정할 때 문제가 생기는 거예요.",
                  "medium": "데이터베이스 내에 중복된 데이터로 인해 발생하는 비일관성 문제로, 삽입, 삭제, 갱신 시 예상치 못한 부작용을 초래합니다.",
                  "hard": "관계형 데이터베이스에서 릴레이션의 속성 간에 적절한 함수적 종속성이 확립되지 않아 발생하는 데이터 일관성 위반 문제로, 삽입 이상, 삭제 이상, 갱신 이상으로 구분되며 데이터 무결성을 저해합니다."
                }
              },
              {
                "term": "정규화 (Normalization)",
                "definition": {
                  "easy": "데이터를 깔끔하게 정리해서 중복을 줄이고 문제 없게 만드는 과정이에요.",
                  "medium": "데이터 중복을 최소화하고 데이터 무결성을 향상시키기 위해 관계형 데이터베이스 스키마를 체계적으로 분해하는 과정입니다.",
                  "hard": "관계형 데이터베이스 설계에서 데이터 중복성을 줄이고 삽입, 삭제, 갱신 이상과 같은 데이터 이상 현상을 방지하며 데이터 무결성을 보장하기 위해, 일련의 정규형 규칙에 따라 릴레이션 스키마를 분해하고 재구성하는 절차입니다."
                }
              },
              {
                "term": "분해 (Decomposition)",
                "definition": {
                  "easy": "큰 덩어리의 데이터를 작은 여러 덩어리로 나누는 거예요.",
                  "medium": "하나의 관계형 스키마를 두 개 이상의 작은 스키마로 나누는 과정으로, 데이터 중복을 줄이고 효율성을 높이는 데 사용됩니다.",
                  "hard": "관계형 데이터베이스에서 하나의 릴레이션 스키마를 둘 이상의 릴레이션 스키마로 분할하는 연산으로, 이 과정에서 원래의 릴레이션이 가지던 함수적 종속성 및 기타 제약 조건이 유지되도록 해야 하며, 특히 무손실 조인 분해가 중요하게 고려됩니다."
                }
              },
              {
                "term": "무손실 분해 (Lossless Decomposition)",
                "definition": {
                  "easy": "데이터를 나눴다가 다시 합쳐도 원래 데이터가 그대로 유지되는 분해예요.",
                  "medium": "릴레이션을 여러 개의 하위 릴레이션으로 분해한 후, 이 하위 릴레이션들을 다시 조인했을 때 원래의 릴레이션과 동일한 정보를 얻을 수 있는 분해 방식입니다.",
                  "hard": "관계형 스키마 R을 R1과 R2로 분해했을 때, 원래 릴레이션 r에 대한 R1과 R2의 투영(projection) 결과를 자연 조인(natural join)한 결과가 r과 정확히 일치하는 경우를 의미하며, 이는 정보 손실 없이 원래의 데이터를 재구성할 수 있음을 보장합니다."
                }
              }
            ],
            "importantTerms": [
              {
                "term": "삽입 이상 (Insertion anomaly)",
                "definition": "새로운 레코드를 추가할 때 원치 않는 중복 데이터가 함께 삽입되거나, 필요한 정보가 없어 삽입이 불가능해지는 문제."
              },
              {
                "term": "삭제 이상 (Deletion anomaly)",
                "definition": "레코드를 삭제할 때, 삭제하려는 정보 외에 다른 중요한 정보까지 함께 손실되는 문제."
              },
              {
                "term": "갱신 이상 (Update anomaly)",
                "definition": "중복된 데이터 중 일부만 갱신되어 데이터 불일치가 발생하는 문제."
              },
              {
                "term": "손실 분해 (Lossy Decomposition)",
                "definition": "릴레이션을 분해한 후 다시 조인했을 때, 원래 릴레이션의 정보가 손실되거나 불필요한 튜플이 생성되는 분해."
              },
              {
                "term": "관계형 스키마 (Relational Schema)",
                "definition": "관계형 데이터베이스에서 릴레이션의 이름과 속성(컬럼) 및 그들의 도메인(데이터 타입)을 정의하는 논리적 구조."
              },
              {
                "term": "데이터 무결성 (Data Integrity)",
                "definition": "데이터베이스 내의 데이터가 정확하고 일관되며 신뢰할 수 있는 상태를 유지하는 것."
              }
            ],
            "outline": [
              {
                "text": "데이터 혼합 시 발생하는 문제점",
                "id": "데이터-혼합-시-발생하는-문제점",
                "children": null
              },
              {
                "text": "해결책: 분해(Decomposition)!",
                "id": "해결책-분해-decomposition",
                "children": null
              },
              {
                "text": "분해(Decomposition)",
                "id": "분해-decomposition",
                "children": null
              },
              {
                "text": "무손실 분해(Lossless Decomposition)",
                "id": "무손실-분해-lossless-decomposition",
                "children": [
                  {
                    "text": "무손실 분해 예시",
                    "id": "무손실-분해-예시",
                    "children": null
                  }
                ]
              },
              {
                "text": "정규화(Normalization)",
                "id": "정규화-normalization",
                "children": null
              }
            ]
          },
          "quiz": [
            {
              "question": "데이터베이스에서 데이터가 혼합될 때 발생할 수 있는 주요 문제점이 아닌 것은 무엇입니까?",
              "options": [
                "데이터 중복 증가",
                "데이터 일관성 문제",
                "데이터 처리 속도 향상",
                "삽입, 삭제, 갱신 이상 발생"
              ],
              "answerIndex": 2,
              "explanation": "데이터가 혼합되면 데이터 중복과 일관성 문제가 발생하며, 이는 삽입, 삭제, 갱신 이상으로 이어져 데이터 처리 속도가 저하될 수 있습니다. 데이터 처리 속도 향상은 문제점이 아닙니다."
            },
            {
              "question": "다음 중 '원본 릴레이션을 재구성할 수 없는 분해'를 의미하는 용어는 무엇입니까?",
              "options": [
                "무손실 분해",
                "정규화",
                "손실 분해",
                "데이터 일관성"
              ],
              "answerIndex": 2,
              "explanation": "손실 분해(Lossy decomposition)는 분해 후 원본 릴레이션을 정확히 재구성할 수 없어 정보가 손실되거나 불필요한 정보가 추가되는 분해를 의미합니다."
            },
            {
              "question": "데이터베이스 정규화의 주요 목적 두 가지는 무엇입니까?",
              "options": [
                "디스크 저장 공간 증가, 데이터 처리 속도 감소",
                "데이터 중복 감소, 데이터 무결성 향상",
                "데이터 보안 강화, 사용자 인터페이스 개선",
                "보고서 생성 자동화, 백업 절차 간소화"
              ],
              "answerIndex": 1,
              "explanation": "데이터베이스 정규화의 주된 목적은 데이터 중복을 줄이고 데이터 일관성 및 정확성을 보장하는 데이터 무결성을 향상시키는 것입니다."
            }
          ]
        },
        {
          "title": "데이터베이스 정규화 과정 및 일반 형식",
          "metadata": "Source: a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf, Text length: 961 chars",
          "documentContent": [
            {
              "type": "heading",
              "content": "정규 형식 (Normal Forms)",
              "level": 1
            },
            {
              "type": "paragraph",
              "content": "정규화는 관계형 데이터베이스 테이블을 더 높은 정규 형식으로 설계하는 데 사용되는 데이터베이스 설계 기법입니다. 이 과정은 논리적으로 독립적이지만 상호 관련된 데이터 엔티티를 여러 릴레이션으로 절차적으로 분리하며, 키를 사용하여 연결을 유지합니다. 정규화는 점진적인 과정으로, 이전 단계가 충족되지 않으면 더 높은 수준의 데이터베이스 정규화를 달성할 수 없습니다. 일반적인 정규화 단계는 다음과 같습니다: UNF (비정규 형식), 1NF (제1 정규 형식), 2NF (제2 정규 형식), 3NF (제3 정규 형식), BCNF (보이스-코드 정규 형식, 3.5NF), 4NF (제4 정규 형식) 등이 있습니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "정규 형식은 일련의 정규화 이론에 의해 뒷받침됩니다. 이러한 이론에는 함수적 종속성, 부분 종속성, 이행 종속성, 다치 종속성 등이 포함됩니다. 이러한 이론들은 특정 릴레이션 R이 '좋은 형식'에 있는지 여부를 결정합니다. 만약 릴레이션 R이 '좋은 형식'이 아니라면, 각 릴레이션이 좋은 형식에 있고 분해가 손실 없는 분해(lossless decomposition)가 되도록 {R1, R2, ..., Rn}과 같은 릴레이션 집합으로 분해해야 합니다.",
              "level": null
            }
          ],
          "aiNotes": {
            "summary": "제공된 텍스트는 데이터베이스 정규화의 개념과 과정을 설명합니다. 정규화는 관계형 데이터베이스 설계 기법으로, 데이터 중복을 최소화하고 데이터 무결성을 유지하기 위해 논리적으로 독립된 데이터를 여러 릴레이션으로 분리하는 점진적인 과정입니다. UNF부터 4NF(BCNF 포함)까지의 다양한 정규 형식 단계를 소개하며, 정규화 이론이 함수적, 부분, 이행, 다치 종속성과 같은 개념에 기반을 두고 있음을 언급합니다. 또한, '좋은 형식'이 아닌 릴레이션은 손실 없는 분해를 통해 여러 '좋은 형식' 릴레이션으로 분해되어야 한다고 강조합니다.",
            "keyConcepts": [
              {
                "term": "데이터베이스 정규화 (Database Normalization)",
                "definition": {
                  "easy": "데이터를 잘 정리해서 중복을 줄이고 효율적으로 만드는 과정.",
                  "medium": "관계형 데이터베이스 설계 기법으로, 논리적으로 독립적인 데이터를 여러 관계로 분리하여 중복을 최소화하고 데이터 무결성을 유지하는 과정.",
                  "hard": "관계형 스키마 설계에서 데이터 중복을 제거하고 갱신 이상(update anomalies)을 방지하기 위해 릴레이션을 더 작은 릴레이션으로 분해하는 체계적인 과정으로, 함수적 종속성(functional dependencies)과 같은 이론적 기반을 바탕으로 한다."
                }
              },
              {
                "term": "정규 형식 (Normal Forms)",
                "definition": {
                  "easy": "데이터베이스가 얼마나 잘 정리되어 있는지 나타내는 단계.",
                  "medium": "관계형 데이터베이스 릴레이션이 특정 조건을 만족하는지 여부를 나타내는 단계로, 데이터 중복 및 이상 현상을 줄이는 데 사용된다.",
                  "hard": "관계형 데이터베이스 스키마 설계에서 릴레이션 스키마의 바람직한 속성을 정의하는 일련의 기준. 각 정규 형식은 특정 유형의 데이터 종속성(예: 부분 함수 종속, 이행 함수 종속)을 제거하여 갱신 이상을 방지하고 데이터 일관성을 향상시킨다."
                }
              },
              {
                "term": "손실 없는 분해 (Lossless Decomposition)",
                "definition": {
                  "easy": "데이터를 나눴다가 다시 합쳐도 원래 데이터가 그대로 유지되는 것.",
                  "medium": "릴레이션을 여러 개의 작은 릴레이션으로 분해할 때, 분해된 릴레이션들을 자연 조인(natural join)하여 원래의 릴레이션을 완벽하게 재구성할 수 있는 분해 방식.",
                  "hard": "관계형 데이터베이스에서 하나의 릴레이션 R을 R1, R2, ..., Rn으로 분해할 때, R = R1 ⋈ R2 ⋈ ... ⋈ Rn이 성립하여 정보 손실이 발생하지 않는 분해를 의미한다. 이는 무결성을 유지하며 중복을 제거하는 데 필수적이다."
                }
              }
            ],
            "importantTerms": [
              {
                "term": "관계형 데이터베이스 (Relational Database)",
                "definition": "데이터를 테이블(릴레이션) 형태로 저장하고 관리하는 데이터베이스 시스템."
              },
              {
                "term": "함수적 종속성 (Functional Dependency)",
                "definition": "릴레이션에서 어떤 속성 집합 X의 값이 다른 속성 집합 Y의 값을 유일하게 결정하는 관계 (X → Y)."
              },
              {
                "term": "부분 함수 종속성 (Partial Dependency)",
                "definition": "기본 키의 일부에 의해 결정되는 비기본 키 속성이 존재하는 경우."
              },
              {
                "term": "이행 함수 종속성 (Transitive Dependency)",
                "definition": "A → B이고 B → C가 성립할 때, A → C가 성립하며 B가 기본 키의 일부가 아닌 경우."
              },
              {
                "term": "다치 종속성 (Multi-valued Dependency)",
                "definition": "릴레이션에서 한 속성의 값이 다른 속성의 여러 값을 결정하는 경우."
              },
              {
                "term": "릴레이션 (Relation)",
                "definition": "관계형 데이터베이스에서 데이터를 저장하는 테이블."
              }
            ],
            "outline": [
              {
                "text": "정규 형식의 개요",
                "id": "정규-형식의-개요",
                "children": [
                  {
                    "text": "정규화 과정의 정의 및 목적",
                    "id": "정규화-과정의-정의-및-목적",
                    "children": null
                  },
                  {
                    "text": "정규화 단계",
                    "id": "정규화-단계",
                    "children": null
                  }
                ]
              },
              {
                "text": "정규 형식의 이론적 배경",
                "id": "정규-형식의-이론적-배경",
                "children": [
                  {
                    "text": "정규화 이론의 기초",
                    "id": "정규화-이론의-기초",
                    "children": null
                  },
                  {
                    "text": "릴레이션 분해의 원칙",
                    "id": "릴레이션-분해의-원칙",
                    "children": null
                  }
                ]
              }
            ]
          },
          "quiz": [
            {
              "question": "데이터베이스 정규화의 주요 목적은 무엇입니까?",
              "options": [
                "데이터 저장 공간 확장",
                "데이터 중복 최소화 및 무결성 유지",
                "데이터베이스 보안 강화",
                "쿼리 처리 속도 저하"
              ],
              "answerIndex": 1,
              "explanation": "정규화는 데이터 중복을 줄이고 논리적으로 독립적인 데이터를 분리하여 데이터 무결성을 유지하는 데 중점을 둡니다."
            },
            {
              "question": "다음 중 주어진 텍스트에서 데이터베이스 정규화의 단계로 명시적으로 언급되지 않은 것은 무엇입니까?",
              "options": [
                "1NF",
                "BCNF",
                "5NF",
                "UNF"
              ],
              "answerIndex": 2,
              "explanation": "주어진 텍스트에서 언급된 정규화 단계는 UNF, 1NF, 2NF, 3NF, BCNF, 4NF입니다. 5NF는 언급되지 않았습니다."
            },
            {
              "question": "릴레이션 R을 R1, R2, ..., Rn으로 분해할 때, 분해된 릴레이션들을 조인하여 원래의 R을 완벽하게 재구성할 수 있는 분해를 무엇이라고 합니까?",
              "options": [
                "손실 있는 분해",
                "부분 분해",
                "손실 없는 분해",
                "비정규 분해"
              ],
              "answerIndex": 2,
              "explanation": "텍스트에 따르면, '좋은 형식'이 아닌 릴레이션을 분해할 때, 'The decomposition is a lossless decomposition' 즉, 손실 없는 분해여야 한다고 명시되어 있습니다."
            }
          ]
        },
        {
          "title": "함수적 종속성 이해",
          "metadata": "Source: a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf, Text length: 3925 chars",
          "documentContent": [
            {
              "type": "heading",
              "content": "함수적 종속성 (Functional Dependencies)",
              "level": 1
            },
            {
              "type": "paragraph",
              "content": "데이터베이스 시스템에서 데이터는 일반적으로 현실 세계의 다양한 제약 조건(규칙)을 따릅니다. 예를 들어, 대학 데이터베이스에서 예상되는 몇 가지 제약 조건은 다음과 같습니다:",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "학생과 강사는 ID에 의해 고유하게 식별됩니다. 각 학생과 강사는 하나의 이름만 가집니다. 각 강사와 학생은 (주로) 하나의 학과에만 연결됩니다. 각 학과는 예산에 대해 하나의 값만 가지며, 하나의 건물과만 연결됩니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "릴레이션은 특정 속성 집합의 값이 다른 속성 집합의 값을 고유하게 결정해야 한다고 요구합니다. 함수적 종속성은 키의 개념을 일반화한 것입니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "함수적 종속성의 정의",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "R을 릴레이션 스키마라고 하고, a와 b를 R의 속성이라고 합시다 (a ⊆ R, b ⊆ R). 함수적 종속성 a → b는 릴레이션 r(R)의 어떤 두 튜플 t1과 t2가 속성 a에 대해 일치할 때마다 속성 b에 대해서도 일치하는 경우에만 R에서 성립합니다. 즉, t1[a] = t2[a] ⇒ t1[b] = t2[b] 입니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "예를 들어, 다음 인스턴스를 가진 릴레이션 r(A, B)를 고려해 봅시다:",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "A     B\n1     4\n1     5\n3     7",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "이 인스턴스에서 B → A는 성립합니다. 그러나 A → B는 성립하지 않습니다. (A 값이 1일 때 B 값이 4와 5로 다르기 때문입니다).",
              "level": null
            },
            {
              "type": "heading",
              "content": "키와 함수적 종속성",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "함수적 종속성은 슈퍼키를 사용하여 표현할 수 없는 제약 조건을 표현할 수 있게 합니다. 예를 들어, `in_dep (ID, name, salary, dept_name, building, budget)` 스키마를 고려해 봅시다. 여기서 ID는 강사 ID이고, dept_name은 강사의 학과입니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "우리는 다음 함수적 종속성이 성립할 것으로 예상합니다:",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "• `dept_name` → `building`\n• `ID` → `building`",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "`dept_name`과 `ID`는 슈퍼키이자 후보 키입니다. 하지만 `dept_name` → `salary`는 성립하지 않을 것으로 예상합니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "부분 종속성 (Partial Dependency)",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "릴레이션 R = a1 a2 a3 a4에서 a1이 키의 일부라고 가정해 봅시다. 함수적 종속성에서 a4가 키인 a1a2a3에 종속되는 것은 일반적입니다. 그러나 a4가 전체 키가 아닌 키의 일부인 a1에만 종속되고 a1a2a3에는 종속되지 않는 경우 (a1 → a4) 이를 부분 종속성이라고 합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "예를 들어, `b_id, b_name, bd_detail_attrib1, bd_detail_attrib2`와 같은 속성 집합에서 후보 키는 `b_id`, `b_name`, `{b_id, b_name}` 등이 될 수 있습니다. 여기서 `bd_detail_attrib1`이 `b_id`에만 종속되고 `{b_id, b_name}`에는 종속되지 않는다면 부분 종속성입니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "자명한 함수적 종속성 (Trivial Functional Dependencies)",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "함수적 종속성은 모든 릴레이션 인스턴스에서 항상 만족될 때 자명하다고 합니다. 예를 들어, `ID, name → ID` 또는 `name → name`과 같은 종속성은 자명합니다. 일반적으로, `a → b`는 b가 a의 부분집합(b ⊆ a)일 때 자명한 종속성입니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "함수적 종속성 예시",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "`student2(ID, name, tot_cred)` 릴레이션을 예로 들면:",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "• `ID → name` (성립)\n• `ID → tot_cred` (성립)\n• `tot_cred → name` (성립하지 않음)\n• `name → tot_cred` (성립하지 않음)",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "`SCORE(score_id, student_id, subject_id, score)` 릴레이션의 경우:",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "• `{student_id, subject_id} → score` (성립)",
              "level": null
            }
          ],
          "aiNotes": {
            "summary": "이 문서는 데이터베이스 시스템에서 중요한 개념인 함수적 종속성에 대해 설명합니다. 함수적 종속성은 현실 세계의 데이터 제약 조건을 표현하며, 특정 속성 집합이 다른 속성 집합의 값을 고유하게 결정하는 관계를 의미합니다. 문서에서는 함수적 종속성의 정의, 키와의 관계, 부분 종속성 및 자명한 종속성의 개념을 다루고, 다양한 예시를 통해 이해를 돕습니다.",
            "keyConcepts": [
              {
                "term": "함수적 종속성 (Functional Dependency)",
                "definition": {
                  "easy": "데이터베이스에서 한 데이터가 다른 데이터를 딱 하나로 정해주는 관계입니다. 예를 들어, 학생 ID를 알면 학생 이름을 알 수 있는 관계처럼요.",
                  "medium": "릴레이션 스키마 R에서 속성 집합 A의 값이 주어졌을 때 속성 집합 B의 값이 항상 고유하게 결정되는 경우, A는 B에 함수적으로 종속된다고 하며 A → B로 표기합니다.",
                  "hard": "데이터베이스 릴레이션 r(R)에서, 모든 튜플 t1, t2에 대해 t1[A] = t2[A]일 때 t1[B] = t2[B]가 성립하면 속성 집합 A는 속성 집합 B를 함수적으로 결정한다고 하며 A → B로 표현합니다. 이는 데이터의 일관성과 무결성을 보장하며 정규화 과정의 핵심 기반이 됩니다."
                }
              },
              {
                "term": "자명한 종속성 (Trivial Dependency)",
                "definition": {
                  "easy": "누구나 당연히 아는 관계입니다. 예를 들어, '이름과 나이를 알면 이름을 알 수 있다'는 식이죠.",
                  "medium": "함수적 종속성 A → B에서 B가 A의 부분집합(B ⊆ A)인 경우, 이 종속성은 자명한 종속성이라고 합니다. 이는 항상 참이며 데이터베이스의 특정 제약 조건을 나타내지 않습니다.",
                  "hard": "릴레이션의 모든 가능한 인스턴스에서 항상 만족되는 함수적 종속성을 의미합니다. 특히, 결정자(determinant) 속성 집합이 종속자(dependent) 속성 집합을 포함하거나 동일할 때 발생하며, 이는 새로운 정보를 제공하지 않는 내재적인 관계입니다."
                }
              },
              {
                "term": "부분 종속성 (Partial Dependency)",
                "definition": {
                  "easy": "키의 일부만 알아도 다른 데이터를 알 수 있는 관계입니다. 키 전체가 필요한데 일부만으로도 알 수 있으면 부분 종속성입니다.",
                  "medium": "릴레이션 R의 후보 키 X에 대해, 속성 A가 X에 함수적으로 종속되지만 X의 진부분집합(proper subset)에도 종속되는 경우 A는 X에 대해 부분 종속성을 가집니다.",
                  "hard": "릴레이션의 비키 속성(non-key attribute)이 후보 키 전체에 함수적으로 종속되는 것이 아니라, 후보 키의 진부분집합(proper subset)에 함수적으로 종속되는 현상을 말합니다. 이는 제2정규형(2NF) 위반의 원인이 되며 데이터 중복 및 갱신 이상을 유발할 수 있습니다."
                }
              },
              {
                "term": "후보 키 (Candidate Key)",
                "definition": {
                  "easy": "테이블의 각 행을 유일하게 구분할 수 있는 최소한의 정보입니다. 주민등록번호처럼요.",
                  "medium": "릴레이션의 모든 튜플을 유일하게 식별할 수 있는 속성(또는 속성 집합) 중, 더 이상 줄일 수 없는 최소한의 속성 집합입니다. 후보 키 중 하나가 기본 키로 선택됩니다.",
                  "hard": "릴레이션 스키마 R에서 모든 비키 속성을 함수적으로 결정할 수 있는 최소 슈퍼키를 의미합니다. 후보 키는 유일성(uniqueness)과 최소성(minimality)을 만족해야 하며, 릴레이션의 각 튜플을 고유하게 식별하는 데 사용될 수 있는 모든 속성 집합을 포함합니다."
                }
              }
            ],
            "importantTerms": [
              {
                "term": "릴레이션 스키마 (Relation Schema)",
                "definition": "릴레이션의 이름과 속성(컬럼)들의 정의를 포함하는 논리적 구조입니다."
              },
              {
                "term": "튜플 (Tuple)",
                "definition": "릴레이션의 한 행을 구성하는 값들의 집합으로, 객체의 특정 인스턴스를 나타냅니다."
              },
              {
                "term": "속성 (Attribute)",
                "definition": "릴레이션의 열(컬럼)을 의미하며, 특정 종류의 정보를 담는 데이터 항목입니다."
              },
              {
                "term": "슈퍼키 (Superkey)",
                "definition": "릴레이션의 모든 튜플을 유일하게 식별할 수 있는 하나 이상의 속성 집합입니다."
              },
              {
                "term": "제약 조건 (Constraint)",
                "definition": "데이터베이스에 저장될 수 있는 데이터의 규칙 또는 조건을 정의하는 것입니다."
              }
            ],
            "outline": [
              {
                "text": "함수적 종속성 개요",
                "id": "함수적-종속성-개요",
                "children": [
                  {
                    "text": "데이터 제약 조건",
                    "id": "데이터-제약-조건",
                    "children": null
                  },
                  {
                    "text": "함수적 종속성의 정의",
                    "id": "함수적-종속성의-정의",
                    "children": null
                  }
                ]
              },
              {
                "text": "함수적 종속성의 상세 이해",
                "id": "함수적-종속성의-상세-이해",
                "children": [
                  {
                    "text": "정의 및 예시",
                    "id": "정의-및-예시",
                    "children": null
                  },
                  {
                    "text": "키와 함수적 종속성",
                    "id": "키와-함수적-종속성",
                    "children": null
                  },
                  {
                    "text": "부분 종속성",
                    "id": "부분-종속성",
                    "children": null
                  },
                  {
                    "text": "자명한 함수적 종속성",
                    "id": "자명한-함수적-종속성",
                    "children": null
                  }
                ]
              },
              {
                "text": "함수적 종속성 예시",
                "id": "함수적-종속성-예시",
                "children": null
              }
            ]
          },
          "quiz": [
            {
              "question": "다음 중 함수적 종속성 A → B가 성립하는 조건으로 가장 정확한 것은 무엇입니까?",
              "options": [
                "릴레이션의 어떤 두 튜플 t1과 t2가 속성 A에 대해 일치할 때, 속성 B에 대해서도 일치하는 경우",
                "속성 A의 값이 변경되면 속성 B의 값도 항상 변경되는 경우",
                "속성 A와 속성 B가 동일한 데이터 타입을 가지는 경우",
                "속성 B가 속성 A의 부분집합인 경우"
              ],
              "answerIndex": 0,
              "explanation": "함수적 종속성 A → B는 A의 값이 같으면 B의 값도 항상 같아야 한다는 것을 의미합니다. 즉, t1[A] = t2[A]이면 t1[B] = t2[B]가 성립해야 합니다."
            },
            {
              "question": "다음 함수적 종속성 중 자명한 종속성(Trivial Functional Dependency)의 예시가 아닌 것은 무엇입니까?",
              "options": [
                "ID, Name → ID",
                "Name → Name",
                "ID → Name",
                "A, B, C → A"
              ],
              "answerIndex": 2,
              "explanation": "자명한 종속성은 종속자(오른쪽)가 결정자(왼쪽)의 부분집합인 경우를 말합니다. 'ID → Name'은 ID가 Name의 부분집합이 아니므로 자명한 종속성이 아닙니다. ID를 알면 Name을 알 수 있지만, Name은 ID에 포함되지 않습니다."
            },
            {
              "question": "릴레이션 `in_dep (ID, name, salary, dept_name, building, budget)`에서 `dept_name`이 `building`을 결정하고, `ID`가 `building`을 결정한다고 할 때, `dept_name`과 `ID`는 어떤 키에 해당됩니까?",
              "options": [
                "외래 키",
                "기본 키",
                "후보 키",
                "보조 키"
              ],
              "answerIndex": 2,
              "explanation": "텍스트에 따르면, `dept_name`과 `ID`는 `building`을 결정하는 속성이며, 이는 슈퍼키이자 후보 키에 해당합니다. 후보 키는 릴레이션의 각 튜플을 유일하게 식별할 수 있는 최소한의 속성 집합입니다."
            }
          ]
        },
        {
          "title": "제1 정규형 (1NF): 원자성 및 고유성",
          "metadata": "Source: a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf, Text length: 1478 chars",
          "documentContent": [
            {
              "type": "heading",
              "content": "제1 정규형 (1NF) 개요",
              "level": 1
            },
            {
              "type": "paragraph",
              "content": "데이터베이스 정규화의 첫 번째 단계인 제1 정규형(1NF)은 관계형 데이터베이스 설계의 기본 원칙을 제시합니다. 본문에서는 1NF의 핵심 요구사항과 체크리스트, 그리고 실제 적용 예시를 통해 1NF의 중요성을 설명합니다. 1NF를 따르지 않는 데이터베이스는 사용을 중단해야 할 만큼 중요하게 간주됩니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "1NF의 요구사항",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "제1 정규형은 다음의 주요 요구사항을 충족해야 합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "**원자성 값**: 릴레이션의 모든 속성은 원자적 값으로 구성되어야 합니다. 원자적 값은 더 이상 나눌 수 없는 단일 값을 의미하며, 자바의 기본 데이터 타입(INT, FLOAT, DOUBLE, DECIMAL (NUMERIC), CHAR, VARCHAR, BLOB, TEXT)과 유사합니다. 구조체나 리스트(배열)와 같이 여러 값을 포함하는 형태는 원자적이지 않아 허용되지 않습니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "**고유 식별자**: 각 속성(열)은 고유한 식별자를 가져야 합니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "1NF 체크리스트",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "제1 정규형을 만족하는지 확인하기 위한 체크리스트는 다음과 같습니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "1. 각 열은 원자적 값을 포함해야 합니다. (예: (x, y)와 같은 항목은 이 규칙을 위반합니다.)",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "2. 각 열은 동일한 데이터 도메인에 속하는 값을 포함해야 합니다. (다른 유형의 값을 한 열에 혼합하지 마십시오.)",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "3. 각 열은 고유한 이름을 가져야 합니다. (중복된 이름은 데이터 접근 시 혼란을 야기합니다.)",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "4. 데이터가 저장되는 순서는 중요하지 않습니다. (SQL을 사용하면 어떤 순서로든 데이터를 쉽게 가져올 수 있습니다.)",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "5. 테이블에 중복된 행이 없어야 합니다. 기본 키(PK)는 다음을 보장합니다:",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "    * 기본 키의 일부인 속성은 고유합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "    * 기본 키의 일부인 속성은 NULL이 될 수 없습니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "1NF 예시",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "다음은 제1 정규형을 만족하지 않는 테이블과 이를 만족하도록 정규화된 테이블의 예시입니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "초기 테이블 'student_id', 'name', 'course'에서 'course' 열이 'Algorithm, OS'와 같이 여러 값을 포함하여 1NF를 위반합니다. 이를 해결하기 위해 테이블을 'student_id', 'name'으로 구성된 학생 정보 테이블과 'student_id', 'course'로 구성된 수강 정보 테이블로 분리합니다. 이 과정을 통해 각 열이 원자적 값을 가지며 중복된 정보를 효과적으로 관리하여 1NF를 만족시킵니다.",
              "level": null
            }
          ],
          "aiNotes": {
            "summary": "제1 정규형(1NF)은 관계형 데이터베이스 정규화의 첫 번째 단계로, 테이블의 모든 속성이 원자적 값을 가져야 하고, 각 열이 고유한 이름을 가지며, 동일한 데이터 도메인에 속해야 함을 강조한다. 또한 테이블에 중복된 행이 없어야 하며, 이는 기본 키(PK)를 통해 보장된다. 비원자적 값을 포함하는 예시 테이블을 통해 1NF 준수 방법을 설명한다.",
            "keyConcepts": [
              {
                "term": "원자적 값 (Atomic Value)",
                "definition": {
                  "easy": "더 이상 나눌 수 없는 가장 작은 데이터 조각.",
                  "medium": "관계형 데이터베이스에서 하나의 속성(열)이 가질 수 있는 최소 단위의 값으로, 더 이상 의미 있는 단위로 분해될 수 없는 단일 값을 의미한다.",
                  "hard": "데이터베이스 릴레이션의 모든 속성에 대해 단일하고 불가분한 값을 요구하는 개념으로, 복합 값(예: 주소의 도시, 거리, 우편번호)이나 다중 값(예: 리스트, 배열)을 허용하지 않음으로써 데이터의 일관성과 무결성을 보장하는 제1 정규형의 핵심 조건이다."
                }
              },
              {
                "term": "제1 정규형 (First Normal Form, 1NF)",
                "definition": {
                  "easy": "데이터베이스 테이블을 깔끔하게 정리하는 첫 번째 규칙으로, 각 칸에 딱 하나의 정보만 들어가고, 같은 줄이 중복되지 않게 하는 것.",
                  "medium": "관계형 데이터베이스 정규화 과정의 첫 단계로, 모든 속성(열)이 원자적 값을 가져야 하고, 각 속성 이름이 고유해야 하며, 테이블 내에 중복된 행이 없어야 한다는 조건을 만족하는 형태이다.",
                  "hard": "관계형 스키마가 비원자적 도메인을 포함하지 않고, 각 릴레이션이 고유한 튜플(행)을 가지며, 모든 속성이 단일 값을 포함하도록 보장하여 데이터의 일관성과 질의 효율성을 높이는 데이터 모델링의 기초적인 요건이다."
                }
              },
              {
                "term": "기본 키 (Primary Key, PK)",
                "definition": {
                  "easy": "테이블에서 각 줄을 유일하게 구분해주는 중요한 값.",
                  "medium": "관계형 데이터베이스 테이블에서 각 행(튜플)을 고유하게 식별할 수 있는 하나 이상의 속성(열)들의 집합이다. 기본 키의 모든 속성은 고유하며 NULL 값을 가질 수 없다.",
                  "hard": "릴레이션 내의 모든 튜플을 고유하게 식별할 수 있는 최소 슈퍼키(Minimal Superkey)로서, 데이터 무결성 제약 조건의 핵심 구성 요소이다. 기본 키로 지정된 속성들은 반드시 고유성(Uniqueness)과 비NULL성(Non-nullability)을 만족해야 하며, 다른 테이블과의 관계 설정(외래 키)에 사용될 수 있다."
                }
              }
            ],
            "importantTerms": [
              {
                "term": "릴레이션 (Relation)",
                "definition": "데이터베이스에서 테이블을 지칭하는 용어."
              },
              {
                "term": "속성 (Attribute)",
                "definition": "테이블의 열(컬럼)을 지칭하는 용어."
              },
              {
                "term": "정규화 (Normalization)",
                "definition": "데이터 중복을 줄이고 무결성을 향상시키기 위해 테이블을 구조화하는 과정."
              },
              {
                "term": "데이터 도메인 (Data Domain)",
                "definition": "특정 열에 올 수 있는 값들의 집합."
              },
              {
                "term": "중복 행 (Duplicated Rows)",
                "definition": "테이블 내에 완전히 동일한 내용을 가진 두 개 이상의 행."
              }
            ],
            "outline": [
              {
                "text": "제1 정규형 (1NF) 개요",
                "id": "제1-정규형-1nf-개요",
                "children": null
              },
              {
                "text": "1NF의 요구사항",
                "id": "1nf의-요구사항",
                "children": null
              },
              {
                "text": "1NF 체크리스트",
                "id": "1nf-체크리스트",
                "children": null
              },
              {
                "text": "1NF 예시",
                "id": "1nf-예시",
                "children": null
              }
            ]
          },
          "quiz": [
            {
              "question": "제1 정규형(1NF)의 핵심 요구사항 중 하나는 무엇입니까?",
              "options": [
                "모든 속성 값이 원자적이어야 한다.",
                "데이터 중복을 허용한다.",
                "각 열의 이름이 중복될 수 있다.",
                "데이터 저장 순서가 중요해야 한다."
              ],
              "answerIndex": 0,
              "explanation": "제1 정규형의 가장 중요한 요구사항 중 하나는 릴레이션의 모든 속성 값이 더 이상 나눌 수 없는 원자적이어야 한다는 것입니다."
            },
            {
              "question": "다음 중 제1 정규형(1NF)을 위반하는 예시는 무엇입니까?",
              "options": [
                "열에 정수 값만 포함되어 있다.",
                "각 열이 고유한 이름을 가지고 있다.",
                "하나의 셀에 '사과, 바나나, 체리'와 같이 여러 값이 콤마로 구분되어 있다.",
                "테이블에 중복된 행이 없다."
              ],
              "answerIndex": 2,
              "explanation": "1NF는 각 열이 원자적 값, 즉 더 이상 나눌 수 없는 단일 값을 포함해야 한다고 명시합니다. '사과, 바나나, 체리'와 같이 콤마로 구분된 여러 값은 비원자적이므로 1NF를 위반합니다."
            },
            {
              "question": "제1 정규형(1NF) 원칙에 따라 기본 키(PK)가 테이블에서 보장하는 것은 무엇입니까?",
              "options": [
                "속성이 선택 사항일 수 있다.",
                "속성이 여러 값을 포함할 수 있다.",
                "속성이 고유하며 NULL 값을 가질 수 없다.",
                "속성이 중복될 수 있다."
              ],
              "answerIndex": 2,
              "explanation": "1NF 체크리스트에 따르면, 기본 키(PK)는 해당 속성들이 고유하며 NULL 값을 가질 수 없음을 보장하여 테이블에 중복된 행이 없도록 합니다."
            }
          ]
        },
        {
          "title": "제2 정규형 (2NF): 부분 종속성 제거",
          "metadata": "Source: a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf, Text length: 1851 chars",
          "documentContent": [
            {
              "type": "heading",
              "content": "제2 정규형 (2NF): 부분 종속성 제거",
              "level": 1
            },
            {
              "type": "heading",
              "content": "제2 정규형 (2NF)의 요구사항",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "제2 정규형(Second Normal Form, 2NF)은 데이터베이스 정규화의 한 단계로, 관계형 데이터베이스에서 데이터 중복을 줄이고 데이터 무결성을 향상시키기 위한 규칙 집합입니다. 2NF를 만족하기 위한 주요 요구사항은 다음과 같습니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "1.  **제1 정규형(1NF)을 만족해야 합니다.** 정규형은 순서대로 적용되어야 합니다. 즉, 2NF를 적용하기 전에 해당 릴레이션은 이미 1NF를 만족하고 있어야 합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "2.  **부분 종속성이 없어야 합니다.** 기본 키(Primary Key, PK)가 아닌 속성(Non-PK attribute)이 후보 키(Candidate Key)의 어떤 부분 집합에도 함수적으로 종속되어서는 안 됩니다. 이는 부분 종속성이 없어야 한다는 것을 의미합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "3.  **기본 키에 완전 함수 종속적이어야 합니다.** 기본 키가 아닌 모든 속성은 기본 키 전체에 함수적으로 종속되어야 합니다. 즉, 테이블의 모든 비기본 키 속성은 기본 키의 일부가 아니라 기본 키 전체에 의존해야 합니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "기본 키(PK)란?",
              "level": 3
            },
            {
              "type": "paragraph",
              "content": "기본 키는 릴레이션(테이블) 내의 각 튜플(행)을 고유하게 식별하는 하나 또는 여러 속성의 집합입니다. 기본 키를 통해 릴레이션 내의 특정 데이터를 가져올 수 있습니다. 예를 들어, `student_ID = 21800999`를 사용하여 학생의 학과 이름을 가져올 수 있습니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "부분 종속성",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "부분 종속성은 기본 키가 복합 키(두 개 이상의 속성으로 구성된 키)일 때 발생합니다. 릴레이션 R이 `a1 a2 a3 a4`로 구성되어 있고, 기본 키가 `a1 a2 a3`라고 가정해 봅시다. 만약 `a4`가 기본 키의 일부인 `a1`에만 종속되고 기본 키 전체인 `a1a2a3`에는 종속되지 않는다면(`a1 -> a4`), 이는 부분 종속성입니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "부분 종속성 제거",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "부분 종속성을 제거하기 위해서는 릴레이션을 두 개 이상의 새로운 릴레이션으로 분해해야 합니다. 각 새로운 릴레이션은 부분 종속성이 없는 형태로 구성됩니다. 다음은 예시를 통해 부분 종속성 제거 과정을 설명합니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "예시 1: teaches2 릴레이션",
              "level": 3
            },
            {
              "type": "paragraph",
              "content": "`teaches2(ID, course_id, sec_id, semester, year, name)` 릴레이션에서 기본 키는 `{ID, course_id, sec_id, semester, year}`로 가정합니다. 이 때, `ID`는 학생의 이름을 결정하는 `ID -> name`이라는 함수 종속성이 존재한다고 가정합시다. `name`은 기본 키의 일부인 `ID`에만 종속되므로, 이는 부분 종속성입니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "이 부분 종속성을 제거하기 위해 `teaches2` 릴레이션을 다음과 같이 분해할 수 있습니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "- `teaches2a(ID, course_id, sec_id, semester, year)`: 기본 키는 `{ID, course_id, sec_id, semester, year}`입니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "- `teaches2b(ID, name)`: 기본 키는 `ID`입니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "이렇게 분해함으로써 `name`은 `teaches2b` 릴레이션에서 `ID`에 완전 함수 종속적이게 되며, `teaches2a` 릴레이션에는 부분 종속성이 제거됩니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "예시 2: score 릴레이션",
              "level": 3
            },
            {
              "type": "paragraph",
              "content": "`score(score_id, student_id, subject_id, score, instructor)` 릴레이션을 살펴봅시다. 기본 키가 `{score_id, student_id, subject_id}`라고 가정했을 때, `subject_id`가 `instructor`를 결정하는 `subject_id -> instructor`라는 함수 종속성이 존재합니다. 이는 `instructor`가 기본 키의 일부인 `subject_id`에만 종속되므로 부분 종속성입니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "부분 종속성을 제거하기 위해 `score` 릴레이션을 다음과 같이 분해합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "- `score_a(score_id, student_id, subject_id, score)`: 기본 키는 `{score_id, student_id, subject_id}`입니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "- `score_b(subject_id, instructor)`: 기본 키는 `subject_id`입니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "이러한 분해를 통해 `score` 릴레이션의 부분 종속성이 제거되고 2NF를 만족하게 됩니다.",
              "level": null
            }
          ],
          "aiNotes": {
            "summary": "제2 정규형(2NF)은 데이터베이스 정규화의 한 단계로, 릴레이션이 제1 정규형을 만족하고 부분 종속성이 없어야 한다는 요구사항을 가집니다. 부분 종속성이란 기본 키가 복합 키일 때, 기본 키가 아닌 속성이 기본 키의 전체가 아닌 일부에만 함수적으로 종속되는 경우를 의미합니다. 부분 종속성을 제거하기 위해서는 해당 릴레이션을 두 개 이상의 새로운 릴레이션으로 분해하여 각 릴레이션이 2NF를 만족하도록 해야 합니다. `teaches2`와 `score` 릴레이션의 예시를 통해 부분 종속성을 식별하고 제거하는 과정을 설명합니다.",
            "keyConcepts": [
              {
                "term": "제2 정규형 (2NF)",
                "definition": {
                  "easy": "데이터베이스 테이블이 깔끔하게 정리되는 두 번째 단계로, 중복 데이터를 줄이기 위해 복합 키의 일부에만 의존하는 정보가 없어야 합니다.",
                  "medium": "릴레이션이 제1 정규형을 만족하면서, 기본 키가 아닌 모든 속성이 기본 키의 어떠한 부분 집합에도 함수적으로 종속되지 않는 형태를 의미합니다. 즉, 부분 종속성이 존재하지 않아야 합니다.",
                  "hard": "데이터 모델링에서 릴레이션 스키마가 제1 정규형의 조건을 충족하고, 추가적으로 모든 비기본(non-prime) 속성이 해당 릴레이션의 모든 후보 키(candidate key)에 대해 완전 함수 종속(fully functionally dependent)이어야 함을 명시하는 정규화 단계입니다. 이는 복합 키의 부분 집합에 대한 함수 종속성을 제거하여 갱신 이상(update anomalies)을 방지하는 데 기여합니다."
                }
              },
              {
                "term": "부분 종속성",
                "definition": {
                  "easy": "테이블의 기본 키가 여러 개로 이루어져 있을 때, 키가 아닌 다른 정보가 전체 기본 키가 아니라 그 일부에만 의존하는 경우입니다.",
                  "medium": "릴레이션의 기본 키가 복합 키일 때, 기본 키가 아닌 속성이 기본 키의 일부 속성 집합에만 함수적으로 종속되고 기본 키 전체에는 종속되지 않는 현상을 말합니다.",
                  "hard": "릴레이션 R의 스키마에서 X가 R의 후보 키이고, Y가 X의 진부분 집합(proper subset)이며, Z가 R의 비기본 속성(non-prime attribute)일 때, Y -> Z인 함수 종속성이 존재하고 Y가 Z를 완전하게 결정하지만 X는 Z를 완전하게 결정하지 않는 경우를 의미합니다. 이는 데이터 중복과 삽입, 삭제, 갱신 이상을 야기할 수 있습니다."
                }
              },
              {
                "term": "기본 키 (PK)",
                "definition": {
                  "easy": "테이블에서 각 줄(데이터)을 정확히 하나씩 구분할 수 있게 해주는 특별한 정보(예: 학번, 주민등록번호)입니다.",
                  "medium": "릴레이션(테이블) 내의 각 튜플(행)을 고유하게 식별할 수 있는 하나 또는 여러 속성의 집합입니다. 기본 키는 중복 값을 가질 수 없으며, NULL 값을 허용하지 않습니다.",
                  "hard": "관계형 데이터 모델에서 릴레이션의 각 튜플을 고유하게 식별하기 위해 선택된 후보 키입니다. 기본 키를 구성하는 속성들은 최소성(minimality), 고유성(uniqueness), 비NULL(not null) 속성을 만족해야 하며, 릴레이션의 무결성 제약 조건 중 개체 무결성(entity integrity)을 보장하는 핵심 요소입니다."
                }
              }
            ],
            "importantTerms": [
              {
                "term": "릴레이션",
                "definition": "관계형 데이터베이스에서 데이터를 저장하는 테이블을 의미합니다."
              },
              {
                "term": "튜플",
                "definition": "릴레이션(테이블)의 각 행을 의미하며, 하나의 레코드를 나타냅니다."
              },
              {
                "term": "속성",
                "definition": "릴레이션(테이블)의 각 열을 의미하며, 데이터의 특정 특성을 나타냅니다."
              },
              {
                "term": "함수 종속성",
                "definition": "릴레이션 R에서 속성 집합 X가 속성 Y를 함수적으로 결정하는 관계 (X -> Y)를 의미합니다. 즉, X의 값이 Y의 값을 고유하게 결정합니다."
              },
              {
                "term": "후보 키",
                "definition": "릴레이션 내의 각 튜플을 고유하게 식별할 수 있는 최소한의 속성 집합입니다. 후보 키 중 하나가 기본 키로 선택됩니다."
              },
              {
                "term": "복합 키",
                "definition": "두 개 이상의 속성(컬럼)으로 구성된 기본 키를 의미합니다."
              }
            ],
            "outline": [
              {
                "text": "제2 정규형 (2NF): 부분 종속성 제거",
                "id": "제2-정규형-2nf-부분-종속성-제거",
                "children": [
                  {
                    "text": "제2 정규형 (2NF)의 요구사항",
                    "id": "제2-정규형-2nf-의-요구사항",
                    "children": [
                      {
                        "text": "기본 키(PK)란?",
                        "id": "기본-키-pk-란",
                        "children": null
                      }
                    ]
                  },
                  {
                    "text": "부분 종속성",
                    "id": "부분-종속성",
                    "children": null
                  },
                  {
                    "text": "부분 종속성 제거",
                    "id": "부분-종속성-제거",
                    "children": [
                      {
                        "text": "예시 1: teaches2 릴레이션",
                        "id": "예시-1-teaches2-릴레이션",
                        "children": null
                      },
                      {
                        "text": "예시 2: score 릴레이션",
                        "id": "예시-2-score-릴레이션",
                        "children": null
                      }
                    ]
                  }
                ]
              }
            ]
          },
          "quiz": [
            {
              "question": "다음 중 제2 정규형(2NF)을 만족하기 위한 필수 요구사항이 아닌 것은 무엇입니까?",
              "options": [
                "릴레이션이 제1 정규형(1NF)을 만족해야 한다.",
                "기본 키가 아닌 속성이 후보 키의 어떤 부분 집합에도 함수적으로 종속되어서는 안 된다.",
                "모든 다중 값 속성이 제거되어야 한다.",
                "기본 키가 아닌 모든 속성은 기본 키 전체에 함수적으로 종속되어야 한다."
              ],
              "answerIndex": 2,
              "explanation": "다중 값 속성의 제거는 제1 정규형(1NF)의 요구사항 중 하나입니다. 제2 정규형은 1NF를 만족하는 것을 전제로 하며, 부분 종속성 제거에 중점을 둡니다."
            },
            {
              "question": "릴레이션 R(A, B, C, D)에서 기본 키가 {A, B}이고, D가 A에만 함수적으로 종속되는 경우 (A -> D)는 어떤 종류의 종속성에 해당합니까?",
              "options": [
                "완전 함수 종속성",
                "부분 종속성",
                "이행 종속성",
                "다치 종속성"
              ],
              "answerIndex": 1,
              "explanation": "D가 기본 키의 일부인 A에만 종속되고 기본 키 전체인 {A, B}에 종속되지 않는 경우를 부분 종속성이라고 합니다."
            },
            {
              "question": "teaches2(ID, course_id, sec_id, semester, year, name) 릴레이션에서 ID -> name이라는 부분 종속성을 제거하기 위해 분해된 두 개의 릴레이션 중 올바른 조합은 무엇입니까?",
              "options": [
                "teaches2a(ID, course_id, sec_id, semester, year)와 teaches2b(ID, name)",
                "teaches2a(ID, name)와 teaches2b(course_id, sec_id, semester, year)",
                "teaches2a(ID, course_id, name)와 teaches2b(sec_id, semester, year)",
                "teaches2a(ID, course_id, sec_id)와 teaches2b(semester, year, name)"
              ],
              "answerIndex": 0,
              "explanation": "부분 종속성 ID -> name을 제거하기 위해, name 속성과 그 결정자인 ID를 별도의 테이블로 분리하고, 나머지 속성들은 원래의 기본 키와 함께 새로운 테이블을 구성합니다."
            }
          ]
        },
        {
          "title": "제3 정규형 (3NF): 이행적 종속성 제거",
          "metadata": "Source: a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf, Text length: 1245 chars",
          "documentContent": [
            {
              "type": "heading",
              "content": "제3 정규형 (3NF)",
              "level": 1
            },
            {
              "type": "heading",
              "content": "요구사항",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "릴레이션은 2NF(제2 정규형)를 만족해야 한다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "릴레이션은 이행적 종속성을 가져서는 안 된다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "이행적 종속성 정의",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "이행적 종속성: 비기본 키 속성(non-PK attribute)이 다른 비기본 키 속성 또는 비기본 키 속성 집합에 종속되는 경우를 말한다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "이행적 종속성 상세 설명",
              "level": 1
            },
            {
              "type": "paragraph",
              "content": "릴레이션 R = a1 a2 a3 a4 에 대해 a1이 R의 기본 키일 때, a3이 a1에 종속되고(a1 ➝ a3) a4가 a3에 종속되는 경우(a1 ➝ a3 ➝ a4)는 비기본 키 속성(a4)이 다른 비기본 키 속성(a3)에 종속되는 이행적 종속성의 예시이다. 이러한 경우, a1은 a3을 결정하고 a3은 a4를 결정하지만, a4는 a1에 직접적으로 종속되지 않고 a3을 통해 간접적으로 종속된다. 여기서 후보 키는 a1, a2, {a1,a2}가 될 수 있다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "이행적 종속성 제거 예시",
              "level": 1
            },
            {
              "type": "heading",
              "content": "예제 1: 도서 대출 정보",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "원본 테이블: BookNo, Patron, Address, Due",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "기본 키(PK): BookNo",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "문제점: Patron(대출자)이 Address(주소)에 종속된다 (Patron → Address). BookNo는 Patron을 결정하지만, Patron이 Address를 결정하므로 BookNo → Patron → Address 형태의 이행적 종속성이 존재한다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "제거 방법: 테이블을 다음과 같이 분리한다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "BookNo, Patron, Due",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "Patron, Address",
              "level": null
            },
            {
              "type": "heading",
              "content": "예제 2: 토너먼트 우승자 정보",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "원본 테이블: Tournament, Year, Winner, DOB",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "기본 키(PK): {Tournament, Year}",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "문제점: Winner(우승자)가 DOB(생년월일)에 종속된다 (Winner → DOB). 기본 키 {Tournament, Year}가 Winner를 결정하고 Winner가 DOB를 결정하므로 {Tournament, Year} → Winner → DOB 형태의 이행적 종속성이 존재한다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "예제 3: 시험 점수 정보 (score2)",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "원본 테이블: score2(id, student_id, subject_id, exam_name, exam_score)",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "문제점: {student_id, subject_id}가 exam_name을 결정하고, exam_name이 exam_score를 결정하는 ({student_id, subject_id} → exam_name → exam_score) 형태의 이행적 종속성이 존재한다. 즉, 시험 점수는 학생-과목 조합에 직접 종속되기보다 시험 이름에 의해 결정되는 구조이다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "제거 방법: 테이블을 다음과 같이 분리한다. (여기서 exam_id는 exam_name을 고유하게 식별하는 새로운 키로 가정)",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "score2a(id, student_id, subject_id, exam_id, exam_name)",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "score2b(student_id, subject_id, exam_id, exam_score)",
              "level": null
            }
          ],
          "aiNotes": {
            "summary": "제3 정규형(3NF)은 데이터베이스 정규화의 한 단계로, 릴레이션이 2NF를 만족하고 이행적 종속성이 없어야 한다는 요구사항을 가진다. 이행적 종속성은 비기본 키 속성이 다른 비기본 키 속성에 종속되는 현상으로, 이는 데이터 중복을 야기하고 삽입, 삭제, 갱신 이상을 초래할 수 있다. 3NF는 이러한 이행적 종속성을 제거하여 데이터 일관성과 무결성을 높이는 것을 목표로 한다. 본문에서는 이행적 종속성의 개념과 이를 제거하기 위한 여러 예시를 통해 3NF의 적용 방법을 설명한다.",
            "keyConcepts": [
              {
                "term": "제3 정규형 (3NF)",
                "definition": {
                  "easy": "데이터베이스 테이블을 깔끔하게 만들어서 정보가 겹치지 않고 잘 정리되도록 하는 세 번째 규칙이에요. 특히, 중요한 정보가 아닌 것들이 다른 중요한 정보가 아닌 것에 의존하지 않게 해요.",
                  "medium": "릴레이션이 2NF를 만족하고, 기본 키가 아닌 속성(non-PK attribute)이 기본 키가 아닌 다른 속성에 이행적으로 종속되지 않는 상태를 의미합니다. 이는 데이터 중복을 줄이고 갱신 이상, 삽입 이상, 삭제 이상과 같은 이상 현상을 방지합니다.",
                  "hard": "릴레이션 R이 2NF를 만족하고, R의 모든 비기본 키 속성 A에 대해 A가 R의 어떤 후보 키 X에 대해 직접적으로 함수 종속(X → A)이 아닌, 다른 비기본 키 속성 B를 경유하는 이행적 함수 종속(X → B → A)이 존재하지 않는 상태를 말한다. 즉, 모든 비기본 키 속성은 오직 후보 키에만 직접적으로 함수 종속되어야 한다."
                }
              },
              {
                "term": "이행적 종속성 (Transitive Dependency)",
                "definition": {
                  "easy": "테이블에서 중요한 정보가 아닌 것(A)이 다른 중요한 정보가 아닌 것(B)에 따라 정해지는 관계를 말해요. 예를 들어, '학생 이름'이 '과목'에 따라 정해지고, '과목'이 '점수'에 따라 정해지는 식이죠.",
                  "medium": "릴레이션 R에서 A → B이고 B → C일 때, A → C가 성립하며 B가 후보 키가 아닌 경우, C는 A에 대해 이행적으로 종속된다고 합니다. 즉, 비기본 키 속성이 기본 키가 아닌 다른 속성을 통해 기본 키에 간접적으로 종속되는 현상입니다.",
                  "hard": "릴레이션 R의 속성 집합 A, B, C에 대해 A → B이고 B → C인 함수 종속성이 존재할 때, 만약 B가 R의 후보 키가 아니거나 A가 B에 함수 종속되지 않는다면 C는 A에 대해 이행적 종속성을 가진다고 한다. 이는 비기본 키 속성이 기본 키에 직접 종속되지 않고 중간의 다른 비기본 키 속성을 통해 종속되는 상황을 나타내며, 3NF 위반의 주된 원인이다."
                }
              },
              {
                "term": "정규화 (Normalization)",
                "definition": {
                  "easy": "데이터베이스를 더 효율적이고 오류 없이 사용할 수 있도록 테이블을 규칙에 따라 잘 정리하는 과정이에요.",
                  "medium": "데이터베이스의 테이블을 구조화하여 데이터 중복을 최소화하고, 삽입, 삭제, 갱신 이상과 같은 데이터 불일치 문제를 해결하며, 데이터 무결성을 유지하기 위한 일련의 과정입니다. 정규형(Normal Form)이라는 규칙을 단계별로 적용하여 수행됩니다.",
                  "hard": "관계형 데이터베이스 설계에서 데이터 중복을 제거하고 데이터 일관성 및 무결성을 보장하기 위해 릴레이션 스키마를 분해하는 체계적인 과정이다. 함수 종속성 및 다치 종속성과 같은 종속성 제약을 기반으로 특정 정규형 규칙을 만족하도록 테이블을 재구성하며, 이를 통해 이상(anomaly) 현상을 방지하고 질의 성능 및 유지보수성을 향상시키는 것을 목표로 한다."
                }
              }
            ],
            "importantTerms": [
              {
                "term": "기본 키 (Primary Key)",
                "definition": "릴레이션 내의 각 튜플(행)을 고유하게 식별할 수 있는 하나 이상의 속성(컬럼) 집합."
              },
              {
                "term": "비기본 키 속성 (Non-PK Attribute)",
                "definition": "기본 키를 구성하지 않는 릴레이션의 속성."
              },
              {
                "term": "후보 키 (Candidate Key)",
                "definition": "릴레이션에서 각 튜플을 고유하게 식별할 수 있는 최소한의 속성 집합. 기본 키로 선택될 수 있는 모든 키를 의미한다."
              },
              {
                "term": "릴레이션 (Relation)",
                "definition": "관계형 데이터베이스에서 데이터를 저장하는 테이블을 의미하며, 행(튜플)과 열(속성)로 구성된다."
              },
              {
                "term": "함수 종속성 (Functional Dependency)",
                "definition": "릴레이션에서 어떤 속성 집합 X의 값이 다른 속성 집합 Y의 값을 유일하게 결정하는 관계 (X → Y)."
              }
            ],
            "outline": [
              {
                "text": "제3 정규형 (3NF)",
                "id": "제3-정규형-3nf",
                "children": [
                  {
                    "text": "요구사항",
                    "id": "요구사항",
                    "children": null
                  },
                  {
                    "text": "이행적 종속성 정의",
                    "id": "이행적-종속성-정의",
                    "children": null
                  }
                ]
              },
              {
                "text": "이행적 종속성 상세 설명",
                "id": "이행적-종속성-상세-설명",
                "children": null
              },
              {
                "text": "이행적 종속성 제거 예시",
                "id": "이행적-종속성-제거-예시",
                "children": [
                  {
                    "text": "예제 1: 도서 대출 정보",
                    "id": "예제-1-도서-대출-정보",
                    "children": null
                  },
                  {
                    "text": "예제 2: 토너먼트 우승자 정보",
                    "id": "예제-2-토너먼트-우승자-정보",
                    "children": null
                  },
                  {
                    "text": "예제 3: 시험 점수 정보 (score2)",
                    "id": "예제-3-시험-점수-정보-score2",
                    "children": null
                  }
                ]
              }
            ]
          },
          "quiz": [
            {
              "question": "릴레이션이 제3 정규형(3NF)을 만족하기 위한 필수 요구사항 중 하나는 무엇입니까?",
              "options": [
                "부분 함수 종속성이 없어야 한다.",
                "기본 키가 없어야 한다.",
                "제2 정규형(2NF)을 만족해야 한다.",
                "모든 속성이 다치 종속성을 가져야 한다."
              ],
              "answerIndex": 2,
              "explanation": "제3 정규형(3NF)의 첫 번째 요구사항은 릴레이션이 제2 정규형(2NF)을 만족해야 한다는 것입니다. 또한, 이행적 종속성이 없어야 합니다."
            },
            {
              "question": "다음 중 이행적 종속성을 가장 잘 설명하는 것은 무엇입니까?",
              "options": [
                "비기본 키 속성이 기본 키에 직접 종속되는 경우",
                "기본 키가 다른 기본 키에 종속되는 경우",
                "비기본 키 속성이 다른 비기본 키 속성 또는 비기본 키 속성 집합에 종속되는 경우",
                "모든 속성이 서로 독립적인 경우"
              ],
              "answerIndex": 2,
              "explanation": "이행적 종속성은 비기본 키 속성이 기본 키가 아닌 다른 비기본 키 속성을 통해 기본 키에 간접적으로 종속되는 경우를 의미합니다. 즉, 비기본 키 속성이 다른 비기본 키 속성에 종속되는 관계를 말합니다."
            },
            {
              "question": "릴레이션 R = a1 a2 a3 a4에서 a1이 기본 키이고, a1 → a3 및 a3 → a4 관계가 성립할 때, a1 → a3 → a4는 어떤 종류의 종속성입니까?",
              "options": [
                "부분 함수 종속성",
                "완전 함수 종속성",
                "이행적 종속성",
                "자명한 종속성"
              ],
              "answerIndex": 2,
              "explanation": "a1 → a3이고 a3 → a4일 때, a3이 기본 키가 아닌 비기본 키 속성이므로, a4는 a1에 대해 이행적 종속성을 가집니다. 이는 비기본 키 속성이 다른 비기본 키 속성을 통해 기본 키에 종속되는 경우에 해당합니다."
            }
          ]
        },
        {
          "title": "보이스-코드 정규형 (BCNF): 강화된 제3 정규형",
          "metadata": "Source: a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf, Text length: 923 chars",
          "documentContent": [
            {
              "type": "heading",
              "content": "보이스-코드 정규형 (BCNF): 3.5NF",
              "level": 1
            },
            {
              "type": "paragraph",
              "content": "BCNF는 제3 정규형(3NF)보다 강화된 정규형으로, '3.5NF'라고도 불립니다. BCNF를 만족하기 위한 요구사항은 다음과 같습니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "1. 관계는 3NF여야 합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "2. 어떤 함수 종속성 A → B에 대해, A는 반드시 슈퍼키(Super Key)여야 합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "3. 만약 A → B에서 A가 비기본키(non-PK)라면, 해당 관계는 BCNF가 아닙니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "BCNF 예시: takes2 테이블",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "다음은 BCNF 위반의 예시를 보여주는 `takes2` 테이블입니다: `takes2(student_id, subject, instructor)`",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "이 테이블에는 두 가지 함수 종속성이 존재합니다:",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "1. `(student, subject) → instructor`: 학생과 과목이 강사를 유일하게 결정합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "2. `Instructor → subject`: 강사가 가르치는 과목을 유일하게 결정합니다. (예: Dr. Cpp는 C++만 가르치고, Dr. Java는 Java만 가르침)",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "여기서 문제가 되는 것은 `Instructor → subject` 종속성입니다. `Instructor`는 `takes2` 테이블의 기본키(또는 후보키)가 아니며, 슈퍼키도 아닙니다. 이처럼 비기본키가 다른 속성을 결정하는 경우, BCNF를 만족하지 못합니다. 즉, '비기본키가 기본키의 구성 요소를 식별'하는 상황이 발생하여 BCNF를 위반합니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "BCNF 분해 예시: takes2 테이블의 정규화",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "`takes2` 테이블의 BCNF 위반 문제를 해결하기 위해, 테이블을 다음과 같이 분해할 수 있습니다:",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "1. `takes2a(student_id, section_id)`",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "2. `takes2b(section_id, subject, instructor)`",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "이 분해를 통해 `Instructor → subject` 종속성은 `takes2b` 테이블 내에서 `section_id`가 `subject`와 `instructor`를 유일하게 결정하는 구조로 변경됩니다. `section_id`는 `takes2b`의 기본키(후보키이자 슈퍼키)이므로, 이제 모든 결정자가 슈퍼키인 조건을 만족하게 되어 BCNF를 만족합니다.",
              "level": null
            }
          ],
          "aiNotes": {
            "summary": "본 문서는 보이스-코드 정규형(BCNF)의 정의와 요구사항을 설명합니다. BCNF는 제3 정규형(3NF)보다 강화된 형태로, 모든 함수 종속성 A → B에서 결정자 A가 반드시 슈퍼키여야 한다고 명시합니다. 특히 A가 비기본키인 경우 BCNF를 위반한다고 강조합니다. `takes2(student_id, subject, instructor)` 예시를 통해 `Instructor → subject`와 같은 함수 종속성이 BCNF 위반을 초래하는 과정을 보여주고, 이를 `takes2a(student_id, section_id)`와 `takes2b(section_id, subject, instructor)`로 분해하여 BCNF를 만족시키는 해결책을 제시합니다.",
            "keyConcepts": [
              {
                "term": "Boyce-Codd Normal Form (BCNF)",
                "definition": {
                  "easy": "데이터베이스에서 중복을 줄이고 데이터를 더 잘 정리하는 방법 중 하나로, 3차 정규형보다 더 엄격한 규칙을 가지고 있어요.",
                  "medium": "관계형 데이터베이스에서 모든 비자명(non-trivial) 함수 종속성 A → B에 대해 결정자 A가 반드시 슈퍼키여야 하는 정규형이다. 이는 3차 정규형의 예외적인 문제를 해결한다.",
                  "hard": "릴레이션 R이 BCNF를 만족하려면, R의 모든 비자명 함수 종속성 X → Y에서 X가 R의 슈퍼키여야 한다. 이는 3NF가 후보 키의 부분 집합이 다른 속성을 결정하는 경우를 다루지 못하는 한계를 극복하며, 모든 결정자가 후보 키가 되도록 요구함으로써 데이터 중복을 최소화하고 갱신 이상을 방지하는 데 기여한다."
                }
              },
              {
                "term": "슈퍼키 (Super Key)",
                "definition": {
                  "easy": "테이블의 한 행을 유일하게 구별할 수 있는 하나 이상의 속성(컬럼)들의 조합이에요. 주민등록번호나 학번처럼 사람을 딱 한 명만 가리킬 수 있는 정보라고 생각하면 돼요.",
                  "medium": "릴레이션의 모든 튜플을 유일하게 식별할 수 있는 속성들의 집합이다. 후보키(Candidate Key)는 슈퍼키 중에서 최소성을 만족하는 키이다.",
                  "hard": "릴레이션 스키마 R에 대해, R의 모든 튜플을 유일하게 식별할 수 있는 속성 집합 K ⊆ R을 슈퍼키라고 한다. 즉, K의 값은 R의 어떤 두 튜플에서도 동일할 수 없다. 슈퍼키는 후보키를 포함하며, 후보키에 임의의 속성을 추가해도 여전히 슈퍼키이다."
                }
              },
              {
                "term": "함수 종속성 (Functional Dependency)",
                "definition": {
                  "easy": "한쪽 정보가 바뀌면 다른 쪽 정보도 따라서 바뀌어야 하는 관계를 말해요. 예를 들어, 학생의 학번이 정해지면 그 학생의 이름도 정해지는 관계처럼요.",
                  "medium": "릴레이션 R에서 속성 집합 A의 값이 속성 집합 B의 값을 유일하게 결정할 때, A → B로 표기하며, B는 A에 함수적으로 종속된다고 한다. A를 결정자(determinant), B를 종속자(dependent)라고 한다.",
                  "hard": "릴레이션 스키마 R에서, X와 Y가 R의 부분 집합일 때, 릴레이션 r(R)의 모든 튜플 t1, t2에 대해 t1[X] = t2[X]이면 t1[Y] = t2[Y]가 성립할 때, Y는 X에 함수적으로 종속된다고 하며 X → Y로 표기한다. 이는 데이터의 일관성과 무결성을 유지하는 데 필수적인 개념이며, 정규화 과정의 핵심이다."
                }
              }
            ],
            "importantTerms": [
              {
                "term": "3NF (제3 정규형)",
                "definition": "이행적 함수 종속성을 제거하여 중복을 줄이는 정규형. BCNF보다 덜 엄격하다."
              },
              {
                "term": "비기본키 (Non-PK)",
                "definition": "기본키 또는 후보키의 구성 요소가 아닌 속성."
              },
              {
                "term": "분해 (Decomposition)",
                "definition": "정규형을 만족시키기 위해 하나의 릴레이션(테이블)을 두 개 이상의 릴레이션으로 나누는 과정."
              },
              {
                "term": "결정자 (Determinant)",
                "definition": "함수 종속성 A → B에서 A에 해당하는 속성 집합으로, 종속자를 유일하게 결정하는 역할을 한다."
              }
            ],
            "outline": [
              {
                "text": "보이스-코드 정규형 (BCNF): 3.5NF",
                "id": "보이스-코드-정규형-bcnf-35nf",
                "children": null
              },
              {
                "text": "BCNF 예시: takes2 테이블",
                "id": "bcnf-예시-takes2-테이블",
                "children": null
              },
              {
                "text": "BCNF 분해 예시: takes2 테이블의 정규화",
                "id": "bcnf-분해-예시-takes2-테이블의-정규화",
                "children": null
              }
            ]
          },
          "quiz": [
            {
              "question": "보이스-코드 정규형(BCNF)의 핵심 요구사항으로 가장 올바른 것은 무엇입니까?",
              "options": [
                "모든 함수 종속성 A → B에서 A는 슈퍼키여야 한다.",
                "모든 비기본키 속성은 기본키에 이행적으로 종속되지 않아야 한다.",
                "모든 테이블은 최소한 세 개의 속성을 가져야 한다.",
                "모든 함수 종속성 A → B에서 B는 기본키의 부분 집합이어야 한다."
              ],
              "answerIndex": 0,
              "explanation": "BCNF의 핵심 요구사항은 '모든 함수 종속성 A → B에 대해 결정자 A가 반드시 슈퍼키여야 한다'는 것입니다. 이는 3NF보다 더 엄격한 조건입니다."
            },
            {
              "question": "본문에서 제시된 `takes2(student_id, subject, instructor)` 테이블에서 BCNF 위반을 발생시키는 함수 종속성은 무엇입니까?",
              "options": [
                "(student, subject) → instructor",
                "student_id → subject",
                "Instructor → subject",
                "subject → instructor"
              ],
              "answerIndex": 2,
              "explanation": "`Instructor → subject` 종속성이 BCNF 위반을 일으킵니다. `Instructor`는 `takes2` 테이블의 슈퍼키가 아니지만 `subject`를 결정하기 때문입니다."
            },
            {
              "question": "BCNF를 만족시키기 위해 `takes2` 테이블을 `takes2a(student_id, section_id)`와 `takes2b(section_id, subject, instructor)`로 분해한 주된 이유는 무엇입니까?",
              "options": [
                "테이블의 총 행 수를 줄이기 위해",
                "데이터 입력 속도를 향상시키기 위해",
                "`Instructor → subject` 함수 종속성으로 인한 BCNF 위반 문제를 해결하기 위해",
                "학생과 과목 간의 관계를 명확히 하기 위해"
              ],
              "answerIndex": 2,
              "explanation": "`takes2` 테이블은 `Instructor`가 슈퍼키가 아님에도 불구하고 `subject`를 결정하는 `Instructor → subject` 함수 종속성 때문에 BCNF를 위반했습니다. 테이블을 분해함으로써 이 문제가 해결됩니다."
            }
          ]
        },
        {
          "title": "제4 정규형 (4NF): 다치 종속성 제거",
          "metadata": "Source: a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf, Text length: 2282 chars",
          "documentContent": [
            {
              "type": "heading",
              "content": "제4 정규형 (4NF) 개요",
              "level": 1
            },
            {
              "type": "paragraph",
              "content": "제4 정규형(Fourth Normal Form, 4NF)은 데이터베이스 정규화의 한 단계로, 릴레이션이 BCNF(보이스-코드 정규형)를 만족하고 다치 종속성(Multi-valued Dependency)을 가지지 않아야 한다는 요구사항을 가집니다. 다치 종속성은 데이터베이스 스키마 설계가 부적절할 때 발생하며, 일반적으로 3개 이상의 속성을 가진 릴레이션에서 나타날 수 있습니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "예를 들어, 릴레이션에 A, B, C 세 가지 속성이 있고, A가 B를 함수적으로 결정(A → B)하면서 B와 C가 서로 독립적일 때 다치 종속성이 발생할 수 있습니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "다치 종속성 (MVD) 이해",
              "level": 1
            },
            {
              "type": "heading",
              "content": "예시 1: 학생-과목-활동 관계",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "다음과 같은 학생 관련 정보 릴레이션이 있다고 가정해 봅시다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "student_id → course (학생은 여러 과목을 수강)",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "student_id → activity (학생은 여러 활동에 참여)",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "course ⊥ activity (과목과 활동은 서로 독립적)",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "이 경우, 한 테이블에 student_id, course, activity를 모두 포함하면 다치 종속성이 발생합니다. 예를 들어, '21800999' 학생이 'Statistics', 'Linear algebra'를 수강하고 'Soccer', 'Basketball' 활동을 한다면, 모든 조합이 튜플로 저장되어 불필요한 중복이 발생합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "이러한 문제를 해결하기 위해, 릴레이션을 student_id와 course로 구성된 테이블과 student_id와 activity로 구성된 테이블로 분리할 수 있습니다. 이는 다치 종속성을 제거하여 데이터 중복을 줄이는 방법입니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "예시 2: 강사-자녀-전화번호 관계",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "강사의 자녀 이름(inst_child(ID, child_name))과 전화번호(inst_phone(ID, phone_number))를 기록한다고 가정해 봅시다. 이 두 스키마를 inst_info(ID, child_name, phone_number)로 결합하면 문제가 발생합니다. 특정 강사 ID(예: 999999)에 대해 여러 자녀 이름(David, William)과 여러 전화번호(x-x-1234, x-x-4321)가 독립적으로 존재할 때, 다음과 같은 튜플들이 생성되어 중복이 발생합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "(99999, David, 512-555-1234)",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "(99999, David, 512-555-4321)",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "(99999, William, 512-555-1234)",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "(99999, William, 512-555-4321)",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "이는 다치 종속성으로 인한 문제로, 자녀 이름과 전화번호가 서로 독립적임에도 불구하고 카테시안 곱 형태로 튜플이 증가하여 불필요한 중복을 야기합니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "다치 종속성의 공식적 정의",
              "level": 1
            },
            {
              "type": "paragraph",
              "content": "릴레이션 스키마 R에서 속성 집합 α와 β가 R의 부분 집합일 때, 다치 종속성 α →→ β는 릴레이션 r(R)의 모든 튜플 t1과 t2에 대해 t1[α] = t2[α]를 만족하면, 다음과 같은 튜플 t3와 t4가 r에 존재함을 의미합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "t1[α] = t2[α] = t3[α] = t4[α]",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "t3[β] = t1[β]",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "t3[R – β] = t2[R – β]",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "t4[β] = t2[β]",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "t4[R – β] = t1[R – β]",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "또 다른 정의는 릴레이션 스키마 R의 속성 집합이 세 개의 비어 있지 않은 부분 집합 Y, Z, W로 분할될 때, Y →→ Z (Y가 Z를 다중 결정)는 r(R)의 모든 가능한 릴레이션에서 <y1, z1, w1> ∈ r 이고 <y1, z2, w2> ∈ r 이면, <y1, z1, w2> ∈ r 이고 <y1, z2, w1> ∈ r 이라는 것입니다. Z와 W의 동작이 동일하므로 Y →→ Z이면 Y →→ W도 성립합니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "다치 종속성 해결의 필요성",
              "level": 1
            },
            {
              "type": "paragraph",
              "content": "FAV(student_id, course, activity) 릴레이션에서 21800999 학생이 {statistics, Linear algebra} 과목과 {Soccer, basketball} 활동을 가지고 있을 때, 이들은 서로 직교(orthogonal)하는 관계입니다. 즉, 과목과 활동은 학생 ID에 종속되지만 서로에게는 독립적입니다. 이러한 다치 종속성을 해결하지 않으면 데이터 중복과 갱신 이상이 발생하여 데이터베이스의 효율성과 무결성이 저해됩니다. 4NF는 이러한 다치 종속성을 제거하여 데이터베이스의 구조를 더욱 견고하게 만듭니다.",
              "level": null
            }
          ],
          "aiNotes": {
            "summary": "제4 정규형(4NF)은 관계형 데이터베이스 정규화의 한 단계로, BCNF를 만족하고 릴레이션 내의 다치 종속성(Multi-valued Dependency, MVD)을 제거하여 데이터 중복을 최소화하고 갱신 이상을 방지하는 것을 목표로 합니다. 다치 종속성은 일반적으로 3개 이상의 속성을 가진 테이블에서 특정 속성 집합이 다른 두 개 이상의 독립적인 속성 집합을 다중 결정할 때 발생하며, 이로 인해 불필요한 튜플 증가와 데이터 중복이 야기됩니다. 본문은 학생-과목-활동 및 강사-자녀-전화번호 예시를 통해 다치 종속성의 발생 원인과 그로 인한 문제점을 설명하고, 다치 종속성의 공식적인 정의를 제시하여 4NF의 중요성을 강조합니다.",
            "keyConcepts": [
              {
                "term": "제4 정규형 (4NF)",
                "definition": {
                  "easy": "데이터베이스에서 중복을 줄이기 위한 규칙 중 하나로, 한 테이블 안에 서로 관련 없는 여러 정보가 동시에 많아지는 것을 막는 것입니다.",
                  "medium": "관계형 데이터베이스에서 다치 종속성을 제거하여 데이터 중복을 최소화하고 갱신 이상을 방지하는 정규화 단계입니다. BCNF를 만족해야 하며, 비자명 다치 종속성이 없어야 합니다.",
                  "hard": "릴레이션 R이 BCNF를 만족하고, R의 모든 비자명 다치 종속성(A →→ B)이 함수 종속성(A → B)이거나 A가 R의 슈퍼키인 경우 R은 4NF를 만족합니다. 이는 특정 속성 집합이 다른 두 개 이상의 독립적인 속성 집합을 다중 결정하는 다치 종속성을 제거하여 불필요한 튜플 증가와 갱신 이상을 방지합니다."
                }
              },
              {
                "term": "다치 종속성 (MVD)",
                "definition": {
                  "easy": "한 가지 정보(예: 학생 ID)가 여러 가지 다른 정보(예: 듣는 과목들, 참여하는 활동들)를 동시에 가질 때, 이 다른 정보들끼리는 서로 관련이 없는 경우를 말합니다.",
                  "medium": "릴레이션 R에서 속성 집합 A가 속성 집합 B를 다중 결정한다는 것은, A의 특정 값에 대해 B의 여러 값들이 존재하고, 이 B 값들이 A의 다른 속성들과는 독립적으로 존재할 때 발생합니다. 이는 릴레이션 내에 불필요한 데이터 중복을 야기합니다.",
                  "hard": "릴레이션 R의 스키마에 대해, A, B, C가 R의 속성 집합의 분할이라고 할 때, A →→ B는 R의 모든 인스턴스에서 A의 특정 값에 대해 B의 값 집합이 독립적으로 존재하며, A의 동일한 값에 대한 C의 값 집합과 독립적으로 결합될 수 있음을 의미합니다. 즉, 튜플 t1과 t2가 A에 대해 동일한 값을 가질 때, t1[A]=t2[A]=t3[A]=t4[A], t3[B]=t1[B], t3[R-B]=t2[R-B], t4[B]=t2[B], t4[R-B]=t1[R-B]를 만족하는 t3와 t4가 존재할 때 발생합니다."
                }
              },
              {
                "term": "BCNF (보이스-코드 정규형)",
                "definition": {
                  "easy": "테이블의 모든 결정자가 후보 키인 상태를 말합니다. 즉, 어떤 한 정보가 다른 정보를 결정할 때, 그 결정하는 정보가 반드시 테이블의 주요 식별자여야 한다는 규칙입니다.",
                  "medium": "모든 함수 종속성 A → B에 대해, A가 슈퍼키인 경우 릴레이션은 BCNF를 만족합니다. 이는 3NF에서 발생할 수 있는 이상 현상을 제거하기 위해 더 엄격한 조건을 적용합니다.",
                  "hard": "릴레이션 스키마 R이 BCNF를 만족하려면, R에 존재하는 모든 비자명 함수 종속성 X → Y에 대해 X가 R의 슈퍼키여야 합니다. 이는 모든 결정자가 후보 키가 되도록 보장하여, 부분 함수 종속성 및 이행 함수 종속성과 같은 이상 현상을 근본적으로 제거합니다."
                }
              },
              {
                "term": "릴레이션 (Relation)",
                "definition": {
                  "easy": "데이터베이스에서 데이터를 표 형태로 저장하는 것을 말합니다. 행과 열로 이루어진 표라고 생각하면 됩니다.",
                  "medium": "관계형 데이터 모델에서, 속성(열)들의 집합과 해당 속성들의 도메인에서 가져온 값들로 구성된 튜플(행)들의 집합입니다. 데이터베이스 테이블과 동의어로 사용됩니다.",
                  "hard": "관계형 대수에서 정의된 수학적 관계의 인스턴스로, 고유한 속성 헤더(스키마)와 해당 속성 도메인에서 가져온 값들로 구성된 순서 없는 튜플(레코드) 집합입니다. 각 튜플은 유일하며, 속성의 순서는 중요하지 않습니다."
                }
              }
            ],
            "importantTerms": [
              {
                "term": "정규형 (Normal Form)",
                "definition": "데이터베이스 테이블의 중복을 줄이고 무결성을 유지하기 위한 구조적 규칙들의 집합."
              },
              {
                "term": "속성 (Attribute)",
                "definition": "릴레이션(테이블)의 열(column)을 의미하며, 특정 종류의 데이터를 저장한다."
              },
              {
                "term": "튜플 (Tuple)",
                "definition": "릴레이션(테이블)의 행(row)을 의미하며, 하나의 레코드를 구성하는 속성 값들의 집합."
              },
              {
                "term": "슈퍼키 (Superkey)",
                "definition": "릴레이션의 모든 튜플을 고유하게 식별할 수 있는 하나 이상의 속성 집합."
              },
              {
                "term": "직교 (Orthogonal)",
                "definition": "두 개 이상의 속성 집합이 서로 독립적으로 존재하며 영향을 주지 않는 관계."
              }
            ],
            "outline": [
              {
                "text": "제4 정규형 (4NF) 개요",
                "id": "제4-정규형-4nf-개요",
                "children": null
              },
              {
                "text": "다치 종속성 (MVD) 이해",
                "id": "다치-종속성-mvd-이해",
                "children": [
                  {
                    "text": "예시 1: 학생-과목-활동 관계",
                    "id": "예시-1-학생-과목-활동-관계",
                    "children": null
                  },
                  {
                    "text": "예시 2: 강사-자녀-전화번호 관계",
                    "id": "예시-2-강사-자녀-전화번호-관계",
                    "children": null
                  }
                ]
              },
              {
                "text": "다치 종속성의 공식적 정의",
                "id": "다치-종속성의-공식적-정의",
                "children": null
              },
              {
                "text": "다치 종속성 해결의 필요성",
                "id": "다치-종속성-해결의-필요성",
                "children": null
              }
            ]
          },
          "quiz": [
            {
              "question": "제4 정규형(4NF)이 만족해야 하는 선행 조건은 무엇인가요?",
              "options": [
                "1NF",
                "2NF",
                "3NF",
                "BCNF"
              ],
              "answerIndex": 3,
              "explanation": "제4 정규형(4NF)의 요구사항 중 하나는 릴레이션이 BCNF를 만족해야 한다는 것입니다."
            },
            {
              "question": "다음 중 다치 종속성(Multi-valued Dependency)이 발생할 수 있는 상황에 대한 설명으로 가장 적절한 것은?",
              "options": [
                "릴레이션에 2개 이하의 속성이 존재할 때",
                "릴레이션의 속성 A가 B를 함수적으로 결정하고 B가 C를 함수적으로 결정할 때",
                "릴레이션에 3개 이상의 속성(A, B, C)이 있고, A가 B를 결정하며, B와 C가 서로 독립적일 때",
                "모든 속성이 기본 키의 부분 집합에 종속될 때"
              ],
              "answerIndex": 2,
              "explanation": "다치 종속성은 릴레이션에 3개 이상의 속성이 존재하고, 어떤 속성(A)이 다른 속성(B)을 결정하지만, B와 또 다른 속성(C)이 서로 독립적일 때 발생할 수 있습니다."
            },
            {
              "question": "강사 정보(ID, 자녀 이름, 전화번호) 테이블에서 ID가 자녀 이름과 전화번호를 다중 결정할 때 발생하는 주요 문제점은?",
              "options": [
                "데이터 무결성 제약 조건 위반",
                "릴레이션의 크기가 줄어듦",
                "불필요한 데이터 중복 및 갱신 이상 발생",
                "함수 종속성 손실"
              ],
              "answerIndex": 2,
              "explanation": "다치 종속성으로 인해 ID에 따라 자녀 이름과 전화번호의 모든 가능한 조합이 튜플로 저장되어, 불필요한 데이터 중복과 삽입, 삭제, 갱신 시의 이상 현상이 발생합니다."
            }
          ]
        },
        {
          "title": "정규화 이론 및 종속성 요약",
          "metadata": "Source: a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf, Text length: 1600 chars",
          "documentContent": [
            {
              "type": "heading",
              "content": "정규형 요약",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "정규형 이론은 데이터베이스 설계에서 릴레이션의 '좋은 형태'를 정의하고, 데이터 중복 및 이상 현상을 줄이는 데 사용됩니다. 각 정규형은 특정 유형의 종속성과 관련이 있습니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "다음은 주요 정규형과 그와 관련된 핵심 아이디어 및 종속성입니다:",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "-   **2NF (제2정규형)**: 부분 종속성(Partial dependency)을 다룹니다. 이는 기본 키의 일부가 비기본 키 속성을 결정하는 경우에 해당합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "-   **3NF (제3정규형)**: 이행 종속성(Transitive dependency)을 다룹니다. 이는 비기본 키 속성이 다른 비기본 키 속성을 결정하는 경우에 해당합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "-   **BCNF (보이스-코드 정규형)**: 3NF보다 엄격한 형태로, 비기본 키가 기본 키를 결정하는 경우를 포함하여 모든 결정자가 후보 키여야 함을 요구합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "-   **4NF (제4정규형)**: 다치 종속성(Multi-valued dependency)을 다룹니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "-   **5NF (제5정규형)**: 조인 종속성(Join dependency)을 다룹니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "정규화 이론",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "정규화 이론은 특정 릴레이션 R이 '좋은 형태'에 해당하는지 여부를 결정하는 것을 목표로 합니다. 만약 릴레이션 R이 '좋은 형태'가 아니라면, 이를 {R1, R2, ..., Rn}과 같은 릴레이션 집합으로 분해합니다. 이때 다음 조건들을 만족해야 합니다:",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "-   각각의 분해된 릴레이션은 '좋은 형태'여야 합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "-   분해는 무손실 분해(lossless decomposition)여야 합니다. 즉, 분해 후 다시 조인했을 때 원래 정보가 손실되지 않아야 합니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "정규화 이론의 기반",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "정규화는 다음을 포함한 관련 이론 집합에 기반을 두고 있습니다:",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "-   함수 종속성 (Functional dependencies)\n-   부분 종속성 (Partial dependencies)\n-   이행 종속성 (Transitive dependencies)\n-   다치 종속성 (Multivalued dependencies)",
              "level": null
            },
            {
              "type": "heading",
              "content": "함수 종속성의 활용",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "함수 종속성은 두 가지 주요 방식으로 활용됩니다:",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "1.  **릴레이션의 유효성 테스트**: 주어진 함수 종속성 집합 하에서 특정 릴레이션이 유효한지 테스트하는 데 사용됩니다. 릴레이션 r이 함수 종속성 집합 F 하에서 유효하다면, 우리는 r이 F를 만족한다고 말합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "2.  **유효한 릴레이션 집합에 제약 조건 지정**: 릴레이션 R에 대한 모든 유효한 릴레이션이 함수 종속성 집합 F를 만족할 경우, R에 F가 성립한다고 말합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "참고: 릴레이션 스키마의 특정 인스턴스는 해당 함수 종속성이 모든 유효한 인스턴스에 성립하지 않더라도 우연히 함수 종속성을 만족할 수 있습니다. 예를 들어, 'instructor' 릴레이션의 특정 인스턴스는 우연히 'name → ID' 관계를 만족할 수 있습니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "다치 종속성의 활용",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "다치 종속성 또한 두 가지 방식으로 활용됩니다:",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "1.  **릴레이션의 유효성 테스트**: 주어진 함수 및 다치 종속성 집합 하에서 릴레이션이 유효한지 여부를 결정하는 데 사용됩니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "2.  **유효한 릴레이션 집합에 제약 조건 지정**: 우리는 주어진 함수 및 다치 종속성을 만족하는 릴레이션만 고려합니다. 만약 릴레이션 r이 주어진 다치 종속성을 만족하지 못한다면, r에 튜플을 추가하여 다치 종속성을 만족하는 r'를 구성할 수 있습니다.",
              "level": null
            }
          ],
          "aiNotes": {
            "summary": "제공된 텍스트는 데이터베이스 정규화 이론과 다양한 종속성(함수, 부분, 이행, 다치, 조인)이 각 정규형(2NF, 3NF, BCNF, 4NF, 5NF)과 어떻게 관련되는지 설명합니다. 또한, 정규화가 릴레이션을 '좋은 형태'로 분해하는 과정이며, 이 과정에서 무손실 분해가 중요함을 강조합니다. 마지막으로 함수 종속성 및 다치 종속성이 릴레이션의 유효성을 테스트하고 제약 조건을 지정하는 데 어떻게 활용되는지 상세히 설명합니다.",
            "keyConcepts": [
              {
                "term": "정규화 (Normalization)",
                "definition": {
                  "easy": "데이터베이스를 잘 정리해서 중복을 줄이고 문제를 없애는 과정이에요.",
                  "medium": "데이터 중복을 제거하고 데이터 일관성을 유지하기 위해 릴레이션 스키마를 더 작고 잘 정의된 릴레이션으로 분해하는 과정입니다.",
                  "hard": "관계형 데이터베이스 설계에서 데이터의 무결성을 보장하고 이상 현상(삽입, 삭제, 갱신 이상)을 최소화하기 위해 릴레이션 스키마를 특정 정규형 규칙에 따라 분해하는 체계적인 과정으로, 주로 함수 종속성과 다치 종속성 등의 제약 조건을 기반으로 합니다."
                }
              },
              {
                "term": "함수 종속성 (Functional Dependency)",
                "definition": {
                  "easy": "어떤 값(들)이 다른 어떤 값(들)을 항상 결정하는 관계를 말해요. 예를 들어, 학생 번호가 학생 이름을 결정하는 것처럼요.",
                  "medium": "릴레이션 R에서 속성 집합 A가 속성 집합 B를 함수적으로 결정한다는 것은, R의 어떤 두 튜플이 A에 대해 같은 값을 가지면 B에 대해서도 같은 값을 가져야 함을 의미합니다 (A → B).",
                  "hard": "관계형 스키마 R에서, 속성 집합 X의 값이 속성 집합 Y의 값을 유일하게 결정할 때 (X → Y), 이를 함수 종속성이라 합니다. 이는 릴레이션 인스턴스에 대한 제약 조건으로, 데이터의 의미론적 관계를 반영하며 정규화 과정에서 중요한 역할을 합니다."
                }
              },
              {
                "term": "무손실 분해 (Lossless Decomposition)",
                "definition": {
                  "easy": "테이블을 여러 개로 나눴다가 다시 합쳐도 원래 정보가 하나도 없어지지 않는 것을 말해요.",
                  "medium": "릴레이션 R을 R1과 R2로 분해했을 때, R1과 R2를 자연 조인(natural join)한 결과가 원래 릴레이션 R과 동일하게 되는 분해를 의미합니다. 정보 손실이 발생하지 않음을 보장합니다.",
                  "hard": "데이터베이스 릴레이션 R을 R1, R2, ..., Rn의 집합으로 분해할 때, 모든 R_i의 자연 조인(⋈ R_i)이 원래 릴레이션 R과 동일한 정보를 포함하는 것을 보장하는 분해 속성입니다. 이는 분해로 인해 데이터가 유실되거나 허위 튜플이 생성되지 않음을 의미하며, 정규화의 필수적인 목표 중 하나입니다."
                }
              }
            ],
            "importantTerms": [
              {
                "term": "정규형 (Normal Form)",
                "definition": "데이터베이스 릴레이션이 만족해야 하는 특정 조건들의 집합으로, 데이터 중복을 줄이고 이상 현상을 방지하기 위해 사용됩니다."
              },
              {
                "term": "부분 종속성 (Partial Dependency)",
                "definition": "기본 키의 일부 속성이 비기본 키 속성을 결정하는 함수 종속성으로, 2NF 위반의 원인이 됩니다."
              },
              {
                "term": "이행 종속성 (Transitive Dependency)",
                "definition": "비기본 키 속성이 다른 비기본 키 속성을 결정하는 함수 종속성으로, 3NF 위반의 원인이 됩니다."
              },
              {
                "term": "다치 종속성 (Multi-valued Dependency)",
                "definition": "한 속성의 값이 다른 속성 집합의 여러 값을 결정하는 상황으로, 4NF 위반의 원인이 됩니다."
              },
              {
                "term": "조인 종속성 (Join Dependency)",
                "definition": "릴레이션을 여러 개의 릴레이션으로 분해한 후 다시 조인했을 때 원래 릴레이션과 동일하게 되는 성질로, 5NF와 관련이 있습니다."
              },
              {
                "term": "BCNF (Boyce-Codd Normal Form)",
                "definition": "3NF보다 더 엄격한 정규형으로, 모든 결정자가 후보 키여야 한다는 조건을 요구합니다."
              },
              {
                "term": "릴레이션 (Relation)",
                "definition": "관계형 데이터베이스에서 데이터를 저장하는 테이블을 지칭하는 용어입니다."
              }
            ],
            "outline": [
              {
                "text": "정규형 및 종속성 요약",
                "id": "정규형-및-종속성-요약",
                "children": [
                  {
                    "text": "정규형별 핵심 아이디어 및 종속성",
                    "id": "정규형별-핵심-아이디어-및-종속성",
                    "children": [
                      {
                        "text": "2NF (부분 종속성)",
                        "id": "2nf-부분-종속성",
                        "children": null
                      },
                      {
                        "text": "3NF (이행 종속성)",
                        "id": "3nf-이행-종속성",
                        "children": null
                      },
                      {
                        "text": "BCNF (비PK -> PK)",
                        "id": "bcnf-비pk-pk",
                        "children": null
                      },
                      {
                        "text": "4NF (다치 종속성)",
                        "id": "4nf-다치-종속성",
                        "children": null
                      },
                      {
                        "text": "5NF (조인 종속성)",
                        "id": "5nf-조인-종속성",
                        "children": null
                      }
                    ]
                  }
                ]
              },
              {
                "text": "정규화 이론",
                "id": "정규화-이론",
                "children": [
                  {
                    "text": "‘좋은 형태’ 릴레이션 판단 및 분해",
                    "id": "좋은-형태-릴레이션-판단-및-분해",
                    "children": null
                  },
                  {
                    "text": "무손실 분해의 중요성",
                    "id": "무손실-분해의-중요성",
                    "children": null
                  },
                  {
                    "text": "정규화의 기반이 되는 이론들",
                    "id": "정규화의-기반이-되는-이론들",
                    "children": [
                      {
                        "text": "함수 종속성",
                        "id": "함수-종속성",
                        "children": null
                      },
                      {
                        "text": "부분 종속성",
                        "id": "부분-종속성",
                        "children": null
                      },
                      {
                        "text": "이행 종속성",
                        "id": "이행-종속성",
                        "children": null
                      },
                      {
                        "text": "다치 종속성",
                        "id": "다치-종속성",
                        "children": null
                      }
                    ]
                  }
                ]
              },
              {
                "text": "종속성의 활용",
                "id": "종속성의-활용",
                "children": [
                  {
                    "text": "함수 종속성의 활용",
                    "id": "함수-종속성의-활용",
                    "children": [
                      {
                        "text": "릴레이션의 유효성 테스트",
                        "id": "릴레이션의-유효성-테스트",
                        "children": null
                      },
                      {
                        "text": "유효한 릴레이션에 대한 제약 조건 지정",
                        "id": "유효한-릴레이션에-대한-제약-조건-지정",
                        "children": null
                      }
                    ]
                  },
                  {
                    "text": "다치 종속성의 활용",
                    "id": "다치-종속성의-활용",
                    "children": [
                      {
                        "text": "릴레이션의 유효성 테스트",
                        "id": "릴레이션의-유효성-테스트",
                        "children": null
                      },
                      {
                        "text": "유효한 릴레이션에 대한 제약 조건 지정",
                        "id": "유효한-릴레이션에-대한-제약-조건-지정",
                        "children": null
                      },
                      {
                        "text": "다치 종속성을 만족하지 못하는 경우 튜플 추가를 통한 만족",
                        "id": "다치-종속성을-만족하지-못하는-경우-튜플-추가를-통한-만족",
                        "children": null
                      }
                    ]
                  }
                ]
              }
            ]
          },
          "quiz": [
            {
              "question": "다음 중 부분 종속성(Partial dependency)과 관련된 정규형은 무엇인가요?",
              "options": [
                "1NF",
                "2NF",
                "3NF",
                "BCNF"
              ],
              "answerIndex": 1,
              "explanation": "부분 종속성은 기본 키의 일부가 비기본 키를 결정하는 경우를 의미하며, 이는 2NF를 위반하는 주된 원인입니다."
            },
            {
              "question": "데이터베이스 정규화의 주요 목적 중 하나가 아닌 것은 무엇인가요?",
              "options": [
                "데이터 중복 제거",
                "데이터 일관성 유지",
                "무손실 분해 보장",
                "데이터 검색 속도 최적화"
              ],
              "answerIndex": 3,
              "explanation": "정규화는 주로 데이터 중복 제거, 일관성 유지, 이상 현상 방지를 목적으로 하며, 반드시 검색 속도를 최적화하는 것은 아닙니다. 오히려 과도한 정규화는 조인 연산을 증가시켜 검색 성능을 저하시킬 수도 있습니다."
            },
            {
              "question": "릴레이션 R이 함수 종속성 집합 F 하에서 '유효하다'는 것의 의미로 가장 적절한 것은?",
              "options": [
                "R의 모든 속성이 기본 키에만 종속된다.",
                "R이 F에 있는 모든 함수 종속성을 만족한다.",
                "R에 허위 튜플이 존재하지 않는다.",
                "R이 2NF를 만족한다."
              ],
              "answerIndex": 1,
              "explanation": "텍스트에 따르면, 릴레이션 r이 주어진 함수 종속성 F 하에서 유효할 경우, r은 F를 만족한다고 명시되어 있습니다. 이는 R의 모든 인스턴스가 F에 정의된 모든 함수 종속성 제약을 따른다는 의미입니다."
            }
          ]
        },
        {
          "title": "데이터베이스 정규화 실전 예시",
          "metadata": "Source: a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf, Text length: 1335 chars",
          "documentContent": [
            {
              "type": "heading",
              "content": "데이터베이스 정규화 실전 예시",
              "level": 1
            },
            {
              "type": "paragraph",
              "content": "위키피디아에서 가져온 예시를 통해 데이터베이스 정규화 과정을 제1 정규형(1NF)부터 제4 정규형(4NF)까지 단계별로 설명합니다. 각 정규형이 어떤 함수 종속성을 해결하는지 구체적인 사례를 통해 살펴봅니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "초기 데이터 상태",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "제공된 초기 데이터는 특정 서적 정보들을 포함하고 있으며, 이후 정규화 과정을 통해 데이터 중복을 줄이고 무결성을 높이는 방법을 보여줍니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "제1 정규형 (1NF) 만족",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "제1 정규형을 만족시키기 위해 각 셀이 단일 값을 포함하도록 하고, 반복되는 그룹을 제거하여 테이블을 분리하거나 확장하는 과정이 필요합니다. 이를 통해 데이터의 원자성을 확보합니다. 예시에서는 초기 비정규형 상태에서 1NF를 만족하는 형태로 개선된 모습을 보여줍니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "제2 정규형 (2NF) 만족",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "제2 정규형은 제1 정규형을 만족하고, 부분 함수 종속성(Partial Dependency)이 없는 상태를 의미합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "예시의 초기 데이터는 `{Title, Format}`을 복합 키(Compound key)로 가집니다. 이때 `Title`이 `Author`, `Author Nationality`, `Pages`, `Thickness`, `Genre ID`, `Genre Name`, `Publisher ID`에 부분 함수 종속성을 가집니다. 즉, 복합 키의 일부인 `Title`만으로 다른 속성들이 결정되는 문제가 있습니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "제2 정규형을 만족시키기 위해 이러한 부분 함수 종속성을 제거하고, 종속된 속성들을 별도의 테이블로 분리하여 데이터 중복을 줄입니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "제3 정규형 (3NF) 만족",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "제3 정규형은 제2 정규형을 만족하고, 추이 함수 종속성(Transitive Dependency)이 없는 상태를 의미합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "예시에서는 `Genre ID`가 `Genre Name`을 결정하는 추이 함수 종속성(`Genre ID` → `Genre Name`)이 존재합니다. 이는 기본 키가 아닌 속성(`Genre ID`)이 다른 기본 키가 아닌 속성(`Genre Name`)을 결정하는 경우입니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "제3 정규형을 만족시키기 위해 `Genre ID`와 `Genre Name`을 포함하는 별도의 테이블을 생성하여 추이 함수 종속성을 제거합니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "보이스/코드 정규형 (BCNF) 만족",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "BCNF는 제3 정규형보다 엄격한 정규형으로, 모든 결정자(Determinant)가 후보 키(Candidate Key)여야 합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "예시에서는 `Author`가 `Author Nationality`를 결정하는 비기본 키 간의 함수 종속성(`Author` → `Author Nationality`)이 존재합니다. `Author`는 후보 키가 아니므로 BCNF를 위반합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "BCNF를 만족시키기 위해 `Author`와 `Author Nationality`를 포함하는 별도의 테이블을 분리하여 이러한 종속성을 제거합니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "제4 정규형 (4NF) 만족",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "제4 정규형은 BCNF를 만족하고, 다치 종속성(Multi-valued Dependency)이 없는 상태를 의미합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "이 예시는 서점 프랜차이즈가 여러 지역에 지점을 소유하고 있으며, 모든 가용 서적이 각 지역에서 제공된다는 가정을 합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "이 가정 하에 `Title`이 특정 `Location`에 명확하게 바인딩되지 않는 다치 종속성이 발생할 수 있습니다. 이는 제4 정규형을 만족하지 않는 경우를 보여주며, 다치 종속성을 제거하여 테이블을 추가로 분리할 필요가 있음을 시사합니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "출처",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "본 예시는 위키피디아의 데이터베이스 정규화 관련 페이지에서 발췌되었습니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "원문 출처: https://en.wikipedia.org/wiki/Database_normalization",
              "level": null
            }
          ],
          "aiNotes": {
            "summary": "이 문서는 데이터베이스 정규화 과정을 제1 정규형(1NF)부터 제4 정규형(4NF)까지 단계별로 설명하는 실전 예시를 제공합니다. 각 정규형이 어떤 종류의 함수 종속성(부분 함수 종속성, 추이 함수 종속성, 비기본 키 간의 함수 종속성, 다치 종속성)을 해결하는지 구체적인 시나리오와 함께 보여주며, 이를 통해 데이터 중복을 줄이고 데이터 무결성을 높이는 방법을 시연합니다.",
            "keyConcepts": [
              {
                "term": "정규화 (Normalization)",
                "definition": {
                  "easy": "데이터베이스를 잘 정리해서 중복을 줄이고 문제없이 데이터를 저장하는 방법입니다.",
                  "medium": "데이터베이스 설계에서 데이터 중복을 최소화하고 무결성을 유지하며 이상 현상(삽입, 삭제, 갱신 이상)을 방지하기 위해 릴레이션을 여러 개의 릴레이션으로 분해하는 과정입니다.",
                  "hard": "관계형 데이터베이스 설계에서 함수 종속성(Functional Dependency) 이론을 기반으로 릴레이션 스키마를 분해하여 데이터 중복성을 제거하고 데이터 무결성을 강화하며, 삽입, 삭제, 갱신 이상(Anomalies)을 최소화하기 위한 체계적인 과정입니다."
                }
              },
              {
                "term": "함수 종속성 (Functional Dependency)",
                "definition": {
                  "easy": "어떤 값(A)이 다른 값(B)을 결정할 때 A가 B에 함수 종속적이라고 합니다. 예를 들어, 책 제목이 저자를 결정하는 경우입니다.",
                  "medium": "릴레이션 R에서 속성 집합 X가 속성 집합 Y를 함수적으로 결정할 때, X → Y로 표기하며, Y가 X에 함수 종속적이라고 합니다. 즉, X의 각 값에 대해 Y의 값이 유일하게 결정되는 관계를 의미합니다.",
                  "hard": "관계형 스키마 R에서, 속성 집합 X와 Y에 대해, R의 어떤 유효한 릴레이션 인스턴스 r에서도 X의 두 튜플이 동일한 값을 가지면, 그 두 튜플은 Y에서도 동일한 값을 가질 때 Y는 X에 함수 종속적이라고 합니다. 이는 데이터 무결성 제약 조건의 한 형태로, 데이터 중복 및 이상 현상을 분석하고 제거하는 데 사용됩니다."
                }
              },
              {
                "term": "부분 함수 종속성 (Partial Dependency)",
                "definition": {
                  "easy": "복합 키의 일부만으로 다른 데이터가 결정될 때를 말합니다.",
                  "medium": "릴레이션에서 기본 키의 부분 집합이 기본 키가 아닌 속성을 결정하는 함수 종속성입니다. 제2 정규형에서 제거 대상입니다.",
                  "hard": "복합 기본 키를 가진 릴레이션 R에서, 기본 키의 적절한 부분 집합 X가 기본 키가 아닌 속성 Y를 함수적으로 결정하는 경우 (X → Y)입니다. 이는 R이 제2 정규형을 만족하지 못하게 하는 원인이며, 이 종속성을 제거함으로써 릴레이션의 중복성을 줄이고 업데이트 이상을 방지할 수 있습니다."
                }
              },
              {
                "term": "추이 함수 종속성 (Transitive Dependency)",
                "definition": {
                  "easy": "A가 B를 결정하고 B가 C를 결정할 때, A가 C를 결정하는 관계(A→B, B→C 이면 A→C)를 말합니다.",
                  "medium": "릴레이션에서 기본 키가 아닌 속성이 다른 기본 키가 아닌 속성을 결정하는 함수 종속성입니다. 제3 정규형에서 제거 대상입니다.",
                  "hard": "릴레이션 R에서, X, Y, Z가 R의 속성 집합일 때 X → Y이고 Y → Z이며 Y가 X의 부분 집합이 아니고 Z가 Y에 함수 종속적이지 않을 때 X → Z가 성립하는 함수 종속성입니다. 이는 기본 키가 아닌 속성 간의 종속성으로, 제3 정규형을 만족시키기 위해 제거되어야 합니다."
                }
              },
              {
                "term": "다치 종속성 (Multi-valued Dependency)",
                "definition": {
                  "easy": "하나의 데이터가 다른 여러 개의 데이터를 결정할 때 발생하며, 이 관계가 다른 데이터와 상관없을 때를 말합니다.",
                  "medium": "릴레이션 R에서 속성 집합 A가 속성 집합 B의 여러 값을 결정하고, 이 관계가 다른 속성 집합 C와 무관할 때 A가 B에 다치 종속적이라고 합니다. 제4 정규형에서 제거 대상입니다.",
                  "hard": "릴레이션 R에서, A, B, C가 R의 속성 집합일 때, A →→ B가 성립하는 경우입니다. 이는 A의 각 값에 대해 B의 값이 다중으로 존재하며, B의 집합이 C와 독립적일 때 발생합니다. 즉, A의 특정 값에 대해 B의 값들의 집합이 존재하고, 그 B의 값들의 집합이 R의 다른 속성들과 무관하게 결정될 때 발생하며, 제4 정규형에서 해결해야 할 대상입니다."
                }
              }
            ],
            "importantTerms": [
              {
                "term": "복합 키 (Compound Key)",
                "definition": "두 개 이상의 속성으로 구성된 기본 키입니다."
              },
              {
                "term": "제1 정규형 (1NF)",
                "definition": "모든 속성 값이 원자 값(Atomic Value)을 가지며, 반복되는 그룹이 없는 형태입니다."
              },
              {
                "term": "제2 정규형 (2NF)",
                "definition": "제1 정규형을 만족하고, 부분 함수 종속성이 없는 형태입니다."
              },
              {
                "term": "제3 정규형 (3NF)",
                "definition": "제2 정규형을 만족하고, 추이 함수 종속성이 없는 형태입니다."
              },
              {
                "term": "보이스/코드 정규형 (BCNF)",
                "definition": "제3 정규형보다 엄격하며, 모든 결정자가 후보 키인 형태입니다."
              },
              {
                "term": "제4 정규형 (4NF)",
                "definition": "BCNF를 만족하고, 다치 종속성(Multi-valued Dependency)이 없는 형태입니다."
              }
            ],
            "outline": [
              {
                "text": "데이터베이스 정규화 실전 예시",
                "id": "데이터베이스-정규화-실전-예시",
                "children": [
                  {
                    "text": "초기 데이터 상태",
                    "id": "초기-데이터-상태",
                    "children": null
                  },
                  {
                    "text": "제1 정규형 (1NF) 만족",
                    "id": "제1-정규형-1nf-만족",
                    "children": null
                  },
                  {
                    "text": "제2 정규형 (2NF) 만족",
                    "id": "제2-정규형-2nf-만족",
                    "children": null
                  },
                  {
                    "text": "제3 정규형 (3NF) 만족",
                    "id": "제3-정규형-3nf-만족",
                    "children": null
                  },
                  {
                    "text": "보이스/코드 정규형 (BCNF) 만족",
                    "id": "보이스코드-정규형-bcnf-만족",
                    "children": null
                  },
                  {
                    "text": "제4 정규형 (4NF) 만족",
                    "id": "제4-정규형-4nf-만족",
                    "children": null
                  },
                  {
                    "text": "출처",
                    "id": "출처",
                    "children": null
                  }
                ]
              }
            ]
          },
          "quiz": [
            {
              "question": "제2 정규형(2NF)이 해결하고자 하는 주요 함수 종속성은 무엇입니까?",
              "options": [
                "부분 함수 종속성",
                "추이 함수 종속성",
                "다치 종속성",
                "비기본 키 간의 함수 종속성"
              ],
              "answerIndex": 0,
              "explanation": "제2 정규형은 복합 키의 일부에만 종속되는 부분 함수 종속성을 제거하여 테이블을 분리하는 것을 목표로 합니다."
            },
            {
              "question": "제3 정규형(3NF)을 만족시키기 위해 제거해야 하는 함수 종속성은 무엇입니까?",
              "options": [
                "부분 함수 종속성",
                "추이 함수 종속성",
                "다치 종속성",
                "복합 키 종속성"
              ],
              "answerIndex": 1,
              "explanation": "제3 정규형은 기본 키가 아닌 속성이 다른 기본 키가 아닌 속성을 결정하는 추이 함수 종속성을 제거하는 데 중점을 둡니다."
            },
            {
              "question": "BCNF(보이스/코드 정규형)가 제3 정규형(3NF)보다 더 엄격하게 요구하는 조건은 무엇입입니까?",
              "options": [
                "모든 속성이 원자 값을 가져야 한다.",
                "모든 결정자가 후보 키여야 한다.",
                "테이블에 반복되는 그룹이 없어야 한다.",
                "다치 종속성이 없어야 한다."
              ],
              "answerIndex": 1,
              "explanation": "BCNF는 제3 정규형보다 엄격하며, 릴레이션 내의 모든 결정자(다른 속성을 결정하는 속성)가 반드시 후보 키여야 합니다. 이는 3NF에서 해결하지 못할 수 있는 비기본 키 간의 함수 종속성 문제까지 다룹니다."
            }
          ]
        },
        {
          "title": "데이터베이스 설계 과정 및 비정규화",
          "metadata": "Source: a9d3b848-7887-4676-a9e0-4d590ff0b031_2fb50d70-d3f3-4b96-979d-b8168194a8ba_DB08 - Normalization.pdf, Text length: 2000 chars",
          "documentContent": [
            {
              "type": "heading",
              "content": "전반적인 데이터베이스 설계 과정",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "스키마 R이 주어졌다고 가정해 봅시다. 이 스키마 R은 E-R 다이어그램을 테이블 집합으로 변환하는 과정(정규화)에서 생성되었을 수 있습니다. 또는 관심 있는 모든 속성을 포함하는 단일 릴레이션(유니버설 릴레이션)이었을 수도 있습니다. 정규화는 R을 더 작은 릴레이션으로 분해합니다. 때로는 R이 임시적인 관계 설계의 결과일 수 있으며, 이 경우 우리는 그것을 정규형으로 테스트하거나 변환합니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "E-R 모델과 정규화",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "E-R 다이어그램이 모든 엔티티를 정확하게 식별하며 신중하게 설계되었다면, E-R 다이어그램에서 생성된 테이블은 추가적인 정규화가 필요 없을 것입니다. 그러나 실제(불완전한) 설계에서는 엔티티의 비키 속성에서 해당 엔티티의 다른 속성으로의 함수 종속성이 존재할 수 있습니다. 예를 들어, 'department_name'과 'building' 속성을 가진 'employee' 엔티티에서 'department_name'이 'building'을 함수적으로 종속시킨다면, 이는 좋은 설계였다면 'department'를 별도의 엔티티로 만들었을 것입니다. 관계 집합의 비키 속성에서 발생하는 함수 종속성도 가능하지만 드뭅니다. 대부분의 관계는 이진 관계이기 때문입니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "성능을 위한 비정규화",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "성능을 위해 비정규화된 스키마를 사용하고 싶을 수 있습니다. 예를 들어, 'course_id' 및 'title'과 함께 선수 과목을 표시하려면 'course' 테이블과 'prereq' 테이블의 조인이 필요합니다. 대안 1은 'course'와 'prereq'의 모든 속성을 포함하는 비정규화된 릴레이션을 사용하는 것입니다. 이는 더 빠른 조회를 가능하게 하지만, 추가적인 공간과 업데이트를 위한 추가 실행 시간, 그리고 프로그래머의 추가적인 코딩 작업과 코드 오류 가능성을 수반합니다. 대안 2는 'course'와 'prereq'의 조인으로 정의된 물리적 뷰(materialized view)를 사용하는 것입니다. 이는 위와 동일한 이점과 단점을 가지지만, 프로그래머의 추가 코딩 작업이 필요 없고 잠재적인 오류를 방지할 수 있습니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "남아있는 문제",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "데이터베이스 설계의 일부 측면은 정규화로 포착되지 않습니다. 예를 들어 (피해야 할 경우): 'earnings_2004, earnings_2005, earnings_2006' 등 모든 속성이 '(company_id, earnings)' 스키마에 있는 경우입니다. 위 예시는 BCNF(보이스-코드 정규형)에서 잘 정규화되어 있지만, 연도별 쿼리를 어렵게 만들고 매년 새 테이블이 필요합니다. 또 다른 예시로 'company_year (company_id, earnings_2004, earnings_2005, earnings_2006)' 스키마도 BCNF에서 잘 정규화되어 있지만, 연도별 쿼리를 어렵게 만들고 매년 새 속성이 필요합니다. 이는 한 속성의 값이 열 이름이 되는 교차 테이블(crosstab)의 예시입니다. 더 나은 스키마는 'earnings (company_id, year, amount)'입니다.",
              "level": null
            }
          ],
          "aiNotes": {
            "summary": "본 텍스트는 전반적인 데이터베이스 설계 과정을 다루며, E-R 모델링과 정규화의 관계를 설명합니다. 잘 설계된 E-R 다이어그램은 추가 정규화가 필요 없지만, 실제 설계에서는 비키 속성 간의 함수 종속성으로 인해 정규화가 필요할 수 있음을 지적합니다. 또한, 성능 향상을 위한 비정규화 전략과 그 대안(비정규화된 릴레이션, 물리적 뷰)을 제시하며, 정규화만으로는 해결하기 어려운 교차 테이블과 같은 설계 문제와 그에 대한 더 나은 스키마 방안을 논의합니다.",
            "keyConcepts": [
              {
                "term": "데이터베이스 설계 과정",
                "definition": {
                  "easy": "데이터베이스를 만들고 정리하는 단계들입니다.",
                  "medium": "요구사항을 분석하고, 개념적/논리적/물리적 모델링을 통해 데이터베이스 스키마를 정의하며, 이를 구현하고 유지보수하는 일련의 과정입니다.",
                  "hard": "데이터 모델링 기법(E-R 모델, 관계형 모델 등)과 정규화 원칙을 적용하여 데이터 무결성, 일관성, 효율성을 보장하는 데이터베이스 구조를 수립하는 체계적인 절차입니다."
                }
              },
              {
                "term": "정규화",
                "definition": {
                  "easy": "데이터를 중복 없이 잘 정리해서 문제가 생기지 않게 하는 과정입니다.",
                  "medium": "관계형 데이터베이스에서 데이터 중복을 줄이고 이상 현상(삽입, 삭제, 갱신 이상)을 방지하며 데이터 무결성을 확보하기 위해 테이블을 분해하는 과정입니다.",
                  "hard": "함수 종속성을 기반으로 릴레이션 스키마를 여러 개의 작은 릴레이션으로 분해하여 데이터 종속성 위반을 제거하고, 데이터 중복 및 갱신 이상을 최소화하여 데이터 모델의 일관성과 효율성을 높이는 구조화 기법입니다."
                }
              },
              {
                "term": "비정규화",
                "definition": {
                  "easy": "데이터베이스를 빠르게 만들려고 일부러 데이터를 겹치게 하는 것입니다.",
                  "medium": "정규화된 데이터베이스에서 성능 향상을 위해 의도적으로 중복을 허용하거나 테이블을 통합하는 과정입니다.",
                  "hard": "데이터 검색 성능을 최적화하기 위해 정규화 원칙을 일부 희생하고, 조인 연산의 오버헤드를 줄이기 위해 중복 데이터를 허용하거나 테이블을 결합하는 등의 방식으로 데이터 모델을 변형하는 과정입니다."
                }
              },
              {
                "term": "E-R 모델",
                "definition": {
                  "easy": "데이터베이스에 들어갈 정보들을 그림으로 보여주는 방법입니다.",
                  "medium": "엔티티(개체)와 이들 간의 관계를 사용하여 데이터베이스의 개념적 구조를 시각적으로 표현하는 모델링 기법입니다.",
                  "hard": "데이터베이스 시스템의 개념적 설계를 위한 상위 수준 데이터 모델로, 개체(Entity), 속성(Attribute), 관계(Relationship)의 세 가지 기본 요소를 사용하여 현실 세계의 정보를 추상화하고 도식화하는 방법론입니다."
                }
              },
              {
                "term": "함수 종속성",
                "definition": {
                  "easy": "어떤 데이터가 다른 데이터를 결정하는 관계입니다.",
                  "medium": "릴레이션 R에서 속성 집합 X의 값이 속성 집합 Y의 값을 유일하게 결정할 때, Y는 X에 함수적으로 종속된다고 하며 X → Y로 표기합니다.",
                  "hard": "관계형 스키마 R에서, 모든 튜플에 대해 X의 두 튜플이 동일한 값을 가지면 Y의 두 튜플도 동일한 값을 갖는 경우, Y는 X에 함수적으로 종속된다고 정의하며, 이는 정규화 과정의 핵심 원리입니다."
                }
              }
            ],
            "importantTerms": [
              {
                "term": "스키마",
                "definition": "데이터베이스의 구조와 제약 조건에 대한 정의입니다."
              },
              {
                "term": "유니버설 릴레이션",
                "definition": "관심 있는 모든 속성을 포함하는 단일 릴레이션입니다."
              },
              {
                "term": "BCNF (Boyce-Codd Normal Form)",
                "definition": "보이스-코드 정규형. 3차 정규형보다 엄격한 정규형으로, 모든 비자명 함수 종속성에서 결정자가 후보 키인 상태를 의미합니다."
              },
              {
                "term": "물리적 뷰 (Materialized View)",
                "definition": "미리 계산되어 데이터베이스에 저장된 뷰로, 쿼리 성능 향상에 사용됩니다."
              },
              {
                "term": "교차 테이블 (Crosstab)",
                "definition": "특정 속성의 값들이 테이블의 열 이름으로 사용되는 형태의 테이블입니다."
              }
            ],
            "outline": [
              {
                "text": "전반적인 데이터베이스 설계 과정",
                "id": "전반적인-데이터베이스-설계-과정",
                "children": null
              },
              {
                "text": "E-R 모델과 정규화",
                "id": "e-r-모델과-정규화",
                "children": null
              },
              {
                "text": "성능을 위한 비정규화",
                "id": "성능을-위한-비정규화",
                "children": null
              },
              {
                "text": "남아있는 문제",
                "id": "남아있는-문제",
                "children": null
              }
            ]
          },
          "quiz": [
            {
              "question": "다음 중 데이터베이스 정규화의 주된 목적은 무엇입니까?",
              "options": [
                "데이터 중복을 줄이고 이상 현상을 방지합니다.",
                "데이터베이스 쿼리 성능을 향상시킵니다.",
                "데이터베이스 보안을 강화합니다.",
                "사용자 인터페이스의 복잡성을 줄입니다."
              ],
              "answerIndex": 0,
              "explanation": "정규화의 주된 목적은 데이터 중복을 제거하고 삽입, 삭제, 갱신과 같은 이상 현상을 방지하여 데이터 무결성을 확보하는 것입니다."
            },
            {
              "question": "데이터베이스 성능 향상을 위해 의도적으로 중복을 허용하거나 테이블을 통합하는 과정을 무엇이라고 합니까?",
              "options": [
                "정규화",
                "비정규화",
                "인덱싱",
                "조인"
              ],
              "answerIndex": 1,
              "explanation": "비정규화는 정규화된 데이터베이스에서 쿼리 성능 향상을 위해 의도적으로 데이터 중복을 허용하거나 테이블을 통합하는 과정입니다."
            },
            {
              "question": "제시된 텍스트에서 정규화만으로는 해결하기 어려운 데이터베이스 설계 문제의 예시로 언급된 것은 무엇입니까?",
              "options": [
                "키 속성(Key Attribute)의 누락",
                "릴레이션 간의 잘못된 관계 설정",
                "연도별 수익 데이터를 열(Column)로 표현하는 교차 테이블(Crosstab) 구조",
                "외래 키(Foreign Key) 제약 조건의 위반"
              ],
              "answerIndex": 2,
              "explanation": "텍스트에서는 'earnings_2004, earnings_2005, earnings_2006'과 같이 연도별 수익 데이터를 열로 표현하는 교차 테이블 구조가 정규화되어 있지만, 연도별 쿼리를 어렵게 만드는 문제로 언급되었습니다."
            }
          ]
        }
      ],
      "final_result": "'데이터베이스 정규화: 원리, 과정 및 적용' 노트북(ID: 2)에 11개의 챕터가 성공적으로 처리 및 저장되었습니다."
    }
  }
]