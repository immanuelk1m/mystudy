[
  {
    "node": "start_processing",
    "status": "completed",
    "state_snapshot": {
      "run_id": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d",
      "pdf_file_paths": [
        "temp_pdf_uploads/cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_1a4c2f45-b482-4e82-826e-fa8945eb99c7_DB03 - mysql.pdf",
        "temp_pdf_uploads/cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf"
      ],
      "all_pdf_texts": [
        {
          "filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_1a4c2f45-b482-4e82-826e-fa8945eb99c7_DB03 - mysql.pdf",
          "text": "ECE30030/ITP30010 Database SystemsHandshaking with an R-DBMSCharmgil Hongcharmgil@handong.eduSpring, 2025Handong Global University\n1\n\nAgenda•Introduction to MySQL•SQL preview\nECE30030/ITP30010 Database Systems2\nMySQL•MySQL is an SQL-based relational database management system (DBMS)•Free and open-source R-DBMS (under GPL)•Owned by Oracle•Commercial version of MySQL is also provided (including technical support)•“My” came from the name of co-founder Michael Widenius’ daughter•C.f., MariaDB•Compatible with standard SQL•Frequently used for commercial web services\nECE30030/ITP30010 Database Systems3\n* Image src: https://en.wikipedia.org/wiki/MySQL\nMySQL•Companies using MySQL (a study by Enlyft)•“We have data on 199,498 (out of 1,409,176) companies that use MySQL”•Often used by companies with 10-50 employees and 1M-10M dollars in revenue•C.f., Oracle 12 is most often used by companies with 50-200 employees and >1000M dollars in revenue\nECE30030/ITP30010 Database Systems4* Source: https://enlyft.com/tech/products/mysql \n\nMySQL•Companies using MySQL (full list: https://www.mysql.com/customers/)\nECE30030/ITP30010 Database Systems5\n* Source: https://stackshare.io/mysql \nMySQL•Why MySQL?•Popular•Active discussions all over the Internet•Versatile: runs on Linux, Windows, Mac OS X, Solaris, FreeBSD, …•Supports wide range of programming languages (C/C++, Java, Python, .Net, …)•Cost starts from zero•High performance (fast and reliable)\nECE30030/ITP30010 Database Systems6* Image src: https://db-engines.com/en/ranking\n\nDBMS Trend Popularity\n•Score definition: https://db-engines.com/en/ranking_definition\nECE30030/ITP30010 Database Systems7* Image src: https://db-engines.com/en/ranking_trend \n\nMySQL•Why MySQL?•Popular•Active discussions all over the Internet•Versatile: runs on Linux, Windows, Mac OS X, Solaris, FreeBSD, …•Supports wide range of programming languages (C/C++, Java, Python, .Net, …)•Cost starts from zero•High performance (fast and reliable)\nECE30030/ITP30010 Database Systems8* Image src: https://dev.mysql.com/downloads/\n\nMySQL\nECE30030/ITP30010 Database Systems9\n•Massive•Convenient•Multi-user•Safe•Efficient•Reliable\nCan handle terabytes of dataSupports high-level query languageSupports concurrent data accessSupports transactionsCan handle thousands of queries/second99.99% up-time in many real-world products\nMySQL Versions•MySQL 5.x vs 8.x\nECE30030/ITP30010 Database Systems10\nVersion 5.x-Most popular version of MySQL-More stable and conventionalVersion 8.x-Current version-Provides up-to-date DB functionalities (better storage engine, faster, more secure)\n* Source: https://www.eversql.com/mysql-8-adoption-usage-rate/#:~:text=MySQL%205.7%20is%20still%20the,17%25%20are%20using%20MySQL%208. \nMySQL Versions•MySQL 5.x vs 8.x\nECE30030/ITP30010 Database Systems11\nVersion 5.x-Most popular version of MySQL-More stable and conventionalVersion 8.x-Current version-Provides up-to-date DB functionalities (better storage engine, faster, more secure)\n* Source: https://severalnines.com/database-blog/mysql-performance-benchmarking-mysql-57-vs-mysql-80 \n\nMySQL Versions•MySQL 5.x vs 8.x\nECE30030/ITP30010 Database Systems12\nVersion 5.x-Most popular version of MySQL-More stable and conventionalVersion 8.x-Current version-Provides up-to-date DB functionalities (better storage engine, faster, more secure)\n* Source: https://severalnines.com/database-blog/mysql-performance-benchmarking-mysql-57-vs-mysql-80 \n\nWhere to Get MySQL?•https://dev.mysql.com/downloads/•Look for the “Community” versions – the branch that is available for free•”Enterprise” versions are the commercial ones•We have prepared a Docker image for the course•Consists of Ubuntu Server, MySQL, example databases for course activities\nECE30030/ITP30010 Database Systems13* Image src: https://www.docker.com \n\nWhere to Get MySQL?\nECE30030/ITP30010 Database Systems14\n* Image source: https://baumannalexj.medium.com/connect-your-db-tool-to-a-dockerized-mysql-server-container-bc18853524ed   https://www.jetbrains.com/datagrip/features/look_and_feel.html\n\nAgenda•Introduction to MySQL•SQL preview\nECE30030/ITP30010 Database Systems15\nStructured Query Language (SQL)•SQL: Structured Query Language•The principal language used to describe and manipulate relational databases•Very high-level•Say “what to do” rather than “how to do it”•SQL is not specifying data-manipulation details•DBMSs figure out the “best” way to execute queries•Called “query optimization”•Two aspects to SQL•Data definition: for declaring database schemas (DDL)•Data manipulation: for querying (asking questions about) databases and for modifying the database (DML)\nECE30030/ITP30010 Database Systems16\nSQL Parts•DML – provides the ability to query information from the database and to insert tuples into, delete tuples from, and modify tuples in the database•Integrity – the DDL includes commands for specifying integrity constraints•Vide definition – the DDL includes commands for defining views•Transaction control – includes commands for specifying the beginning and ending of transactions•Embedded SQL and dynamic SQL – define how SQL statements can be embedded within general-purpose programming language•Authorization – includes commands for specifying access rights to relations and viewsECE30030/ITP30010 Database Systems17\nA Brief History•IBM SEQUEL (Structured English Query Language) was developed as a part of the System R project (Chamberlin and Boyce, early 1970s)•Later on, SEQUEL was renamed SQL (structured query language)•System R à System/38 (1979), SQL/DS (1981), DB2 (1983)•Relational Software, Inc released the first commercial implementation of SQL, Oracle V2 for VAX computers•Relational Software, Inc is now Oracle Corporation•ANSI and ISO standardized SQL:•SQL-86,  SQL-89,  SQL-92,  SQL:1999,  …,  SQL:2011,  SQL:2016 (current)•SQL-92 is supported by the most of database systems\nECE30030/ITP30010 Database Systems18\nBasic Query Structure•A typical SQL query has the form:   SELECT A1, A2, ..., An FROM r1, r2, ..., rm WHERE P•Ai represents an attribute•Ri represents a relation•P is a predicate\n•The result of an SQL query is a relation\nECE30030/ITP30010 Database Systems19\nEOF•Coming next:•Structured Query Language\nECE30030/ITP30010 Database Systems20"
        },
        {
          "filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf",
          "text": "ECE30030/ITP30010 Database SystemsStructured Query LanguageReading: Chapter 3\nCharmgil Hongcharmgil@handong.eduSpring, 2025Handong Global University\n1\n\nAgenda•Structured query language (SQL)•SQL data manipulation language (DML)•SELECT, FROM, WHERE•NULL values•Set operations•String operations, ordering•Aggregate functions, aggregation•SQL data definition language (DDL)   --   NEXT CLASS\nECE30030/ITP30010 Database Systems2\nStructured Query Language (SQL)•SQL: Structured Query Language•The principal language used to describe and manipulate relational databases•Very high-level•Say “what to do” rather than “how to do it”•SQL is not specifying data-manipulation details•DBMSs figure out the “best” way to execute queries•Called “query optimization”•Two aspects to SQL•Data definition: for declaring database schemas (DDL)•Data manipulation: for querying (asking questions about) databases and for modifying the database (DML)\nECE30030/ITP30010 Database Systems3\nSQL Parts•DML – provides the ability to query information from the database and to insert tuples into, delete tuples from, and modify tuples in the database•Integrity – the DDL includes commands for specifying integrity constraints•View definition – the DDL includes commands for defining views•Transaction control – includes commands for specifying the beginning and ending of transactions•Embedded SQL and dynamic SQL – define how SQL statements can be embedded within general-purpose programming language•Authorization – includes commands for specifying access rights to relations and viewsECE30030/ITP30010 Database Systems4\nA Brief History•IBM SEQUEL (Structured English Query Language) was developed as a part of the System R project (Chamberlin and Boyce, early 1970s)•Later on, SEQUEL was renamed SQL (structured query language)•System R à System/38 (1979), SQL/DS (1981), DB2 (1983)•Relational Software, Inc released the first commercial implementation of SQL, Oracle V2 for VAX computers•Relational Software, Inc is now Oracle Corporation•ANSI and ISO standardized SQL:•SQL-86,  SQL-89,  SQL-92,  SQL:1999,  …,  SQL:2011,  SQL:2016 (current)•SQL-92 is supported by the most of database systems\nECE30030/ITP30010 Database Systems5\nBasic Query Structure•A typical SQL query has the form:   SELECT A1, A2, ..., An FROM r1, r2, ..., rm WHERE P•Ai represents an attribute•Ri represents a relation•P is a predicate\n•The result of an SQL query is a relation\nECE30030/ITP30010 Database Systems6\nAgenda•Structured query language (SQL)•SQL data manipulation language (DML)•SELECT, FROM, WHERE•NULL values•Set operations•String operations, ordering•Aggregate functions, aggregation•SQL data definition language (DDL)\nECE30030/ITP30010 Database Systems7\nSQL Data Manipulation Language•The SQL data-manipulation language (DML) allows querying (ask questions about) and modifying the databases\nECE30030/ITP30010 Database Systems8\nRunning Examples•Relations (tables): instructor, teaches\nECE30030/ITP30010 Database Systems9\nInstructor relationteaches relation\nBasic Query Structure•A typical SQL query has the form:   SELECT A1, A2, ..., An FROM r1, r2, ..., rm WHERE P•Ai represents an attribute•Ri represents a relation•P is a predicate\n•The result of an SQL query is a relation\nECE30030/ITP30010 Database Systems10\nThe SELECT Clause•The SELECT clause lists the attributes desired in the result of a query•Corresponds to the projection operation of the relational algebra\n•Example: Find the names of all instructors•SQL: SELECT name FROM instructor;\nECE30030/ITP30010 Database Systems11\n\nNote•Note: SQL names are case insensitive•E.g., Name ≡ NAME ≡ name•SQL commands (SELECT, FROM, WHERE, …) are written in upper case (just a convention)•MySQL has an option flag, lower_case_table_names•Link: https://dev.mysql.com/doc/refman/8.0/en/identifier-case-sensitivity.html \nECE30030/ITP30010 Database Systems12\nThe SELECT Clause•SQL allows duplicates in relations as well as in query results•The keyword ALL specifies that duplicates should not be removed SELECT ALL dept_name FROM instructor\nECE30030/ITP30010 Database Systems13\n\nThe SELECT Clause•SQL allows duplicates in relations as well as in query results•The keyword ALL specifies that duplicates should not be removed SELECT ALL dept_name FROM instructor•To force the elimination of duplicates, insert the keyword DISTINCT after SELECT•Find the department names of all instructor, removing duplicates: SELECT DISTINCT dept_name FROM instructor;\nECE30030/ITP30010 Database Systems14\n\nThe SELECT Clause•An asterisk in the select clause denotes “all attributes” SELECT * FROM instructor;•An attribute can be a literal with no FROM clause SELECT ‘437’;•Result is a table with one column and a single row with value “437”•Can give the column a name using AS: SELECT ‘437’ AS FOO\nECE30030/ITP30010 Database Systems15\n\nThe SELECT Clause•An attribute can be a literal with FROM clause SELECT 'A' FROM instructor•Result is a table with one column and N rows (number of tuples in the instructor table), each row with value “A”\nECE30030/ITP30010 Database Systems16\n\nThe SELECT Clause•The SELECT clause can contain arithmetic expressions involving the operation, +, –, *, and /, and operating on constants or attributes of tuples•The query:     SELECT ID, name, salary/12      FROM instructorwould return a relation that is the same as the instructor relation,except that the value of the attribute salary is divided by 12\n17\n\nThe SELECT Clause•The SELECT clause can contain arithmetic expressions involving the operation, +, –, *, and /, and operating on constants or attributes of tuples•Can rename “salary/12” using the AS clause:  SELECT ID, name, salary/12 AS monthly_salary   FROM instructor\n18\n\nThe WHERE Clause•The WHERE clause specifies conditions that the result must satisfy•Corresponds to the selection predicate of the relational algebra•E.g., To find all instructors in Comp. Sci. dept: SELECT name FROM instructor  WHERE dept_name = 'Comp. Sci.';\nECE30030/ITP30010 Database Systems19\n\nThe WHERE Clause•SQL allows the use of the logical connectives AND, OR, and NOT•The operands of the logical connectives can be expressions involving the comparison operators <, <=, >, >=, =, and <>•<> means not equal (there is no != in SQL)•Comparisons can be applied to results of arithmetic expressions•E.g., To find all instructors in Comp. Sci. with salary > 70,000: SELECT name FROM instructor WHERE dept_name = 'Comp. Sci.' AND salary > 70000;\nECE30030/ITP30010 Database Systems20\n\nThe WHERE Clause•SQL includes a BETWEEN comparison operator•Example: Find the names of all instructors with salary between $90,000 and $100,000 (that is, ³ $90,000 and £ $100,000)•SELECT nameFROM instructorWHERE salary BETWEEN 90000 AND 100000\nECE30030/ITP30010 Database Systems21\n\nThe WHERE Clause•Tuple comparison: makes comparisons per tuple•SELECT name, course_idFROM instructor, teachesWHERE (instructor.ID, dept_name) = (teaches.ID, 'Biology');\nECE30030/ITP30010 Database Systems22\n\nThe FROM Clause•The FROM clause lists the relations involved in the query•Corresponds to the Cartesian-product operation of the relational algebra•Find the Cartesian-product instructor × teaches SELECT * FROM instructor, teaches;•Generates every possible instructor-teaches pairs, with all attributes from both relations•For common attributes (e.g., ID), the attributes in the resulting table are renamed using the relation name (e.g., instructor.ID)\nECE30030/ITP30010 Database Systems23\nThe FROM Clause•Find the Cartesian-product instructor X teaches SELECT * FROM instructor, teaches;\n24\ninstructor.IDnamedept_namesalaryteaches.IDcourse_idsec_idsemesteryear10101SrinivasanComp. Sci.6500076766BIO-101 1Summer201712121WuFinance9000076766BIO-101 1Summer201715151MozartMusic4000076766BIO-101 1Summer201722222EinsteinPhysics9500076766BIO-101 1Summer201732343El SaidHistory6000076766BIO-101 1Summer2017… … … … … … … … …10101SrinivasanComp. Sci.6500010101CS-101 1Fall 201712121WuFinance9000010101CS-101 1Fall 201715151MozartMusic4000010101CS-101 1Fall 201722222EinsteinPhysics9500010101CS-101 1Fall 201732343El SaidHistory6000010101CS-101 1Fall 2017… … … … … … … … …… … … … … … … … …10101SrinivasanComp. Sci.6500083821CS-190 2Spring201712121WuFinance9000083821CS-190 2Spring201715151MozartMusic4000083821CS-190 2Spring2017… … … … … … … … …10101SrinivasanComp. Sci.6500010101CS-315 1Spring201812121WuFinance9000010101CS-315 1Spring201815151MozartMusic4000010101CS-315 1Spring2018… … … … … … … … …… … … … … … … … …\nImplementing JOIN•Cartesian-product is not very useful directly; but useful combined with WHERE-clause condition (selection operation in relational algebra)•Cartesian-product + selection = join•E.g., Find the names of all instructors who have taught some course and the course_id SELECT name, course_id FROM instructor , teaches WHERE instructor.ID = teaches.ID\nECE30030/ITP30010 Database Systems25\n\nImplementing JOIN•Cartesian-product is not very useful directly; but useful combined with WHERE-clause condition (selection operation in relational algebra)•Cartesian-product + selection = join•Find the names of all instructors in the Music department who have taught some course and the course_id SELECT name, course_id FROM instructor , teaches WHERE instructor.ID = teaches.ID  AND instructor. dept_name = 'Music'\nECE30030/ITP30010 Database Systems26\n\nThe Rename Operation•The SQL allows renaming relations and attributes using the AS clause:   old-name AS new-name•Find the names of all instructors who have a higher salary than some instructor in ‘Comp. Sci.’•SELECT DISTINCT T.nameFROM instructor AS T, instructor AS SWHERE T.salary > S.salary AND S.dept_name = 'Comp. Sci.'\nECE30030/ITP30010 Database Systems27\n\nThe Rename Operation•The SQL allows renaming relations and attributes using the AS clause:   old-name AS new-name•Find the names of all instructors who have a higher salary than some instructor in ‘Comp. Sci.’•SELECT DISTINCT T.nameFROM instructor AS T, instructor AS SWHERE T.salary > S.salary AND S.dept_name = 'Comp. Sci.'•Keyword AS is optional and may be omitted  instructor AS T  ≡  instructor T\nECE30030/ITP30010 Database Systems28\nAgenda•Structured query language (SQL)•SQL data manipulation language (DML)•SELECT, FROM, WHERE•NULL values•Set operations•String operations, ordering•Aggregate functions, aggregation•SQL data definition language (DDL)\nECE30030/ITP30010 Database Systems29\nNULL Values•It is possible for tuples to have a NULL value for some of their attributes•NULL signifies an unknown value or that a value does not exist•The result of any arithmetic expression involving NULL is NULL•E.g.,  5 + NULL returns NULL\nECE30030/ITP30010 Database Systems30\nIS NULL / IS NOT NULL•The predicate IS NULL can be used to check for NULL values•E.g., Find all instructors whose salary is null SELECT name FROM instructor WHERE salary IS NULL•The predicate IS NOT NULL succeeds if the value on which it is applied is not null\nECE30030/ITP30010 Database Systems31\nAgenda•Structured query language (SQL)•SQL data manipulation language (DML)•SELECT, FROM, WHERE•NULL values•Set operations•String operations, ordering•Aggregate functions, aggregation•SQL data definition language (DDL)\nECE30030/ITP30010 Database Systems32\nSet Operations•Set operations UNION, INTERSECT, and EXCEPT•Each of the above operations automatically eliminates duplicates•To retain all duplicates, use ALL:•UNION ALL•INTERSECT ALL•EXCEPT ALL\n•C.f., SELECT retains all duplicates by default\nECE30030/ITP30010 Database Systems33\nSet Operations: UNION•Find courses that ran in Fall 2017 or in Spring 2018•(SELECT course_id  FROM teaches WHERE semester = 'Fall' AND year = 2017)UNION(SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018)\nECE30030/ITP30010 Database Systems34\n\nSet Operations: INTERSECT•Find courses that ran in Fall 2017 and in Spring 2018•(SELECT course_id  FROM teaches WHERE semester = 'Fall' AND year = 2017)INTERSECT(SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018)•C.f., MySQL does NOT support INTERSECT•One can emulate INTERSECT using JOIN (we’ll study JOIN later)•SELECT LT.course_idFROM (SELECT course_id FROM teaches WHERE semester = 'Fall' AND year = 2017) AS LTJOIN (SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018) AS RTON LT.course_id=RT.course_id;\nECE30030/ITP30010 Database Systems35\n\nSet Operations: EXCEPT•Find courses that ran in Fall 2017 but not in Spring 2018•(SELECT course_id  FROM teaches WHERE semester = 'Fall' AND year = 2017)EXCEPT(SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018)•C.f., MySQL does NOT support EXCEPT•One can emulate EXCEPT using NOT IN•SELECT course_id FROM teaches WHERE semester = 'Fall' AND year = 2017AND course_id NOT IN(SELECT course_id  FROM teaches  WHERE semester = 'Spring' AND year = 2018);\nECE30030/ITP30010 Database Systems36\n\nAgenda•Structured query language (SQL)•SQL data manipulation language (DML)•SELECT, FROM, WHERE•NULL values•Set operations•String operations, ordering•Aggregate functions, aggregation•SQL data definition language (DDL)\nECE30030/ITP30010 Database Systems37\nString Operations•SQL includes a string-matching operator for comparisons on character strings•The operator LIKE uses patterns that are described using two special characters:•percent (%) – The % character matches any substring•underscore (_) – The _ character matches any character•Find the names of all instructors whose name includes the substring “ri” SELECT name FROM instructor WHERE name LIKE ‘%ri%'\nECE30030/ITP30010 Database Systems38\n\nString Operations•Escape character: Use backslash (\\) as the escape character•E.g., Match the string “100%” LIKE '100 \\%’ ESCAPE  ‘\\’\nECE30030/ITP30010 Database Systems39\nString Operations•Patterns are case sensitive•Pattern matching examples:•'Intro%' matches any string beginning with “Intro”•'%Comp%' matches any string containing “Comp” as a substring•'_ _ _' matches any string of exactly three characters•'_ _ _ %' matches any string of at least three characters•SQL supports a variety of string operations such as•concatenation (using “||”)•converting from upper to lower case (and vice versa)•finding string length, extracting substrings, etc.\nECE30030/ITP30010 Database Systems40\nOrdering the Display of Tuples•List in alphabetic order the names of all instructors•SELECT DISTINCT nameFROM instructorORDER BY name\nECE30030/ITP30010 Database Systems41\n\nOrdering the Display of Tuples•Can sort on multiple attributes•E.g., SELECT dept_name, name     FROM instructor      ORDER BY dept_name, name\nECE30030/ITP30010 Database Systems42\n\nOrdering the Display of Tuples•We may specify DESC for descending order or ASC for ascending order, for each attribute; ascending order is the default•E.g., ORDER BY name DESC\nECE30030/ITP30010 Database Systems43\n\nAgenda•Structured query language (SQL)•SQL data manipulation language (DML)•SELECT, FROM, WHERE•NULL values•Set operations•String operations, ordering•Aggregate functions, aggregation•SQL data definition language (DDL)\nECE30030/ITP30010 Database Systems44\nAggregate Functions•These functions operate on the multiset of values of a column of a relation, and return a value•AVG:  average value•MIN:  minimum value•MAX:  maximum value•SUM:  sum of values•COUNT:  number of values\nECE30030/ITP30010 Database Systems45\nAggregate Functions Examples•Find the average salary of instructors in the Computer Science department•SELECT AVG(salary)FROM instructorWHERE dept_name= 'Comp. Sci.';•Find the total number of instructors who teach a course in the Spring 2018 semester•SELECT COUNT(DISTINCT ID)FROM teachesWHERE semester = 'Spring’ AND year = 2018;•Find the number of tuples in the teaches relation•SELECT COUNT (*)FROM teaches;\nECE30030/ITP30010 Database Systems46\n\nAggregate Functions: Group By•Find the average salary of instructors in each department•SELECT dept_name, AVG(salary) AS avg_salaryFROM instructorGROUP BY dept_name;\nECE30030/ITP30010 Database Systems47\n\nAggregation•Attributes in SELECT clause outside of aggregate functions must appear in GROUP BY list•/* erroneous query */SELECT dept_name, ID, AVG(salary)FROM instructorGROUP BY dept_name;\nECE30030/ITP30010 Database Systems48\n\nAggregate Functions – Having Clause•Find the names and average salaries of all departments whose average salary is greater than 65000•SELECT dept_name, AVG(salary) AS avg_salaryFROM instructorGROUP BY dept_nameHAVING AVG(salary) > 65000;\nECE30030/ITP30010 Database Systems49\n\nAggregate Functions – Having Clause•Note: predicates in the HAVING clause are applied after the formation of groups whereas predicates in the WHERE clause are applied before forming groups\nECE30030/ITP30010 Database Systems50\nSELECT dept_name, AVG(salary) AS avg_salaryFROM instructorGROUP BY dept_nameHAVING AVG(salary) > 65000;\nSELECT dept_name, AVG(salary) AS avg_salaryFROM instructorWHERE salary > 65000GROUP BY dept_name;\n\nSQL Commands\nSQLDMLSELECTINSERTUPDATEDELETE\nDDLCREATEALTERDROP\nECE30030/ITP30010 Database Systems51\nINSERT•Basic syntax•Insert data into every column:•INSERT INTO tablenameVALUES (col1_value, col2_value, …)•Must list values in the same order as in the table schema•If some data values are unknown, must type NULL •For character sequences, use quotation marks•Single quotation marks are preferred (but double quotation marks are allowed)•Value in quotations is case-sensitive•Insert data into selected columns•INSERT INTO tablename (col1_name, col3_name, col4_name, …)VALUES (col1_value, col3_value, col4_value, …)\nECE30030/ITP30010 Database Systems52\nINSERT•Add a new tuple to course•INSERT INTO courseVALUES ('CS-437', 'Database Systems', 'Comp. Sci.', 4);•or equivalently•INSERT INTO course (course_id, title, dept_name, credits)VALUES ('CS-437', 'Database Systems', 'Comp. Sci.', 4);•Add a new tuple to student  with tot_creds set to null•INSERT INTO studentVALUES ('3003', 'Green', 'Finance', null);\nECE30030/ITP30010 Database Systems53\nINSERT•A foreign key specifies that an attribute from one relation has to map to a tuple in another relation•Value in one relation must appear in another relation\nECE30030/ITP30010 Database Systems54\nRelation: instructor\nRelation: department\nINSERT•A foreign key specifies that an attribute from one relation has to map to a tuple in another relation•Value in one relation must appear in another relation•Make sure all foreign keys that new row references have already been added to database•One cannot insert a foreign key value unless the corresponding value exists in the referenced relation\nECE30030/ITP30010 Database Systems55\nINSERT•Inserting results of other SELECT query•Make each student in the Music department who has earned more than 144 credit hours an instructor in the Music department with a salary of  $18,000•INSERT INTO instructor  SELECT ID, name, dept_name, 18000  FROM student   WHERE dept_name = 'Music’ AND total_cred > 144;•The SELECT FROM WHERE statement is evaluated fully before any of its results are inserted into the relation•Otherwise queries like  INSERT INTO table1 SELECT * FROM table1would cause problem\nECE30030/ITP30010 Database Systems56\nUPDATE•Basic syntax•Updating a table•UPDATE tablenameSET col1_name = new_col1_value, col2_name = new_col2_value, …;•Updating a table with conditions•UPDATE tablenameSET col1_name = new_col1_value, col2_name = new_col2_value, …WHERE predicate;\nECE30030/ITP30010 Database Systems57\nUPDATE•Give a 5% salary raise to all instructors•UPDATE instructorSET salary = salary * 1.05•Give a 5% salary raise to those instructors who earn less than 70000•UPDATE instructorSET salary = salary * 1.05WHERE salary < 70000;•Give a 5% salary raise to instructors whose salary is less than average•UPDATE instructorSET salary = salary * 1.05WHERE salary <  (SELECT AVG(salary) FROM instructor);\nECE30030/ITP30010 Database Systems58\nUPDATE•Increase salaries of instructors whose salary is over $100,000 by 3%, and all others by a 5%•Write two UPDATE statements:  UPDATE instructor  SET salary = salary * 1.03  WHERE salary > 100000;  UPDATE instructor  SET salary = salary * 1.05  WHERE salary <= 100000;•The order is important•Can be done better using the case statement (next slide)\nECE30030/ITP30010 Database Systems59\nCASE Statement for Conditional Update•The following query is equivalent to the previous UPDATE queries•UPDATE instructorSET salary = CASE                           WHEN salary <= 100000 THEN salary * 1.05                           ELSE salary * 1.03                       END\nECE30030/ITP30010 Database Systems60\nUPDATE with Scalar Subqueries•Recompute and update tot_creds value for all students•UPDATE student SSET tot_cred = (SELECT SUM(credits)                             FROM takes, course                             WHERE takes.course_id = course.course_id  AND                                            S.ID= takes.ID  AND                                            takes.grade <> 'F' AND                                            takes.grade IS NOT NULL);\nECE30030/ITP30010 Database Systems61\nDELETE•Basic syntax•To remove specific rows•DELETE FROM tablenameWHERE predicate;•To remove all rows•DELETE FROM tablename;•This is equivalent to TRUNCATE:TRUNCATE (TABLE) tablename;•One cannot truncate a table with foreign key constraints•Must disable the constraints first (we will cover ALTER when we study SQL DDL):ALTER TABLE tablenameDISABLE CONSTRAINT constraint_name;\nECE30030/ITP30010 Database Systems62\nDELETE•Delete all instructors•DELETE FROM instructor;•Delete all instructors from the Finance department•DELETE FROM instructorWHERE dept_name= 'Finance';•Delete all tuples in the instructor relation for those instructors associated with a department located in the Watson building•DELETE FROM instructorWHERE dept name IN (SELECT dept name        FROM department        WHERE building = 'Watson');\nECE30030/ITP30010 Database Systems63\nDELETE•Delete all instructors whose salary is less than the average salary of instructors•Example:  DELETE FROM instructor                WHERE salary < (SELECT AVG (salary)                  FROM instructor);•Issue:  as we delete tuples from instructor, the average salary changes•Solution used in SQL:1.First, compute AVG(salary) and find all tuples to delete2.Next, delete all tuples found above (without recomputing AVG or retesting the tuples)\nECE30030/ITP30010 Database Systems64\nEOF•Coming next:•More on Structured Query Language\nECE30030/ITP30010 Database Systems65"
        }
      ],
      "notebook_title": "",
      "holistic_chapters": [],
      "generated_content": [],
      "log_entries": [
        {
          "node": "start_processing",
          "status": "completed",
          "state_snapshot": {
            "run_id": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d",
            "pdf_file_paths": [
              "temp_pdf_uploads/cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_1a4c2f45-b482-4e82-826e-fa8945eb99c7_DB03 - mysql.pdf",
              "temp_pdf_uploads/cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf"
            ],
            "notebook_title": "",
            "holistic_chapters": [],
            "generated_content": [],
            "final_result": ""
          }
        }
      ],
      "final_result": ""
    }
  },
  {
    "node": "analyze_overall_structure",
    "status": "completed",
    "state_snapshot": {
      "run_id": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d",
      "pdf_file_paths": [
        "temp_pdf_uploads/cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_1a4c2f45-b482-4e82-826e-fa8945eb99c7_DB03 - mysql.pdf",
        "temp_pdf_uploads/cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf"
      ],
      "all_pdf_texts": [
        {
          "filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_1a4c2f45-b482-4e82-826e-fa8945eb99c7_DB03 - mysql.pdf",
          "text": "ECE30030/ITP30010 Database SystemsHandshaking with an R-DBMSCharmgil Hongcharmgil@handong.eduSpring, 2025Handong Global University\n1\n\nAgenda•Introduction to MySQL•SQL preview\nECE30030/ITP30010 Database Systems2\nMySQL•MySQL is an SQL-based relational database management system (DBMS)•Free and open-source R-DBMS (under GPL)•Owned by Oracle•Commercial version of MySQL is also provided (including technical support)•“My” came from the name of co-founder Michael Widenius’ daughter•C.f., MariaDB•Compatible with standard SQL•Frequently used for commercial web services\nECE30030/ITP30010 Database Systems3\n* Image src: https://en.wikipedia.org/wiki/MySQL\nMySQL•Companies using MySQL (a study by Enlyft)•“We have data on 199,498 (out of 1,409,176) companies that use MySQL”•Often used by companies with 10-50 employees and 1M-10M dollars in revenue•C.f., Oracle 12 is most often used by companies with 50-200 employees and >1000M dollars in revenue\nECE30030/ITP30010 Database Systems4* Source: https://enlyft.com/tech/products/mysql \n\nMySQL•Companies using MySQL (full list: https://www.mysql.com/customers/)\nECE30030/ITP30010 Database Systems5\n* Source: https://stackshare.io/mysql \nMySQL•Why MySQL?•Popular•Active discussions all over the Internet•Versatile: runs on Linux, Windows, Mac OS X, Solaris, FreeBSD, …•Supports wide range of programming languages (C/C++, Java, Python, .Net, …)•Cost starts from zero•High performance (fast and reliable)\nECE30030/ITP30010 Database Systems6* Image src: https://db-engines.com/en/ranking\n\nDBMS Trend Popularity\n•Score definition: https://db-engines.com/en/ranking_definition\nECE30030/ITP30010 Database Systems7* Image src: https://db-engines.com/en/ranking_trend \n\nMySQL•Why MySQL?•Popular•Active discussions all over the Internet•Versatile: runs on Linux, Windows, Mac OS X, Solaris, FreeBSD, …•Supports wide range of programming languages (C/C++, Java, Python, .Net, …)•Cost starts from zero•High performance (fast and reliable)\nECE30030/ITP30010 Database Systems8* Image src: https://dev.mysql.com/downloads/\n\nMySQL\nECE30030/ITP30010 Database Systems9\n•Massive•Convenient•Multi-user•Safe•Efficient•Reliable\nCan handle terabytes of dataSupports high-level query languageSupports concurrent data accessSupports transactionsCan handle thousands of queries/second99.99% up-time in many real-world products\nMySQL Versions•MySQL 5.x vs 8.x\nECE30030/ITP30010 Database Systems10\nVersion 5.x-Most popular version of MySQL-More stable and conventionalVersion 8.x-Current version-Provides up-to-date DB functionalities (better storage engine, faster, more secure)\n* Source: https://www.eversql.com/mysql-8-adoption-usage-rate/#:~:text=MySQL%205.7%20is%20still%20the,17%25%20are%20using%20MySQL%208. \nMySQL Versions•MySQL 5.x vs 8.x\nECE30030/ITP30010 Database Systems11\nVersion 5.x-Most popular version of MySQL-More stable and conventionalVersion 8.x-Current version-Provides up-to-date DB functionalities (better storage engine, faster, more secure)\n* Source: https://severalnines.com/database-blog/mysql-performance-benchmarking-mysql-57-vs-mysql-80 \n\nMySQL Versions•MySQL 5.x vs 8.x\nECE30030/ITP30010 Database Systems12\nVersion 5.x-Most popular version of MySQL-More stable and conventionalVersion 8.x-Current version-Provides up-to-date DB functionalities (better storage engine, faster, more secure)\n* Source: https://severalnines.com/database-blog/mysql-performance-benchmarking-mysql-57-vs-mysql-80 \n\nWhere to Get MySQL?•https://dev.mysql.com/downloads/•Look for the “Community” versions – the branch that is available for free•”Enterprise” versions are the commercial ones•We have prepared a Docker image for the course•Consists of Ubuntu Server, MySQL, example databases for course activities\nECE30030/ITP30010 Database Systems13* Image src: https://www.docker.com \n\nWhere to Get MySQL?\nECE30030/ITP30010 Database Systems14\n* Image source: https://baumannalexj.medium.com/connect-your-db-tool-to-a-dockerized-mysql-server-container-bc18853524ed   https://www.jetbrains.com/datagrip/features/look_and_feel.html\n\nAgenda•Introduction to MySQL•SQL preview\nECE30030/ITP30010 Database Systems15\nStructured Query Language (SQL)•SQL: Structured Query Language•The principal language used to describe and manipulate relational databases•Very high-level•Say “what to do” rather than “how to do it”•SQL is not specifying data-manipulation details•DBMSs figure out the “best” way to execute queries•Called “query optimization”•Two aspects to SQL•Data definition: for declaring database schemas (DDL)•Data manipulation: for querying (asking questions about) databases and for modifying the database (DML)\nECE30030/ITP30010 Database Systems16\nSQL Parts•DML – provides the ability to query information from the database and to insert tuples into, delete tuples from, and modify tuples in the database•Integrity – the DDL includes commands for specifying integrity constraints•Vide definition – the DDL includes commands for defining views•Transaction control – includes commands for specifying the beginning and ending of transactions•Embedded SQL and dynamic SQL – define how SQL statements can be embedded within general-purpose programming language•Authorization – includes commands for specifying access rights to relations and viewsECE30030/ITP30010 Database Systems17\nA Brief History•IBM SEQUEL (Structured English Query Language) was developed as a part of the System R project (Chamberlin and Boyce, early 1970s)•Later on, SEQUEL was renamed SQL (structured query language)•System R à System/38 (1979), SQL/DS (1981), DB2 (1983)•Relational Software, Inc released the first commercial implementation of SQL, Oracle V2 for VAX computers•Relational Software, Inc is now Oracle Corporation•ANSI and ISO standardized SQL:•SQL-86,  SQL-89,  SQL-92,  SQL:1999,  …,  SQL:2011,  SQL:2016 (current)•SQL-92 is supported by the most of database systems\nECE30030/ITP30010 Database Systems18\nBasic Query Structure•A typical SQL query has the form:   SELECT A1, A2, ..., An FROM r1, r2, ..., rm WHERE P•Ai represents an attribute•Ri represents a relation•P is a predicate\n•The result of an SQL query is a relation\nECE30030/ITP30010 Database Systems19\nEOF•Coming next:•Structured Query Language\nECE30030/ITP30010 Database Systems20"
        },
        {
          "filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf",
          "text": "ECE30030/ITP30010 Database SystemsStructured Query LanguageReading: Chapter 3\nCharmgil Hongcharmgil@handong.eduSpring, 2025Handong Global University\n1\n\nAgenda•Structured query language (SQL)•SQL data manipulation language (DML)•SELECT, FROM, WHERE•NULL values•Set operations•String operations, ordering•Aggregate functions, aggregation•SQL data definition language (DDL)   --   NEXT CLASS\nECE30030/ITP30010 Database Systems2\nStructured Query Language (SQL)•SQL: Structured Query Language•The principal language used to describe and manipulate relational databases•Very high-level•Say “what to do” rather than “how to do it”•SQL is not specifying data-manipulation details•DBMSs figure out the “best” way to execute queries•Called “query optimization”•Two aspects to SQL•Data definition: for declaring database schemas (DDL)•Data manipulation: for querying (asking questions about) databases and for modifying the database (DML)\nECE30030/ITP30010 Database Systems3\nSQL Parts•DML – provides the ability to query information from the database and to insert tuples into, delete tuples from, and modify tuples in the database•Integrity – the DDL includes commands for specifying integrity constraints•View definition – the DDL includes commands for defining views•Transaction control – includes commands for specifying the beginning and ending of transactions•Embedded SQL and dynamic SQL – define how SQL statements can be embedded within general-purpose programming language•Authorization – includes commands for specifying access rights to relations and viewsECE30030/ITP30010 Database Systems4\nA Brief History•IBM SEQUEL (Structured English Query Language) was developed as a part of the System R project (Chamberlin and Boyce, early 1970s)•Later on, SEQUEL was renamed SQL (structured query language)•System R à System/38 (1979), SQL/DS (1981), DB2 (1983)•Relational Software, Inc released the first commercial implementation of SQL, Oracle V2 for VAX computers•Relational Software, Inc is now Oracle Corporation•ANSI and ISO standardized SQL:•SQL-86,  SQL-89,  SQL-92,  SQL:1999,  …,  SQL:2011,  SQL:2016 (current)•SQL-92 is supported by the most of database systems\nECE30030/ITP30010 Database Systems5\nBasic Query Structure•A typical SQL query has the form:   SELECT A1, A2, ..., An FROM r1, r2, ..., rm WHERE P•Ai represents an attribute•Ri represents a relation•P is a predicate\n•The result of an SQL query is a relation\nECE30030/ITP30010 Database Systems6\nAgenda•Structured query language (SQL)•SQL data manipulation language (DML)•SELECT, FROM, WHERE•NULL values•Set operations•String operations, ordering•Aggregate functions, aggregation•SQL data definition language (DDL)\nECE30030/ITP30010 Database Systems7\nSQL Data Manipulation Language•The SQL data-manipulation language (DML) allows querying (ask questions about) and modifying the databases\nECE30030/ITP30010 Database Systems8\nRunning Examples•Relations (tables): instructor, teaches\nECE30030/ITP30010 Database Systems9\nInstructor relationteaches relation\nBasic Query Structure•A typical SQL query has the form:   SELECT A1, A2, ..., An FROM r1, r2, ..., rm WHERE P•Ai represents an attribute•Ri represents a relation•P is a predicate\n•The result of an SQL query is a relation\nECE30030/ITP30010 Database Systems10\nThe SELECT Clause•The SELECT clause lists the attributes desired in the result of a query•Corresponds to the projection operation of the relational algebra\n•Example: Find the names of all instructors•SQL: SELECT name FROM instructor;\nECE30030/ITP30010 Database Systems11\n\nNote•Note: SQL names are case insensitive•E.g., Name ≡ NAME ≡ name•SQL commands (SELECT, FROM, WHERE, …) are written in upper case (just a convention)•MySQL has an option flag, lower_case_table_names•Link: https://dev.mysql.com/doc/refman/8.0/en/identifier-case-sensitivity.html \nECE30030/ITP30010 Database Systems12\nThe SELECT Clause•SQL allows duplicates in relations as well as in query results•The keyword ALL specifies that duplicates should not be removed SELECT ALL dept_name FROM instructor\nECE30030/ITP30010 Database Systems13\n\nThe SELECT Clause•SQL allows duplicates in relations as well as in query results•The keyword ALL specifies that duplicates should not be removed SELECT ALL dept_name FROM instructor•To force the elimination of duplicates, insert the keyword DISTINCT after SELECT•Find the department names of all instructor, removing duplicates: SELECT DISTINCT dept_name FROM instructor;\nECE30030/ITP30010 Database Systems14\n\nThe SELECT Clause•An asterisk in the select clause denotes “all attributes” SELECT * FROM instructor;•An attribute can be a literal with no FROM clause SELECT ‘437’;•Result is a table with one column and a single row with value “437”•Can give the column a name using AS: SELECT ‘437’ AS FOO\nECE30030/ITP30010 Database Systems15\n\nThe SELECT Clause•An attribute can be a literal with FROM clause SELECT 'A' FROM instructor•Result is a table with one column and N rows (number of tuples in the instructor table), each row with value “A”\nECE30030/ITP30010 Database Systems16\n\nThe SELECT Clause•The SELECT clause can contain arithmetic expressions involving the operation, +, –, *, and /, and operating on constants or attributes of tuples•The query:     SELECT ID, name, salary/12      FROM instructorwould return a relation that is the same as the instructor relation,except that the value of the attribute salary is divided by 12\n17\n\nThe SELECT Clause•The SELECT clause can contain arithmetic expressions involving the operation, +, –, *, and /, and operating on constants or attributes of tuples•Can rename “salary/12” using the AS clause:  SELECT ID, name, salary/12 AS monthly_salary   FROM instructor\n18\n\nThe WHERE Clause•The WHERE clause specifies conditions that the result must satisfy•Corresponds to the selection predicate of the relational algebra•E.g., To find all instructors in Comp. Sci. dept: SELECT name FROM instructor  WHERE dept_name = 'Comp. Sci.';\nECE30030/ITP30010 Database Systems19\n\nThe WHERE Clause•SQL allows the use of the logical connectives AND, OR, and NOT•The operands of the logical connectives can be expressions involving the comparison operators <, <=, >, >=, =, and <>•<> means not equal (there is no != in SQL)•Comparisons can be applied to results of arithmetic expressions•E.g., To find all instructors in Comp. Sci. with salary > 70,000: SELECT name FROM instructor WHERE dept_name = 'Comp. Sci.' AND salary > 70000;\nECE30030/ITP30010 Database Systems20\n\nThe WHERE Clause•SQL includes a BETWEEN comparison operator•Example: Find the names of all instructors with salary between $90,000 and $100,000 (that is, ³ $90,000 and £ $100,000)•SELECT nameFROM instructorWHERE salary BETWEEN 90000 AND 100000\nECE30030/ITP30010 Database Systems21\n\nThe WHERE Clause•Tuple comparison: makes comparisons per tuple•SELECT name, course_idFROM instructor, teachesWHERE (instructor.ID, dept_name) = (teaches.ID, 'Biology');\nECE30030/ITP30010 Database Systems22\n\nThe FROM Clause•The FROM clause lists the relations involved in the query•Corresponds to the Cartesian-product operation of the relational algebra•Find the Cartesian-product instructor × teaches SELECT * FROM instructor, teaches;•Generates every possible instructor-teaches pairs, with all attributes from both relations•For common attributes (e.g., ID), the attributes in the resulting table are renamed using the relation name (e.g., instructor.ID)\nECE30030/ITP30010 Database Systems23\nThe FROM Clause•Find the Cartesian-product instructor X teaches SELECT * FROM instructor, teaches;\n24\ninstructor.IDnamedept_namesalaryteaches.IDcourse_idsec_idsemesteryear10101SrinivasanComp. Sci.6500076766BIO-101 1Summer201712121WuFinance9000076766BIO-101 1Summer201715151MozartMusic4000076766BIO-101 1Summer201722222EinsteinPhysics9500076766BIO-101 1Summer201732343El SaidHistory6000076766BIO-101 1Summer2017… … … … … … … … …10101SrinivasanComp. Sci.6500010101CS-101 1Fall 201712121WuFinance9000010101CS-101 1Fall 201715151MozartMusic4000010101CS-101 1Fall 201722222EinsteinPhysics9500010101CS-101 1Fall 201732343El SaidHistory6000010101CS-101 1Fall 2017… … … … … … … … …… … … … … … … … …10101SrinivasanComp. Sci.6500083821CS-190 2Spring201712121WuFinance9000083821CS-190 2Spring201715151MozartMusic4000083821CS-190 2Spring2017… … … … … … … … …10101SrinivasanComp. Sci.6500010101CS-315 1Spring201812121WuFinance9000010101CS-315 1Spring201815151MozartMusic4000010101CS-315 1Spring2018… … … … … … … … …… … … … … … … … …\nImplementing JOIN•Cartesian-product is not very useful directly; but useful combined with WHERE-clause condition (selection operation in relational algebra)•Cartesian-product + selection = join•E.g., Find the names of all instructors who have taught some course and the course_id SELECT name, course_id FROM instructor , teaches WHERE instructor.ID = teaches.ID\nECE30030/ITP30010 Database Systems25\n\nImplementing JOIN•Cartesian-product is not very useful directly; but useful combined with WHERE-clause condition (selection operation in relational algebra)•Cartesian-product + selection = join•Find the names of all instructors in the Music department who have taught some course and the course_id SELECT name, course_id FROM instructor , teaches WHERE instructor.ID = teaches.ID  AND instructor. dept_name = 'Music'\nECE30030/ITP30010 Database Systems26\n\nThe Rename Operation•The SQL allows renaming relations and attributes using the AS clause:   old-name AS new-name•Find the names of all instructors who have a higher salary than some instructor in ‘Comp. Sci.’•SELECT DISTINCT T.nameFROM instructor AS T, instructor AS SWHERE T.salary > S.salary AND S.dept_name = 'Comp. Sci.'\nECE30030/ITP30010 Database Systems27\n\nThe Rename Operation•The SQL allows renaming relations and attributes using the AS clause:   old-name AS new-name•Find the names of all instructors who have a higher salary than some instructor in ‘Comp. Sci.’•SELECT DISTINCT T.nameFROM instructor AS T, instructor AS SWHERE T.salary > S.salary AND S.dept_name = 'Comp. Sci.'•Keyword AS is optional and may be omitted  instructor AS T  ≡  instructor T\nECE30030/ITP30010 Database Systems28\nAgenda•Structured query language (SQL)•SQL data manipulation language (DML)•SELECT, FROM, WHERE•NULL values•Set operations•String operations, ordering•Aggregate functions, aggregation•SQL data definition language (DDL)\nECE30030/ITP30010 Database Systems29\nNULL Values•It is possible for tuples to have a NULL value for some of their attributes•NULL signifies an unknown value or that a value does not exist•The result of any arithmetic expression involving NULL is NULL•E.g.,  5 + NULL returns NULL\nECE30030/ITP30010 Database Systems30\nIS NULL / IS NOT NULL•The predicate IS NULL can be used to check for NULL values•E.g., Find all instructors whose salary is null SELECT name FROM instructor WHERE salary IS NULL•The predicate IS NOT NULL succeeds if the value on which it is applied is not null\nECE30030/ITP30010 Database Systems31\nAgenda•Structured query language (SQL)•SQL data manipulation language (DML)•SELECT, FROM, WHERE•NULL values•Set operations•String operations, ordering•Aggregate functions, aggregation•SQL data definition language (DDL)\nECE30030/ITP30010 Database Systems32\nSet Operations•Set operations UNION, INTERSECT, and EXCEPT•Each of the above operations automatically eliminates duplicates•To retain all duplicates, use ALL:•UNION ALL•INTERSECT ALL•EXCEPT ALL\n•C.f., SELECT retains all duplicates by default\nECE30030/ITP30010 Database Systems33\nSet Operations: UNION•Find courses that ran in Fall 2017 or in Spring 2018•(SELECT course_id  FROM teaches WHERE semester = 'Fall' AND year = 2017)UNION(SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018)\nECE30030/ITP30010 Database Systems34\n\nSet Operations: INTERSECT•Find courses that ran in Fall 2017 and in Spring 2018•(SELECT course_id  FROM teaches WHERE semester = 'Fall' AND year = 2017)INTERSECT(SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018)•C.f., MySQL does NOT support INTERSECT•One can emulate INTERSECT using JOIN (we’ll study JOIN later)•SELECT LT.course_idFROM (SELECT course_id FROM teaches WHERE semester = 'Fall' AND year = 2017) AS LTJOIN (SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018) AS RTON LT.course_id=RT.course_id;\nECE30030/ITP30010 Database Systems35\n\nSet Operations: EXCEPT•Find courses that ran in Fall 2017 but not in Spring 2018•(SELECT course_id  FROM teaches WHERE semester = 'Fall' AND year = 2017)EXCEPT(SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018)•C.f., MySQL does NOT support EXCEPT•One can emulate EXCEPT using NOT IN•SELECT course_id FROM teaches WHERE semester = 'Fall' AND year = 2017AND course_id NOT IN(SELECT course_id  FROM teaches  WHERE semester = 'Spring' AND year = 2018);\nECE30030/ITP30010 Database Systems36\n\nAgenda•Structured query language (SQL)•SQL data manipulation language (DML)•SELECT, FROM, WHERE•NULL values•Set operations•String operations, ordering•Aggregate functions, aggregation•SQL data definition language (DDL)\nECE30030/ITP30010 Database Systems37\nString Operations•SQL includes a string-matching operator for comparisons on character strings•The operator LIKE uses patterns that are described using two special characters:•percent (%) – The % character matches any substring•underscore (_) – The _ character matches any character•Find the names of all instructors whose name includes the substring “ri” SELECT name FROM instructor WHERE name LIKE ‘%ri%'\nECE30030/ITP30010 Database Systems38\n\nString Operations•Escape character: Use backslash (\\) as the escape character•E.g., Match the string “100%” LIKE '100 \\%’ ESCAPE  ‘\\’\nECE30030/ITP30010 Database Systems39\nString Operations•Patterns are case sensitive•Pattern matching examples:•'Intro%' matches any string beginning with “Intro”•'%Comp%' matches any string containing “Comp” as a substring•'_ _ _' matches any string of exactly three characters•'_ _ _ %' matches any string of at least three characters•SQL supports a variety of string operations such as•concatenation (using “||”)•converting from upper to lower case (and vice versa)•finding string length, extracting substrings, etc.\nECE30030/ITP30010 Database Systems40\nOrdering the Display of Tuples•List in alphabetic order the names of all instructors•SELECT DISTINCT nameFROM instructorORDER BY name\nECE30030/ITP30010 Database Systems41\n\nOrdering the Display of Tuples•Can sort on multiple attributes•E.g., SELECT dept_name, name     FROM instructor      ORDER BY dept_name, name\nECE30030/ITP30010 Database Systems42\n\nOrdering the Display of Tuples•We may specify DESC for descending order or ASC for ascending order, for each attribute; ascending order is the default•E.g., ORDER BY name DESC\nECE30030/ITP30010 Database Systems43\n\nAgenda•Structured query language (SQL)•SQL data manipulation language (DML)•SELECT, FROM, WHERE•NULL values•Set operations•String operations, ordering•Aggregate functions, aggregation•SQL data definition language (DDL)\nECE30030/ITP30010 Database Systems44\nAggregate Functions•These functions operate on the multiset of values of a column of a relation, and return a value•AVG:  average value•MIN:  minimum value•MAX:  maximum value•SUM:  sum of values•COUNT:  number of values\nECE30030/ITP30010 Database Systems45\nAggregate Functions Examples•Find the average salary of instructors in the Computer Science department•SELECT AVG(salary)FROM instructorWHERE dept_name= 'Comp. Sci.';•Find the total number of instructors who teach a course in the Spring 2018 semester•SELECT COUNT(DISTINCT ID)FROM teachesWHERE semester = 'Spring’ AND year = 2018;•Find the number of tuples in the teaches relation•SELECT COUNT (*)FROM teaches;\nECE30030/ITP30010 Database Systems46\n\nAggregate Functions: Group By•Find the average salary of instructors in each department•SELECT dept_name, AVG(salary) AS avg_salaryFROM instructorGROUP BY dept_name;\nECE30030/ITP30010 Database Systems47\n\nAggregation•Attributes in SELECT clause outside of aggregate functions must appear in GROUP BY list•/* erroneous query */SELECT dept_name, ID, AVG(salary)FROM instructorGROUP BY dept_name;\nECE30030/ITP30010 Database Systems48\n\nAggregate Functions – Having Clause•Find the names and average salaries of all departments whose average salary is greater than 65000•SELECT dept_name, AVG(salary) AS avg_salaryFROM instructorGROUP BY dept_nameHAVING AVG(salary) > 65000;\nECE30030/ITP30010 Database Systems49\n\nAggregate Functions – Having Clause•Note: predicates in the HAVING clause are applied after the formation of groups whereas predicates in the WHERE clause are applied before forming groups\nECE30030/ITP30010 Database Systems50\nSELECT dept_name, AVG(salary) AS avg_salaryFROM instructorGROUP BY dept_nameHAVING AVG(salary) > 65000;\nSELECT dept_name, AVG(salary) AS avg_salaryFROM instructorWHERE salary > 65000GROUP BY dept_name;\n\nSQL Commands\nSQLDMLSELECTINSERTUPDATEDELETE\nDDLCREATEALTERDROP\nECE30030/ITP30010 Database Systems51\nINSERT•Basic syntax•Insert data into every column:•INSERT INTO tablenameVALUES (col1_value, col2_value, …)•Must list values in the same order as in the table schema•If some data values are unknown, must type NULL •For character sequences, use quotation marks•Single quotation marks are preferred (but double quotation marks are allowed)•Value in quotations is case-sensitive•Insert data into selected columns•INSERT INTO tablename (col1_name, col3_name, col4_name, …)VALUES (col1_value, col3_value, col4_value, …)\nECE30030/ITP30010 Database Systems52\nINSERT•Add a new tuple to course•INSERT INTO courseVALUES ('CS-437', 'Database Systems', 'Comp. Sci.', 4);•or equivalently•INSERT INTO course (course_id, title, dept_name, credits)VALUES ('CS-437', 'Database Systems', 'Comp. Sci.', 4);•Add a new tuple to student  with tot_creds set to null•INSERT INTO studentVALUES ('3003', 'Green', 'Finance', null);\nECE30030/ITP30010 Database Systems53\nINSERT•A foreign key specifies that an attribute from one relation has to map to a tuple in another relation•Value in one relation must appear in another relation\nECE30030/ITP30010 Database Systems54\nRelation: instructor\nRelation: department\nINSERT•A foreign key specifies that an attribute from one relation has to map to a tuple in another relation•Value in one relation must appear in another relation•Make sure all foreign keys that new row references have already been added to database•One cannot insert a foreign key value unless the corresponding value exists in the referenced relation\nECE30030/ITP30010 Database Systems55\nINSERT•Inserting results of other SELECT query•Make each student in the Music department who has earned more than 144 credit hours an instructor in the Music department with a salary of  $18,000•INSERT INTO instructor  SELECT ID, name, dept_name, 18000  FROM student   WHERE dept_name = 'Music’ AND total_cred > 144;•The SELECT FROM WHERE statement is evaluated fully before any of its results are inserted into the relation•Otherwise queries like  INSERT INTO table1 SELECT * FROM table1would cause problem\nECE30030/ITP30010 Database Systems56\nUPDATE•Basic syntax•Updating a table•UPDATE tablenameSET col1_name = new_col1_value, col2_name = new_col2_value, …;•Updating a table with conditions•UPDATE tablenameSET col1_name = new_col1_value, col2_name = new_col2_value, …WHERE predicate;\nECE30030/ITP30010 Database Systems57\nUPDATE•Give a 5% salary raise to all instructors•UPDATE instructorSET salary = salary * 1.05•Give a 5% salary raise to those instructors who earn less than 70000•UPDATE instructorSET salary = salary * 1.05WHERE salary < 70000;•Give a 5% salary raise to instructors whose salary is less than average•UPDATE instructorSET salary = salary * 1.05WHERE salary <  (SELECT AVG(salary) FROM instructor);\nECE30030/ITP30010 Database Systems58\nUPDATE•Increase salaries of instructors whose salary is over $100,000 by 3%, and all others by a 5%•Write two UPDATE statements:  UPDATE instructor  SET salary = salary * 1.03  WHERE salary > 100000;  UPDATE instructor  SET salary = salary * 1.05  WHERE salary <= 100000;•The order is important•Can be done better using the case statement (next slide)\nECE30030/ITP30010 Database Systems59\nCASE Statement for Conditional Update•The following query is equivalent to the previous UPDATE queries•UPDATE instructorSET salary = CASE                           WHEN salary <= 100000 THEN salary * 1.05                           ELSE salary * 1.03                       END\nECE30030/ITP30010 Database Systems60\nUPDATE with Scalar Subqueries•Recompute and update tot_creds value for all students•UPDATE student SSET tot_cred = (SELECT SUM(credits)                             FROM takes, course                             WHERE takes.course_id = course.course_id  AND                                            S.ID= takes.ID  AND                                            takes.grade <> 'F' AND                                            takes.grade IS NOT NULL);\nECE30030/ITP30010 Database Systems61\nDELETE•Basic syntax•To remove specific rows•DELETE FROM tablenameWHERE predicate;•To remove all rows•DELETE FROM tablename;•This is equivalent to TRUNCATE:TRUNCATE (TABLE) tablename;•One cannot truncate a table with foreign key constraints•Must disable the constraints first (we will cover ALTER when we study SQL DDL):ALTER TABLE tablenameDISABLE CONSTRAINT constraint_name;\nECE30030/ITP30010 Database Systems62\nDELETE•Delete all instructors•DELETE FROM instructor;•Delete all instructors from the Finance department•DELETE FROM instructorWHERE dept_name= 'Finance';•Delete all tuples in the instructor relation for those instructors associated with a department located in the Watson building•DELETE FROM instructorWHERE dept name IN (SELECT dept name        FROM department        WHERE building = 'Watson');\nECE30030/ITP30010 Database Systems63\nDELETE•Delete all instructors whose salary is less than the average salary of instructors•Example:  DELETE FROM instructor                WHERE salary < (SELECT AVG (salary)                  FROM instructor);•Issue:  as we delete tuples from instructor, the average salary changes•Solution used in SQL:1.First, compute AVG(salary) and find all tuples to delete2.Next, delete all tuples found above (without recomputing AVG or retesting the tuples)\nECE30030/ITP30010 Database Systems64\nEOF•Coming next:•More on Structured Query Language\nECE30030/ITP30010 Database Systems65"
        }
      ],
      "notebook_title": "관계형 데이터베이스 시스템: MySQL 소개 및 SQL 심층 활용",
      "holistic_chapters": [
        {
          "chapter_title": "관계형 데이터베이스 시스템(R-DBMS) 개요 및 MySQL 소개",
          "source_pdf_filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_1a4c2f45-b482-4e82-826e-fa8945eb99c7_DB03 - mysql.pdf",
          "chapter_content_summary": "이 장에서는 관계형 데이터베이스 관리 시스템(R-DBMS)의 기본 개념을 소개하고, 대표적인 오픈소스 R-DBMS인 MySQL에 대해 심층적으로 다룹니다. MySQL의 정의, Oracle 소유권, 표준 SQL 호환성, 상업적 웹 서비스에서의 활용 사례, 기업 사용 통계, 그리고 MySQL의 인기 요인(다양한 운영체제 및 프로그래밍 언어 지원, 비용 효율성, 고성능)을 설명합니다. 또한, R-DBMS 시장에서의 MySQL의 트렌드와 인기도를 살펴보고, MySQL 5.x와 8.x 버전의 주요 차이점 및 MySQL 커뮤니티 버전을 다운로드하고 Docker 이미지를 활용하는 방법을 안내합니다. MySQL이 대규모 데이터 처리, 다중 사용자 지원, 효율성, 안정성, 보안성 측면에서 갖는 강점들을 강조합니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database SystemsHandshaking with an R-DBMSCharmgil Hongcharmgil@handong.eduSpring, 2025Handong Global University\n1\nAgenda•Introduction to MySQL•SQL preview\nECE30030/ITP30010 Database Systems2\nMySQL•MySQL is an SQL-based relational database management system (DBMS)•Free and open-source R-DBMS (under GPL)•Owned by Oracle•Commercial version of MySQL is also provided (including technical support)•“My” came from the name of co-founder Michael Widenius’ daughter•C.f., MariaDB•Compatible with standard SQL•Frequently used for commercial web services\nECE30030/ITP30010 Database Systems3\n* Image src: https://en.wikipedia.org/wiki/MySQL\nMySQL•Companies using MySQL (a study by Enlyft)•“We have data on 199,498 (out of 1,409,176) companies that use MySQL”•Often used by companies with 10-50 employees and 1M-10M dollars in revenue•C.f., Oracle 12 is most often used by companies with 50-200 employees and >1000M dollars in revenue\nECE30030/ITP30010 Database Systems4* Source: https://enlyft.com/tech/products/mysql \nMySQL•Companies using MySQL (full list: https://www.mysql.com/customers/)\nECE30030/ITP30010 Database Systems5\n* Source: https://stackshare.io/mysql \nMySQL•Why MySQL?•Popular•Active discussions all over the Internet•Versatile: runs on Linux, Windows, Mac OS X, Solaris, FreeBSD, …•Supports wide range of programming languages (C/C++, Java, Python, .Net, …)•Cost starts from zero•High performance (fast and reliable)\nECE30030/ITP30010 Database Systems6* Image src: https://db-engines.com/en/ranking\nDBMS Trend Popularity\n•Score definition: https://db-engines.com/en/ranking_definition\nECE30030/ITP30010 Database Systems7* Image src: https://db-engines.com/en/ranking_trend \nMySQL•Why MySQL?•Popular•Active discussions all over the Internet•Versatile: runs on Linux, Windows, Mac OS X, Solaris, FreeBSD, …•Supports wide range of programming languages (C/C++, Java, Python, .Net, …)•Cost starts from zero•High performance (fast and reliable)\nECE30030/ITP30010 Database Systems8* Image src: https://dev.mysql.com/downloads/\nMySQL\nECE30030/ITP30010 Database Systems9\n•Massive•Convenient•Multi-user•Safe•Efficient•Reliable\nCan handle terabytes of dataSupports high-level query languageSupports concurrent data accessSupports transactionsCan handle thousands of queries/second99.99% up-time in many real-world products\nMySQL Versions•MySQL 5.x vs 8.x\nECE30030/ITP30010 Database Systems10\nVersion 5.x-Most popular version of MySQL-More stable and conventionalVersion 8.x-Current version-Provides up-to-date DB functionalities (better storage engine, faster, more secure)\n* Source: https://www.eversql.com/mysql-8-adoption-usage-rate/#:~:text=MySQL%205.7%20is%20still%20the,17%25%20are%20using%20MySQL%208. \nMySQL Versions•MySQL 5.x vs 8.x\nECE30030/ITP30010 Database Systems11\nVersion 5.x-Most popular version of MySQL-More stable and conventionalVersion 8.x-Current version-Provides up-to-date DB functionalities (better storage engine, faster, more secure)\n* Source: https://severalnines.com/database-blog/mysql-performance-benchmarking-mysql-57-vs-mysql-80 \nMySQL Versions•MySQL 5.x vs 8.x\nECE30030/ITP30010 Database Systems12\nVersion 5.x-Most popular version of MySQL-More stable and conventionalVersion 8.x-Current version-Provides up-to-date DB functionalities (better storage engine, faster, more secure)\n* Source: https://severalnines.com/database-blog/mysql-performance-benchmarking-mysql-57-vs-mysql-80 \nWhere to Get MySQL?•https://dev.mysql.com/downloads/•Look for the “Community” versions – the branch that is available for free•”Enterprise” versions are the commercial ones•We have prepared a Docker image for the course•Consists of Ubuntu Server, MySQL, example databases for course activities\nECE30030/ITP30010 Database Systems13* Image src: https://www.docker.com \nWhere to Get MySQL?\nECE30030/ITP30010 Database Systems14\n* Image source: https://baumannalexj.medium.com/connect-your-db-tool-to-a-dockerized-mysql-server-container-bc18853524ed   https://www.jetbrains.com/datagrip/features/look_and_feel.html"
        },
        {
          "chapter_title": "SQL(구조적 질의어)의 이해: 기본 개념과 역사",
          "source_pdf_filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf",
          "chapter_content_summary": "SQL(Structured Query Language)의 정의와 관계형 데이터베이스를 조작하는 주된 언어로서의 역할을 설명합니다. SQL이 '무엇을 할지'를 명시하는 고수준 언어이며, DBMS가 '어떻게 할지'를 결정하는 쿼리 최적화 과정을 다룹니다. 또한, SQL의 두 가지 주요 측면인 데이터 정의 언어(DDL)와 데이터 조작 언어(DML)를 소개하고, 무결성, 뷰 정의, 트랜잭션 제어, 내장 SQL 및 동적 SQL, 권한 부여와 같은 SQL의 다양한 구성 요소를 살펴봅니다. 마지막으로, IBM SEQUEL에서 시작하여 Oracle V2를 거쳐 ANSI 및 ISO 표준으로 발전한 SQL의 간략한 역사를 소개하고, 기본적인 SQL 쿼리 구조(SELECT, FROM, WHERE)를 설명합니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database SystemsStructured Query LanguageReading: Chapter 3\nCharmgil Hongcharmgil@handong.eduSpring, 2025Handong Global University\n1\nAgenda•Structured query language (SQL)•SQL data manipulation language (DML)•SELECT, FROM, WHERE•NULL values•Set operations•String operations, ordering•Aggregate functions, aggregation•SQL data definition language (DDL)   --   NEXT CLASS\nECE30030/ITP30010 Database Systems2\nStructured Query Language (SQL)•SQL: Structured Query Language•The principal language used to describe and manipulate relational databases•Very high-level•Say “what to do” rather than “how to do it”•SQL is not specifying data-manipulation details•DBMSs figure out the “best” way to execute queries•Called “query optimization”•Two aspects to SQL•Data definition: for declaring database schemas (DDL)•Data manipulation: for querying (asking questions about) databases and for modifying the database (DML)\nECE30030/ITP30010 Database Systems3\nSQL Parts•DML – provides the ability to query information from the database and to insert tuples into, delete tuples from, and modify tuples in the database•Integrity – the DDL includes commands for specifying integrity constraints•View definition – the DDL includes commands for defining views•Transaction control – includes commands for specifying the beginning and ending of transactions•Embedded SQL and dynamic SQL – define how SQL statements can be embedded within general-purpose programming language•Authorization – includes commands for specifying access rights to relations and viewsECE30030/ITP30010 Database Systems4\nA Brief History•IBM SEQUEL (Structured English Query Language) was developed as a part of the System R project (Chamberlin and Boyce, early 1970s)•Later on, SEQUEL was renamed SQL (structured query language)•System R à System/38 (1979), SQL/DS (1981), DB2 (1983)•Relational Software, Inc released the first commercial implementation of SQL, Oracle V2 for VAX computers•Relational Software, Inc is now Oracle Corporation•ANSI and ISO standardized SQL:•SQL-86,  SQL-89,  SQL-92,  SQL:1999,  …,  SQL:2011,  SQL:2016 (current)•SQL-92 is supported by the most of database systems\nECE30030/ITP30010 Database Systems5\nBasic Query Structure•A typical SQL query has the form:   SELECT A1, A2, ..., An FROM r1, r2, ..., rm WHERE P•Ai represents an attribute•Ri represents a relation•P is a predicate\n•The result of an SQL query is a relation\nECE30030/ITP30010 Database Systems6"
        },
        {
          "chapter_title": "SQL 데이터 조작 언어(DML) 기초: SELECT, FROM, WHERE 절",
          "source_pdf_filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf",
          "chapter_content_summary": "이 장에서는 SQL 데이터 조작 언어(DML)의 핵심 구성 요소인 SELECT, FROM, WHERE 절을 상세히 다룹니다. 'instructor' 및 'teaches'와 같은 예시 관계(테이블)를 사용하여 실제 쿼리 작성 방법을 시연합니다. SELECT 절을 통해 원하는 속성을 선택하고, 중복을 포함하거나 제거하는 방법(ALL, DISTINCT), 모든 속성을 선택하는 '*' 사용법, 리터럴 및 산술 표현식 활용, 그리고 AS 키워드를 사용한 속성 이름 변경 방법을 학습합니다. WHERE 절에서는 논리 연산자(AND, OR, NOT) 및 비교 연산자(<, <=, >, >=, =, <>, BETWEEN)를 사용하여 조건을 지정하고, 튜플 비교를 수행하는 방법을 설명합니다. 마지막으로 FROM 절을 통해 쿼리에 포함될 관계를 지정하고, 카르테시안 곱을 이해하며, WHERE 절과 결합하여 JOIN 연산을 구현하는 방법을 구체적인 예시와 함께 제시합니다. 또한, AS 키워드를 이용한 관계 및 속성 이름 변경(별칭 지정)을 다룹니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems7\nSQL Data Manipulation Language•The SQL data-manipulation language (DML) allows querying (ask questions about) and modifying the databases\nECE30030/ITP30010 Database Systems8\nRunning Examples•Relations (tables): instructor, teaches\nECE30030/ITP30010 Database Systems9\nInstructor relationteaches relation\nBasic Query Structure•A typical SQL query has the form:   SELECT A1, A2, ..., An FROM r1, r2, ..., rm WHERE P•Ai represents an attribute•Ri represents a relation•P is a predicate\n•The result of an SQL query is a relation\nECE30030/ITP30010 Database Systems10\nThe SELECT Clause•The SELECT clause lists the attributes desired in the result of a query•Corresponds to the projection operation of the relational algebra\n•Example: Find the names of all instructors•SQL: SELECT name FROM instructor;\nECE30030/ITP30010 Database Systems11\nNote•Note: SQL names are case insensitive•E.g., Name ≡ NAME ≡ name•SQL commands (SELECT, FROM, WHERE, …) are written in upper case (just a convention)•MySQL has an option flag, lower_case_table_names•Link: https://dev.mysql.com/doc/refman/8.0/en/identifier-case-sensitivity.html \nECE30030/ITP30010 Database Systems12\nThe SELECT Clause•SQL allows duplicates in relations as well as in query results•The keyword ALL specifies that duplicates should not be removed SELECT ALL dept_name FROM instructor\nECE30030/ITP30010 Database Systems13\nThe SELECT Clause•SQL allows duplicates in relations as well as in query results•The keyword ALL specifies that duplicates should not be removed SELECT ALL dept_name FROM instructor•To force the elimination of duplicates, insert the keyword DISTINCT after SELECT•Find the department names of all instructor, removing duplicates: SELECT DISTINCT dept_name FROM instructor;\nECE30030/ITP30010 Database Systems14\nThe SELECT Clause•An asterisk in the select clause denotes “all attributes” SELECT * FROM instructor;•An attribute can be a literal with no FROM clause SELECT ‘437’;•Result is a table with one column and a single row with value “437”•Can give the column a name using AS: SELECT ‘437’ AS FOO\nECE30030/ITP30010 Database Systems15\nThe SELECT Clause•An attribute can be a literal with FROM clause SELECT 'A' FROM instructor•Result is a table with one column and N rows (number of tuples in the instructor table), each row with value “A”\nECE30030/ITP30010 Database Systems16\nThe SELECT Clause•The SELECT clause can contain arithmetic expressions involving the operation, +, –, *, and /, and operating on constants or attributes of tuples•The query:     SELECT ID, name, salary/12      FROM instructorwould return a relation that is the same as the instructor relation,except that the value of the attribute salary is divided by 12\n17\nThe SELECT Clause•The SELECT clause can contain arithmetic expressions involving the operation, +, –, *, and /, and operating on constants or attributes of tuples•Can rename “salary/12” using the AS clause:  SELECT ID, name, salary/12 AS monthly_salary   FROM instructor\n18\nThe WHERE Clause•The WHERE clause specifies conditions that the result must satisfy•Corresponds to the selection predicate of the relational algebra•E.g., To find all instructors in Comp. Sci. dept: SELECT name FROM instructor  WHERE dept_name = 'Comp. Sci.';\nECE30030/ITP30010 Database Systems19\nThe WHERE Clause•SQL allows the use of the logical connectives AND, OR, and NOT•The operands of the logical connectives can be expressions involving the comparison operators <, <=, >, >=, =, and <>•<> means not equal (there is no != in SQL)•Comparisons can be applied to results of arithmetic expressions•E.g., To find all instructors in Comp. Sci. with salary > 70,000: SELECT name FROM instructor WHERE dept_name = 'Comp. Sci.' AND salary > 70000;\nECE30030/ITP30010 Database Systems20\nThe WHERE Clause•SQL includes a BETWEEN comparison operator•Example: Find the names of all instructors with salary between $90,000 and $100,000 (that is, ³ $90,000 and £ $100,000)•SELECT nameFROM instructorWHERE salary BETWEEN 90000 AND 100000\nECE30030/ITP30010 Database Systems21\nThe WHERE Clause•Tuple comparison: makes comparisons per tuple•SELECT name, course_idFROM instructor, teachesWHERE (instructor.ID, dept_name) = (teaches.ID, 'Biology');\nECE30030/ITP30010 Database Systems22\nThe FROM Clause•The FROM clause lists the relations involved in the query•Corresponds to the Cartesian-product operation of the relational algebra•Find the Cartesian-product instructor × teaches SELECT * FROM instructor, teaches;•Generates every possible instructor-teaches pairs, with all attributes from both relations•For common attributes (e.g., ID), the attributes in the resulting table are renamed using the relation name (e.g., instructor.ID)\nECE30030/ITP30010 Database Systems23\nThe FROM Clause•Find the Cartesian-product instructor X teaches SELECT * FROM instructor, teaches;\n24\ninstructor.IDnamedept_namesalaryteaches.IDcourse_idsec_idsemesteryear10101SrinivasanComp. Sci.6500076766BIO-101 1Summer201712121WuFinance9000076766BIO-101 1Summer201715151MozartMusic4000076766BIO-101 1Summer201722222EinsteinPhysics9500076766BIO-101 1Summer201732343El SaidHistory6000076766BIO-101 1Summer2017… … … … … … … … …10101SrinivasanComp. Sci.6500010101CS-101 1Fall 201712121WuFinance9000010101CS-101 1Fall 201715151MozartMusic4000010101CS-101 1Fall 201722222EinsteinPhysics9500010101CS-101 1Fall 201732343El SaidHistory6000010101CS-101 1Fall 2017… … … … … … … … …… … … … … … … … …10101SrinivasanComp. Sci.6500083821CS-190 2Spring201712121WuFinance9000083821CS-190 2Spring201715151MozartMusic4000083821CS-190 2Spring2017… … … … … … … … …10101SrinivasanComp. Sci.6500010101CS-315 1Spring201812121WuFinance9000010101CS-315 1Spring201815151MozartMusic4000010101CS-315 1Spring2018… … … … … … … … …… … … … … … … … …\nImplementing JOIN•Cartesian-product is not very useful directly; but useful combined with WHERE-clause condition (selection operation in relational algebra)•Cartesian-product + selection = join•E.g., Find the names of all instructors who have taught some course and the course_id SELECT name, course_id FROM instructor , teaches WHERE instructor.ID = teaches.ID\nECE30030/ITP30010 Database Systems25\nImplementing JOIN•Cartesian-product is not very useful directly; but useful combined with WHERE-clause condition (selection operation in relational algebra)•Cartesian-product + selection = join•Find the names of all instructors in the Music department who have taught some course and the course_id SELECT name, course_id FROM instructor , teaches WHERE instructor.ID = teaches.ID  AND instructor. dept_name = 'Music'\nECE30030/ITP30010 Database Systems26\nThe Rename Operation•The SQL allows renaming relations and attributes using the AS clause:   old-name AS new-name•Find the names of all instructors who have a higher salary than some instructor in ‘Comp. Sci.’•SELECT DISTINCT T.nameFROM instructor AS T, instructor AS SWHERE T.salary > S.salary AND S.dept_name = 'Comp. Sci.'\nECE30030/ITP30010 Database Systems27\nThe Rename Operation•The SQL allows renaming relations and attributes using the AS clause:   old-name AS new-name•Find the names of all instructors who have a higher salary than some instructor in ‘Comp. Sci.’•SELECT DISTINCT T.nameFROM instructor AS T, instructor AS SWHERE T.salary > S.salary AND S.dept_name = 'Comp. Sci.'•Keyword AS is optional and may be omitted  instructor AS T  ≡  instructor T\nECE30030/ITP30010 Database Systems28"
        },
        {
          "chapter_title": "SQL DML 고급 기능: NULL 값, 집합 연산, 문자열 처리 및 정렬",
          "source_pdf_filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf",
          "chapter_content_summary": "이 장에서는 SQL DML의 고급 기능을 탐구합니다. 먼저, 알려지지 않거나 존재하지 않는 값을 나타내는 NULL 값의 특성을 이해하고, 산술 연산에서의 NULL 동작 및 IS NULL / IS NOT NULL 술어를 사용하여 NULL 값을 확인하는 방법을 배웁니다. 다음으로, 여러 쿼리 결과를 결합하는 집합 연산인 UNION, INTERSECT, EXCEPT를 살펴봅니다. 각 연산이 기본적으로 중복을 제거하며, ALL 키워드를 사용하여 중복을 유지하는 방법을 설명합니다. 특히 MySQL에서 INTERSECT와 EXCEPT가 직접 지원되지 않을 때 JOIN 또는 NOT IN을 사용하여 에뮬레이션하는 기법을 소개합니다. 이어서, 문자열 패턴 매칭을 위한 LIKE 연산자와 '%' (모든 부분 문자열), '_' (단일 문자) 특수 문자의 사용법을 다룹니다. 백슬래시를 이용한 이스케이프 문자 처리, 패턴 매칭의 대소문자 구분, 그리고 연결, 대소문자 변환, 길이 확인, 부분 문자열 추출 등 다양한 SQL 문자열 함수를 소개합니다. 마지막으로, ORDER BY 절을 사용하여 쿼리 결과를 특정 속성을 기준으로 오름차순(ASC) 또는 내림차순(DESC)으로 정렬하는 방법을 학습하며, 여러 속성을 기준으로 정렬하는 예시도 제시합니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems29\nNULL Values•It is possible for tuples to have a NULL value for some of their attributes•NULL signifies an unknown value or that a value does not exist•The result of any arithmetic expression involving NULL is NULL•E.g.,  5 + NULL returns NULL\nECE30030/ITP30010 Database Systems30\nIS NULL / IS NOT NULL•The predicate IS NULL can be used to check for NULL values•E.g., Find all instructors whose salary is null SELECT name FROM instructor WHERE salary IS NULL•The predicate IS NOT NULL succeeds if the value on which it is applied is not null\nECE30030/ITP30010 Database Systems31\nECE30030/ITP30010 Database Systems32\nSet Operations•Set operations UNION, INTERSECT, and EXCEPT•Each of the above operations automatically eliminates duplicates•To retain all duplicates, use ALL:•UNION ALL•INTERSECT ALL•EXCEPT ALL\n•C.f., SELECT retains all duplicates by default\nECE30030/ITP30010 Database Systems33\nSet Operations: UNION•Find courses that ran in Fall 2017 or in Spring 2018•(SELECT course_id  FROM teaches WHERE semester = 'Fall' AND year = 2017)UNION(SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018)\nECE30030/ITP30010 Database Systems34\nSet Operations: INTERSECT•Find courses that ran in Fall 2017 and in Spring 2018•(SELECT course_id  FROM teaches WHERE semester = 'Fall' AND year = 2017)INTERSECT(SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018)•C.f., MySQL does NOT support INTERSECT•One can emulate INTERSECT using JOIN (we’ll study JOIN later)•SELECT LT.course_idFROM (SELECT course_id FROM teaches WHERE semester = 'Fall' AND year = 2017) AS LTJOIN (SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018) AS RTON LT.course_id=RT.course_id;\nECE30030/ITP30010 Database Systems35\nSet Operations: EXCEPT•Find courses that ran in Fall 2017 but not in Spring 2018•(SELECT course_id  FROM teaches WHERE semester = 'Fall' AND year = 2017)EXCEPT(SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018)•C.f., MySQL does NOT support EXCEPT•One can emulate EXCEPT using NOT IN•SELECT course_id FROM teaches WHERE semester = 'Fall' AND year = 2017AND course_id NOT IN(SELECT course_id  FROM teaches  WHERE semester = 'Spring' AND year = 2018);\nECE30030/ITP30010 Database Systems36\nECE30030/ITP30010 Database Systems37\nString Operations•SQL includes a string-matching operator for comparisons on character strings•The operator LIKE uses patterns that are described using two special characters:•percent (%) – The % character matches any substring•underscore (_) – The _ character matches any character•Find the names of all instructors whose name includes the substring “ri” SELECT name FROM instructor WHERE name LIKE ‘%ri%'\nECE30030/ITP30010 Database Systems38\nString Operations•Escape character: Use backslash (\\) as the escape character•E.g., Match the string “100%” LIKE '100 \\%’ ESCAPE  ‘\\’\nECE30030/ITP30010 Database Systems39\nString Operations•Patterns are case sensitive•Pattern matching examples:•'Intro%' matches any string beginning with “Intro”•'%Comp%' matches any string containing “Comp” as a substring•'_ _ _' matches any string of exactly three characters•'_ _ _ %' matches any string of at least three characters•SQL supports a variety of string operations such as•concatenation (using “||”)•converting from upper to lower case (and vice versa)•finding string length, extracting substrings, etc.\nECE30030/ITP30010 Database Systems40\nOrdering the Display of Tuples•List in alphabetic order the names of all instructors•SELECT DISTINCT nameFROM instructorORDER BY name\nECE30030/ITP30010 Database Systems41\nOrdering the Display of Tuples•Can sort on multiple attributes•E.g., SELECT dept_name, name     FROM instructor      ORDER BY dept_name, name\nECE30030/ITP30010 Database Systems42\nOrdering the Display of Tuples•We may specify DESC for descending order or ASC for ascending order, for each attribute; ascending order is the default•E.g., ORDER BY name DESC\nECE30030/ITP30010 Database Systems43"
        },
        {
          "chapter_title": "SQL DML 집계 함수 및 데이터 수정 (INSERT, UPDATE, DELETE)",
          "source_pdf_filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf",
          "chapter_content_summary": "이 장에서는 SQL 데이터 조작 언어(DML)의 고급 기능인 집계 함수와 데이터를 수정하는 명령어를 다룹니다. AVG, MIN, MAX, SUM, COUNT와 같은 집계 함수를 사용하여 컬럼 값의 멀티셋에 대한 통계 값을 계산하는 방법을 학습합니다. 특히 GROUP BY 절을 이용한 데이터 그룹화와 HAVING 절을 이용한 그룹별 필터링을 심층적으로 다루며, WHERE 절과의 차이점을 명확히 설명합니다. 또한, DML의 핵심 명령인 INSERT, UPDATE, DELETE에 대해 자세히 알아봅니다. INSERT 명령을 통해 테이블에 새로운 튜플을 추가하는 다양한 방법(모든 컬럼, 선택된 컬럼, NULL 값 처리, SELECT 쿼리 결과 삽입)과 외래 키 제약 조건의 중요성을 강조합니다. UPDATE 명령으로는 기존 데이터를 수정하는 기본 구문, 조건부 업데이트, CASE 문을 사용한 복잡한 조건 처리, 스칼라 서브쿼리 활용법을 배웁니다. 마지막으로 DELETE 명령을 통해 테이블에서 특정 행 또는 모든 행을 삭제하는 방법과 TRUNCATE 명령의 차이점, 그리고 삭제 시 서브쿼리 사용 시의 고려사항을 설명합니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems44\nAggregate Functions•These functions operate on the multiset of values of a column of a relation, and return a value•AVG:  average value•MIN:  minimum value•MAX:  maximum value•SUM:  sum of values•COUNT:  number of values\nECE30030/ITP30010 Database Systems45\nAggregate Functions Examples•Find the average salary of instructors in the Computer Science department•SELECT AVG(salary)FROM instructorWHERE dept_name= 'Comp. Sci.';•Find the total number of instructors who teach a course in the Spring 2018 semester•SELECT COUNT(DISTINCT ID)FROM teachesWHERE semester = 'Spring’ AND year = 2018;•Find the number of tuples in the teaches relation•SELECT COUNT (*)FROM teaches;\nECE30030/ITP30010 Database Systems46\nAggregate Functions: Group By•Find the average salary of instructors in each department•SELECT dept_name, AVG(salary) AS avg_salaryFROM instructorGROUP BY dept_name;\nECE30030/ITP30010 Database Systems47\nAggregation•Attributes in SELECT clause outside of aggregate functions must appear in GROUP BY list•/* erroneous query */SELECT dept_name, ID, AVG(salary)FROM instructorGROUP BY dept_name;\nECE30030/ITP30010 Database Systems48\nAggregate Functions – Having Clause•Find the names and average salaries of all departments whose average salary is greater than 65000•SELECT dept_name, AVG(salary) AS avg_salaryFROM instructorGROUP BY dept_nameHAVING AVG(salary) > 65000;\nECE30030/ITP30010 Database Systems49\nAggregate Functions – Having Clause•Note: predicates in the HAVING clause are applied after the formation of groups whereas predicates in the WHERE clause are applied before forming groups\nECE30030/ITP30010 Database Systems50\nSELECT dept_name, AVG(salary) AS avg_salaryFROM instructorGROUP BY dept_nameHAVING AVG(salary) > 65000;\nSELECT dept_name, AVG(salary) AS avg_salaryFROM instructorWHERE salary > 65000GROUP BY dept_name;\nSQL Commands\nSQLDMLSELECTINSERTUPDATEDELETE\nDDLCREATEALTERDROP\nECE30030/ITP30010 Database Systems51\nINSERT•Basic syntax•Insert data into every column:•INSERT INTO tablenameVALUES (col1_value, col2_value, …)•Must list values in the same order as in the table schema•If some data values are unknown, must type NULL •For character sequences, use quotation marks•Single quotation marks are preferred (but double quotation marks are allowed)•Value in quotations is case-sensitive•Insert data into selected columns•INSERT INTO tablename (col1_name, col3_name, col4_name, …)VALUES (col1_value, col3_value, col4_value, …)\nECE30030/ITP30010 Database Systems52\nINSERT•Add a new tuple to course•INSERT INTO courseVALUES ('CS-437', 'Database Systems', 'Comp. Sci.', 4);•or equivalently•INSERT INTO course (course_id, title, dept_name, credits)VALUES ('CS-437', 'Database Systems', 'Comp. Sci.', 4);•Add a new tuple to student  with tot_creds set to null•INSERT INTO studentVALUES ('3003', 'Green', 'Finance', null);\nECE30030/ITP30010 Database Systems53\nINSERT•A foreign key specifies that an attribute from one relation has to map to a tuple in another relation•Value in one relation must appear in another relation\nECE30030/ITP30010 Database Systems54\nRelation: instructor\nRelation: department\nINSERT•A foreign key specifies that an attribute from one relation has to map to a tuple in another relation•Value in one relation must appear in another relation•Make sure all foreign keys that new row references have already been added to database•One cannot insert a foreign key value unless the corresponding value exists in the referenced relation\nECE30030/ITP30010 Database Systems55\nINSERT•Inserting results of other SELECT query•Make each student in the Music department who has earned more than 144 credit hours an instructor in the Music department with a salary of  $18,000•INSERT INTO instructor  SELECT ID, name, dept_name, 18000  FROM student   WHERE dept_name = 'Music’ AND total_cred > 144;•The SELECT FROM WHERE statement is evaluated fully before any of its results are inserted into the relation•Otherwise queries like  INSERT INTO table1 SELECT * FROM table1would cause problem\nECE30030/ITP30010 Database Systems56\nUPDATE•Basic syntax•Updating a table•UPDATE tablenameSET col1_name = new_col1_value, col2_name = new_col2_value, …;•Updating a table with conditions•UPDATE tablenameSET col1_name = new_col1_value, col2_name = new_col2_value, …WHERE predicate;\nECE30030/ITP30010 Database Systems57\nUPDATE•Give a 5% salary raise to all instructors•UPDATE instructorSET salary = salary * 1.05•Give a 5% salary raise to those instructors who earn less than 70000•UPDATE instructorSET salary = salary * 1.05WHERE salary < 70000;•Give a 5% salary raise to instructors whose salary is less than average•UPDATE instructorSET salary = salary * 1.05WHERE salary <  (SELECT AVG(salary) FROM instructor);\nECE30030/ITP30010 Database Systems58\nUPDATE•Increase salaries of instructors whose salary is over $100,000 by 3%, and all others by a 5%•Write two UPDATE statements:  UPDATE instructor  SET salary = salary * 1.03  WHERE salary > 100000;  UPDATE instructor  SET salary = salary * 1.05  WHERE salary <= 100000;•The order is important•Can be done better using the case statement (next slide)\nECE30030/ITP30010 Database Systems59\nCASE Statement for Conditional Update•The following query is equivalent to the previous UPDATE queries•UPDATE instructorSET salary = CASE                           WHEN salary <= 100000 THEN salary * 1.05                           ELSE salary * 1.03                       END\nECE30030/ITP30010 Database Systems60\nUPDATE with Scalar Subqueries•Recompute and update tot_creds value for all students•UPDATE student SSET tot_cred = (SELECT SUM(credits)                             FROM takes, course                             WHERE takes.course_id = course.course_id  AND                                            S.ID= takes.ID  AND                                            takes.grade <> 'F' AND                                            takes.grade IS NOT NULL);\nECE30030/ITP30010 Database Systems61\nDELETE•Basic syntax•To remove specific rows•DELETE FROM tablenameWHERE predicate;•To remove all rows•DELETE FROM tablename;•This is equivalent to TRUNCATE:TRUNCATE (TABLE) tablename;•One cannot truncate a table with foreign key constraints•Must disable the constraints first (we will cover ALTER when we study SQL DDL):ALTER TABLE tablenameDISABLE CONSTRAINT constraint_name;\nECE30030/ITP30010 Database Systems62\nDELETE•Delete all instructors•DELETE FROM instructor;•Delete all instructors from the Finance department•DELETE FROM instructorWHERE dept_name= 'Finance';•Delete all tuples in the instructor relation for those instructors associated with a department located in the Watson building•DELETE FROM instructorWHERE dept name IN (SELECT dept name        FROM department        WHERE building = 'Watson');\nECE30030/ITP30010 Database Systems63\nDELETE•Delete all instructors whose salary is less than the average salary of instructors•Example:  DELETE FROM instructor                WHERE salary < (SELECT AVG (salary)                  FROM instructor);•Issue:  as we delete tuples from instructor, the average salary changes•Solution used in SQL:1.First, compute AVG(salary) and find all tuples to delete2.Next, delete all tuples found above (without recomputing AVG or retesting the tuples)\nECE30030/ITP30010 Database Systems64"
        }
      ],
      "generated_content": [],
      "log_entries": [
        {
          "node": "start_processing",
          "status": "completed",
          "state_snapshot": {
            "run_id": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d",
            "pdf_file_paths": [
              "temp_pdf_uploads/cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_1a4c2f45-b482-4e82-826e-fa8945eb99c7_DB03 - mysql.pdf",
              "temp_pdf_uploads/cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf"
            ],
            "notebook_title": "",
            "holistic_chapters": [],
            "generated_content": [],
            "final_result": ""
          }
        },
        {
          "node": "start_processing",
          "status": "completed",
          "state_snapshot": {
            "run_id": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d",
            "pdf_file_paths": [
              "temp_pdf_uploads/cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_1a4c2f45-b482-4e82-826e-fa8945eb99c7_DB03 - mysql.pdf",
              "temp_pdf_uploads/cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf"
            ],
            "notebook_title": "",
            "holistic_chapters": [],
            "generated_content": [],
            "final_result": ""
          }
        },
        {
          "node": "analyze_overall_structure",
          "status": "completed",
          "state_snapshot": {
            "run_id": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d",
            "pdf_file_paths": [
              "temp_pdf_uploads/cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_1a4c2f45-b482-4e82-826e-fa8945eb99c7_DB03 - mysql.pdf",
              "temp_pdf_uploads/cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf"
            ],
            "notebook_title": "관계형 데이터베이스 시스템: MySQL 소개 및 SQL 심층 활용",
            "holistic_chapters": [
              {
                "chapter_title": "관계형 데이터베이스 시스템(R-DBMS) 개요 및 MySQL 소개",
                "source_pdf_filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_1a4c2f45-b482-4e82-826e-fa8945eb99c7_DB03 - mysql.pdf",
                "chapter_content_summary": "이 장에서는 관계형 데이터베이스 관리 시스템(R-DBMS)의 기본 개념을 소개하고, 대표적인 오픈소스 R-DBMS인 MySQL에 대해 심층적으로 다룹니다. MySQL의 정의, Oracle 소유권, 표준 SQL 호환성, 상업적 웹 서비스에서의 활용 사례, 기업 사용 통계, 그리고 MySQL의 인기 요인(다양한 운영체제 및 프로그래밍 언어 지원, 비용 효율성, 고성능)을 설명합니다. 또한, R-DBMS 시장에서의 MySQL의 트렌드와 인기도를 살펴보고, MySQL 5.x와 8.x 버전의 주요 차이점 및 MySQL 커뮤니티 버전을 다운로드하고 Docker 이미지를 활용하는 방법을 안내합니다. MySQL이 대규모 데이터 처리, 다중 사용자 지원, 효율성, 안정성, 보안성 측면에서 갖는 강점들을 강조합니다.",
                "chapter_full_text": "ECE30030/ITP30010 Database SystemsHandshaking with an R-DBMSCharmgil Hongcharmgil@handong.eduSpring, 2025Handong Global University\n1\nAgenda•Introduction to MySQL•SQL preview\nECE30030/ITP30010 Database Systems2\nMySQL•MySQL is an SQL-based relational database management system (DBMS)•Free and open-source R-DBMS (under GPL)•Owned by Oracle•Commercial version of MySQL is also provided (including technical support)•“My” came from the name of co-founder Michael Widenius’ daughter•C.f., MariaDB•Compatible with standard SQL•Frequently used for commercial web services\nECE30030/ITP30010 Database Systems3\n* Image src: https://en.wikipedia.org/wiki/MySQL\nMySQL•Companies using MySQL (a study by Enlyft)•“We have data on 199,498 (out of 1,409,176) companies that use MySQL”•Often used by companies with 10-50 employees and 1M-10M dollars in revenue•C.f., Oracle 12 is most often used by companies with 50-200 employees and >1000M dollars in revenue\nECE30030/ITP30010 Database Systems4* Source: https://enlyft.com/tech/products/mysql \nMySQL•Companies using MySQL (full list: https://www.mysql.com/customers/)\nECE30030/ITP30010 Database Systems5\n* Source: https://stackshare.io/mysql \nMySQL•Why MySQL?•Popular•Active discussions all over the Internet•Versatile: runs on Linux, Windows, Mac OS X, Solaris, FreeBSD, …•Supports wide range of programming languages (C/C++, Java, Python, .Net, …)•Cost starts from zero•High performance (fast and reliable)\nECE30030/ITP30010 Database Systems6* Image src: https://db-engines.com/en/ranking\nDBMS Trend Popularity\n•Score definition: https://db-engines.com/en/ranking_definition\nECE30030/ITP30010 Database Systems7* Image src: https://db-engines.com/en/ranking_trend \nMySQL•Why MySQL?•Popular•Active discussions all over the Internet•Versatile: runs on Linux, Windows, Mac OS X, Solaris, FreeBSD, …•Supports wide range of programming languages (C/C++, Java, Python, .Net, …)•Cost starts from zero•High performance (fast and reliable)\nECE30030/ITP30010 Database Systems8* Image src: https://dev.mysql.com/downloads/\nMySQL\nECE30030/ITP30010 Database Systems9\n•Massive•Convenient•Multi-user•Safe•Efficient•Reliable\nCan handle terabytes of dataSupports high-level query languageSupports concurrent data accessSupports transactionsCan handle thousands of queries/second99.99% up-time in many real-world products\nMySQL Versions•MySQL 5.x vs 8.x\nECE30030/ITP30010 Database Systems10\nVersion 5.x-Most popular version of MySQL-More stable and conventionalVersion 8.x-Current version-Provides up-to-date DB functionalities (better storage engine, faster, more secure)\n* Source: https://www.eversql.com/mysql-8-adoption-usage-rate/#:~:text=MySQL%205.7%20is%20still%20the,17%25%20are%20using%20MySQL%208. \nMySQL Versions•MySQL 5.x vs 8.x\nECE30030/ITP30010 Database Systems11\nVersion 5.x-Most popular version of MySQL-More stable and conventionalVersion 8.x-Current version-Provides up-to-date DB functionalities (better storage engine, faster, more secure)\n* Source: https://severalnines.com/database-blog/mysql-performance-benchmarking-mysql-57-vs-mysql-80 \nMySQL Versions•MySQL 5.x vs 8.x\nECE30030/ITP30010 Database Systems12\nVersion 5.x-Most popular version of MySQL-More stable and conventionalVersion 8.x-Current version-Provides up-to-date DB functionalities (better storage engine, faster, more secure)\n* Source: https://severalnines.com/database-blog/mysql-performance-benchmarking-mysql-57-vs-mysql-80 \nWhere to Get MySQL?•https://dev.mysql.com/downloads/•Look for the “Community” versions – the branch that is available for free•”Enterprise” versions are the commercial ones•We have prepared a Docker image for the course•Consists of Ubuntu Server, MySQL, example databases for course activities\nECE30030/ITP30010 Database Systems13* Image src: https://www.docker.com \nWhere to Get MySQL?\nECE30030/ITP30010 Database Systems14\n* Image source: https://baumannalexj.medium.com/connect-your-db-tool-to-a-dockerized-mysql-server-container-bc18853524ed   https://www.jetbrains.com/datagrip/features/look_and_feel.html"
              },
              {
                "chapter_title": "SQL(구조적 질의어)의 이해: 기본 개념과 역사",
                "source_pdf_filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf",
                "chapter_content_summary": "SQL(Structured Query Language)의 정의와 관계형 데이터베이스를 조작하는 주된 언어로서의 역할을 설명합니다. SQL이 '무엇을 할지'를 명시하는 고수준 언어이며, DBMS가 '어떻게 할지'를 결정하는 쿼리 최적화 과정을 다룹니다. 또한, SQL의 두 가지 주요 측면인 데이터 정의 언어(DDL)와 데이터 조작 언어(DML)를 소개하고, 무결성, 뷰 정의, 트랜잭션 제어, 내장 SQL 및 동적 SQL, 권한 부여와 같은 SQL의 다양한 구성 요소를 살펴봅니다. 마지막으로, IBM SEQUEL에서 시작하여 Oracle V2를 거쳐 ANSI 및 ISO 표준으로 발전한 SQL의 간략한 역사를 소개하고, 기본적인 SQL 쿼리 구조(SELECT, FROM, WHERE)를 설명합니다.",
                "chapter_full_text": "ECE30030/ITP30010 Database SystemsStructured Query LanguageReading: Chapter 3\nCharmgil Hongcharmgil@handong.eduSpring, 2025Handong Global University\n1\nAgenda•Structured query language (SQL)•SQL data manipulation language (DML)•SELECT, FROM, WHERE•NULL values•Set operations•String operations, ordering•Aggregate functions, aggregation•SQL data definition language (DDL)   --   NEXT CLASS\nECE30030/ITP30010 Database Systems2\nStructured Query Language (SQL)•SQL: Structured Query Language•The principal language used to describe and manipulate relational databases•Very high-level•Say “what to do” rather than “how to do it”•SQL is not specifying data-manipulation details•DBMSs figure out the “best” way to execute queries•Called “query optimization”•Two aspects to SQL•Data definition: for declaring database schemas (DDL)•Data manipulation: for querying (asking questions about) databases and for modifying the database (DML)\nECE30030/ITP30010 Database Systems3\nSQL Parts•DML – provides the ability to query information from the database and to insert tuples into, delete tuples from, and modify tuples in the database•Integrity – the DDL includes commands for specifying integrity constraints•View definition – the DDL includes commands for defining views•Transaction control – includes commands for specifying the beginning and ending of transactions•Embedded SQL and dynamic SQL – define how SQL statements can be embedded within general-purpose programming language•Authorization – includes commands for specifying access rights to relations and viewsECE30030/ITP30010 Database Systems4\nA Brief History•IBM SEQUEL (Structured English Query Language) was developed as a part of the System R project (Chamberlin and Boyce, early 1970s)•Later on, SEQUEL was renamed SQL (structured query language)•System R à System/38 (1979), SQL/DS (1981), DB2 (1983)•Relational Software, Inc released the first commercial implementation of SQL, Oracle V2 for VAX computers•Relational Software, Inc is now Oracle Corporation•ANSI and ISO standardized SQL:•SQL-86,  SQL-89,  SQL-92,  SQL:1999,  …,  SQL:2011,  SQL:2016 (current)•SQL-92 is supported by the most of database systems\nECE30030/ITP30010 Database Systems5\nBasic Query Structure•A typical SQL query has the form:   SELECT A1, A2, ..., An FROM r1, r2, ..., rm WHERE P•Ai represents an attribute•Ri represents a relation•P is a predicate\n•The result of an SQL query is a relation\nECE30030/ITP30010 Database Systems6"
              },
              {
                "chapter_title": "SQL 데이터 조작 언어(DML) 기초: SELECT, FROM, WHERE 절",
                "source_pdf_filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf",
                "chapter_content_summary": "이 장에서는 SQL 데이터 조작 언어(DML)의 핵심 구성 요소인 SELECT, FROM, WHERE 절을 상세히 다룹니다. 'instructor' 및 'teaches'와 같은 예시 관계(테이블)를 사용하여 실제 쿼리 작성 방법을 시연합니다. SELECT 절을 통해 원하는 속성을 선택하고, 중복을 포함하거나 제거하는 방법(ALL, DISTINCT), 모든 속성을 선택하는 '*' 사용법, 리터럴 및 산술 표현식 활용, 그리고 AS 키워드를 사용한 속성 이름 변경 방법을 학습합니다. WHERE 절에서는 논리 연산자(AND, OR, NOT) 및 비교 연산자(<, <=, >, >=, =, <>, BETWEEN)를 사용하여 조건을 지정하고, 튜플 비교를 수행하는 방법을 설명합니다. 마지막으로 FROM 절을 통해 쿼리에 포함될 관계를 지정하고, 카르테시안 곱을 이해하며, WHERE 절과 결합하여 JOIN 연산을 구현하는 방법을 구체적인 예시와 함께 제시합니다. 또한, AS 키워드를 이용한 관계 및 속성 이름 변경(별칭 지정)을 다룹니다.",
                "chapter_full_text": "ECE30030/ITP30010 Database Systems7\nSQL Data Manipulation Language•The SQL data-manipulation language (DML) allows querying (ask questions about) and modifying the databases\nECE30030/ITP30010 Database Systems8\nRunning Examples•Relations (tables): instructor, teaches\nECE30030/ITP30010 Database Systems9\nInstructor relationteaches relation\nBasic Query Structure•A typical SQL query has the form:   SELECT A1, A2, ..., An FROM r1, r2, ..., rm WHERE P•Ai represents an attribute•Ri represents a relation•P is a predicate\n•The result of an SQL query is a relation\nECE30030/ITP30010 Database Systems10\nThe SELECT Clause•The SELECT clause lists the attributes desired in the result of a query•Corresponds to the projection operation of the relational algebra\n•Example: Find the names of all instructors•SQL: SELECT name FROM instructor;\nECE30030/ITP30010 Database Systems11\nNote•Note: SQL names are case insensitive•E.g., Name ≡ NAME ≡ name•SQL commands (SELECT, FROM, WHERE, …) are written in upper case (just a convention)•MySQL has an option flag, lower_case_table_names•Link: https://dev.mysql.com/doc/refman/8.0/en/identifier-case-sensitivity.html \nECE30030/ITP30010 Database Systems12\nThe SELECT Clause•SQL allows duplicates in relations as well as in query results•The keyword ALL specifies that duplicates should not be removed SELECT ALL dept_name FROM instructor\nECE30030/ITP30010 Database Systems13\nThe SELECT Clause•SQL allows duplicates in relations as well as in query results•The keyword ALL specifies that duplicates should not be removed SELECT ALL dept_name FROM instructor•To force the elimination of duplicates, insert the keyword DISTINCT after SELECT•Find the department names of all instructor, removing duplicates: SELECT DISTINCT dept_name FROM instructor;\nECE30030/ITP30010 Database Systems14\nThe SELECT Clause•An asterisk in the select clause denotes “all attributes” SELECT * FROM instructor;•An attribute can be a literal with no FROM clause SELECT ‘437’;•Result is a table with one column and a single row with value “437”•Can give the column a name using AS: SELECT ‘437’ AS FOO\nECE30030/ITP30010 Database Systems15\nThe SELECT Clause•An attribute can be a literal with FROM clause SELECT 'A' FROM instructor•Result is a table with one column and N rows (number of tuples in the instructor table), each row with value “A”\nECE30030/ITP30010 Database Systems16\nThe SELECT Clause•The SELECT clause can contain arithmetic expressions involving the operation, +, –, *, and /, and operating on constants or attributes of tuples•The query:     SELECT ID, name, salary/12      FROM instructorwould return a relation that is the same as the instructor relation,except that the value of the attribute salary is divided by 12\n17\nThe SELECT Clause•The SELECT clause can contain arithmetic expressions involving the operation, +, –, *, and /, and operating on constants or attributes of tuples•Can rename “salary/12” using the AS clause:  SELECT ID, name, salary/12 AS monthly_salary   FROM instructor\n18\nThe WHERE Clause•The WHERE clause specifies conditions that the result must satisfy•Corresponds to the selection predicate of the relational algebra•E.g., To find all instructors in Comp. Sci. dept: SELECT name FROM instructor  WHERE dept_name = 'Comp. Sci.';\nECE30030/ITP30010 Database Systems19\nThe WHERE Clause•SQL allows the use of the logical connectives AND, OR, and NOT•The operands of the logical connectives can be expressions involving the comparison operators <, <=, >, >=, =, and <>•<> means not equal (there is no != in SQL)•Comparisons can be applied to results of arithmetic expressions•E.g., To find all instructors in Comp. Sci. with salary > 70,000: SELECT name FROM instructor WHERE dept_name = 'Comp. Sci.' AND salary > 70000;\nECE30030/ITP30010 Database Systems20\nThe WHERE Clause•SQL includes a BETWEEN comparison operator•Example: Find the names of all instructors with salary between $90,000 and $100,000 (that is, ³ $90,000 and £ $100,000)•SELECT nameFROM instructorWHERE salary BETWEEN 90000 AND 100000\nECE30030/ITP30010 Database Systems21\nThe WHERE Clause•Tuple comparison: makes comparisons per tuple•SELECT name, course_idFROM instructor, teachesWHERE (instructor.ID, dept_name) = (teaches.ID, 'Biology');\nECE30030/ITP30010 Database Systems22\nThe FROM Clause•The FROM clause lists the relations involved in the query•Corresponds to the Cartesian-product operation of the relational algebra•Find the Cartesian-product instructor × teaches SELECT * FROM instructor, teaches;•Generates every possible instructor-teaches pairs, with all attributes from both relations•For common attributes (e.g., ID), the attributes in the resulting table are renamed using the relation name (e.g., instructor.ID)\nECE30030/ITP30010 Database Systems23\nThe FROM Clause•Find the Cartesian-product instructor X teaches SELECT * FROM instructor, teaches;\n24\ninstructor.IDnamedept_namesalaryteaches.IDcourse_idsec_idsemesteryear10101SrinivasanComp. Sci.6500076766BIO-101 1Summer201712121WuFinance9000076766BIO-101 1Summer201715151MozartMusic4000076766BIO-101 1Summer201722222EinsteinPhysics9500076766BIO-101 1Summer201732343El SaidHistory6000076766BIO-101 1Summer2017… … … … … … … … …10101SrinivasanComp. Sci.6500010101CS-101 1Fall 201712121WuFinance9000010101CS-101 1Fall 201715151MozartMusic4000010101CS-101 1Fall 201722222EinsteinPhysics9500010101CS-101 1Fall 201732343El SaidHistory6000010101CS-101 1Fall 2017… … … … … … … … …… … … … … … … … …10101SrinivasanComp. Sci.6500083821CS-190 2Spring201712121WuFinance9000083821CS-190 2Spring201715151MozartMusic4000083821CS-190 2Spring2017… … … … … … … … …10101SrinivasanComp. Sci.6500010101CS-315 1Spring201812121WuFinance9000010101CS-315 1Spring201815151MozartMusic4000010101CS-315 1Spring2018… … … … … … … … …… … … … … … … … …\nImplementing JOIN•Cartesian-product is not very useful directly; but useful combined with WHERE-clause condition (selection operation in relational algebra)•Cartesian-product + selection = join•E.g., Find the names of all instructors who have taught some course and the course_id SELECT name, course_id FROM instructor , teaches WHERE instructor.ID = teaches.ID\nECE30030/ITP30010 Database Systems25\nImplementing JOIN•Cartesian-product is not very useful directly; but useful combined with WHERE-clause condition (selection operation in relational algebra)•Cartesian-product + selection = join•Find the names of all instructors in the Music department who have taught some course and the course_id SELECT name, course_id FROM instructor , teaches WHERE instructor.ID = teaches.ID  AND instructor. dept_name = 'Music'\nECE30030/ITP30010 Database Systems26\nThe Rename Operation•The SQL allows renaming relations and attributes using the AS clause:   old-name AS new-name•Find the names of all instructors who have a higher salary than some instructor in ‘Comp. Sci.’•SELECT DISTINCT T.nameFROM instructor AS T, instructor AS SWHERE T.salary > S.salary AND S.dept_name = 'Comp. Sci.'\nECE30030/ITP30010 Database Systems27\nThe Rename Operation•The SQL allows renaming relations and attributes using the AS clause:   old-name AS new-name•Find the names of all instructors who have a higher salary than some instructor in ‘Comp. Sci.’•SELECT DISTINCT T.nameFROM instructor AS T, instructor AS SWHERE T.salary > S.salary AND S.dept_name = 'Comp. Sci.'•Keyword AS is optional and may be omitted  instructor AS T  ≡  instructor T\nECE30030/ITP30010 Database Systems28"
              },
              {
                "chapter_title": "SQL DML 고급 기능: NULL 값, 집합 연산, 문자열 처리 및 정렬",
                "source_pdf_filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf",
                "chapter_content_summary": "이 장에서는 SQL DML의 고급 기능을 탐구합니다. 먼저, 알려지지 않거나 존재하지 않는 값을 나타내는 NULL 값의 특성을 이해하고, 산술 연산에서의 NULL 동작 및 IS NULL / IS NOT NULL 술어를 사용하여 NULL 값을 확인하는 방법을 배웁니다. 다음으로, 여러 쿼리 결과를 결합하는 집합 연산인 UNION, INTERSECT, EXCEPT를 살펴봅니다. 각 연산이 기본적으로 중복을 제거하며, ALL 키워드를 사용하여 중복을 유지하는 방법을 설명합니다. 특히 MySQL에서 INTERSECT와 EXCEPT가 직접 지원되지 않을 때 JOIN 또는 NOT IN을 사용하여 에뮬레이션하는 기법을 소개합니다. 이어서, 문자열 패턴 매칭을 위한 LIKE 연산자와 '%' (모든 부분 문자열), '_' (단일 문자) 특수 문자의 사용법을 다룹니다. 백슬래시를 이용한 이스케이프 문자 처리, 패턴 매칭의 대소문자 구분, 그리고 연결, 대소문자 변환, 길이 확인, 부분 문자열 추출 등 다양한 SQL 문자열 함수를 소개합니다. 마지막으로, ORDER BY 절을 사용하여 쿼리 결과를 특정 속성을 기준으로 오름차순(ASC) 또는 내림차순(DESC)으로 정렬하는 방법을 학습하며, 여러 속성을 기준으로 정렬하는 예시도 제시합니다.",
                "chapter_full_text": "ECE30030/ITP30010 Database Systems29\nNULL Values•It is possible for tuples to have a NULL value for some of their attributes•NULL signifies an unknown value or that a value does not exist•The result of any arithmetic expression involving NULL is NULL•E.g.,  5 + NULL returns NULL\nECE30030/ITP30010 Database Systems30\nIS NULL / IS NOT NULL•The predicate IS NULL can be used to check for NULL values•E.g., Find all instructors whose salary is null SELECT name FROM instructor WHERE salary IS NULL•The predicate IS NOT NULL succeeds if the value on which it is applied is not null\nECE30030/ITP30010 Database Systems31\nECE30030/ITP30010 Database Systems32\nSet Operations•Set operations UNION, INTERSECT, and EXCEPT•Each of the above operations automatically eliminates duplicates•To retain all duplicates, use ALL:•UNION ALL•INTERSECT ALL•EXCEPT ALL\n•C.f., SELECT retains all duplicates by default\nECE30030/ITP30010 Database Systems33\nSet Operations: UNION•Find courses that ran in Fall 2017 or in Spring 2018•(SELECT course_id  FROM teaches WHERE semester = 'Fall' AND year = 2017)UNION(SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018)\nECE30030/ITP30010 Database Systems34\nSet Operations: INTERSECT•Find courses that ran in Fall 2017 and in Spring 2018•(SELECT course_id  FROM teaches WHERE semester = 'Fall' AND year = 2017)INTERSECT(SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018)•C.f., MySQL does NOT support INTERSECT•One can emulate INTERSECT using JOIN (we’ll study JOIN later)•SELECT LT.course_idFROM (SELECT course_id FROM teaches WHERE semester = 'Fall' AND year = 2017) AS LTJOIN (SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018) AS RTON LT.course_id=RT.course_id;\nECE30030/ITP30010 Database Systems35\nSet Operations: EXCEPT•Find courses that ran in Fall 2017 but not in Spring 2018•(SELECT course_id  FROM teaches WHERE semester = 'Fall' AND year = 2017)EXCEPT(SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018)•C.f., MySQL does NOT support EXCEPT•One can emulate EXCEPT using NOT IN•SELECT course_id FROM teaches WHERE semester = 'Fall' AND year = 2017AND course_id NOT IN(SELECT course_id  FROM teaches  WHERE semester = 'Spring' AND year = 2018);\nECE30030/ITP30010 Database Systems36\nECE30030/ITP30010 Database Systems37\nString Operations•SQL includes a string-matching operator for comparisons on character strings•The operator LIKE uses patterns that are described using two special characters:•percent (%) – The % character matches any substring•underscore (_) – The _ character matches any character•Find the names of all instructors whose name includes the substring “ri” SELECT name FROM instructor WHERE name LIKE ‘%ri%'\nECE30030/ITP30010 Database Systems38\nString Operations•Escape character: Use backslash (\\) as the escape character•E.g., Match the string “100%” LIKE '100 \\%’ ESCAPE  ‘\\’\nECE30030/ITP30010 Database Systems39\nString Operations•Patterns are case sensitive•Pattern matching examples:•'Intro%' matches any string beginning with “Intro”•'%Comp%' matches any string containing “Comp” as a substring•'_ _ _' matches any string of exactly three characters•'_ _ _ %' matches any string of at least three characters•SQL supports a variety of string operations such as•concatenation (using “||”)•converting from upper to lower case (and vice versa)•finding string length, extracting substrings, etc.\nECE30030/ITP30010 Database Systems40\nOrdering the Display of Tuples•List in alphabetic order the names of all instructors•SELECT DISTINCT nameFROM instructorORDER BY name\nECE30030/ITP30010 Database Systems41\nOrdering the Display of Tuples•Can sort on multiple attributes•E.g., SELECT dept_name, name     FROM instructor      ORDER BY dept_name, name\nECE30030/ITP30010 Database Systems42\nOrdering the Display of Tuples•We may specify DESC for descending order or ASC for ascending order, for each attribute; ascending order is the default•E.g., ORDER BY name DESC\nECE30030/ITP30010 Database Systems43"
              },
              {
                "chapter_title": "SQL DML 집계 함수 및 데이터 수정 (INSERT, UPDATE, DELETE)",
                "source_pdf_filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf",
                "chapter_content_summary": "이 장에서는 SQL 데이터 조작 언어(DML)의 고급 기능인 집계 함수와 데이터를 수정하는 명령어를 다룹니다. AVG, MIN, MAX, SUM, COUNT와 같은 집계 함수를 사용하여 컬럼 값의 멀티셋에 대한 통계 값을 계산하는 방법을 학습합니다. 특히 GROUP BY 절을 이용한 데이터 그룹화와 HAVING 절을 이용한 그룹별 필터링을 심층적으로 다루며, WHERE 절과의 차이점을 명확히 설명합니다. 또한, DML의 핵심 명령인 INSERT, UPDATE, DELETE에 대해 자세히 알아봅니다. INSERT 명령을 통해 테이블에 새로운 튜플을 추가하는 다양한 방법(모든 컬럼, 선택된 컬럼, NULL 값 처리, SELECT 쿼리 결과 삽입)과 외래 키 제약 조건의 중요성을 강조합니다. UPDATE 명령으로는 기존 데이터를 수정하는 기본 구문, 조건부 업데이트, CASE 문을 사용한 복잡한 조건 처리, 스칼라 서브쿼리 활용법을 배웁니다. 마지막으로 DELETE 명령을 통해 테이블에서 특정 행 또는 모든 행을 삭제하는 방법과 TRUNCATE 명령의 차이점, 그리고 삭제 시 서브쿼리 사용 시의 고려사항을 설명합니다.",
                "chapter_full_text": "ECE30030/ITP30010 Database Systems44\nAggregate Functions•These functions operate on the multiset of values of a column of a relation, and return a value•AVG:  average value•MIN:  minimum value•MAX:  maximum value•SUM:  sum of values•COUNT:  number of values\nECE30030/ITP30010 Database Systems45\nAggregate Functions Examples•Find the average salary of instructors in the Computer Science department•SELECT AVG(salary)FROM instructorWHERE dept_name= 'Comp. Sci.';•Find the total number of instructors who teach a course in the Spring 2018 semester•SELECT COUNT(DISTINCT ID)FROM teachesWHERE semester = 'Spring’ AND year = 2018;•Find the number of tuples in the teaches relation•SELECT COUNT (*)FROM teaches;\nECE30030/ITP30010 Database Systems46\nAggregate Functions: Group By•Find the average salary of instructors in each department•SELECT dept_name, AVG(salary) AS avg_salaryFROM instructorGROUP BY dept_name;\nECE30030/ITP30010 Database Systems47\nAggregation•Attributes in SELECT clause outside of aggregate functions must appear in GROUP BY list•/* erroneous query */SELECT dept_name, ID, AVG(salary)FROM instructorGROUP BY dept_name;\nECE30030/ITP30010 Database Systems48\nAggregate Functions – Having Clause•Find the names and average salaries of all departments whose average salary is greater than 65000•SELECT dept_name, AVG(salary) AS avg_salaryFROM instructorGROUP BY dept_nameHAVING AVG(salary) > 65000;\nECE30030/ITP30010 Database Systems49\nAggregate Functions – Having Clause•Note: predicates in the HAVING clause are applied after the formation of groups whereas predicates in the WHERE clause are applied before forming groups\nECE30030/ITP30010 Database Systems50\nSELECT dept_name, AVG(salary) AS avg_salaryFROM instructorGROUP BY dept_nameHAVING AVG(salary) > 65000;\nSELECT dept_name, AVG(salary) AS avg_salaryFROM instructorWHERE salary > 65000GROUP BY dept_name;\nSQL Commands\nSQLDMLSELECTINSERTUPDATEDELETE\nDDLCREATEALTERDROP\nECE30030/ITP30010 Database Systems51\nINSERT•Basic syntax•Insert data into every column:•INSERT INTO tablenameVALUES (col1_value, col2_value, …)•Must list values in the same order as in the table schema•If some data values are unknown, must type NULL •For character sequences, use quotation marks•Single quotation marks are preferred (but double quotation marks are allowed)•Value in quotations is case-sensitive•Insert data into selected columns•INSERT INTO tablename (col1_name, col3_name, col4_name, …)VALUES (col1_value, col3_value, col4_value, …)\nECE30030/ITP30010 Database Systems52\nINSERT•Add a new tuple to course•INSERT INTO courseVALUES ('CS-437', 'Database Systems', 'Comp. Sci.', 4);•or equivalently•INSERT INTO course (course_id, title, dept_name, credits)VALUES ('CS-437', 'Database Systems', 'Comp. Sci.', 4);•Add a new tuple to student  with tot_creds set to null•INSERT INTO studentVALUES ('3003', 'Green', 'Finance', null);\nECE30030/ITP30010 Database Systems53\nINSERT•A foreign key specifies that an attribute from one relation has to map to a tuple in another relation•Value in one relation must appear in another relation\nECE30030/ITP30010 Database Systems54\nRelation: instructor\nRelation: department\nINSERT•A foreign key specifies that an attribute from one relation has to map to a tuple in another relation•Value in one relation must appear in another relation•Make sure all foreign keys that new row references have already been added to database•One cannot insert a foreign key value unless the corresponding value exists in the referenced relation\nECE30030/ITP30010 Database Systems55\nINSERT•Inserting results of other SELECT query•Make each student in the Music department who has earned more than 144 credit hours an instructor in the Music department with a salary of  $18,000•INSERT INTO instructor  SELECT ID, name, dept_name, 18000  FROM student   WHERE dept_name = 'Music’ AND total_cred > 144;•The SELECT FROM WHERE statement is evaluated fully before any of its results are inserted into the relation•Otherwise queries like  INSERT INTO table1 SELECT * FROM table1would cause problem\nECE30030/ITP30010 Database Systems56\nUPDATE•Basic syntax•Updating a table•UPDATE tablenameSET col1_name = new_col1_value, col2_name = new_col2_value, …;•Updating a table with conditions•UPDATE tablenameSET col1_name = new_col1_value, col2_name = new_col2_value, …WHERE predicate;\nECE30030/ITP30010 Database Systems57\nUPDATE•Give a 5% salary raise to all instructors•UPDATE instructorSET salary = salary * 1.05•Give a 5% salary raise to those instructors who earn less than 70000•UPDATE instructorSET salary = salary * 1.05WHERE salary < 70000;•Give a 5% salary raise to instructors whose salary is less than average•UPDATE instructorSET salary = salary * 1.05WHERE salary <  (SELECT AVG(salary) FROM instructor);\nECE30030/ITP30010 Database Systems58\nUPDATE•Increase salaries of instructors whose salary is over $100,000 by 3%, and all others by a 5%•Write two UPDATE statements:  UPDATE instructor  SET salary = salary * 1.03  WHERE salary > 100000;  UPDATE instructor  SET salary = salary * 1.05  WHERE salary <= 100000;•The order is important•Can be done better using the case statement (next slide)\nECE30030/ITP30010 Database Systems59\nCASE Statement for Conditional Update•The following query is equivalent to the previous UPDATE queries•UPDATE instructorSET salary = CASE                           WHEN salary <= 100000 THEN salary * 1.05                           ELSE salary * 1.03                       END\nECE30030/ITP30010 Database Systems60\nUPDATE with Scalar Subqueries•Recompute and update tot_creds value for all students•UPDATE student SSET tot_cred = (SELECT SUM(credits)                             FROM takes, course                             WHERE takes.course_id = course.course_id  AND                                            S.ID= takes.ID  AND                                            takes.grade <> 'F' AND                                            takes.grade IS NOT NULL);\nECE30030/ITP30010 Database Systems61\nDELETE•Basic syntax•To remove specific rows•DELETE FROM tablenameWHERE predicate;•To remove all rows•DELETE FROM tablename;•This is equivalent to TRUNCATE:TRUNCATE (TABLE) tablename;•One cannot truncate a table with foreign key constraints•Must disable the constraints first (we will cover ALTER when we study SQL DDL):ALTER TABLE tablenameDISABLE CONSTRAINT constraint_name;\nECE30030/ITP30010 Database Systems62\nDELETE•Delete all instructors•DELETE FROM instructor;•Delete all instructors from the Finance department•DELETE FROM instructorWHERE dept_name= 'Finance';•Delete all tuples in the instructor relation for those instructors associated with a department located in the Watson building•DELETE FROM instructorWHERE dept name IN (SELECT dept name        FROM department        WHERE building = 'Watson');\nECE30030/ITP30010 Database Systems63\nDELETE•Delete all instructors whose salary is less than the average salary of instructors•Example:  DELETE FROM instructor                WHERE salary < (SELECT AVG (salary)                  FROM instructor);•Issue:  as we delete tuples from instructor, the average salary changes•Solution used in SQL:1.First, compute AVG(salary) and find all tuples to delete2.Next, delete all tuples found above (without recomputing AVG or retesting the tuples)\nECE30030/ITP30010 Database Systems64"
              }
            ],
            "generated_content": [],
            "final_result": ""
          }
        }
      ],
      "final_result": ""
    }
  },
  {
    "node": "generate_chapter_content",
    "status": "completed",
    "state_snapshot": {
      "run_id": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d",
      "pdf_file_paths": [
        "temp_pdf_uploads/cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_1a4c2f45-b482-4e82-826e-fa8945eb99c7_DB03 - mysql.pdf",
        "temp_pdf_uploads/cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf"
      ],
      "all_pdf_texts": [
        {
          "filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_1a4c2f45-b482-4e82-826e-fa8945eb99c7_DB03 - mysql.pdf",
          "text": "ECE30030/ITP30010 Database SystemsHandshaking with an R-DBMSCharmgil Hongcharmgil@handong.eduSpring, 2025Handong Global University\n1\n\nAgenda•Introduction to MySQL•SQL preview\nECE30030/ITP30010 Database Systems2\nMySQL•MySQL is an SQL-based relational database management system (DBMS)•Free and open-source R-DBMS (under GPL)•Owned by Oracle•Commercial version of MySQL is also provided (including technical support)•“My” came from the name of co-founder Michael Widenius’ daughter•C.f., MariaDB•Compatible with standard SQL•Frequently used for commercial web services\nECE30030/ITP30010 Database Systems3\n* Image src: https://en.wikipedia.org/wiki/MySQL\nMySQL•Companies using MySQL (a study by Enlyft)•“We have data on 199,498 (out of 1,409,176) companies that use MySQL”•Often used by companies with 10-50 employees and 1M-10M dollars in revenue•C.f., Oracle 12 is most often used by companies with 50-200 employees and >1000M dollars in revenue\nECE30030/ITP30010 Database Systems4* Source: https://enlyft.com/tech/products/mysql \n\nMySQL•Companies using MySQL (full list: https://www.mysql.com/customers/)\nECE30030/ITP30010 Database Systems5\n* Source: https://stackshare.io/mysql \nMySQL•Why MySQL?•Popular•Active discussions all over the Internet•Versatile: runs on Linux, Windows, Mac OS X, Solaris, FreeBSD, …•Supports wide range of programming languages (C/C++, Java, Python, .Net, …)•Cost starts from zero•High performance (fast and reliable)\nECE30030/ITP30010 Database Systems6* Image src: https://db-engines.com/en/ranking\n\nDBMS Trend Popularity\n•Score definition: https://db-engines.com/en/ranking_definition\nECE30030/ITP30010 Database Systems7* Image src: https://db-engines.com/en/ranking_trend \n\nMySQL•Why MySQL?•Popular•Active discussions all over the Internet•Versatile: runs on Linux, Windows, Mac OS X, Solaris, FreeBSD, …•Supports wide range of programming languages (C/C++, Java, Python, .Net, …)•Cost starts from zero•High performance (fast and reliable)\nECE30030/ITP30010 Database Systems8* Image src: https://dev.mysql.com/downloads/\n\nMySQL\nECE30030/ITP30010 Database Systems9\n•Massive•Convenient•Multi-user•Safe•Efficient•Reliable\nCan handle terabytes of dataSupports high-level query languageSupports concurrent data accessSupports transactionsCan handle thousands of queries/second99.99% up-time in many real-world products\nMySQL Versions•MySQL 5.x vs 8.x\nECE30030/ITP30010 Database Systems10\nVersion 5.x-Most popular version of MySQL-More stable and conventionalVersion 8.x-Current version-Provides up-to-date DB functionalities (better storage engine, faster, more secure)\n* Source: https://www.eversql.com/mysql-8-adoption-usage-rate/#:~:text=MySQL%205.7%20is%20still%20the,17%25%20are%20using%20MySQL%208. \nMySQL Versions•MySQL 5.x vs 8.x\nECE30030/ITP30010 Database Systems11\nVersion 5.x-Most popular version of MySQL-More stable and conventionalVersion 8.x-Current version-Provides up-to-date DB functionalities (better storage engine, faster, more secure)\n* Source: https://severalnines.com/database-blog/mysql-performance-benchmarking-mysql-57-vs-mysql-80 \n\nMySQL Versions•MySQL 5.x vs 8.x\nECE30030/ITP30010 Database Systems12\nVersion 5.x-Most popular version of MySQL-More stable and conventionalVersion 8.x-Current version-Provides up-to-date DB functionalities (better storage engine, faster, more secure)\n* Source: https://severalnines.com/database-blog/mysql-performance-benchmarking-mysql-57-vs-mysql-80 \n\nWhere to Get MySQL?•https://dev.mysql.com/downloads/•Look for the “Community” versions – the branch that is available for free•”Enterprise” versions are the commercial ones•We have prepared a Docker image for the course•Consists of Ubuntu Server, MySQL, example databases for course activities\nECE30030/ITP30010 Database Systems13* Image src: https://www.docker.com \n\nWhere to Get MySQL?\nECE30030/ITP30010 Database Systems14\n* Image source: https://baumannalexj.medium.com/connect-your-db-tool-to-a-dockerized-mysql-server-container-bc18853524ed   https://www.jetbrains.com/datagrip/features/look_and_feel.html\n\nAgenda•Introduction to MySQL•SQL preview\nECE30030/ITP30010 Database Systems15\nStructured Query Language (SQL)•SQL: Structured Query Language•The principal language used to describe and manipulate relational databases•Very high-level•Say “what to do” rather than “how to do it”•SQL is not specifying data-manipulation details•DBMSs figure out the “best” way to execute queries•Called “query optimization”•Two aspects to SQL•Data definition: for declaring database schemas (DDL)•Data manipulation: for querying (asking questions about) databases and for modifying the database (DML)\nECE30030/ITP30010 Database Systems16\nSQL Parts•DML – provides the ability to query information from the database and to insert tuples into, delete tuples from, and modify tuples in the database•Integrity – the DDL includes commands for specifying integrity constraints•Vide definition – the DDL includes commands for defining views•Transaction control – includes commands for specifying the beginning and ending of transactions•Embedded SQL and dynamic SQL – define how SQL statements can be embedded within general-purpose programming language•Authorization – includes commands for specifying access rights to relations and viewsECE30030/ITP30010 Database Systems17\nA Brief History•IBM SEQUEL (Structured English Query Language) was developed as a part of the System R project (Chamberlin and Boyce, early 1970s)•Later on, SEQUEL was renamed SQL (structured query language)•System R à System/38 (1979), SQL/DS (1981), DB2 (1983)•Relational Software, Inc released the first commercial implementation of SQL, Oracle V2 for VAX computers•Relational Software, Inc is now Oracle Corporation•ANSI and ISO standardized SQL:•SQL-86,  SQL-89,  SQL-92,  SQL:1999,  …,  SQL:2011,  SQL:2016 (current)•SQL-92 is supported by the most of database systems\nECE30030/ITP30010 Database Systems18\nBasic Query Structure•A typical SQL query has the form:   SELECT A1, A2, ..., An FROM r1, r2, ..., rm WHERE P•Ai represents an attribute•Ri represents a relation•P is a predicate\n•The result of an SQL query is a relation\nECE30030/ITP30010 Database Systems19\nEOF•Coming next:•Structured Query Language\nECE30030/ITP30010 Database Systems20"
        },
        {
          "filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf",
          "text": "ECE30030/ITP30010 Database SystemsStructured Query LanguageReading: Chapter 3\nCharmgil Hongcharmgil@handong.eduSpring, 2025Handong Global University\n1\n\nAgenda•Structured query language (SQL)•SQL data manipulation language (DML)•SELECT, FROM, WHERE•NULL values•Set operations•String operations, ordering•Aggregate functions, aggregation•SQL data definition language (DDL)   --   NEXT CLASS\nECE30030/ITP30010 Database Systems2\nStructured Query Language (SQL)•SQL: Structured Query Language•The principal language used to describe and manipulate relational databases•Very high-level•Say “what to do” rather than “how to do it”•SQL is not specifying data-manipulation details•DBMSs figure out the “best” way to execute queries•Called “query optimization”•Two aspects to SQL•Data definition: for declaring database schemas (DDL)•Data manipulation: for querying (asking questions about) databases and for modifying the database (DML)\nECE30030/ITP30010 Database Systems3\nSQL Parts•DML – provides the ability to query information from the database and to insert tuples into, delete tuples from, and modify tuples in the database•Integrity – the DDL includes commands for specifying integrity constraints•View definition – the DDL includes commands for defining views•Transaction control – includes commands for specifying the beginning and ending of transactions•Embedded SQL and dynamic SQL – define how SQL statements can be embedded within general-purpose programming language•Authorization – includes commands for specifying access rights to relations and viewsECE30030/ITP30010 Database Systems4\nA Brief History•IBM SEQUEL (Structured English Query Language) was developed as a part of the System R project (Chamberlin and Boyce, early 1970s)•Later on, SEQUEL was renamed SQL (structured query language)•System R à System/38 (1979), SQL/DS (1981), DB2 (1983)•Relational Software, Inc released the first commercial implementation of SQL, Oracle V2 for VAX computers•Relational Software, Inc is now Oracle Corporation•ANSI and ISO standardized SQL:•SQL-86,  SQL-89,  SQL-92,  SQL:1999,  …,  SQL:2011,  SQL:2016 (current)•SQL-92 is supported by the most of database systems\nECE30030/ITP30010 Database Systems5\nBasic Query Structure•A typical SQL query has the form:   SELECT A1, A2, ..., An FROM r1, r2, ..., rm WHERE P•Ai represents an attribute•Ri represents a relation•P is a predicate\n•The result of an SQL query is a relation\nECE30030/ITP30010 Database Systems6\nAgenda•Structured query language (SQL)•SQL data manipulation language (DML)•SELECT, FROM, WHERE•NULL values•Set operations•String operations, ordering•Aggregate functions, aggregation•SQL data definition language (DDL)\nECE30030/ITP30010 Database Systems7\nSQL Data Manipulation Language•The SQL data-manipulation language (DML) allows querying (ask questions about) and modifying the databases\nECE30030/ITP30010 Database Systems8\nRunning Examples•Relations (tables): instructor, teaches\nECE30030/ITP30010 Database Systems9\nInstructor relationteaches relation\nBasic Query Structure•A typical SQL query has the form:   SELECT A1, A2, ..., An FROM r1, r2, ..., rm WHERE P•Ai represents an attribute•Ri represents a relation•P is a predicate\n•The result of an SQL query is a relation\nECE30030/ITP30010 Database Systems10\nThe SELECT Clause•The SELECT clause lists the attributes desired in the result of a query•Corresponds to the projection operation of the relational algebra\n•Example: Find the names of all instructors•SQL: SELECT name FROM instructor;\nECE30030/ITP30010 Database Systems11\n\nNote•Note: SQL names are case insensitive•E.g., Name ≡ NAME ≡ name•SQL commands (SELECT, FROM, WHERE, …) are written in upper case (just a convention)•MySQL has an option flag, lower_case_table_names•Link: https://dev.mysql.com/doc/refman/8.0/en/identifier-case-sensitivity.html \nECE30030/ITP30010 Database Systems12\nThe SELECT Clause•SQL allows duplicates in relations as well as in query results•The keyword ALL specifies that duplicates should not be removed SELECT ALL dept_name FROM instructor\nECE30030/ITP30010 Database Systems13\n\nThe SELECT Clause•SQL allows duplicates in relations as well as in query results•The keyword ALL specifies that duplicates should not be removed SELECT ALL dept_name FROM instructor•To force the elimination of duplicates, insert the keyword DISTINCT after SELECT•Find the department names of all instructor, removing duplicates: SELECT DISTINCT dept_name FROM instructor;\nECE30030/ITP30010 Database Systems14\n\nThe SELECT Clause•An asterisk in the select clause denotes “all attributes” SELECT * FROM instructor;•An attribute can be a literal with no FROM clause SELECT ‘437’;•Result is a table with one column and a single row with value “437”•Can give the column a name using AS: SELECT ‘437’ AS FOO\nECE30030/ITP30010 Database Systems15\n\nThe SELECT Clause•An attribute can be a literal with FROM clause SELECT 'A' FROM instructor•Result is a table with one column and N rows (number of tuples in the instructor table), each row with value “A”\nECE30030/ITP30010 Database Systems16\n\nThe SELECT Clause•The SELECT clause can contain arithmetic expressions involving the operation, +, –, *, and /, and operating on constants or attributes of tuples•The query:     SELECT ID, name, salary/12      FROM instructorwould return a relation that is the same as the instructor relation,except that the value of the attribute salary is divided by 12\n17\n\nThe SELECT Clause•The SELECT clause can contain arithmetic expressions involving the operation, +, –, *, and /, and operating on constants or attributes of tuples•Can rename “salary/12” using the AS clause:  SELECT ID, name, salary/12 AS monthly_salary   FROM instructor\n18\n\nThe WHERE Clause•The WHERE clause specifies conditions that the result must satisfy•Corresponds to the selection predicate of the relational algebra•E.g., To find all instructors in Comp. Sci. dept: SELECT name FROM instructor  WHERE dept_name = 'Comp. Sci.';\nECE30030/ITP30010 Database Systems19\n\nThe WHERE Clause•SQL allows the use of the logical connectives AND, OR, and NOT•The operands of the logical connectives can be expressions involving the comparison operators <, <=, >, >=, =, and <>•<> means not equal (there is no != in SQL)•Comparisons can be applied to results of arithmetic expressions•E.g., To find all instructors in Comp. Sci. with salary > 70,000: SELECT name FROM instructor WHERE dept_name = 'Comp. Sci.' AND salary > 70000;\nECE30030/ITP30010 Database Systems20\n\nThe WHERE Clause•SQL includes a BETWEEN comparison operator•Example: Find the names of all instructors with salary between $90,000 and $100,000 (that is, ³ $90,000 and £ $100,000)•SELECT nameFROM instructorWHERE salary BETWEEN 90000 AND 100000\nECE30030/ITP30010 Database Systems21\n\nThe WHERE Clause•Tuple comparison: makes comparisons per tuple•SELECT name, course_idFROM instructor, teachesWHERE (instructor.ID, dept_name) = (teaches.ID, 'Biology');\nECE30030/ITP30010 Database Systems22\n\nThe FROM Clause•The FROM clause lists the relations involved in the query•Corresponds to the Cartesian-product operation of the relational algebra•Find the Cartesian-product instructor × teaches SELECT * FROM instructor, teaches;•Generates every possible instructor-teaches pairs, with all attributes from both relations•For common attributes (e.g., ID), the attributes in the resulting table are renamed using the relation name (e.g., instructor.ID)\nECE30030/ITP30010 Database Systems23\nThe FROM Clause•Find the Cartesian-product instructor X teaches SELECT * FROM instructor, teaches;\n24\ninstructor.IDnamedept_namesalaryteaches.IDcourse_idsec_idsemesteryear10101SrinivasanComp. Sci.6500076766BIO-101 1Summer201712121WuFinance9000076766BIO-101 1Summer201715151MozartMusic4000076766BIO-101 1Summer201722222EinsteinPhysics9500076766BIO-101 1Summer201732343El SaidHistory6000076766BIO-101 1Summer2017… … … … … … … … …10101SrinivasanComp. Sci.6500010101CS-101 1Fall 201712121WuFinance9000010101CS-101 1Fall 201715151MozartMusic4000010101CS-101 1Fall 201722222EinsteinPhysics9500010101CS-101 1Fall 201732343El SaidHistory6000010101CS-101 1Fall 2017… … … … … … … … …… … … … … … … … …10101SrinivasanComp. Sci.6500083821CS-190 2Spring201712121WuFinance9000083821CS-190 2Spring201715151MozartMusic4000083821CS-190 2Spring2017… … … … … … … … …10101SrinivasanComp. Sci.6500010101CS-315 1Spring201812121WuFinance9000010101CS-315 1Spring201815151MozartMusic4000010101CS-315 1Spring2018… … … … … … … … …… … … … … … … … …\nImplementing JOIN•Cartesian-product is not very useful directly; but useful combined with WHERE-clause condition (selection operation in relational algebra)•Cartesian-product + selection = join•E.g., Find the names of all instructors who have taught some course and the course_id SELECT name, course_id FROM instructor , teaches WHERE instructor.ID = teaches.ID\nECE30030/ITP30010 Database Systems25\n\nImplementing JOIN•Cartesian-product is not very useful directly; but useful combined with WHERE-clause condition (selection operation in relational algebra)•Cartesian-product + selection = join•Find the names of all instructors in the Music department who have taught some course and the course_id SELECT name, course_id FROM instructor , teaches WHERE instructor.ID = teaches.ID  AND instructor. dept_name = 'Music'\nECE30030/ITP30010 Database Systems26\n\nThe Rename Operation•The SQL allows renaming relations and attributes using the AS clause:   old-name AS new-name•Find the names of all instructors who have a higher salary than some instructor in ‘Comp. Sci.’•SELECT DISTINCT T.nameFROM instructor AS T, instructor AS SWHERE T.salary > S.salary AND S.dept_name = 'Comp. Sci.'\nECE30030/ITP30010 Database Systems27\n\nThe Rename Operation•The SQL allows renaming relations and attributes using the AS clause:   old-name AS new-name•Find the names of all instructors who have a higher salary than some instructor in ‘Comp. Sci.’•SELECT DISTINCT T.nameFROM instructor AS T, instructor AS SWHERE T.salary > S.salary AND S.dept_name = 'Comp. Sci.'•Keyword AS is optional and may be omitted  instructor AS T  ≡  instructor T\nECE30030/ITP30010 Database Systems28\nAgenda•Structured query language (SQL)•SQL data manipulation language (DML)•SELECT, FROM, WHERE•NULL values•Set operations•String operations, ordering•Aggregate functions, aggregation•SQL data definition language (DDL)\nECE30030/ITP30010 Database Systems29\nNULL Values•It is possible for tuples to have a NULL value for some of their attributes•NULL signifies an unknown value or that a value does not exist•The result of any arithmetic expression involving NULL is NULL•E.g.,  5 + NULL returns NULL\nECE30030/ITP30010 Database Systems30\nIS NULL / IS NOT NULL•The predicate IS NULL can be used to check for NULL values•E.g., Find all instructors whose salary is null SELECT name FROM instructor WHERE salary IS NULL•The predicate IS NOT NULL succeeds if the value on which it is applied is not null\nECE30030/ITP30010 Database Systems31\nAgenda•Structured query language (SQL)•SQL data manipulation language (DML)•SELECT, FROM, WHERE•NULL values•Set operations•String operations, ordering•Aggregate functions, aggregation•SQL data definition language (DDL)\nECE30030/ITP30010 Database Systems32\nSet Operations•Set operations UNION, INTERSECT, and EXCEPT•Each of the above operations automatically eliminates duplicates•To retain all duplicates, use ALL:•UNION ALL•INTERSECT ALL•EXCEPT ALL\n•C.f., SELECT retains all duplicates by default\nECE30030/ITP30010 Database Systems33\nSet Operations: UNION•Find courses that ran in Fall 2017 or in Spring 2018•(SELECT course_id  FROM teaches WHERE semester = 'Fall' AND year = 2017)UNION(SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018)\nECE30030/ITP30010 Database Systems34\n\nSet Operations: INTERSECT•Find courses that ran in Fall 2017 and in Spring 2018•(SELECT course_id  FROM teaches WHERE semester = 'Fall' AND year = 2017)INTERSECT(SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018)•C.f., MySQL does NOT support INTERSECT•One can emulate INTERSECT using JOIN (we’ll study JOIN later)•SELECT LT.course_idFROM (SELECT course_id FROM teaches WHERE semester = 'Fall' AND year = 2017) AS LTJOIN (SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018) AS RTON LT.course_id=RT.course_id;\nECE30030/ITP30010 Database Systems35\n\nSet Operations: EXCEPT•Find courses that ran in Fall 2017 but not in Spring 2018•(SELECT course_id  FROM teaches WHERE semester = 'Fall' AND year = 2017)EXCEPT(SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018)•C.f., MySQL does NOT support EXCEPT•One can emulate EXCEPT using NOT IN•SELECT course_id FROM teaches WHERE semester = 'Fall' AND year = 2017AND course_id NOT IN(SELECT course_id  FROM teaches  WHERE semester = 'Spring' AND year = 2018);\nECE30030/ITP30010 Database Systems36\n\nAgenda•Structured query language (SQL)•SQL data manipulation language (DML)•SELECT, FROM, WHERE•NULL values•Set operations•String operations, ordering•Aggregate functions, aggregation•SQL data definition language (DDL)\nECE30030/ITP30010 Database Systems37\nString Operations•SQL includes a string-matching operator for comparisons on character strings•The operator LIKE uses patterns that are described using two special characters:•percent (%) – The % character matches any substring•underscore (_) – The _ character matches any character•Find the names of all instructors whose name includes the substring “ri” SELECT name FROM instructor WHERE name LIKE ‘%ri%'\nECE30030/ITP30010 Database Systems38\n\nString Operations•Escape character: Use backslash (\\) as the escape character•E.g., Match the string “100%” LIKE '100 \\%’ ESCAPE  ‘\\’\nECE30030/ITP30010 Database Systems39\nString Operations•Patterns are case sensitive•Pattern matching examples:•'Intro%' matches any string beginning with “Intro”•'%Comp%' matches any string containing “Comp” as a substring•'_ _ _' matches any string of exactly three characters•'_ _ _ %' matches any string of at least three characters•SQL supports a variety of string operations such as•concatenation (using “||”)•converting from upper to lower case (and vice versa)•finding string length, extracting substrings, etc.\nECE30030/ITP30010 Database Systems40\nOrdering the Display of Tuples•List in alphabetic order the names of all instructors•SELECT DISTINCT nameFROM instructorORDER BY name\nECE30030/ITP30010 Database Systems41\n\nOrdering the Display of Tuples•Can sort on multiple attributes•E.g., SELECT dept_name, name     FROM instructor      ORDER BY dept_name, name\nECE30030/ITP30010 Database Systems42\n\nOrdering the Display of Tuples•We may specify DESC for descending order or ASC for ascending order, for each attribute; ascending order is the default•E.g., ORDER BY name DESC\nECE30030/ITP30010 Database Systems43\n\nAgenda•Structured query language (SQL)•SQL data manipulation language (DML)•SELECT, FROM, WHERE•NULL values•Set operations•String operations, ordering•Aggregate functions, aggregation•SQL data definition language (DDL)\nECE30030/ITP30010 Database Systems44\nAggregate Functions•These functions operate on the multiset of values of a column of a relation, and return a value•AVG:  average value•MIN:  minimum value•MAX:  maximum value•SUM:  sum of values•COUNT:  number of values\nECE30030/ITP30010 Database Systems45\nAggregate Functions Examples•Find the average salary of instructors in the Computer Science department•SELECT AVG(salary)FROM instructorWHERE dept_name= 'Comp. Sci.';•Find the total number of instructors who teach a course in the Spring 2018 semester•SELECT COUNT(DISTINCT ID)FROM teachesWHERE semester = 'Spring’ AND year = 2018;•Find the number of tuples in the teaches relation•SELECT COUNT (*)FROM teaches;\nECE30030/ITP30010 Database Systems46\n\nAggregate Functions: Group By•Find the average salary of instructors in each department•SELECT dept_name, AVG(salary) AS avg_salaryFROM instructorGROUP BY dept_name;\nECE30030/ITP30010 Database Systems47\n\nAggregation•Attributes in SELECT clause outside of aggregate functions must appear in GROUP BY list•/* erroneous query */SELECT dept_name, ID, AVG(salary)FROM instructorGROUP BY dept_name;\nECE30030/ITP30010 Database Systems48\n\nAggregate Functions – Having Clause•Find the names and average salaries of all departments whose average salary is greater than 65000•SELECT dept_name, AVG(salary) AS avg_salaryFROM instructorGROUP BY dept_nameHAVING AVG(salary) > 65000;\nECE30030/ITP30010 Database Systems49\n\nAggregate Functions – Having Clause•Note: predicates in the HAVING clause are applied after the formation of groups whereas predicates in the WHERE clause are applied before forming groups\nECE30030/ITP30010 Database Systems50\nSELECT dept_name, AVG(salary) AS avg_salaryFROM instructorGROUP BY dept_nameHAVING AVG(salary) > 65000;\nSELECT dept_name, AVG(salary) AS avg_salaryFROM instructorWHERE salary > 65000GROUP BY dept_name;\n\nSQL Commands\nSQLDMLSELECTINSERTUPDATEDELETE\nDDLCREATEALTERDROP\nECE30030/ITP30010 Database Systems51\nINSERT•Basic syntax•Insert data into every column:•INSERT INTO tablenameVALUES (col1_value, col2_value, …)•Must list values in the same order as in the table schema•If some data values are unknown, must type NULL •For character sequences, use quotation marks•Single quotation marks are preferred (but double quotation marks are allowed)•Value in quotations is case-sensitive•Insert data into selected columns•INSERT INTO tablename (col1_name, col3_name, col4_name, …)VALUES (col1_value, col3_value, col4_value, …)\nECE30030/ITP30010 Database Systems52\nINSERT•Add a new tuple to course•INSERT INTO courseVALUES ('CS-437', 'Database Systems', 'Comp. Sci.', 4);•or equivalently•INSERT INTO course (course_id, title, dept_name, credits)VALUES ('CS-437', 'Database Systems', 'Comp. Sci.', 4);•Add a new tuple to student  with tot_creds set to null•INSERT INTO studentVALUES ('3003', 'Green', 'Finance', null);\nECE30030/ITP30010 Database Systems53\nINSERT•A foreign key specifies that an attribute from one relation has to map to a tuple in another relation•Value in one relation must appear in another relation\nECE30030/ITP30010 Database Systems54\nRelation: instructor\nRelation: department\nINSERT•A foreign key specifies that an attribute from one relation has to map to a tuple in another relation•Value in one relation must appear in another relation•Make sure all foreign keys that new row references have already been added to database•One cannot insert a foreign key value unless the corresponding value exists in the referenced relation\nECE30030/ITP30010 Database Systems55\nINSERT•Inserting results of other SELECT query•Make each student in the Music department who has earned more than 144 credit hours an instructor in the Music department with a salary of  $18,000•INSERT INTO instructor  SELECT ID, name, dept_name, 18000  FROM student   WHERE dept_name = 'Music’ AND total_cred > 144;•The SELECT FROM WHERE statement is evaluated fully before any of its results are inserted into the relation•Otherwise queries like  INSERT INTO table1 SELECT * FROM table1would cause problem\nECE30030/ITP30010 Database Systems56\nUPDATE•Basic syntax•Updating a table•UPDATE tablenameSET col1_name = new_col1_value, col2_name = new_col2_value, …;•Updating a table with conditions•UPDATE tablenameSET col1_name = new_col1_value, col2_name = new_col2_value, …WHERE predicate;\nECE30030/ITP30010 Database Systems57\nUPDATE•Give a 5% salary raise to all instructors•UPDATE instructorSET salary = salary * 1.05•Give a 5% salary raise to those instructors who earn less than 70000•UPDATE instructorSET salary = salary * 1.05WHERE salary < 70000;•Give a 5% salary raise to instructors whose salary is less than average•UPDATE instructorSET salary = salary * 1.05WHERE salary <  (SELECT AVG(salary) FROM instructor);\nECE30030/ITP30010 Database Systems58\nUPDATE•Increase salaries of instructors whose salary is over $100,000 by 3%, and all others by a 5%•Write two UPDATE statements:  UPDATE instructor  SET salary = salary * 1.03  WHERE salary > 100000;  UPDATE instructor  SET salary = salary * 1.05  WHERE salary <= 100000;•The order is important•Can be done better using the case statement (next slide)\nECE30030/ITP30010 Database Systems59\nCASE Statement for Conditional Update•The following query is equivalent to the previous UPDATE queries•UPDATE instructorSET salary = CASE                           WHEN salary <= 100000 THEN salary * 1.05                           ELSE salary * 1.03                       END\nECE30030/ITP30010 Database Systems60\nUPDATE with Scalar Subqueries•Recompute and update tot_creds value for all students•UPDATE student SSET tot_cred = (SELECT SUM(credits)                             FROM takes, course                             WHERE takes.course_id = course.course_id  AND                                            S.ID= takes.ID  AND                                            takes.grade <> 'F' AND                                            takes.grade IS NOT NULL);\nECE30030/ITP30010 Database Systems61\nDELETE•Basic syntax•To remove specific rows•DELETE FROM tablenameWHERE predicate;•To remove all rows•DELETE FROM tablename;•This is equivalent to TRUNCATE:TRUNCATE (TABLE) tablename;•One cannot truncate a table with foreign key constraints•Must disable the constraints first (we will cover ALTER when we study SQL DDL):ALTER TABLE tablenameDISABLE CONSTRAINT constraint_name;\nECE30030/ITP30010 Database Systems62\nDELETE•Delete all instructors•DELETE FROM instructor;•Delete all instructors from the Finance department•DELETE FROM instructorWHERE dept_name= 'Finance';•Delete all tuples in the instructor relation for those instructors associated with a department located in the Watson building•DELETE FROM instructorWHERE dept name IN (SELECT dept name        FROM department        WHERE building = 'Watson');\nECE30030/ITP30010 Database Systems63\nDELETE•Delete all instructors whose salary is less than the average salary of instructors•Example:  DELETE FROM instructor                WHERE salary < (SELECT AVG (salary)                  FROM instructor);•Issue:  as we delete tuples from instructor, the average salary changes•Solution used in SQL:1.First, compute AVG(salary) and find all tuples to delete2.Next, delete all tuples found above (without recomputing AVG or retesting the tuples)\nECE30030/ITP30010 Database Systems64\nEOF•Coming next:•More on Structured Query Language\nECE30030/ITP30010 Database Systems65"
        }
      ],
      "notebook_title": "관계형 데이터베이스 시스템: MySQL 소개 및 SQL 심층 활용",
      "holistic_chapters": [
        {
          "chapter_title": "관계형 데이터베이스 시스템(R-DBMS) 개요 및 MySQL 소개",
          "source_pdf_filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_1a4c2f45-b482-4e82-826e-fa8945eb99c7_DB03 - mysql.pdf",
          "chapter_content_summary": "이 장에서는 관계형 데이터베이스 관리 시스템(R-DBMS)의 기본 개념을 소개하고, 대표적인 오픈소스 R-DBMS인 MySQL에 대해 심층적으로 다룹니다. MySQL의 정의, Oracle 소유권, 표준 SQL 호환성, 상업적 웹 서비스에서의 활용 사례, 기업 사용 통계, 그리고 MySQL의 인기 요인(다양한 운영체제 및 프로그래밍 언어 지원, 비용 효율성, 고성능)을 설명합니다. 또한, R-DBMS 시장에서의 MySQL의 트렌드와 인기도를 살펴보고, MySQL 5.x와 8.x 버전의 주요 차이점 및 MySQL 커뮤니티 버전을 다운로드하고 Docker 이미지를 활용하는 방법을 안내합니다. MySQL이 대규모 데이터 처리, 다중 사용자 지원, 효율성, 안정성, 보안성 측면에서 갖는 강점들을 강조합니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database SystemsHandshaking with an R-DBMSCharmgil Hongcharmgil@handong.eduSpring, 2025Handong Global University\n1\nAgenda•Introduction to MySQL•SQL preview\nECE30030/ITP30010 Database Systems2\nMySQL•MySQL is an SQL-based relational database management system (DBMS)•Free and open-source R-DBMS (under GPL)•Owned by Oracle•Commercial version of MySQL is also provided (including technical support)•“My” came from the name of co-founder Michael Widenius’ daughter•C.f., MariaDB•Compatible with standard SQL•Frequently used for commercial web services\nECE30030/ITP30010 Database Systems3\n* Image src: https://en.wikipedia.org/wiki/MySQL\nMySQL•Companies using MySQL (a study by Enlyft)•“We have data on 199,498 (out of 1,409,176) companies that use MySQL”•Often used by companies with 10-50 employees and 1M-10M dollars in revenue•C.f., Oracle 12 is most often used by companies with 50-200 employees and >1000M dollars in revenue\nECE30030/ITP30010 Database Systems4* Source: https://enlyft.com/tech/products/mysql \nMySQL•Companies using MySQL (full list: https://www.mysql.com/customers/)\nECE30030/ITP30010 Database Systems5\n* Source: https://stackshare.io/mysql \nMySQL•Why MySQL?•Popular•Active discussions all over the Internet•Versatile: runs on Linux, Windows, Mac OS X, Solaris, FreeBSD, …•Supports wide range of programming languages (C/C++, Java, Python, .Net, …)•Cost starts from zero•High performance (fast and reliable)\nECE30030/ITP30010 Database Systems6* Image src: https://db-engines.com/en/ranking\nDBMS Trend Popularity\n•Score definition: https://db-engines.com/en/ranking_definition\nECE30030/ITP30010 Database Systems7* Image src: https://db-engines.com/en/ranking_trend \nMySQL•Why MySQL?•Popular•Active discussions all over the Internet•Versatile: runs on Linux, Windows, Mac OS X, Solaris, FreeBSD, …•Supports wide range of programming languages (C/C++, Java, Python, .Net, …)•Cost starts from zero•High performance (fast and reliable)\nECE30030/ITP30010 Database Systems8* Image src: https://dev.mysql.com/downloads/\nMySQL\nECE30030/ITP30010 Database Systems9\n•Massive•Convenient•Multi-user•Safe•Efficient•Reliable\nCan handle terabytes of dataSupports high-level query languageSupports concurrent data accessSupports transactionsCan handle thousands of queries/second99.99% up-time in many real-world products\nMySQL Versions•MySQL 5.x vs 8.x\nECE30030/ITP30010 Database Systems10\nVersion 5.x-Most popular version of MySQL-More stable and conventionalVersion 8.x-Current version-Provides up-to-date DB functionalities (better storage engine, faster, more secure)\n* Source: https://www.eversql.com/mysql-8-adoption-usage-rate/#:~:text=MySQL%205.7%20is%20still%20the,17%25%20are%20using%20MySQL%208. \nMySQL Versions•MySQL 5.x vs 8.x\nECE30030/ITP30010 Database Systems11\nVersion 5.x-Most popular version of MySQL-More stable and conventionalVersion 8.x-Current version-Provides up-to-date DB functionalities (better storage engine, faster, more secure)\n* Source: https://severalnines.com/database-blog/mysql-performance-benchmarking-mysql-57-vs-mysql-80 \nMySQL Versions•MySQL 5.x vs 8.x\nECE30030/ITP30010 Database Systems12\nVersion 5.x-Most popular version of MySQL-More stable and conventionalVersion 8.x-Current version-Provides up-to-date DB functionalities (better storage engine, faster, more secure)\n* Source: https://severalnines.com/database-blog/mysql-performance-benchmarking-mysql-57-vs-mysql-80 \nWhere to Get MySQL?•https://dev.mysql.com/downloads/•Look for the “Community” versions – the branch that is available for free•”Enterprise” versions are the commercial ones•We have prepared a Docker image for the course•Consists of Ubuntu Server, MySQL, example databases for course activities\nECE30030/ITP30010 Database Systems13* Image src: https://www.docker.com \nWhere to Get MySQL?\nECE30030/ITP30010 Database Systems14\n* Image source: https://baumannalexj.medium.com/connect-your-db-tool-to-a-dockerized-mysql-server-container-bc18853524ed   https://www.jetbrains.com/datagrip/features/look_and_feel.html"
        },
        {
          "chapter_title": "SQL(구조적 질의어)의 이해: 기본 개념과 역사",
          "source_pdf_filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf",
          "chapter_content_summary": "SQL(Structured Query Language)의 정의와 관계형 데이터베이스를 조작하는 주된 언어로서의 역할을 설명합니다. SQL이 '무엇을 할지'를 명시하는 고수준 언어이며, DBMS가 '어떻게 할지'를 결정하는 쿼리 최적화 과정을 다룹니다. 또한, SQL의 두 가지 주요 측면인 데이터 정의 언어(DDL)와 데이터 조작 언어(DML)를 소개하고, 무결성, 뷰 정의, 트랜잭션 제어, 내장 SQL 및 동적 SQL, 권한 부여와 같은 SQL의 다양한 구성 요소를 살펴봅니다. 마지막으로, IBM SEQUEL에서 시작하여 Oracle V2를 거쳐 ANSI 및 ISO 표준으로 발전한 SQL의 간략한 역사를 소개하고, 기본적인 SQL 쿼리 구조(SELECT, FROM, WHERE)를 설명합니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database SystemsStructured Query LanguageReading: Chapter 3\nCharmgil Hongcharmgil@handong.eduSpring, 2025Handong Global University\n1\nAgenda•Structured query language (SQL)•SQL data manipulation language (DML)•SELECT, FROM, WHERE•NULL values•Set operations•String operations, ordering•Aggregate functions, aggregation•SQL data definition language (DDL)   --   NEXT CLASS\nECE30030/ITP30010 Database Systems2\nStructured Query Language (SQL)•SQL: Structured Query Language•The principal language used to describe and manipulate relational databases•Very high-level•Say “what to do” rather than “how to do it”•SQL is not specifying data-manipulation details•DBMSs figure out the “best” way to execute queries•Called “query optimization”•Two aspects to SQL•Data definition: for declaring database schemas (DDL)•Data manipulation: for querying (asking questions about) databases and for modifying the database (DML)\nECE30030/ITP30010 Database Systems3\nSQL Parts•DML – provides the ability to query information from the database and to insert tuples into, delete tuples from, and modify tuples in the database•Integrity – the DDL includes commands for specifying integrity constraints•View definition – the DDL includes commands for defining views•Transaction control – includes commands for specifying the beginning and ending of transactions•Embedded SQL and dynamic SQL – define how SQL statements can be embedded within general-purpose programming language•Authorization – includes commands for specifying access rights to relations and viewsECE30030/ITP30010 Database Systems4\nA Brief History•IBM SEQUEL (Structured English Query Language) was developed as a part of the System R project (Chamberlin and Boyce, early 1970s)•Later on, SEQUEL was renamed SQL (structured query language)•System R à System/38 (1979), SQL/DS (1981), DB2 (1983)•Relational Software, Inc released the first commercial implementation of SQL, Oracle V2 for VAX computers•Relational Software, Inc is now Oracle Corporation•ANSI and ISO standardized SQL:•SQL-86,  SQL-89,  SQL-92,  SQL:1999,  …,  SQL:2011,  SQL:2016 (current)•SQL-92 is supported by the most of database systems\nECE30030/ITP30010 Database Systems5\nBasic Query Structure•A typical SQL query has the form:   SELECT A1, A2, ..., An FROM r1, r2, ..., rm WHERE P•Ai represents an attribute•Ri represents a relation•P is a predicate\n•The result of an SQL query is a relation\nECE30030/ITP30010 Database Systems6"
        },
        {
          "chapter_title": "SQL 데이터 조작 언어(DML) 기초: SELECT, FROM, WHERE 절",
          "source_pdf_filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf",
          "chapter_content_summary": "이 장에서는 SQL 데이터 조작 언어(DML)의 핵심 구성 요소인 SELECT, FROM, WHERE 절을 상세히 다룹니다. 'instructor' 및 'teaches'와 같은 예시 관계(테이블)를 사용하여 실제 쿼리 작성 방법을 시연합니다. SELECT 절을 통해 원하는 속성을 선택하고, 중복을 포함하거나 제거하는 방법(ALL, DISTINCT), 모든 속성을 선택하는 '*' 사용법, 리터럴 및 산술 표현식 활용, 그리고 AS 키워드를 사용한 속성 이름 변경 방법을 학습합니다. WHERE 절에서는 논리 연산자(AND, OR, NOT) 및 비교 연산자(<, <=, >, >=, =, <>, BETWEEN)를 사용하여 조건을 지정하고, 튜플 비교를 수행하는 방법을 설명합니다. 마지막으로 FROM 절을 통해 쿼리에 포함될 관계를 지정하고, 카르테시안 곱을 이해하며, WHERE 절과 결합하여 JOIN 연산을 구현하는 방법을 구체적인 예시와 함께 제시합니다. 또한, AS 키워드를 이용한 관계 및 속성 이름 변경(별칭 지정)을 다룹니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems7\nSQL Data Manipulation Language•The SQL data-manipulation language (DML) allows querying (ask questions about) and modifying the databases\nECE30030/ITP30010 Database Systems8\nRunning Examples•Relations (tables): instructor, teaches\nECE30030/ITP30010 Database Systems9\nInstructor relationteaches relation\nBasic Query Structure•A typical SQL query has the form:   SELECT A1, A2, ..., An FROM r1, r2, ..., rm WHERE P•Ai represents an attribute•Ri represents a relation•P is a predicate\n•The result of an SQL query is a relation\nECE30030/ITP30010 Database Systems10\nThe SELECT Clause•The SELECT clause lists the attributes desired in the result of a query•Corresponds to the projection operation of the relational algebra\n•Example: Find the names of all instructors•SQL: SELECT name FROM instructor;\nECE30030/ITP30010 Database Systems11\nNote•Note: SQL names are case insensitive•E.g., Name ≡ NAME ≡ name•SQL commands (SELECT, FROM, WHERE, …) are written in upper case (just a convention)•MySQL has an option flag, lower_case_table_names•Link: https://dev.mysql.com/doc/refman/8.0/en/identifier-case-sensitivity.html \nECE30030/ITP30010 Database Systems12\nThe SELECT Clause•SQL allows duplicates in relations as well as in query results•The keyword ALL specifies that duplicates should not be removed SELECT ALL dept_name FROM instructor\nECE30030/ITP30010 Database Systems13\nThe SELECT Clause•SQL allows duplicates in relations as well as in query results•The keyword ALL specifies that duplicates should not be removed SELECT ALL dept_name FROM instructor•To force the elimination of duplicates, insert the keyword DISTINCT after SELECT•Find the department names of all instructor, removing duplicates: SELECT DISTINCT dept_name FROM instructor;\nECE30030/ITP30010 Database Systems14\nThe SELECT Clause•An asterisk in the select clause denotes “all attributes” SELECT * FROM instructor;•An attribute can be a literal with no FROM clause SELECT ‘437’;•Result is a table with one column and a single row with value “437”•Can give the column a name using AS: SELECT ‘437’ AS FOO\nECE30030/ITP30010 Database Systems15\nThe SELECT Clause•An attribute can be a literal with FROM clause SELECT 'A' FROM instructor•Result is a table with one column and N rows (number of tuples in the instructor table), each row with value “A”\nECE30030/ITP30010 Database Systems16\nThe SELECT Clause•The SELECT clause can contain arithmetic expressions involving the operation, +, –, *, and /, and operating on constants or attributes of tuples•The query:     SELECT ID, name, salary/12      FROM instructorwould return a relation that is the same as the instructor relation,except that the value of the attribute salary is divided by 12\n17\nThe SELECT Clause•The SELECT clause can contain arithmetic expressions involving the operation, +, –, *, and /, and operating on constants or attributes of tuples•Can rename “salary/12” using the AS clause:  SELECT ID, name, salary/12 AS monthly_salary   FROM instructor\n18\nThe WHERE Clause•The WHERE clause specifies conditions that the result must satisfy•Corresponds to the selection predicate of the relational algebra•E.g., To find all instructors in Comp. Sci. dept: SELECT name FROM instructor  WHERE dept_name = 'Comp. Sci.';\nECE30030/ITP30010 Database Systems19\nThe WHERE Clause•SQL allows the use of the logical connectives AND, OR, and NOT•The operands of the logical connectives can be expressions involving the comparison operators <, <=, >, >=, =, and <>•<> means not equal (there is no != in SQL)•Comparisons can be applied to results of arithmetic expressions•E.g., To find all instructors in Comp. Sci. with salary > 70,000: SELECT name FROM instructor WHERE dept_name = 'Comp. Sci.' AND salary > 70000;\nECE30030/ITP30010 Database Systems20\nThe WHERE Clause•SQL includes a BETWEEN comparison operator•Example: Find the names of all instructors with salary between $90,000 and $100,000 (that is, ³ $90,000 and £ $100,000)•SELECT nameFROM instructorWHERE salary BETWEEN 90000 AND 100000\nECE30030/ITP30010 Database Systems21\nThe WHERE Clause•Tuple comparison: makes comparisons per tuple•SELECT name, course_idFROM instructor, teachesWHERE (instructor.ID, dept_name) = (teaches.ID, 'Biology');\nECE30030/ITP30010 Database Systems22\nThe FROM Clause•The FROM clause lists the relations involved in the query•Corresponds to the Cartesian-product operation of the relational algebra•Find the Cartesian-product instructor × teaches SELECT * FROM instructor, teaches;•Generates every possible instructor-teaches pairs, with all attributes from both relations•For common attributes (e.g., ID), the attributes in the resulting table are renamed using the relation name (e.g., instructor.ID)\nECE30030/ITP30010 Database Systems23\nThe FROM Clause•Find the Cartesian-product instructor X teaches SELECT * FROM instructor, teaches;\n24\ninstructor.IDnamedept_namesalaryteaches.IDcourse_idsec_idsemesteryear10101SrinivasanComp. Sci.6500076766BIO-101 1Summer201712121WuFinance9000076766BIO-101 1Summer201715151MozartMusic4000076766BIO-101 1Summer201722222EinsteinPhysics9500076766BIO-101 1Summer201732343El SaidHistory6000076766BIO-101 1Summer2017… … … … … … … … …10101SrinivasanComp. Sci.6500010101CS-101 1Fall 201712121WuFinance9000010101CS-101 1Fall 201715151MozartMusic4000010101CS-101 1Fall 201722222EinsteinPhysics9500010101CS-101 1Fall 201732343El SaidHistory6000010101CS-101 1Fall 2017… … … … … … … … …… … … … … … … … …10101SrinivasanComp. Sci.6500083821CS-190 2Spring201712121WuFinance9000083821CS-190 2Spring201715151MozartMusic4000083821CS-190 2Spring2017… … … … … … … … …10101SrinivasanComp. Sci.6500010101CS-315 1Spring201812121WuFinance9000010101CS-315 1Spring201815151MozartMusic4000010101CS-315 1Spring2018… … … … … … … … …… … … … … … … … …\nImplementing JOIN•Cartesian-product is not very useful directly; but useful combined with WHERE-clause condition (selection operation in relational algebra)•Cartesian-product + selection = join•E.g., Find the names of all instructors who have taught some course and the course_id SELECT name, course_id FROM instructor , teaches WHERE instructor.ID = teaches.ID\nECE30030/ITP30010 Database Systems25\nImplementing JOIN•Cartesian-product is not very useful directly; but useful combined with WHERE-clause condition (selection operation in relational algebra)•Cartesian-product + selection = join•Find the names of all instructors in the Music department who have taught some course and the course_id SELECT name, course_id FROM instructor , teaches WHERE instructor.ID = teaches.ID  AND instructor. dept_name = 'Music'\nECE30030/ITP30010 Database Systems26\nThe Rename Operation•The SQL allows renaming relations and attributes using the AS clause:   old-name AS new-name•Find the names of all instructors who have a higher salary than some instructor in ‘Comp. Sci.’•SELECT DISTINCT T.nameFROM instructor AS T, instructor AS SWHERE T.salary > S.salary AND S.dept_name = 'Comp. Sci.'\nECE30030/ITP30010 Database Systems27\nThe Rename Operation•The SQL allows renaming relations and attributes using the AS clause:   old-name AS new-name•Find the names of all instructors who have a higher salary than some instructor in ‘Comp. Sci.’•SELECT DISTINCT T.nameFROM instructor AS T, instructor AS SWHERE T.salary > S.salary AND S.dept_name = 'Comp. Sci.'•Keyword AS is optional and may be omitted  instructor AS T  ≡  instructor T\nECE30030/ITP30010 Database Systems28"
        },
        {
          "chapter_title": "SQL DML 고급 기능: NULL 값, 집합 연산, 문자열 처리 및 정렬",
          "source_pdf_filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf",
          "chapter_content_summary": "이 장에서는 SQL DML의 고급 기능을 탐구합니다. 먼저, 알려지지 않거나 존재하지 않는 값을 나타내는 NULL 값의 특성을 이해하고, 산술 연산에서의 NULL 동작 및 IS NULL / IS NOT NULL 술어를 사용하여 NULL 값을 확인하는 방법을 배웁니다. 다음으로, 여러 쿼리 결과를 결합하는 집합 연산인 UNION, INTERSECT, EXCEPT를 살펴봅니다. 각 연산이 기본적으로 중복을 제거하며, ALL 키워드를 사용하여 중복을 유지하는 방법을 설명합니다. 특히 MySQL에서 INTERSECT와 EXCEPT가 직접 지원되지 않을 때 JOIN 또는 NOT IN을 사용하여 에뮬레이션하는 기법을 소개합니다. 이어서, 문자열 패턴 매칭을 위한 LIKE 연산자와 '%' (모든 부분 문자열), '_' (단일 문자) 특수 문자의 사용법을 다룹니다. 백슬래시를 이용한 이스케이프 문자 처리, 패턴 매칭의 대소문자 구분, 그리고 연결, 대소문자 변환, 길이 확인, 부분 문자열 추출 등 다양한 SQL 문자열 함수를 소개합니다. 마지막으로, ORDER BY 절을 사용하여 쿼리 결과를 특정 속성을 기준으로 오름차순(ASC) 또는 내림차순(DESC)으로 정렬하는 방법을 학습하며, 여러 속성을 기준으로 정렬하는 예시도 제시합니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems29\nNULL Values•It is possible for tuples to have a NULL value for some of their attributes•NULL signifies an unknown value or that a value does not exist•The result of any arithmetic expression involving NULL is NULL•E.g.,  5 + NULL returns NULL\nECE30030/ITP30010 Database Systems30\nIS NULL / IS NOT NULL•The predicate IS NULL can be used to check for NULL values•E.g., Find all instructors whose salary is null SELECT name FROM instructor WHERE salary IS NULL•The predicate IS NOT NULL succeeds if the value on which it is applied is not null\nECE30030/ITP30010 Database Systems31\nECE30030/ITP30010 Database Systems32\nSet Operations•Set operations UNION, INTERSECT, and EXCEPT•Each of the above operations automatically eliminates duplicates•To retain all duplicates, use ALL:•UNION ALL•INTERSECT ALL•EXCEPT ALL\n•C.f., SELECT retains all duplicates by default\nECE30030/ITP30010 Database Systems33\nSet Operations: UNION•Find courses that ran in Fall 2017 or in Spring 2018•(SELECT course_id  FROM teaches WHERE semester = 'Fall' AND year = 2017)UNION(SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018)\nECE30030/ITP30010 Database Systems34\nSet Operations: INTERSECT•Find courses that ran in Fall 2017 and in Spring 2018•(SELECT course_id  FROM teaches WHERE semester = 'Fall' AND year = 2017)INTERSECT(SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018)•C.f., MySQL does NOT support INTERSECT•One can emulate INTERSECT using JOIN (we’ll study JOIN later)•SELECT LT.course_idFROM (SELECT course_id FROM teaches WHERE semester = 'Fall' AND year = 2017) AS LTJOIN (SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018) AS RTON LT.course_id=RT.course_id;\nECE30030/ITP30010 Database Systems35\nSet Operations: EXCEPT•Find courses that ran in Fall 2017 but not in Spring 2018•(SELECT course_id  FROM teaches WHERE semester = 'Fall' AND year = 2017)EXCEPT(SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018)•C.f., MySQL does NOT support EXCEPT•One can emulate EXCEPT using NOT IN•SELECT course_id FROM teaches WHERE semester = 'Fall' AND year = 2017AND course_id NOT IN(SELECT course_id  FROM teaches  WHERE semester = 'Spring' AND year = 2018);\nECE30030/ITP30010 Database Systems36\nECE30030/ITP30010 Database Systems37\nString Operations•SQL includes a string-matching operator for comparisons on character strings•The operator LIKE uses patterns that are described using two special characters:•percent (%) – The % character matches any substring•underscore (_) – The _ character matches any character•Find the names of all instructors whose name includes the substring “ri” SELECT name FROM instructor WHERE name LIKE ‘%ri%'\nECE30030/ITP30010 Database Systems38\nString Operations•Escape character: Use backslash (\\) as the escape character•E.g., Match the string “100%” LIKE '100 \\%’ ESCAPE  ‘\\’\nECE30030/ITP30010 Database Systems39\nString Operations•Patterns are case sensitive•Pattern matching examples:•'Intro%' matches any string beginning with “Intro”•'%Comp%' matches any string containing “Comp” as a substring•'_ _ _' matches any string of exactly three characters•'_ _ _ %' matches any string of at least three characters•SQL supports a variety of string operations such as•concatenation (using “||”)•converting from upper to lower case (and vice versa)•finding string length, extracting substrings, etc.\nECE30030/ITP30010 Database Systems40\nOrdering the Display of Tuples•List in alphabetic order the names of all instructors•SELECT DISTINCT nameFROM instructorORDER BY name\nECE30030/ITP30010 Database Systems41\nOrdering the Display of Tuples•Can sort on multiple attributes•E.g., SELECT dept_name, name     FROM instructor      ORDER BY dept_name, name\nECE30030/ITP30010 Database Systems42\nOrdering the Display of Tuples•We may specify DESC for descending order or ASC for ascending order, for each attribute; ascending order is the default•E.g., ORDER BY name DESC\nECE30030/ITP30010 Database Systems43"
        },
        {
          "chapter_title": "SQL DML 집계 함수 및 데이터 수정 (INSERT, UPDATE, DELETE)",
          "source_pdf_filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf",
          "chapter_content_summary": "이 장에서는 SQL 데이터 조작 언어(DML)의 고급 기능인 집계 함수와 데이터를 수정하는 명령어를 다룹니다. AVG, MIN, MAX, SUM, COUNT와 같은 집계 함수를 사용하여 컬럼 값의 멀티셋에 대한 통계 값을 계산하는 방법을 학습합니다. 특히 GROUP BY 절을 이용한 데이터 그룹화와 HAVING 절을 이용한 그룹별 필터링을 심층적으로 다루며, WHERE 절과의 차이점을 명확히 설명합니다. 또한, DML의 핵심 명령인 INSERT, UPDATE, DELETE에 대해 자세히 알아봅니다. INSERT 명령을 통해 테이블에 새로운 튜플을 추가하는 다양한 방법(모든 컬럼, 선택된 컬럼, NULL 값 처리, SELECT 쿼리 결과 삽입)과 외래 키 제약 조건의 중요성을 강조합니다. UPDATE 명령으로는 기존 데이터를 수정하는 기본 구문, 조건부 업데이트, CASE 문을 사용한 복잡한 조건 처리, 스칼라 서브쿼리 활용법을 배웁니다. 마지막으로 DELETE 명령을 통해 테이블에서 특정 행 또는 모든 행을 삭제하는 방법과 TRUNCATE 명령의 차이점, 그리고 삭제 시 서브쿼리 사용 시의 고려사항을 설명합니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems44\nAggregate Functions•These functions operate on the multiset of values of a column of a relation, and return a value•AVG:  average value•MIN:  minimum value•MAX:  maximum value•SUM:  sum of values•COUNT:  number of values\nECE30030/ITP30010 Database Systems45\nAggregate Functions Examples•Find the average salary of instructors in the Computer Science department•SELECT AVG(salary)FROM instructorWHERE dept_name= 'Comp. Sci.';•Find the total number of instructors who teach a course in the Spring 2018 semester•SELECT COUNT(DISTINCT ID)FROM teachesWHERE semester = 'Spring’ AND year = 2018;•Find the number of tuples in the teaches relation•SELECT COUNT (*)FROM teaches;\nECE30030/ITP30010 Database Systems46\nAggregate Functions: Group By•Find the average salary of instructors in each department•SELECT dept_name, AVG(salary) AS avg_salaryFROM instructorGROUP BY dept_name;\nECE30030/ITP30010 Database Systems47\nAggregation•Attributes in SELECT clause outside of aggregate functions must appear in GROUP BY list•/* erroneous query */SELECT dept_name, ID, AVG(salary)FROM instructorGROUP BY dept_name;\nECE30030/ITP30010 Database Systems48\nAggregate Functions – Having Clause•Find the names and average salaries of all departments whose average salary is greater than 65000•SELECT dept_name, AVG(salary) AS avg_salaryFROM instructorGROUP BY dept_nameHAVING AVG(salary) > 65000;\nECE30030/ITP30010 Database Systems49\nAggregate Functions – Having Clause•Note: predicates in the HAVING clause are applied after the formation of groups whereas predicates in the WHERE clause are applied before forming groups\nECE30030/ITP30010 Database Systems50\nSELECT dept_name, AVG(salary) AS avg_salaryFROM instructorGROUP BY dept_nameHAVING AVG(salary) > 65000;\nSELECT dept_name, AVG(salary) AS avg_salaryFROM instructorWHERE salary > 65000GROUP BY dept_name;\nSQL Commands\nSQLDMLSELECTINSERTUPDATEDELETE\nDDLCREATEALTERDROP\nECE30030/ITP30010 Database Systems51\nINSERT•Basic syntax•Insert data into every column:•INSERT INTO tablenameVALUES (col1_value, col2_value, …)•Must list values in the same order as in the table schema•If some data values are unknown, must type NULL •For character sequences, use quotation marks•Single quotation marks are preferred (but double quotation marks are allowed)•Value in quotations is case-sensitive•Insert data into selected columns•INSERT INTO tablename (col1_name, col3_name, col4_name, …)VALUES (col1_value, col3_value, col4_value, …)\nECE30030/ITP30010 Database Systems52\nINSERT•Add a new tuple to course•INSERT INTO courseVALUES ('CS-437', 'Database Systems', 'Comp. Sci.', 4);•or equivalently•INSERT INTO course (course_id, title, dept_name, credits)VALUES ('CS-437', 'Database Systems', 'Comp. Sci.', 4);•Add a new tuple to student  with tot_creds set to null•INSERT INTO studentVALUES ('3003', 'Green', 'Finance', null);\nECE30030/ITP30010 Database Systems53\nINSERT•A foreign key specifies that an attribute from one relation has to map to a tuple in another relation•Value in one relation must appear in another relation\nECE30030/ITP30010 Database Systems54\nRelation: instructor\nRelation: department\nINSERT•A foreign key specifies that an attribute from one relation has to map to a tuple in another relation•Value in one relation must appear in another relation•Make sure all foreign keys that new row references have already been added to database•One cannot insert a foreign key value unless the corresponding value exists in the referenced relation\nECE30030/ITP30010 Database Systems55\nINSERT•Inserting results of other SELECT query•Make each student in the Music department who has earned more than 144 credit hours an instructor in the Music department with a salary of  $18,000•INSERT INTO instructor  SELECT ID, name, dept_name, 18000  FROM student   WHERE dept_name = 'Music’ AND total_cred > 144;•The SELECT FROM WHERE statement is evaluated fully before any of its results are inserted into the relation•Otherwise queries like  INSERT INTO table1 SELECT * FROM table1would cause problem\nECE30030/ITP30010 Database Systems56\nUPDATE•Basic syntax•Updating a table•UPDATE tablenameSET col1_name = new_col1_value, col2_name = new_col2_value, …;•Updating a table with conditions•UPDATE tablenameSET col1_name = new_col1_value, col2_name = new_col2_value, …WHERE predicate;\nECE30030/ITP30010 Database Systems57\nUPDATE•Give a 5% salary raise to all instructors•UPDATE instructorSET salary = salary * 1.05•Give a 5% salary raise to those instructors who earn less than 70000•UPDATE instructorSET salary = salary * 1.05WHERE salary < 70000;•Give a 5% salary raise to instructors whose salary is less than average•UPDATE instructorSET salary = salary * 1.05WHERE salary <  (SELECT AVG(salary) FROM instructor);\nECE30030/ITP30010 Database Systems58\nUPDATE•Increase salaries of instructors whose salary is over $100,000 by 3%, and all others by a 5%•Write two UPDATE statements:  UPDATE instructor  SET salary = salary * 1.03  WHERE salary > 100000;  UPDATE instructor  SET salary = salary * 1.05  WHERE salary <= 100000;•The order is important•Can be done better using the case statement (next slide)\nECE30030/ITP30010 Database Systems59\nCASE Statement for Conditional Update•The following query is equivalent to the previous UPDATE queries•UPDATE instructorSET salary = CASE                           WHEN salary <= 100000 THEN salary * 1.05                           ELSE salary * 1.03                       END\nECE30030/ITP30010 Database Systems60\nUPDATE with Scalar Subqueries•Recompute and update tot_creds value for all students•UPDATE student SSET tot_cred = (SELECT SUM(credits)                             FROM takes, course                             WHERE takes.course_id = course.course_id  AND                                            S.ID= takes.ID  AND                                            takes.grade <> 'F' AND                                            takes.grade IS NOT NULL);\nECE30030/ITP30010 Database Systems61\nDELETE•Basic syntax•To remove specific rows•DELETE FROM tablenameWHERE predicate;•To remove all rows•DELETE FROM tablename;•This is equivalent to TRUNCATE:TRUNCATE (TABLE) tablename;•One cannot truncate a table with foreign key constraints•Must disable the constraints first (we will cover ALTER when we study SQL DDL):ALTER TABLE tablenameDISABLE CONSTRAINT constraint_name;\nECE30030/ITP30010 Database Systems62\nDELETE•Delete all instructors•DELETE FROM instructor;•Delete all instructors from the Finance department•DELETE FROM instructorWHERE dept_name= 'Finance';•Delete all tuples in the instructor relation for those instructors associated with a department located in the Watson building•DELETE FROM instructorWHERE dept name IN (SELECT dept name        FROM department        WHERE building = 'Watson');\nECE30030/ITP30010 Database Systems63\nDELETE•Delete all instructors whose salary is less than the average salary of instructors•Example:  DELETE FROM instructor                WHERE salary < (SELECT AVG (salary)                  FROM instructor);•Issue:  as we delete tuples from instructor, the average salary changes•Solution used in SQL:1.First, compute AVG(salary) and find all tuples to delete2.Next, delete all tuples found above (without recomputing AVG or retesting the tuples)\nECE30030/ITP30010 Database Systems64"
        }
      ],
      "generated_content": [
        {
          "title": "관계형 데이터베이스 시스템(R-DBMS) 개요 및 MySQL 소개",
          "metadata": "Source: cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_1a4c2f45-b482-4e82-826e-fa8945eb99c7_DB03 - mysql.pdf, Text length: 2496 chars",
          "documentContent": [
            {
              "type": "heading",
              "content": "목차",
              "level": 1
            },
            {
              "type": "paragraph",
              "content": "MySQL 소개",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "SQL 미리보기",
              "level": null
            },
            {
              "type": "heading",
              "content": "MySQL",
              "level": 1
            },
            {
              "type": "paragraph",
              "content": "MySQL은 SQL 기반의 관계형 데이터베이스 관리 시스템(DBMS)입니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "GPL 라이선스 하의 무료 오픈소스 R-DBMS입니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "오라클이 소유하고 있습니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "상업용 MySQL 버전도 제공됩니다(기술 지원 포함).",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "“My”는 공동 창립자 Michael Widenius의 딸 이름에서 유래했습니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "참고: MariaDB",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "표준 SQL과 호환됩니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "상업용 웹 서비스에 자주 사용됩니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "MySQL 사용 기업",
              "level": 1
            },
            {
              "type": "paragraph",
              "content": "Enlyft의 연구에 따르면, MySQL을 사용하는 1,409,176개 회사 중 199,498개 회사에 대한 데이터를 보유하고 있습니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "주로 직원 수 10-50명, 매출 100만-1000만 달러 규모의 회사에서 사용됩니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "참고: Oracle 12는 직원 수 50-200명, 매출 10억 달러 이상 규모의 회사에서 가장 많이 사용됩니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "MySQL을 사용하는 회사 전체 목록은 https://www.mysql.com/customers/ 에서 확인할 수 있습니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "MySQL을 사용하는 이유",
              "level": 1
            },
            {
              "type": "paragraph",
              "content": "인기 많음",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "인터넷 전반에 걸쳐 활발한 토론이 이루어집니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "다재다능함: Linux, Windows, Mac OS X, Solaris, FreeBSD 등 다양한 운영체제에서 실행됩니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "다양한 프로그래밍 언어(C/C++, Java, Python, .Net 등)를 지원합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "비용이 0부터 시작합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "고성능 (빠르고 신뢰할 수 있음)",
              "level": null
            },
            {
              "type": "heading",
              "content": "DBMS 인기 추세",
              "level": 1
            },
            {
              "type": "paragraph",
              "content": "점수 정의: https://db-engines.com/en/ranking_definition",
              "level": null
            },
            {
              "type": "heading",
              "content": "MySQL의 주요 특징",
              "level": 1
            },
            {
              "type": "paragraph",
              "content": "방대함: 테라바이트 단위의 데이터를 처리할 수 있습니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "편리함: 고수준 질의어를 지원합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "다중 사용자: 동시 데이터 접근을 지원합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "안전함: 트랜잭션을 지원합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "효율적임: 초당 수천 건의 질의를 처리할 수 있습니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "신뢰성: 많은 실제 제품에서 99.99%의 가동 시간을 자랑합니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "MySQL 버전",
              "level": 1
            },
            {
              "type": "paragraph",
              "content": "MySQL 5.x 대 8.x",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "버전 5.x: MySQL의 가장 인기 있는 버전이며, 더 안정적이고 보편적입니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "버전 8.x: 현재 버전으로, 최신 DB 기능(더 나은 스토리지 엔진, 더 빠른 속도, 더 강력한 보안)을 제공합니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "MySQL 얻는 방법",
              "level": 1
            },
            {
              "type": "paragraph",
              "content": "https://dev.mysql.com/downloads/",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "무료로 사용 가능한 \"커뮤니티\" 버전을 찾아보세요.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "”엔터프라이즈” 버전은 상업용입니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "이 강의를 위해 Docker 이미지가 준비되어 있습니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "Ubuntu 서버, MySQL, 그리고 강의 활동을 위한 예제 데이터베이스로 구성되어 있습니다.",
              "level": null
            }
          ],
          "aiNotes": {
            "summary": "본 문서는 관계형 데이터베이스 관리 시스템(R-DBMS)의 개요와 MySQL에 대해 소개합니다. MySQL이 SQL 기반의 무료 오픈소스 R-DBMS이며, 오라클이 소유하고 있음을 설명합니다. 또한 MySQL의 광범위한 사용 현황, 다양한 운영체제 및 프로그래밍 언어 지원, 고성능, 안정성 등의 장점을 강조합니다. MySQL 5.x와 8.x 버전의 주요 차이점을 비교하고, MySQL을 다운로드하고 활용할 수 있는 방법을 안내합니다.",
            "keyConcepts": [
              {
                "term": "관계형 데이터베이스 관리 시스템 (R-DBMS)",
                "definition": "SQL 기반으로 데이터를 관계형 모델에 따라 저장, 관리, 검색하는 시스템입니다."
              },
              {
                "term": "MySQL",
                "definition": "오라클이 소유한 SQL 기반의 오픈소스 R-DBMS로, 상업용 웹 서비스에 널리 사용되며 높은 성능과 안정성을 제공합니다."
              },
              {
                "term": "오픈소스 소프트웨어",
                "definition": "소스 코드가 공개되어 누구나 자유롭게 사용, 수정, 배포할 수 있는 소프트웨어입니다."
              },
              {
                "term": "SQL (Structured Query Language)",
                "definition": "관계형 데이터베이스와 상호작용하고 데이터를 정의, 조작, 제어하기 위한 표준 언어입니다."
              },
              {
                "term": "MySQL 버전 5.x vs 8.x",
                "definition": "5.x는 가장 대중적이고 안정적인 버전이며, 8.x는 현재 버전으로 최신 기능, 향상된 스토리지 엔진, 속도 및 보안을 제공합니다."
              }
            ],
            "importantTerms": [
              {
                "term": "DBMS",
                "definition": "데이터베이스 관리 시스템(Database Management System)의 약자로, 데이터베이스를 효율적으로 관리하는 소프트웨어입니다."
              },
              {
                "term": "GPL",
                "definition": "General Public License의 약자로, 자유 소프트웨어 라이선스의 일종이며, 소프트웨어의 복사, 배포, 수정 권한을 부여합니다."
              },
              {
                "term": "MariaDB",
                "definition": "MySQL의 한 포크(fork)로, MySQL과 높은 호환성을 가지며 오픈소스 커뮤니티에 의해 개발되고 있습니다."
              },
              {
                "term": "트랜잭션",
                "definition": "데이터베이스의 논리적인 작업 단위로, 데이터의 무결성을 보장하기 위해 전부 실행되거나 전혀 실행되지 않아야 하는 일련의 연산입니다."
              },
              {
                "term": "스토리지 엔진",
                "definition": "데이터베이스 시스템 내에서 데이터를 디스크에 저장하고 검색하는 방식을 담당하는 구성 요소입니다."
              },
              {
                "term": "Docker",
                "definition": "애플리케이션을 컨테이너라는 격리된 환경에서 개발, 배포, 실행할 수 있게 해주는 플랫폼입니다."
              }
            ],
            "outline": [
              {
                "text": "목차",
                "id": "목차",
                "children": null
              },
              {
                "text": "MySQL",
                "id": "mysql",
                "children": [
                  {
                    "text": "MySQL 정의 및 특징",
                    "id": "mysql-정의-및-특징",
                    "children": null
                  },
                  {
                    "text": "MySQL 사용 기업",
                    "id": "mysql-사용-기업",
                    "children": null
                  },
                  {
                    "text": "MySQL을 사용하는 이유",
                    "id": "mysql을-사용하는-이유",
                    "children": null
                  },
                  {
                    "text": "MySQL의 주요 특징",
                    "id": "mysql의-주요-특징",
                    "children": null
                  }
                ]
              },
              {
                "text": "DBMS 인기 추세",
                "id": "dbms-인기-추세",
                "children": null
              },
              {
                "text": "MySQL 버전",
                "id": "mysql-버전",
                "children": null
              },
              {
                "text": "MySQL 얻는 방법",
                "id": "mysql-얻는-방법",
                "children": null
              }
            ]
          },
          "quiz": [
            {
              "question": "MySQL의 주요 특징이 아닌 것은 무엇인가요?",
              "options": [
                "오라클이 소유한 상용 소프트웨어이다.",
                "SQL 기반의 관계형 데이터베이스 관리 시스템이다.",
                "GPL 라이선스 하에 무료 오픈소스 버전이 제공된다.",
                "다양한 운영체제와 프로그래밍 언어를 지원한다."
              ],
              "answerIndex": 0,
              "explanation": "MySQL은 오라클이 소유하고 있지만, GPL 라이선스 하에 무료 오픈소스 버전이 제공되며 상용 버전도 별도로 존재합니다. 따라서 '오라클이 소유한 상용 소프트웨어이다'는 MySQL의 모든 특징을 포괄하지 않습니다."
            },
            {
              "question": "MySQL 5.x 버전과 8.x 버전의 주요 차이점은 무엇인가요?",
              "options": [
                "5.x는 최신 기능에 중점을 둔 반면 8.x는 안정성에 중점을 둡니다.",
                "5.x는 현재 버전이고 8.x는 이전 버전입니다.",
                "5.x는 더 안정적이고 대중적이며, 8.x는 최신 기능과 향상된 성능을 제공합니다.",
                "5.x는 유료 버전이고 8.x는 무료 버전입니다."
              ],
              "answerIndex": 2,
              "explanation": "MySQL 5.x는 가장 대중적이고 안정적인 버전으로 남아있지만, 8.x는 최신 버전으로서 더 나은 스토리지 엔진, 속도 및 보안 등 최신 기능을 제공합니다."
            },
            {
              "question": "다음 중 MySQL을 얻을 수 있는 방법으로 본문에 언급되지 않은 것은 무엇인가요?",
              "options": [
                "dev.mysql.com/downloads/에서 커뮤니티 버전 다운로드",
                "MySQL 엔터프라이즈 버전 구매",
                "Docker 이미지를 통해 구축",
                "CD-ROM으로 설치"
              ],
              "answerIndex": 3,
              "explanation": "본문에서는 공식 다운로드 페이지에서 커뮤니티 버전 다운로드, 엔터프라이즈 버전 구매, 그리고 Docker 이미지 활용 방법이 언급되었으나, CD-ROM을 통한 설치는 언급되지 않았습니다."
            }
          ]
        },
        {
          "title": "SQL(구조적 질의어)의 이해: 기본 개념과 역사",
          "metadata": "Source: cd0e465a-9cfa-47bf-93fa-9eb3748fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf, Text length: 1968 chars",
          "documentContent": [
            {
              "type": "heading",
              "content": "서론",
              "level": 1
            },
            {
              "type": "paragraph",
              "content": "이 문서는 관계형 데이터베이스를 다루는 핵심 언어인 SQL(구조적 질의어)의 기본 개념과 역사, 그리고 주요 구성 요소에 대해 설명합니다. SQL은 데이터베이스에 '무엇을 할지'를 지시하는 높은 수준의 언어로, '어떻게 할지'에 대한 세부 사항은 DBMS(데이터베이스 관리 시스템)의 질의 최적화 기능에 맡깁니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "구조적 질의어 (SQL) 개요",
              "level": 1
            },
            {
              "type": "heading",
              "content": "SQL의 정의 및 특징",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "SQL은 관계형 데이터베이스를 기술하고 조작하는 데 사용되는 주요 언어입니다. SQL은 매우 높은 수준의 언어로, 사용자에게 데이터 조작의 세부 사항을 명시하는 대신 '무엇을 할지'를 지시하도록 합니다. DBMS는 질의 최적화(query optimization)를 통해 질의를 실행하는 '최적의' 방법을 찾아냅니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "SQL의 주요 구성 요소",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "SQL은 크게 두 가지 주요 측면으로 나뉩니다:",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "데이터 정의: 데이터베이스 스키마를 선언하는 데 사용되는 DDL(Data Definition Language).",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "데이터 조작: 데이터베이스에 질의하고(질문을 던지고) 데이터베이스를 수정하는 데 사용되는 DML(Data Manipulation Language).",
              "level": null
            },
            {
              "type": "heading",
              "content": "SQL의 다양한 기능",
              "level": 1
            },
            {
              "type": "heading",
              "content": "데이터 조작 언어 (DML)",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "DML은 데이터베이스에서 정보를 질의하고, 튜플을 삽입, 삭제, 수정하는 기능을 제공합니다. `SELECT`, `FROM`, `WHERE`와 같은 구문이 DML의 핵심을 이룹니다. 또한, NULL 값 처리, 집합 연산, 문자열 연산, 정렬, 그리고 집계 함수와 같은 고급 기능도 포함됩니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "기타 SQL 기능",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "SQL은 DML 외에도 다양한 기능을 포함합니다:",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "무결성: DDL은 무결성 제약 조건을 명시하기 위한 명령어를 포함합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "뷰 정의: DDL은 뷰를 정의하기 위한 명령어를 포함합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "트랜잭션 제어: 트랜잭션의 시작과 끝을 명시하기 위한 명령어를 포함합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "임베디드 SQL 및 동적 SQL: SQL 문을 범용 프로그래밍 언어 내에 포함하는 방법을 정의합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "권한 부여: 관계 및 뷰에 대한 접근 권한을 명시하기 위한 명령어를 포함합니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "SQL의 간략한 역사",
              "level": 1
            },
            {
              "type": "heading",
              "content": "초기 개발: IBM SEQUEL과 System R",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "SQL의 전신인 IBM SEQUEL(Structured English Query Language)은 1970년대 초 Chamberlin과 Boyce에 의해 System R 프로젝트의 일환으로 개발되었습니다. 이후 SEQUEL은 SQL(Structured Query Language)로 이름이 변경되었습니다. System R은 System/38(1979), SQL/DS(1981), DB2(1983)로 발전했습니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "상업적 구현 및 표준화",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "Relational Software, Inc.(현재 Oracle Corporation)는 VAX 컴퓨터용 Oracle V2를 출시하며 최초의 상업적 SQL 구현을 선보였습니다. ANSI와 ISO는 SQL을 표준화했으며, SQL-86을 시작으로 SQL-89, SQL-92, SQL:1999 등을 거쳐 현재는 SQL:2016에 이르렀습니다. 특히 SQL-92는 대부분의 데이터베이스 시스템에서 지원됩니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "기본 질의 구조",
              "level": 1
            },
            {
              "type": "heading",
              "content": "SELECT-FROM-WHERE 구문",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "전형적인 SQL 질의는 다음과 같은 형태를 가집니다:",
              "level": null
            },
            {
              "type": "code",
              "content": "SELECT A1, A2, ..., An\nFROM r1, r2, ..., rm\nWHERE P",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "여기서 Ai는 속성(attribute)을 나타내고, Ri는 관계(relation)를 나타내며, P는 술어(predicate)입니다. SQL 질의의 결과는 항상 관계(테이블)입니다.",
              "level": null
            }
          ],
          "aiNotes": {
            "summary": "이 문서는 관계형 데이터베이스의 핵심 언어인 SQL(구조적 질의어)에 대해 설명합니다. SQL의 정의와 특징, 데이터 정의 언어(DDL)와 데이터 조작 언어(DML)로의 구분, 그리고 무결성 제약 조건, 뷰 정의, 트랜잭션 제어 등 다양한 기능을 다룹니다. 또한, IBM의 SEQUEL 개발부터 Oracle의 상업적 구현, 그리고 ANSI 및 ISO 표준화에 이르는 SQL의 간략한 역사와 함께, `SELECT-FROM-WHERE`로 대표되는 SQL의 기본 질의 구조를 소개합니다.",
            "keyConcepts": [
              {
                "term": "SQL (구조적 질의어)",
                "definition": {
                  "easy": null,
                  "medium": "관계형 데이터베이스를 기술하고 조작하는 데 사용되는 주요 언어로, '무엇을 할지'를 지시하는 높은 수준의 언어입니다.",
                  "hard": null
                }
              },
              {
                "term": "DML (데이터 조작 언어)",
                "definition": {
                  "easy": null,
                  "medium": "데이터베이스에서 정보를 질의하고, 튜플을 삽입, 삭제, 수정하는 기능을 제공하는 SQL의 한 부분입니다.",
                  "hard": null
                }
              },
              {
                "term": "DDL (데이터 정의 언어)",
                "definition": {
                  "easy": null,
                  "medium": "데이터베이스 스키마를 선언하고 무결성 제약 조건 및 뷰 정의와 같은 데이터베이스 구조 관련 기능을 담당하는 SQL의 한 부분입니다.",
                  "hard": null
                }
              },
              {
                "term": "질의 최적화",
                "definition": {
                  "easy": null,
                  "medium": "DBMS가 SQL 질의를 효율적으로 실행하기 위해 '최적의' 실행 계획을 찾는 과정입니다.",
                  "hard": null
                }
              }
            ],
            "importantTerms": [
              {
                "term": "SQL",
                "definition": "Structured Query Language의 약자로, 관계형 데이터베이스를 관리하는 표준 언어입니다."
              },
              {
                "term": "DML",
                "definition": "Data Manipulation Language의 약자로, 데이터 검색, 삽입, 수정, 삭제 등 데이터 조작에 사용되는 SQL 명령어 집합입니다."
              },
              {
                "term": "DDL",
                "definition": "Data Definition Language의 약자로, 데이터베이스 스키마 정의, 테이블 생성 및 수정, 뷰 생성 등 데이터 구조 정의에 사용되는 SQL 명령어 집합입니다."
              },
              {
                "term": "SEQUEL",
                "definition": "Structured English Query Language의 약자로, SQL의 초기 명칭이자 IBM System R 프로젝트에서 개발되었습니다."
              },
              {
                "term": "System R",
                "definition": "IBM에서 1970년대 초에 개발한 관계형 데이터베이스 시스템 연구 프로젝트로, SQL의 기원이 되었습니다."
              },
              {
                "term": "질의 최적화 (Query Optimization)",
                "definition": "DBMS가 SQL 질의를 가장 효율적으로 실행하기 위한 방법을 결정하는 과정입니다."
              },
              {
                "term": "SELECT-FROM-WHERE",
                "definition": "SQL에서 데이터를 질의하는 가장 기본적인 구문 형태입니다."
              }
            ],
            "outline": [
              {
                "text": "서론",
                "id": "서론",
                "children": null
              },
              {
                "text": "구조적 질의어 (SQL) 개요",
                "id": "구조적-질의어-sql-개요",
                "children": [
                  {
                    "text": "SQL의 정의 및 특징",
                    "id": "sql의-정의-및-특징",
                    "children": null
                  },
                  {
                    "text": "SQL의 주요 구성 요소",
                    "id": "sql의-주요-구성-요소",
                    "children": null
                  }
                ]
              },
              {
                "text": "SQL의 다양한 기능",
                "id": "sql의-다양한-기능",
                "children": [
                  {
                    "text": "데이터 조작 언어 (DML)",
                    "id": "데이터-조작-언어-dml",
                    "children": null
                  },
                  {
                    "text": "기타 SQL 기능",
                    "id": "기타-sql-기능",
                    "children": null
                  }
                ]
              },
              {
                "text": "SQL의 간략한 역사",
                "id": "sql의-간략한-역사",
                "children": [
                  {
                    "text": "초기 개발: IBM SEQUEL과 System R",
                    "id": "초기-개발-ibm-sequel과-system-r",
                    "children": null
                  },
                  {
                    "text": "상업적 구현 및 표준화",
                    "id": "상업적-구현-및-표준화",
                    "children": null
                  }
                ]
              },
              {
                "text": "기본 질의 구조",
                "id": "기본-질의-구조",
                "children": [
                  {
                    "text": "SELECT-FROM-WHERE 구문",
                    "id": "select-from-where-구문",
                    "children": null
                  }
                ]
              }
            ]
          },
          "quiz": [
            {
              "question": "SQL의 주요 특징 중 하나는 무엇입니까?",
              "options": [
                "데이터 조작의 세부 사항을 명시합니다.",
                "데이터베이스에 '무엇을 할지'보다 '어떻게 할지'를 지시합니다.",
                "DBMS가 질의 실행 방법을 최적화하도록 합니다.",
                "비관계형 데이터베이스를 조작하는 데 주로 사용됩니다."
              ],
              "answerIndex": 2,
              "explanation": "SQL은 '무엇을 할지'를 명시하며, '어떻게 할지'에 대한 세부 사항은 DBMS의 질의 최적화 기능에 맡깁니다."
            },
            {
              "question": "최초의 상업적 SQL 구현을 출시한 회사는 어디입니까?",
              "options": [
                "IBM",
                "Microsoft",
                "Relational Software, Inc. (현재 Oracle Corporation)",
                "ANSI"
              ],
              "answerIndex": 2,
              "explanation": "Relational Software, Inc. (현재 Oracle Corporation)가 VAX 컴퓨터용 Oracle V2를 통해 최초의 상업적 SQL 구현을 출시했습니다."
            },
            {
              "question": "SQL의 구성 요소 중 데이터베이스 스키마를 선언하고 무결성 제약 조건 및 뷰를 정의하는 역할을 하는 것은 무엇입니까?",
              "options": [
                "DML (Data Manipulation Language)",
                "DDL (Data Definition Language)",
                "Transaction Control (트랜잭션 제어)",
                "Authorization (권한 부여)"
              ],
              "answerIndex": 1,
              "explanation": "DDL(데이터 정의 언어)은 데이터베이스 스키마를 선언하고 무결성 제약 조건 및 뷰를 정의하는 데 사용됩니다."
            }
          ]
        },
        {
          "title": "SQL 데이터 조작 언어(DML) 기초: SELECT, FROM, WHERE 절",
          "metadata": "Source: cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf, Text length: 4209 chars",
          "documentContent": [
            {
              "type": "heading",
              "content": "SQL 데이터 조작 언어(DML)",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "SQL 데이터 조작 언어(DML)는 데이터베이스를 질의(질문)하고 수정할 수 있도록 합니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "실행 예시",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "관계(테이블): instructor, teaches",
              "level": null
            },
            {
              "type": "heading",
              "content": "Instructor 관계 및 Teaches 관계",
              "level": 2
            },
            {
              "type": "heading",
              "content": "기본 질의 구조",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "일반적인 SQL 질의는 다음과 같은 형태를 가집니다: SELECT A1, A2, ..., An FROM r1, r2, ..., rm WHERE P",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "Ai는 속성을 나타냅니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "Ri는 관계를 나타냅니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "P는 술어(predicate)입니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "SQL 질의의 결과는 관계(relation)입니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "SELECT 절",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "SELECT 절은 질의 결과에 필요한 속성들을 나열합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "관계 대수의 프로젝션(projection) 연산에 해당합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "예시: 모든 강사의 이름을 찾기",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "SQL: SELECT name FROM instructor;",
              "level": null
            },
            {
              "type": "heading",
              "content": "참고",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "참고: SQL 이름은 대소문자를 구분하지 않습니다. 예: Name ≡ NAME ≡ name",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "SQL 명령(SELECT, FROM, WHERE 등)은 대문자로 작성하는 것이 일반적인 관례입니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "MySQL에는 lower_case_table_names라는 옵션 플래그가 있습니다. 링크: https://dev.mysql.com/doc/refman/8.0/en/identifier-case-sensitivity.html",
              "level": null
            },
            {
              "type": "heading",
              "content": "SELECT 절: 중복 처리",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "SQL은 관계뿐만 아니라 질의 결과에서도 중복을 허용합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "ALL 키워드는 중복을 제거하지 않도록 지정합니다. SELECT ALL dept_name FROM instructor",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "중복 제거를 강제하려면 SELECT 뒤에 DISTINCT 키워드를 삽입합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "모든 강사의 부서 이름을 중복 없이 찾기: SELECT DISTINCT dept_name FROM instructor;",
              "level": null
            },
            {
              "type": "heading",
              "content": "SELECT 절: 모든 속성 및 리터럴 사용",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "SELECT 절의 별표(*)는 “모든 속성”을 의미합니다. SELECT * FROM instructor;",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "속성은 FROM 절 없이 리터럴(상수)이 될 수 있습니다. SELECT ‘437’;",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "결과는 하나의 열과 “437” 값을 가진 단일 행으로 구성된 테이블입니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "AS를 사용하여 열에 이름을 부여할 수 있습니다: SELECT ‘437’ AS FOO",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "속성은 FROM 절을 포함하는 리터럴이 될 수 있습니다. SELECT 'A' FROM instructor",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "결과는 하나의 열과 N개의 행(instructor 테이블의 튜플 수)으로 구성된 테이블이며, 각 행은 “A” 값을 가집니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "SELECT 절: 산술 표현식",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "SELECT 절은 +, –, *, / 연산을 포함하는 산술 표현식을 포함할 수 있으며, 상수 또는 튜플의 속성에 대해 작동합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "질의: SELECT ID, name, salary/12 FROM instructor는 instructor 관계와 동일한 관계를 반환하지만, salary 속성 값이 12로 나뉘어 표시됩니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "AS 절을 사용하여 “salary/12”의 이름을 변경할 수 있습니다: SELECT ID, name, salary/12 AS monthly_salary FROM instructor",
              "level": null
            },
            {
              "type": "heading",
              "content": "WHERE 절",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "WHERE 절은 결과가 만족해야 하는 조건을 지정합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "관계 대수의 선택(selection) 술어에 해당합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "예시: ‘Comp. Sci.’ 부서의 모든 강사를 찾으려면: SELECT name FROM instructor WHERE dept_name = 'Comp. Sci.';",
              "level": null
            },
            {
              "type": "heading",
              "content": "WHERE 절: 논리 연산자와 비교 연산자",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "SQL은 AND, OR, NOT 논리 연결자를 사용할 수 있도록 합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "논리 연결자의 피연산자는 <, <=, >, >=, =, <>와 같은 비교 연산자를 포함하는 표현식일 수 있습니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "<>는 같지 않음을 의미합니다 (SQL에는 !=가 없습니다).",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "비교는 산술 표현식의 결과에도 적용될 수 있습니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "예시: ‘Comp. Sci.’ 부서에 속하며 급여가 70,000보다 많은 모든 강사를 찾으려면: SELECT name FROM instructor WHERE dept_name = 'Comp. Sci.' AND salary > 70000;",
              "level": null
            },
            {
              "type": "heading",
              "content": "WHERE 절: BETWEEN 연산자",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "SQL에는 BETWEEN 비교 연산자가 포함되어 있습니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "예시: 급여가 $90,000에서 $100,000 사이(즉, $90,000 이상 $100,000 이하)인 모든 강사의 이름을 찾으려면:",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "SELECT name FROM instructor WHERE salary BETWEEN 90000 AND 100000",
              "level": null
            },
            {
              "type": "heading",
              "content": "WHERE 절: 튜플 비교",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "튜플 비교: 튜플별로 비교를 수행합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "SELECT name, course_id FROM instructor, teaches WHERE (instructor.ID, dept_name) = (teaches.ID, 'Biology');",
              "level": null
            },
            {
              "type": "heading",
              "content": "FROM 절",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "FROM 절은 질의에 관련된 관계(테이블)들을 나열합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "관계 대수의 카티션 곱(Cartesian-product) 연산에 해당합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "예시: instructor × teaches의 카티션 곱을 찾으려면: SELECT * FROM instructor, teaches;",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "두 관계의 모든 속성을 포함하여 가능한 모든 instructor-teaches 쌍을 생성합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "공통 속성(예: ID)의 경우, 결과 테이블의 속성 이름은 관계 이름(예: instructor.ID)을 사용하여 변경됩니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "FROM 절: 카티션 곱 예시",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "instructor X teaches의 카티션 곱을 찾으려면: SELECT * FROM instructor, teaches;",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "결과 테이블은 instructor와 teaches 관계의 모든 속성을 포함하며, 각 instructor 튜플과 각 teaches 튜플의 모든 가능한 조합을 생성합니다. 예를 들어, instructor.ID, name, dept_name, salary와 teaches.ID, course_id, sec_id, semester, year와 같은 속성들이 조합되어 나타납니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "조인 구현",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "카티션 곱은 직접적으로는 유용하지 않지만, WHERE 절 조건(관계 대수의 선택 연산)과 결합하면 유용합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "카티션 곱 + 선택 = 조인(join)",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "예시: 어떤 과목을 가르친 모든 강사의 이름과 course_id를 찾으려면: SELECT name, course_id FROM instructor , teaches WHERE instructor.ID = teaches.ID",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "음악과에 속하며 어떤 과목을 가르친 모든 강사의 이름과 course_id를 찾으려면: SELECT name, course_id FROM instructor , teaches WHERE instructor.ID = teaches.ID AND instructor. dept_name = 'Music'",
              "level": null
            },
            {
              "type": "heading",
              "content": "이름 변경(Rename) 연산",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "SQL은 AS 절을 사용하여 관계와 속성의 이름을 변경할 수 있도록 합니다: old-name AS new-name",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "예시: 'Comp. Sci.' 부서의 어떤 강사보다 급여가 높은 모든 강사의 이름을 찾으려면:",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "SELECT DISTINCT T.name FROM instructor AS T, instructor AS S WHERE T.salary > S.salary AND S.dept_name = 'Comp. Sci.'",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "AS 키워드는 선택 사항이며 생략될 수 있습니다. instructor AS T ≡ instructor T",
              "level": null
            }
          ],
          "aiNotes": {
            "summary": "본 문서는 SQL 데이터 조작 언어(DML)의 핵심 구성 요소인 SELECT, FROM, WHERE 절의 기초를 다룹니다. 각 절의 기본적인 기능과 함께 중복 처리(ALL, DISTINCT), 산술 표현식, 조건 필터링(AND, OR, NOT, BETWEEN), 테이블 간의 조인(JOIN) 구현, 그리고 테이블 및 속성 이름 변경(AS)과 같은 다양한 활용 방법을 예시와 함께 설명합니다. 또한 SQL 이름의 대소문자 구분 규칙에 대한 내용도 포함되어 있습니다.",
            "keyConcepts": [
              {
                "term": "SQL DML",
                "definition": "데이터베이스에서 데이터를 질의하고 수정하는 데 사용되는 언어입니다."
              },
              {
                "term": "SELECT 절",
                "definition": "질의 결과에 포함할 속성(컬럼)을 지정하는 부분으로, 관계 대수의 프로젝션(Projection) 연산에 해당합니다."
              },
              {
                "term": "FROM 절",
                "definition": "데이터를 검색할 관계(테이블)를 지정하는 부분으로, 관계 대수의 카티션 곱(Cartesian Product) 연산에 해당합니다."
              },
              {
                "term": "WHERE 절",
                "definition": "질의 결과가 만족해야 할 조건을 지정하는 부분으로, 관계 대수의 선택(Selection) 연산에 해당합니다."
              },
              {
                "term": "조인 (JOIN)",
                "definition": "FROM 절의 카티션 곱과 WHERE 절의 선택 조건을 결합하여 두 개 이상의 테이블에서 관련 튜플을 연결하여 새로운 테이블을 생성하는 연산입니다."
              }
            ],
            "importantTerms": [
              {
                "term": "DML (Data Manipulation Language)",
                "definition": "데이터베이스에서 데이터를 검색, 삽입, 삭제, 수정하는 데 사용되는 언어."
              },
              {
                "term": "SELECT",
                "definition": "SQL 쿼리의 결과를 정의하는 절로, 어떤 컬럼을 반환할지 지정."
              },
              {
                "term": "FROM",
                "definition": "SQL 쿼리에서 데이터를 검색할 테이블을 지정하는 절."
              },
              {
                "term": "WHERE",
                "definition": "SQL 쿼리에서 특정 조건을 만족하는 행만 선택하도록 필터링하는 절."
              },
              {
                "term": "DISTINCT",
                "definition": "SELECT 절에서 중복된 결과를 제거할 때 사용하는 키워드."
              },
              {
                "term": "AS",
                "definition": "SQL에서 테이블이나 컬럼의 이름을 변경(별칭 지정)할 때 사용하는 키워드."
              },
              {
                "term": "카티션 곱 (Cartesian Product)",
                "definition": "두 테이블의 모든 가능한 행 조합을 생성하는 연산."
              }
            ],
            "outline": [
              {
                "text": "SQL 데이터 조작 언어(DML) 개요",
                "id": "sql-데이터-조작-언어-dml-개요",
                "children": null
              },
              {
                "text": "기본 질의 구조",
                "id": "기본-질의-구조",
                "children": null
              },
              {
                "text": "SELECT 절의 활용",
                "id": "select-절의-활용",
                "children": [
                  {
                    "text": "속성 선택 및 프로젝션",
                    "id": "속성-선택-및-프로젝션",
                    "children": null
                  },
                  {
                    "text": "대소문자 구분 및 SQL 명령 규칙",
                    "id": "대소문자-구분-및-sql-명령-규칙",
                    "children": null
                  },
                  {
                    "text": "중복 처리 (ALL, DISTINCT)",
                    "id": "중복-처리-all-distinct",
                    "children": null
                  },
                  {
                    "text": "모든 속성 선택 (*) 및 리터럴 사용",
                    "id": "모든-속성-선택-및-리터럴-사용",
                    "children": null
                  },
                  {
                    "text": "산술 표현식 및 결과 이름 변경 (AS)",
                    "id": "산술-표현식-및-결과-이름-변경-as",
                    "children": null
                  }
                ]
              },
              {
                "text": "WHERE 절의 활용",
                "id": "where-절의-활용",
                "children": [
                  {
                    "text": "조건 지정 및 선택 연산",
                    "id": "조건-지정-및-선택-연산",
                    "children": null
                  },
                  {
                    "text": "논리 연산자 (AND, OR, NOT) 및 비교 연산자",
                    "id": "논리-연산자-and-or-not-및-비교-연산자",
                    "children": null
                  },
                  {
                    "text": "BETWEEN 연산자",
                    "id": "between-연산자",
                    "children": null
                  },
                  {
                    "text": "튜플 비교",
                    "id": "튜플-비교",
                    "children": null
                  }
                ]
              },
              {
                "text": "FROM 절의 활용",
                "id": "from-절의-활용",
                "children": [
                  {
                    "text": "관계 지정 및 카티션 곱",
                    "id": "관계-지정-및-카티션-곱",
                    "children": null
                  },
                  {
                    "text": "조인 구현 (Cartesian-product + selection)",
                    "id": "조인-구현-cartesian-product-selection",
                    "children": null
                  }
                ]
              },
              {
                "text": "이름 변경 (AS) 연산",
                "id": "이름-변경-as-연산",
                "children": null
              }
            ]
          },
          "quiz": [
            {
              "question": "중복된 값을 제거하고 강사들의 부서 이름을 검색하는 올바른 SQL 쿼리는 무엇입니까?",
              "options": [
                "SELECT ALL dept_name FROM instructor;",
                "SELECT dept_name FROM instructor;",
                "SELECT DISTINCT dept_name FROM instructor;",
                "SELECT UNIQUE dept_name FROM instructor;"
              ],
              "answerIndex": 2,
              "explanation": "`DISTINCT` 키워드는 SELECT 절에서 중복된 결과를 제거하는 데 사용됩니다."
            },
            {
              "question": "'Comp. Sci.' 부서에 속하며 급여가 70,000보다 많은 모든 강사의 이름을 찾는 SQL 쿼리로 가장 적절한 것은 무엇입니까?",
              "options": [
                "SELECT name FROM instructor WHERE dept_name = 'Comp. Sci.' OR salary > 70000;",
                "SELECT name FROM instructor WHERE dept_name = 'Comp. Sci.' AND salary > 70000;",
                "SELECT name FROM instructor WHERE dept_name <> 'Comp. Sci.' AND salary <= 70000;",
                "SELECT name FROM instructor WHERE dept_name = 'Comp. Sci.' BETWEEN salary 70000;"
              ],
              "answerIndex": 1,
              "explanation": "`AND` 논리 연산자는 두 조건을 모두 만족하는 경우를 찾을 때 사용됩니다."
            },
            {
              "question": "다음 SQL 쿼리 `SELECT DISTINCT T.name FROM instructor AS T, instructor AS S WHERE T.salary > S.salary AND S.dept_name = 'Comp. Sci.'`에 대한 설명으로 옳은 것은 무엇입니까?",
              "options": [
                "이 쿼리는 'Comp. Sci.' 부서 강사들 중 가장 높은 급여를 받는 강사의 이름을 찾습니다.",
                "이 쿼리는 'Comp. Sci.' 부서의 특정 강사보다 급여가 높은 다른 강사들의 이름을 찾습니다.",
                "이 쿼리는 'Comp. Sci.' 부서의 모든 강사 이름을 나열합니다.",
                "이 쿼리는 두 개의 다른 테이블에서 강사 정보를 조인합니다."
              ],
              "answerIndex": 1,
              "explanation": "`FROM instructor AS T, instructor AS S`는 instructor 테이블을 두 개의 별칭(T와 S)으로 사용하여 자체 조인(self-join)을 수행하며, `WHERE T.salary > S.salary AND S.dept_name = 'Comp. Sci.'` 조건은 'Comp. Sci.' 부서의 어떤 강사(S)보다 급여가 높은 강사(T)를 찾습니다."
            }
          ]
        },
        {
          "title": "SQL DML 고급 기능: NULL 값, 집합 연산, 문자열 처리 및 정렬",
          "metadata": "Source: cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf, Text length: 3206 chars",
          "documentContent": [
            {
              "type": "heading",
              "content": "NULL 값",
              "level": 1
            },
            {
              "type": "paragraph",
              "content": "튜플에 일부 속성에 대해 NULL 값이 있을 수 있습니다. NULL은 알 수 없거나 값이 존재하지 않음을 의미합니다. NULL이 포함된 모든 산술 표현식의 결과는 NULL입니다. 예를 들어, '5 + NULL'은 NULL을 반환합니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "IS NULL / IS NOT NULL",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "술어 `IS NULL`은 NULL 값을 확인하는 데 사용됩니다. 예를 들어, `SELECT name FROM instructor WHERE salary IS NULL`은 급여가 NULL인 모든 강사의 이름을 찾습니다. `IS NOT NULL` 술어는 적용된 값이 NULL이 아닐 때 성공합니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "집합 연산",
              "level": 1
            },
            {
              "type": "paragraph",
              "content": "`UNION`, `INTERSECT`, `EXCEPT`와 같은 집합 연산이 있습니다. 이 연산들은 각각 자동으로 중복을 제거합니다. 모든 중복을 유지하려면 `ALL` 키워드를 사용합니다(예: `UNION ALL`, `INTERSECT ALL`, `EXCEPT ALL`). 참고로 `SELECT` 문은 기본적으로 모든 중복을 유지합니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "UNION",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "`UNION`은 두 쿼리의 결과를 결합합니다. 예를 들어, 2017년 가을 또는 2018년 봄에 개설된 강좌를 찾을 수 있습니다. (`SELECT course_id FROM teaches WHERE semester = 'Fall' AND year = 2017) UNION (SELECT course_id FROM teaches WHERE semester = 'Spring' AND year = 2018`).",
              "level": null
            },
            {
              "type": "heading",
              "content": "INTERSECT",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "`INTERSECT`는 두 쿼리 결과의 공통 부분을 찾습니다. 예를 들어, 2017년 가을과 2018년 봄 모두에 개설된 강좌를 찾을 수 있습니다. MySQL은 `INTERSECT`를 직접 지원하지 않으므로, `JOIN`을 사용하여 에뮬레이션할 수 있습니다. (`SELECT LT.course_id FROM (SELECT course_id FROM teaches WHERE semester = 'Fall' AND year = 2017) AS LT JOIN (SELECT course_id FROM teaches WHERE semester = 'Spring' AND year = 2018) AS RT ON LT.course_id=RT.course_id;`)",
              "level": null
            },
            {
              "type": "heading",
              "content": "EXCEPT",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "`EXCEPT`는 첫 번째 쿼리 결과에서 두 번째 쿼리 결과를 제외한 부분을 찾습니다. 예를 들어, 2017년 가을에 개설되었지만 2018년 봄에는 개설되지 않은 강좌를 찾을 수 있습니다. MySQL은 `EXCEPT`를 직접 지원하지 않으므로, `NOT IN`을 사용하여 에뮬레이션할 수 있습니다. (`SELECT course_id FROM teaches WHERE semester = 'Fall' AND year = 2017 AND course_id NOT IN(SELECT course_id FROM teaches WHERE semester = 'Spring' AND year = 2018);`)",
              "level": null
            },
            {
              "type": "heading",
              "content": "문자열 연산",
              "level": 1
            },
            {
              "type": "paragraph",
              "content": "SQL은 문자열 비교를 위한 문자열 일치 연산자를 포함합니다. `LIKE` 연산자는 두 가지 특수 문자를 사용하여 패턴을 설명합니다. 퍼센트(`%`) 문자는 모든 부분 문자열과 일치하고, 밑줄(`_`) 문자는 모든 단일 문자와 일치합니다. 예를 들어, `SELECT name FROM instructor WHERE name LIKE ‘%ri%'`는 이름에 \"ri\" 부분 문자열이 포함된 모든 강사의 이름을 찾습니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "이스케이프 문자(예: 백슬래시 `\\`)를 사용하여 특수 문자를 리터럴로 일치시킬 수 있습니다. 예를 들어, \"100%\" 문자열과 일치시키려면 `LIKE '100 \\%' ESCAPE '\\'`를 사용합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "패턴은 대소문자를 구분합니다. 패턴 일치 예시: 'Intro%'는 \"Intro\"로 시작하는 모든 문자열과 일치하고, '%Comp%'는 \"Comp\"를 포함하는 모든 문자열과 일치하며, '_ _ _'는 정확히 세 문자로 된 모든 문자열과 일치하고, '_ _ _ %'는 최소 세 문자로 된 모든 문자열과 일치합니다. SQL은 연결(`||`), 대소문자 변환, 문자열 길이 찾기, 부분 문자열 추출 등 다양한 문자열 연산을 지원합니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "튜플 표시 정렬",
              "level": 1
            },
            {
              "type": "paragraph",
              "content": "`ORDER BY` 절을 사용하여 튜플의 표시 순서를 정렬할 수 있습니다. 예를 들어, 모든 강사의 이름을 알파벳 순서로 나열하려면 `SELECT DISTINCT name FROM instructor ORDER BY name`을 사용합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "여러 속성을 기준으로 정렬할 수 있습니다. 예를 들어, `SELECT dept_name, name FROM instructor ORDER BY dept_name, name`과 같이 부서 이름과 이름 순으로 정렬할 수 있습니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "각 속성에 대해 내림차순(`DESC`) 또는 오름차순(`ASC`)을 지정할 수 있으며, 오름차순이 기본값입니다. 예를 들어, `ORDER BY name DESC`는 이름을 내림차순으로 정렬합니다.",
              "level": null
            }
          ],
          "aiNotes": {
            "summary": "이 문서는 SQL DML의 고급 기능을 다룹니다. NULL 값의 개념과 `IS NULL`, `IS NOT NULL`을 이용한 처리 방법을 설명합니다. 또한 `UNION`, `INTERSECT`, `EXCEPT`와 같은 집합 연산의 사용법과 `ALL` 키워드를 통한 중복 유지 방법, 그리고 MySQL에서의 에뮬레이션 방안을 제시합니다. 마지막으로 `LIKE` 연산자를 활용한 문자열 패턴 매칭과 `ORDER BY` 절을 이용한 결과 정렬 방법에 대해 자세히 설명합니다.",
            "keyConcepts": [
              {
                "term": "NULL 값 처리",
                "definition": "데이터베이스에서 알 수 없거나 존재하지 않는 값을 나타내는 NULL을 다루는 방법과 관련된 SQL 기능."
              },
              {
                "term": "SQL 집합 연산",
                "definition": "여러 쿼리 결과를 `UNION`, `INTERSECT`, `EXCEPT`를 사용하여 결합하거나 비교하는 기능."
              },
              {
                "term": "문자열 패턴 매칭",
                "definition": "`LIKE` 연산자와 `%`, `_` 특수 문자를 사용하여 문자열 내의 특정 패턴을 검색하는 방법."
              },
              {
                "term": "결과 집합 정렬",
                "definition": "`ORDER BY` 절을 사용하여 쿼리 결과 튜플의 표시 순서를 오름차순(`ASC`) 또는 내림차순(`DESC`)으로 지정하는 방법."
              }
            ],
            "importantTerms": [
              {
                "term": "NULL",
                "definition": "알 수 없거나 존재하지 않는 값."
              },
              {
                "term": "IS NULL / IS NOT NULL",
                "definition": "NULL 값을 확인하는 데 사용되는 술어."
              },
              {
                "term": "UNION",
                "definition": "두 쿼리 결과를 합치는 집합 연산자이며, 기본적으로 중복을 제거한다."
              },
              {
                "term": "LIKE",
                "definition": "문자열 패턴 매칭에 사용되는 연산자."
              },
              {
                "term": "%",
                "definition": "`LIKE` 연산자에서 임의의 부분 문자열과 일치하는 특수 문자."
              },
              {
                "term": "_",
                "definition": "`LIKE` 연산자에서 임의의 단일 문자와 일치하는 특수 문자."
              },
              {
                "term": "ORDER BY",
                "definition": "쿼리 결과의 정렬 순서를 지정하는 절."
              }
            ],
            "outline": [
              {
                "text": "NULL 값",
                "id": "null-값",
                "children": [
                  {
                    "text": "NULL 값의 정의 및 특징",
                    "id": "null-값의-정의-및-특징",
                    "children": null
                  },
                  {
                    "text": "IS NULL / IS NOT NULL 술어",
                    "id": "is-null-is-not-null-술어",
                    "children": null
                  }
                ]
              },
              {
                "text": "집합 연산",
                "id": "집합-연산",
                "children": [
                  {
                    "text": "집합 연산의 종류 (UNION, INTERSECT, EXCEPT)",
                    "id": "집합-연산의-종류",
                    "children": null
                  },
                  {
                    "text": "중복 제거 및 ALL 키워드",
                    "id": "중복-제거-및-all-키워드",
                    "children": null
                  },
                  {
                    "text": "UNION 예시",
                    "id": "union-예시",
                    "children": null
                  },
                  {
                    "text": "INTERSECT 예시 및 MySQL 에뮬레이션",
                    "id": "intersect-예시-및-mysql-에뮬레이션",
                    "children": null
                  },
                  {
                    "text": "EXCEPT 예시 및 MySQL 에뮬레이션",
                    "id": "except-예시-및-mysql-에뮬레이션",
                    "children": null
                  }
                ]
              },
              {
                "text": "문자열 연산",
                "id": "문자열-연산",
                "children": [
                  {
                    "text": "LIKE 연산자 및 패턴 매칭 특수 문자 (%, _)",
                    "id": "like-연산자-및-패턴-매칭-특수-문자",
                    "children": null
                  },
                  {
                    "text": "이스케이프 문자",
                    "id": "이스케이프-문자",
                    "children": null
                  },
                  {
                    "text": "패턴 매칭 예시 및 특징 (대소문자 구분)",
                    "id": "패턴-매칭-예시-및-특징",
                    "children": null
                  },
                  {
                    "text": "기타 문자열 함수",
                    "id": "기타-문자열-함수",
                    "children": null
                  }
                ]
              },
              {
                "text": "튜플 표시 정렬",
                "id": "튜플-표시-정렬",
                "children": [
                  {
                    "text": "ORDER BY 절 기본 사용법",
                    "id": "order-by-절-기본-사용법",
                    "children": null
                  },
                  {
                    "text": "여러 속성으로 정렬",
                    "id": "여러-속성으로-정렬",
                    "children": null
                  },
                  {
                    "text": "오름차순 (ASC) 및 내림차순 (DESC) 지정",
                    "id": "오름차순-및-내림차순-지정",
                    "children": null
                  }
                ]
              }
            ]
          },
          "quiz": [
            {
              "question": "SQL에서 NULL 값이 포함된 산술 연산의 결과는 무엇입니까?",
              "options": [
                "0",
                "1",
                "NULL",
                "오류"
              ],
              "answerIndex": 2,
              "explanation": "NULL이 포함된 산술 표현식의 결과는 항상 NULL입니다."
            },
            {
              "question": "다음 중 두 쿼리 결과의 중복을 포함하여 합치는 SQL 집합 연산자는 무엇입니까?",
              "options": [
                "UNION",
                "INTERSECT ALL",
                "UNION ALL",
                "EXCEPT"
              ],
              "answerIndex": 2,
              "explanation": "`UNION`은 중복을 제거하지만, `UNION ALL`은 모든 중복을 유지하면서 두 쿼리 결과를 합칩니다."
            },
            {
              "question": "`LIKE` 연산자에서 임의의 단일 문자와 일치하는 특수 문자는 무엇입니까?",
              "options": [
                "%",
                "_",
                "\\",
                "?"
              ],
              "answerIndex": 1,
              "explanation": "`%`는 임의의 부분 문자열과 일치하고, `_`는 임의의 단일 문자와 일치합니다."
            }
          ]
        },
        {
          "title": "SQL DML: 집계 함수 및 데이터 수정 (INSERT, UPDATE, DELETE)",
          "metadata": "Source: cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf, Text length: 5040 chars",
          "documentContent": [
            {
              "type": "heading",
              "content": "집계 함수 (Aggregate Functions)",
              "level": 1
            },
            {
              "type": "paragraph",
              "content": "집계 함수는 릴레이션의 특정 컬럼 값들의 멀티셋에 대해 작동하며 단일 값을 반환합니다. 주요 집계 함수는 다음과 같습니다:",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "•   **AVG**: 평균값",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "•   **MIN**: 최솟값",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "•   **MAX**: 최댓값",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "•   **SUM**: 합계",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "•   **COUNT**: 값의 개수",
              "level": null
            },
            {
              "type": "heading",
              "content": "집계 함수 예시",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "집계 함수는 다양한 질의에 사용될 수 있습니다. 예를 들어, 컴퓨터 공학과 강사들의 평균 급여를 찾거나, 2018년 봄 학기에 강의를 가르친 강사의 총 수를 세거나, `teaches` 릴레이션의 튜플 수를 세는 데 활용됩니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "•   **컴퓨터 공학과 강사들의 평균 급여 찾기:**",
              "level": null
            },
            {
              "type": "code",
              "content": "SELECT AVG(salary)\nFROM instructor\nWHERE dept_name= 'Comp. Sci.';",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "•   **2018년 봄 학기에 강의를 가르친 강사의 총 수 찾기:**",
              "level": null
            },
            {
              "type": "code",
              "content": "SELECT COUNT(DISTINCT ID)\nFROM teaches\nWHERE semester = 'Spring’ AND year = 2018;",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "•   **`teaches` 릴레이션의 튜플 수 찾기:**",
              "level": null
            },
            {
              "type": "code",
              "content": "SELECT COUNT (*)\nFROM teaches;",
              "level": null
            },
            {
              "type": "heading",
              "content": "GROUP BY 절",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "`GROUP BY` 절은 특정 컬럼의 값을 기준으로 행들을 그룹으로 묶고, 각 그룹에 대해 집계 함수를 적용할 때 사용됩니다. 예를 들어, 각 부서의 강사 평균 급여를 찾을 수 있습니다.",
              "level": null
            },
            {
              "type": "code",
              "content": "SELECT dept_name, AVG(salary) AS avg_salary\nFROM instructor\nGROUP BY dept_name;",
              "level": null
            },
            {
              "type": "heading",
              "content": "GROUP BY 규칙",
              "level": 3
            },
            {
              "type": "paragraph",
              "content": "`SELECT` 절에 집계 함수 외에 사용된 모든 속성은 반드시 `GROUP BY` 목록에 포함되어야 합니다. 그렇지 않으면 오류가 발생합니다.",
              "level": null
            },
            {
              "type": "code",
              "content": "/* 오류가 발생하는 질의 */\nSELECT dept_name, ID, AVG(salary)\nFROM instructor\nGROUP BY dept_name;",
              "level": null
            },
            {
              "type": "heading",
              "content": "HAVING 절",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "`HAVING` 절은 `GROUP BY` 절에 의해 생성된 그룹에 조건을 적용하여 결과를 필터링하는 데 사용됩니다. 예를 들어, 평균 급여가 65000을 초과하는 모든 부서의 이름과 평균 급여를 찾을 수 있습니다.",
              "level": null
            },
            {
              "type": "code",
              "content": "SELECT dept_name, AVG(salary) AS avg_salary\nFROM instructor\nGROUP BY dept_name\nHAVING AVG(salary) > 65000;",
              "level": null
            },
            {
              "type": "heading",
              "content": "HAVING과 WHERE의 차이",
              "level": 3
            },
            {
              "type": "paragraph",
              "content": "`HAVING` 절의 조건은 그룹이 형성된 **후**에 적용되는 반면, `WHERE` 절의 조건은 그룹을 형성하기 **전**에 적용됩니다. 이는 데이터 필터링 시점의 중요한 차이입니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "SQL DML 명령어",
              "level": 1
            },
            {
              "type": "paragraph",
              "content": "SQL 데이터 조작 언어(DML)는 데이터베이스 내의 데이터를 검색, 삽입, 수정, 삭제하는 데 사용됩니다. 주요 DML 명령어는 `SELECT`, `INSERT`, `UPDATE`, `DELETE`입니다. 데이터 정의 언어(DDL)는 `CREATE`, `ALTER`, `DROP`과 같이 데이터베이스 스키마를 정의하고 관리하는 데 사용됩니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "INSERT (데이터 삽입)",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "`INSERT` 문은 테이블에 새로운 행(튜플)을 추가하는 데 사용됩니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "기본 문법",
              "level": 3
            },
            {
              "type": "paragraph",
              "content": "•   **모든 컬럼에 데이터 삽입:**",
              "level": null
            },
            {
              "type": "code",
              "content": "INSERT INTO tablename\nVALUES (col1_value, col2_value, …)",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "    *   값은 테이블 스키마와 동일한 순서로 나열되어야 합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "    *   알 수 없는 데이터 값은 `NULL`로 지정해야 합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "    *   문자열은 따옴표를 사용하며, 작은따옴표(')가 권장됩니다. 따옴표 안의 값은 대소문자를 구분합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "•   **선택한 컬럼에 데이터 삽입:**",
              "level": null
            },
            {
              "type": "code",
              "content": "INSERT INTO tablename (col1_name, col3_name, col4_name, …)\nVALUES (col1_value, col3_value, col4_value, …)",
              "level": null
            },
            {
              "type": "heading",
              "content": "INSERT 예시",
              "level": 3
            },
            {
              "type": "paragraph",
              "content": "•   **`course` 테이블에 새로운 튜플 추가:**",
              "level": null
            },
            {
              "type": "code",
              "content": "INSERT INTO course\nVALUES ('CS-437', 'Database Systems', 'Comp. Sci.', 4);",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "    또는 동일하게:",
              "level": null
            },
            {
              "type": "code",
              "content": "INSERT INTO course (course_id, title, dept_name, credits)\nVALUES ('CS-437', 'Database Systems', 'Comp. Sci.', 4);",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "•   **`student` 테이블에 `tot_creds`가 NULL인 새로운 튜플 추가:**",
              "level": null
            },
            {
              "type": "code",
              "content": "INSERT INTO student\nVALUES ('3003', 'Green', 'Finance', null);",
              "level": null
            },
            {
              "type": "heading",
              "content": "외래 키 제약 조건과 INSERT",
              "level": 3
            },
            {
              "type": "paragraph",
              "content": "외래 키는 한 릴레이션의 속성이 다른 릴레이션의 튜플에 매핑되어야 함을 지정합니다. 즉, 한 릴레이션의 값이 다른 릴레이션에 존재해야 합니다. 새로운 행을 삽입할 때는 해당 행이 참조하는 모든 외래 키가 데이터베이스에 이미 추가되어 있는지 확인해야 합니다. 참조된 릴레이션에 해당 값이 존재하지 않으면 외래 키 값을 삽입할 수 없습니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "다른 SELECT 쿼리 결과 삽입",
              "level": 3
            },
            {
              "type": "paragraph",
              "content": "`SELECT` 쿼리의 결과를 다른 테이블에 삽입할 수 있습니다. 이때 `SELECT FROM WHERE` 문은 그 결과가 릴레이션에 삽입되기 전에 완전히 평가됩니다. 이는 `INSERT INTO table1 SELECT * FROM table1`과 같은 질의에서 발생할 수 있는 문제를 방지합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "•   **음악학과 학생 중 144학점 이상을 이수한 학생들을 $18,000 급여의 음악학과 강사로 추가:**",
              "level": null
            },
            {
              "type": "code",
              "content": "INSERT INTO instructor\n  SELECT ID, name, dept_name, 18000\n  FROM student\n  WHERE dept_name = 'Music’ AND total_cred > 144;",
              "level": null
            },
            {
              "type": "heading",
              "content": "UPDATE (데이터 수정)",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "`UPDATE` 문은 테이블의 기존 데이터를 수정하는 데 사용됩니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "기본 문법",
              "level": 3
            },
            {
              "type": "paragraph",
              "content": "•   **테이블 업데이트 (조건 없음):** 모든 행의 지정된 컬럼을 수정합니다.",
              "level": null
            },
            {
              "type": "code",
              "content": "UPDATE tablename\nSET col1_name = new_col1_value, col2_name = new_col2_value, …;",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "•   **조건 있는 테이블 업데이트:** `WHERE` 절의 조건과 일치하는 행만 수정합니다.",
              "level": null
            },
            {
              "type": "code",
              "content": "UPDATE tablename\nSET col1_name = new_col1_value, col2_name = new_col2_value, …\nWHERE predicate;",
              "level": null
            },
            {
              "type": "heading",
              "content": "UPDATE 예시",
              "level": 3
            },
            {
              "type": "paragraph",
              "content": "•   **모든 강사의 급여를 5% 인상:**",
              "level": null
            },
            {
              "type": "code",
              "content": "UPDATE instructor\nSET salary = salary * 1.05",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "•   **급여가 70000 미만인 강사의 급여를 5% 인상:**",
              "level": null
            },
            {
              "type": "code",
              "content": "UPDATE instructor\nSET salary = salary * 1.05\nWHERE salary < 70000;",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "•   **급여가 평균 급여 미만인 강사의 급여를 5% 인상:**",
              "level": null
            },
            {
              "type": "code",
              "content": "UPDATE instructor\nSET salary = salary * 1.05\nWHERE salary <  (SELECT AVG(salary) FROM instructor);",
              "level": null
            },
            {
              "type": "heading",
              "content": "CASE 문을 이용한 조건부 UPDATE",
              "level": 3
            },
            {
              "type": "paragraph",
              "content": "여러 조건에 따라 다른 값을 적용해야 할 경우 `CASE` 문을 사용할 수 있습니다. 이는 여러 `UPDATE` 문을 사용하는 것보다 효율적이며, 실행 순서에 따른 문제를 방지할 수 있습니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "•   **급여가 $100,000 초과인 강사는 3% 인상, 그 외는 5% 인상:**",
              "level": null
            },
            {
              "type": "code",
              "content": "UPDATE instructor\nSET salary = CASE\n                           WHEN salary <= 100000 THEN salary * 1.05\n                           ELSE salary * 1.03\n                       END",
              "level": null
            },
            {
              "type": "heading",
              "content": "스칼라 서브쿼리를 이용한 UPDATE",
              "level": 3
            },
            {
              "type": "paragraph",
              "content": "스칼라 서브쿼리(단일 값을 반환하는 서브쿼리)를 사용하여 컬럼 값을 업데이트할 수 있습니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "•   **모든 학생의 `tot_creds` 값을 재계산하여 업데이트:**",
              "level": null
            },
            {
              "type": "code",
              "content": "UPDATE student S\nSET tot_cred = (SELECT SUM(credits)\n                             FROM takes, course\n                             WHERE takes.course_id = course.course_id  AND\n                                            S.ID= takes.ID  AND\n                                            takes.grade <> 'F' AND\n                                            takes.grade IS NOT NULL);",
              "level": null
            },
            {
              "type": "heading",
              "content": "DELETE (데이터 삭제)",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "`DELETE` 문은 테이블에서 행을 제거하는 데 사용됩니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "기본 문법",
              "level": 3
            },
            {
              "type": "paragraph",
              "content": "•   **특정 행 제거:** `WHERE` 절의 조건과 일치하는 행을 제거합니다.",
              "level": null
            },
            {
              "type": "code",
              "content": "DELETE FROM tablename\nWHERE predicate;",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "•   **모든 행 제거:** 테이블의 모든 행을 제거합니다.",
              "level": null
            },
            {
              "type": "code",
              "content": "DELETE FROM tablename;",
              "level": null
            },
            {
              "type": "heading",
              "content": "TRUNCATE와의 비교",
              "level": 3
            },
            {
              "type": "paragraph",
              "content": "`DELETE FROM tablename;`는 `TRUNCATE (TABLE) tablename;`와 기능적으로 유사하게 테이블의 모든 행을 제거합니다. 그러나 `TRUNCATE`는 외래 키 제약 조건이 있는 테이블에서는 사용할 수 없습니다. 외래 키 제약 조건이 있는 테이블을 `TRUNCATE`하려면 먼저 제약 조건을 비활성화해야 합니다.",
              "level": null
            },
            {
              "type": "code",
              "content": "ALTER TABLE tablename\nDISABLE CONSTRAINT constraint_name;",
              "level": null
            },
            {
              "type": "heading",
              "content": "DELETE 예시",
              "level": 3
            },
            {
              "type": "paragraph",
              "content": "•   **모든 강사 삭제:**",
              "level": null
            },
            {
              "type": "code",
              "content": "DELETE FROM instructor;",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "•   **재무학과 강사 모두 삭제:**",
              "level": null
            },
            {
              "type": "code",
              "content": "DELETE FROM instructor\nWHERE dept_name= 'Finance';",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "•   **Watson 건물에 위치한 부서에 소속된 강사 모두 삭제:**",
              "level": null
            },
            {
              "type": "code",
              "content": "DELETE FROM instructor\nWHERE dept_name IN (SELECT dept_name\n        FROM department\n        WHERE building = 'Watson');",
              "level": null
            },
            {
              "type": "heading",
              "content": "서브쿼리를 이용한 DELETE 시 주의사항",
              "level": 3
            },
            {
              "type": "paragraph",
              "content": "서브쿼리를 사용하여 `DELETE` 작업을 수행할 때, 삭제되는 튜플이 서브쿼리의 결과에 영향을 미칠 수 있습니다. 예를 들어, 강사 평균 급여보다 낮은 급여를 가진 강사를 삭제하는 경우, 강사가 삭제됨에 따라 평균 급여가 변경될 수 있습니다.",
              "level": null
            },
            {
              "type": "code",
              "content": "DELETE FROM instructor\nWHERE salary < (SELECT AVG (salary) FROM instructor);",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "SQL에서는 이러한 문제를 해결하기 위해 다음과 같은 방식을 사용합니다. 먼저 `AVG(salary)`를 계산하고 삭제할 모든 튜플을 찾은 다음, 평균을 재계산하거나 튜플을 재확인하지 않고 찾아진 모든 튜플을 삭제합니다.",
              "level": null
            }
          ],
          "aiNotes": {
            "summary": "이 문서는 SQL의 데이터 조작 언어(DML) 중 집계 함수와 데이터 수정 명령어(INSERT, UPDATE, DELETE)에 대해 설명합니다. 집계 함수의 종류(AVG, MIN, MAX, SUM, COUNT)와 사용 예시를 제시하며, GROUP BY 및 HAVING 절의 사용법과 WHERE 절과의 차이점을 강조합니다. 또한, INSERT 명령어를 이용한 데이터 삽입 방법, 외래 키 제약 조건과의 관계, 그리고 SELECT 쿼리 결과 삽입에 대해 다룹니다. UPDATE 명령어의 기본 문법, 다양한 조건부 업데이트 예시, 그리고 CASE 문 및 스칼라 서브쿼리 활용법을 설명합니다. 마지막으로 DELETE 명령어의 기본 문법, TRUNCATE와의 차이점, 외래 키 제약 조건, 그리고 서브쿼리를 사용한 삭제 시의 처리 방식에 대해 상세히 기술합니다.",
            "keyConcepts": [
              {
                "term": "집계 함수 (Aggregate Functions)",
                "definition": "릴레이션의 컬럼 값들의 멀티셋에 대해 작동하여 단일 값을 반환하는 함수 (예: AVG, MIN, MAX, SUM, COUNT)."
              },
              {
                "term": "GROUP BY",
                "definition": "SQL에서 특정 컬럼의 값을 기준으로 행들을 그룹으로 묶어 각 그룹에 대해 집계 함수를 적용할 수 있게 하는 절."
              },
              {
                "term": "HAVING 절",
                "definition": "GROUP BY 절에 의해 생성된 그룹에 조건을 적용하여 결과를 필터링하는 데 사용되는 절. WHERE 절과 달리 그룹화 후에 적용된다."
              },
              {
                "term": "INSERT",
                "definition": "SQL에서 테이블에 새로운 행(튜플)을 추가하는 데 사용되는 DML 명령어."
              },
              {
                "term": "UPDATE",
                "definition": "SQL에서 테이블의 기존 데이터를 수정하는 데 사용되는 DML 명령어."
              },
              {
                "term": "DELETE",
                "definition": "SQL에서 테이블의 행을 제거하는 데 사용되는 DML 명령어."
              }
            ],
            "importantTerms": [
              {
                "term": "멀티셋 (Multiset)",
                "definition": "중복된 값을 허용하는 집합."
              },
              {
                "term": "튜플 (Tuple)",
                "definition": "릴레이션(테이블)의 한 행을 의미한다."
              },
              {
                "term": "외래 키 (Foreign Key)",
                "definition": "한 릴레이션의 속성이 다른 릴레이션의 기본 키를 참조하여 두 릴레이션 간의 관계를 설정하는 제약 조건."
              },
              {
                "term": "스칼라 서브쿼리 (Scalar Subquery)",
                "definition": "단일 행, 단일 컬럼의 값을 반환하는 서브쿼리."
              },
              {
                "term": "TRUNCATE",
                "definition": "테이블의 모든 행을 빠르게 제거하는 DDL 명령어. DELETE와 달리 외래 키 제약 조건이 있는 테이블에는 직접 적용할 수 없다."
              }
            ],
            "outline": [
              {
                "text": "집계 함수 (Aggregate Functions)",
                "id": "집계-함수-aggregate-functions",
                "children": [
                  {
                    "text": "집계 함수 예시",
                    "id": "집계-함수-예시",
                    "children": null
                  },
                  {
                    "text": "GROUP BY 절",
                    "id": "group-by-절",
                    "children": [
                      {
                        "text": "GROUP BY 규칙",
                        "id": "group-by-규칙",
                        "children": null
                      }
                    ]
                  },
                  {
                    "text": "HAVING 절",
                    "id": "having-절",
                    "children": [
                      {
                        "text": "HAVING과 WHERE의 차이",
                        "id": "having과-where의-차이",
                        "children": null
                      }
                    ]
                  }
                ]
              },
              {
                "text": "SQL DML 명령어",
                "id": "sql-dml-명령어",
                "children": [
                  {
                    "text": "INSERT (데이터 삽입)",
                    "id": "insert-데이터-삽입",
                    "children": [
                      {
                        "text": "기본 문법",
                        "id": "기본-문법",
                        "children": null
                      },
                      {
                        "text": "INSERT 예시",
                        "id": "insert-예시",
                        "children": null
                      },
                      {
                        "text": "외래 키 제약 조건과 INSERT",
                        "id": "외래-키-제약-조건과-insert",
                        "children": null
                      },
                      {
                        "text": "다른 SELECT 쿼리 결과 삽입",
                        "id": "다른-select-쿼리-결과-삽입",
                        "children": null
                      }
                    ]
                  },
                  {
                    "text": "UPDATE (데이터 수정)",
                    "id": "update-데이터-수정",
                    "children": [
                      {
                        "text": "기본 문법",
                        "id": "기본-문법-1",
                        "children": null
                      },
                      {
                        "text": "UPDATE 예시",
                        "id": "update-예시",
                        "children": null
                      },
                      {
                        "text": "CASE 문을 이용한 조건부 UPDATE",
                        "id": "case-문을-이용한-조건부-update",
                        "children": null
                      },
                      {
                        "text": "스칼라 서브쿼리를 이용한 UPDATE",
                        "id": "스칼라-서브쿼리를-이용한-update",
                        "children": null
                      }
                    ]
                  },
                  {
                    "text": "DELETE (데이터 삭제)",
                    "id": "delete-데이터-삭제",
                    "children": [
                      {
                        "text": "기본 문법",
                        "id": "기본-문법-2",
                        "children": null
                      },
                      {
                        "text": "TRUNCATE와의 비교",
                        "id": "truncate와의-비교",
                        "children": null
                      },
                      {
                        "text": "DELETE 예시",
                        "id": "delete-예시",
                        "children": null
                      },
                      {
                        "text": "서브쿼리를 이용한 DELETE 시 주의사항",
                        "id": "서브쿼리를-이용한-delete-시-주의사항",
                        "children": null
                      }
                    ]
                  }
                ]
              }
            ]
          },
          "quiz": [
            {
              "question": "다음 중 SQL의 `HAVING` 절에 대한 설명으로 올바른 것은 무엇입니까?",
              "options": [
                "그룹을 형성하기 전에 개별 행에 조건을 적용합니다.",
                "집계 함수가 적용된 그룹에 조건을 적용합니다.",
                "테이블에서 데이터를 삭제할 때 사용됩니다.",
                "새로운 행을 테이블에 삽입할 때 사용됩니다."
              ],
              "answerIndex": 1,
              "explanation": "`HAVING` 절은 `GROUP BY` 절에 의해 생성된 그룹에 조건을 적용하여 필터링하는 데 사용됩니다. `WHERE` 절과 달리 그룹화가 완료된 후에 적용됩니다."
            },
            {
              "question": "SQL `INSERT` 문을 사용하여 새 행을 삽입할 때, 외래 키(Foreign Key) 제약 조건과 관련하여 반드시 지켜야 할 사항은 무엇입니까?",
              "options": [
                "외래 키 값은 항상 NULL로 설정되어야 합니다.",
                "새로운 행의 외래 키 값이 참조하는 릴레이션에 이미 존재해야 합니다.",
                "외래 키 값은 삽입 후 자동으로 생성됩니다.",
                "외래 키 제약 조건은 `INSERT` 작업에 영향을 미치지 않습니다."
              ],
              "answerIndex": 1,
              "explanation": "외래 키는 다른 릴레이션의 기본 키를 참조하므로, 새로운 행을 삽입할 때 해당 외래 키 값이 참조하는 릴레이션에 이미 존재해야 참조 무결성이 유지됩니다."
            },
            {
              "question": "다음 SQL `UPDATE` 문 중, 급여가 $100,000 이하인 강사의 급여는 5% 인상하고, $100,000 초과인 강사의 급여는 3% 인상하는 올바른 방법은 무엇입니까?",
              "options": [
                "UPDATE instructor SET salary = salary * 1.05 WHERE salary <= 100000; UPDATE instructor SET salary = salary * 1.03 WHERE salary > 100000;",
                "UPDATE instructor SET salary = CASE WHEN salary <= 100000 THEN salary * 1.05 ELSE salary * 1.03 END;",
                "UPDATE instructor SET salary = salary * 1.03 OR salary * 1.05;",
                "UPDATE instructor WHERE salary <= 100000 SET salary = salary * 1.05; ELSE SET salary = salary * 1.03;"
              ],
              "answerIndex": 1,
              "explanation": "`CASE` 문은 여러 조건에 따라 다른 값을 적용할 때 사용되는 효율적인 방법입니다. 제시된 `CASE` 문은 주어진 조건에 따라 급여 인상률을 정확하게 적용합니다. 두 개의 `UPDATE` 문을 사용하는 첫 번째 옵션도 가능하지만, 순서에 따라 결과가 달라질 수 있고 `CASE` 문이 더 간결하고 안전한 방법입니다."
            }
          ]
        }
      ],
      "log_entries": [
        {
          "node": "start_processing",
          "status": "completed",
          "state_snapshot": {
            "run_id": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d",
            "pdf_file_paths": [
              "temp_pdf_uploads/cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_1a4c2f45-b482-4e82-826e-fa8945eb99c7_DB03 - mysql.pdf",
              "temp_pdf_uploads/cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf"
            ],
            "notebook_title": "",
            "holistic_chapters": [],
            "generated_content": [],
            "final_result": ""
          }
        },
        {
          "node": "start_processing",
          "status": "completed",
          "state_snapshot": {
            "run_id": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d",
            "pdf_file_paths": [
              "temp_pdf_uploads/cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_1a4c2f45-b482-4e82-826e-fa8945eb99c7_DB03 - mysql.pdf",
              "temp_pdf_uploads/cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf"
            ],
            "notebook_title": "",
            "holistic_chapters": [],
            "generated_content": [],
            "final_result": ""
          }
        },
        {
          "node": "analyze_overall_structure",
          "status": "completed",
          "state_snapshot": {
            "run_id": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d",
            "pdf_file_paths": [
              "temp_pdf_uploads/cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_1a4c2f45-b482-4e82-826e-fa8945eb99c7_DB03 - mysql.pdf",
              "temp_pdf_uploads/cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf"
            ],
            "notebook_title": "관계형 데이터베이스 시스템: MySQL 소개 및 SQL 심층 활용",
            "holistic_chapters": [
              {
                "chapter_title": "관계형 데이터베이스 시스템(R-DBMS) 개요 및 MySQL 소개",
                "source_pdf_filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_1a4c2f45-b482-4e82-826e-fa8945eb99c7_DB03 - mysql.pdf",
                "chapter_content_summary": "이 장에서는 관계형 데이터베이스 관리 시스템(R-DBMS)의 기본 개념을 소개하고, 대표적인 오픈소스 R-DBMS인 MySQL에 대해 심층적으로 다룹니다. MySQL의 정의, Oracle 소유권, 표준 SQL 호환성, 상업적 웹 서비스에서의 활용 사례, 기업 사용 통계, 그리고 MySQL의 인기 요인(다양한 운영체제 및 프로그래밍 언어 지원, 비용 효율성, 고성능)을 설명합니다. 또한, R-DBMS 시장에서의 MySQL의 트렌드와 인기도를 살펴보고, MySQL 5.x와 8.x 버전의 주요 차이점 및 MySQL 커뮤니티 버전을 다운로드하고 Docker 이미지를 활용하는 방법을 안내합니다. MySQL이 대규모 데이터 처리, 다중 사용자 지원, 효율성, 안정성, 보안성 측면에서 갖는 강점들을 강조합니다.",
                "chapter_full_text": "ECE30030/ITP30010 Database SystemsHandshaking with an R-DBMSCharmgil Hongcharmgil@handong.eduSpring, 2025Handong Global University\n1\nAgenda•Introduction to MySQL•SQL preview\nECE30030/ITP30010 Database Systems2\nMySQL•MySQL is an SQL-based relational database management system (DBMS)•Free and open-source R-DBMS (under GPL)•Owned by Oracle•Commercial version of MySQL is also provided (including technical support)•“My” came from the name of co-founder Michael Widenius’ daughter•C.f., MariaDB•Compatible with standard SQL•Frequently used for commercial web services\nECE30030/ITP30010 Database Systems3\n* Image src: https://en.wikipedia.org/wiki/MySQL\nMySQL•Companies using MySQL (a study by Enlyft)•“We have data on 199,498 (out of 1,409,176) companies that use MySQL”•Often used by companies with 10-50 employees and 1M-10M dollars in revenue•C.f., Oracle 12 is most often used by companies with 50-200 employees and >1000M dollars in revenue\nECE30030/ITP30010 Database Systems4* Source: https://enlyft.com/tech/products/mysql \nMySQL•Companies using MySQL (full list: https://www.mysql.com/customers/)\nECE30030/ITP30010 Database Systems5\n* Source: https://stackshare.io/mysql \nMySQL•Why MySQL?•Popular•Active discussions all over the Internet•Versatile: runs on Linux, Windows, Mac OS X, Solaris, FreeBSD, …•Supports wide range of programming languages (C/C++, Java, Python, .Net, …)•Cost starts from zero•High performance (fast and reliable)\nECE30030/ITP30010 Database Systems6* Image src: https://db-engines.com/en/ranking\nDBMS Trend Popularity\n•Score definition: https://db-engines.com/en/ranking_definition\nECE30030/ITP30010 Database Systems7* Image src: https://db-engines.com/en/ranking_trend \nMySQL•Why MySQL?•Popular•Active discussions all over the Internet•Versatile: runs on Linux, Windows, Mac OS X, Solaris, FreeBSD, …•Supports wide range of programming languages (C/C++, Java, Python, .Net, …)•Cost starts from zero•High performance (fast and reliable)\nECE30030/ITP30010 Database Systems8* Image src: https://dev.mysql.com/downloads/\nMySQL\nECE30030/ITP30010 Database Systems9\n•Massive•Convenient•Multi-user•Safe•Efficient•Reliable\nCan handle terabytes of dataSupports high-level query languageSupports concurrent data accessSupports transactionsCan handle thousands of queries/second99.99% up-time in many real-world products\nMySQL Versions•MySQL 5.x vs 8.x\nECE30030/ITP30010 Database Systems10\nVersion 5.x-Most popular version of MySQL-More stable and conventionalVersion 8.x-Current version-Provides up-to-date DB functionalities (better storage engine, faster, more secure)\n* Source: https://www.eversql.com/mysql-8-adoption-usage-rate/#:~:text=MySQL%205.7%20is%20still%20the,17%25%20are%20using%20MySQL%208. \nMySQL Versions•MySQL 5.x vs 8.x\nECE30030/ITP30010 Database Systems11\nVersion 5.x-Most popular version of MySQL-More stable and conventionalVersion 8.x-Current version-Provides up-to-date DB functionalities (better storage engine, faster, more secure)\n* Source: https://severalnines.com/database-blog/mysql-performance-benchmarking-mysql-57-vs-mysql-80 \nMySQL Versions•MySQL 5.x vs 8.x\nECE30030/ITP30010 Database Systems12\nVersion 5.x-Most popular version of MySQL-More stable and conventionalVersion 8.x-Current version-Provides up-to-date DB functionalities (better storage engine, faster, more secure)\n* Source: https://severalnines.com/database-blog/mysql-performance-benchmarking-mysql-57-vs-mysql-80 \nWhere to Get MySQL?•https://dev.mysql.com/downloads/•Look for the “Community” versions – the branch that is available for free•”Enterprise” versions are the commercial ones•We have prepared a Docker image for the course•Consists of Ubuntu Server, MySQL, example databases for course activities\nECE30030/ITP30010 Database Systems13* Image src: https://www.docker.com \nWhere to Get MySQL?\nECE30030/ITP30010 Database Systems14\n* Image source: https://baumannalexj.medium.com/connect-your-db-tool-to-a-dockerized-mysql-server-container-bc18853524ed   https://www.jetbrains.com/datagrip/features/look_and_feel.html"
              },
              {
                "chapter_title": "SQL(구조적 질의어)의 이해: 기본 개념과 역사",
                "source_pdf_filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf",
                "chapter_content_summary": "SQL(Structured Query Language)의 정의와 관계형 데이터베이스를 조작하는 주된 언어로서의 역할을 설명합니다. SQL이 '무엇을 할지'를 명시하는 고수준 언어이며, DBMS가 '어떻게 할지'를 결정하는 쿼리 최적화 과정을 다룹니다. 또한, SQL의 두 가지 주요 측면인 데이터 정의 언어(DDL)와 데이터 조작 언어(DML)를 소개하고, 무결성, 뷰 정의, 트랜잭션 제어, 내장 SQL 및 동적 SQL, 권한 부여와 같은 SQL의 다양한 구성 요소를 살펴봅니다. 마지막으로, IBM SEQUEL에서 시작하여 Oracle V2를 거쳐 ANSI 및 ISO 표준으로 발전한 SQL의 간략한 역사를 소개하고, 기본적인 SQL 쿼리 구조(SELECT, FROM, WHERE)를 설명합니다.",
                "chapter_full_text": "ECE30030/ITP30010 Database SystemsStructured Query LanguageReading: Chapter 3\nCharmgil Hongcharmgil@handong.eduSpring, 2025Handong Global University\n1\nAgenda•Structured query language (SQL)•SQL data manipulation language (DML)•SELECT, FROM, WHERE•NULL values•Set operations•String operations, ordering•Aggregate functions, aggregation•SQL data definition language (DDL)   --   NEXT CLASS\nECE30030/ITP30010 Database Systems2\nStructured Query Language (SQL)•SQL: Structured Query Language•The principal language used to describe and manipulate relational databases•Very high-level•Say “what to do” rather than “how to do it”•SQL is not specifying data-manipulation details•DBMSs figure out the “best” way to execute queries•Called “query optimization”•Two aspects to SQL•Data definition: for declaring database schemas (DDL)•Data manipulation: for querying (asking questions about) databases and for modifying the database (DML)\nECE30030/ITP30010 Database Systems3\nSQL Parts•DML – provides the ability to query information from the database and to insert tuples into, delete tuples from, and modify tuples in the database•Integrity – the DDL includes commands for specifying integrity constraints•View definition – the DDL includes commands for defining views•Transaction control – includes commands for specifying the beginning and ending of transactions•Embedded SQL and dynamic SQL – define how SQL statements can be embedded within general-purpose programming language•Authorization – includes commands for specifying access rights to relations and viewsECE30030/ITP30010 Database Systems4\nA Brief History•IBM SEQUEL (Structured English Query Language) was developed as a part of the System R project (Chamberlin and Boyce, early 1970s)•Later on, SEQUEL was renamed SQL (structured query language)•System R à System/38 (1979), SQL/DS (1981), DB2 (1983)•Relational Software, Inc released the first commercial implementation of SQL, Oracle V2 for VAX computers•Relational Software, Inc is now Oracle Corporation•ANSI and ISO standardized SQL:•SQL-86,  SQL-89,  SQL-92,  SQL:1999,  …,  SQL:2011,  SQL:2016 (current)•SQL-92 is supported by the most of database systems\nECE30030/ITP30010 Database Systems5\nBasic Query Structure•A typical SQL query has the form:   SELECT A1, A2, ..., An FROM r1, r2, ..., rm WHERE P•Ai represents an attribute•Ri represents a relation•P is a predicate\n•The result of an SQL query is a relation\nECE30030/ITP30010 Database Systems6"
              },
              {
                "chapter_title": "SQL 데이터 조작 언어(DML) 기초: SELECT, FROM, WHERE 절",
                "source_pdf_filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf",
                "chapter_content_summary": "이 장에서는 SQL 데이터 조작 언어(DML)의 핵심 구성 요소인 SELECT, FROM, WHERE 절을 상세히 다룹니다. 'instructor' 및 'teaches'와 같은 예시 관계(테이블)를 사용하여 실제 쿼리 작성 방법을 시연합니다. SELECT 절을 통해 원하는 속성을 선택하고, 중복을 포함하거나 제거하는 방법(ALL, DISTINCT), 모든 속성을 선택하는 '*' 사용법, 리터럴 및 산술 표현식 활용, 그리고 AS 키워드를 사용한 속성 이름 변경 방법을 학습합니다. WHERE 절에서는 논리 연산자(AND, OR, NOT) 및 비교 연산자(<, <=, >, >=, =, <>, BETWEEN)를 사용하여 조건을 지정하고, 튜플 비교를 수행하는 방법을 설명합니다. 마지막으로 FROM 절을 통해 쿼리에 포함될 관계를 지정하고, 카르테시안 곱을 이해하며, WHERE 절과 결합하여 JOIN 연산을 구현하는 방법을 구체적인 예시와 함께 제시합니다. 또한, AS 키워드를 이용한 관계 및 속성 이름 변경(별칭 지정)을 다룹니다.",
                "chapter_full_text": "ECE30030/ITP30010 Database Systems7\nSQL Data Manipulation Language•The SQL data-manipulation language (DML) allows querying (ask questions about) and modifying the databases\nECE30030/ITP30010 Database Systems8\nRunning Examples•Relations (tables): instructor, teaches\nECE30030/ITP30010 Database Systems9\nInstructor relationteaches relation\nBasic Query Structure•A typical SQL query has the form:   SELECT A1, A2, ..., An FROM r1, r2, ..., rm WHERE P•Ai represents an attribute•Ri represents a relation•P is a predicate\n•The result of an SQL query is a relation\nECE30030/ITP30010 Database Systems10\nThe SELECT Clause•The SELECT clause lists the attributes desired in the result of a query•Corresponds to the projection operation of the relational algebra\n•Example: Find the names of all instructors•SQL: SELECT name FROM instructor;\nECE30030/ITP30010 Database Systems11\nNote•Note: SQL names are case insensitive•E.g., Name ≡ NAME ≡ name•SQL commands (SELECT, FROM, WHERE, …) are written in upper case (just a convention)•MySQL has an option flag, lower_case_table_names•Link: https://dev.mysql.com/doc/refman/8.0/en/identifier-case-sensitivity.html \nECE30030/ITP30010 Database Systems12\nThe SELECT Clause•SQL allows duplicates in relations as well as in query results•The keyword ALL specifies that duplicates should not be removed SELECT ALL dept_name FROM instructor\nECE30030/ITP30010 Database Systems13\nThe SELECT Clause•SQL allows duplicates in relations as well as in query results•The keyword ALL specifies that duplicates should not be removed SELECT ALL dept_name FROM instructor•To force the elimination of duplicates, insert the keyword DISTINCT after SELECT•Find the department names of all instructor, removing duplicates: SELECT DISTINCT dept_name FROM instructor;\nECE30030/ITP30010 Database Systems14\nThe SELECT Clause•An asterisk in the select clause denotes “all attributes” SELECT * FROM instructor;•An attribute can be a literal with no FROM clause SELECT ‘437’;•Result is a table with one column and a single row with value “437”•Can give the column a name using AS: SELECT ‘437’ AS FOO\nECE30030/ITP30010 Database Systems15\nThe SELECT Clause•An attribute can be a literal with FROM clause SELECT 'A' FROM instructor•Result is a table with one column and N rows (number of tuples in the instructor table), each row with value “A”\nECE30030/ITP30010 Database Systems16\nThe SELECT Clause•The SELECT clause can contain arithmetic expressions involving the operation, +, –, *, and /, and operating on constants or attributes of tuples•The query:     SELECT ID, name, salary/12      FROM instructorwould return a relation that is the same as the instructor relation,except that the value of the attribute salary is divided by 12\n17\nThe SELECT Clause•The SELECT clause can contain arithmetic expressions involving the operation, +, –, *, and /, and operating on constants or attributes of tuples•Can rename “salary/12” using the AS clause:  SELECT ID, name, salary/12 AS monthly_salary   FROM instructor\n18\nThe WHERE Clause•The WHERE clause specifies conditions that the result must satisfy•Corresponds to the selection predicate of the relational algebra•E.g., To find all instructors in Comp. Sci. dept: SELECT name FROM instructor  WHERE dept_name = 'Comp. Sci.';\nECE30030/ITP30010 Database Systems19\nThe WHERE Clause•SQL allows the use of the logical connectives AND, OR, and NOT•The operands of the logical connectives can be expressions involving the comparison operators <, <=, >, >=, =, and <>•<> means not equal (there is no != in SQL)•Comparisons can be applied to results of arithmetic expressions•E.g., To find all instructors in Comp. Sci. with salary > 70,000: SELECT name FROM instructor WHERE dept_name = 'Comp. Sci.' AND salary > 70000;\nECE30030/ITP30010 Database Systems20\nThe WHERE Clause•SQL includes a BETWEEN comparison operator•Example: Find the names of all instructors with salary between $90,000 and $100,000 (that is, ³ $90,000 and £ $100,000)•SELECT nameFROM instructorWHERE salary BETWEEN 90000 AND 100000\nECE30030/ITP30010 Database Systems21\nThe WHERE Clause•Tuple comparison: makes comparisons per tuple•SELECT name, course_idFROM instructor, teachesWHERE (instructor.ID, dept_name) = (teaches.ID, 'Biology');\nECE30030/ITP30010 Database Systems22\nThe FROM Clause•The FROM clause lists the relations involved in the query•Corresponds to the Cartesian-product operation of the relational algebra•Find the Cartesian-product instructor × teaches SELECT * FROM instructor, teaches;•Generates every possible instructor-teaches pairs, with all attributes from both relations•For common attributes (e.g., ID), the attributes in the resulting table are renamed using the relation name (e.g., instructor.ID)\nECE30030/ITP30010 Database Systems23\nThe FROM Clause•Find the Cartesian-product instructor X teaches SELECT * FROM instructor, teaches;\n24\ninstructor.IDnamedept_namesalaryteaches.IDcourse_idsec_idsemesteryear10101SrinivasanComp. Sci.6500076766BIO-101 1Summer201712121WuFinance9000076766BIO-101 1Summer201715151MozartMusic4000076766BIO-101 1Summer201722222EinsteinPhysics9500076766BIO-101 1Summer201732343El SaidHistory6000076766BIO-101 1Summer2017… … … … … … … … …10101SrinivasanComp. Sci.6500010101CS-101 1Fall 201712121WuFinance9000010101CS-101 1Fall 201715151MozartMusic4000010101CS-101 1Fall 201722222EinsteinPhysics9500010101CS-101 1Fall 201732343El SaidHistory6000010101CS-101 1Fall 2017… … … … … … … … …… … … … … … … … …10101SrinivasanComp. Sci.6500083821CS-190 2Spring201712121WuFinance9000083821CS-190 2Spring201715151MozartMusic4000083821CS-190 2Spring2017… … … … … … … … …10101SrinivasanComp. Sci.6500010101CS-315 1Spring201812121WuFinance9000010101CS-315 1Spring201815151MozartMusic4000010101CS-315 1Spring2018… … … … … … … … …… … … … … … … … …\nImplementing JOIN•Cartesian-product is not very useful directly; but useful combined with WHERE-clause condition (selection operation in relational algebra)•Cartesian-product + selection = join•E.g., Find the names of all instructors who have taught some course and the course_id SELECT name, course_id FROM instructor , teaches WHERE instructor.ID = teaches.ID\nECE30030/ITP30010 Database Systems25\nImplementing JOIN•Cartesian-product is not very useful directly; but useful combined with WHERE-clause condition (selection operation in relational algebra)•Cartesian-product + selection = join•Find the names of all instructors in the Music department who have taught some course and the course_id SELECT name, course_id FROM instructor , teaches WHERE instructor.ID = teaches.ID  AND instructor. dept_name = 'Music'\nECE30030/ITP30010 Database Systems26\nThe Rename Operation•The SQL allows renaming relations and attributes using the AS clause:   old-name AS new-name•Find the names of all instructors who have a higher salary than some instructor in ‘Comp. Sci.’•SELECT DISTINCT T.nameFROM instructor AS T, instructor AS SWHERE T.salary > S.salary AND S.dept_name = 'Comp. Sci.'\nECE30030/ITP30010 Database Systems27\nThe Rename Operation•The SQL allows renaming relations and attributes using the AS clause:   old-name AS new-name•Find the names of all instructors who have a higher salary than some instructor in ‘Comp. Sci.’•SELECT DISTINCT T.nameFROM instructor AS T, instructor AS SWHERE T.salary > S.salary AND S.dept_name = 'Comp. Sci.'•Keyword AS is optional and may be omitted  instructor AS T  ≡  instructor T\nECE30030/ITP30010 Database Systems28"
              },
              {
                "chapter_title": "SQL DML 고급 기능: NULL 값, 집합 연산, 문자열 처리 및 정렬",
                "source_pdf_filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf",
                "chapter_content_summary": "이 장에서는 SQL DML의 고급 기능을 탐구합니다. 먼저, 알려지지 않거나 존재하지 않는 값을 나타내는 NULL 값의 특성을 이해하고, 산술 연산에서의 NULL 동작 및 IS NULL / IS NOT NULL 술어를 사용하여 NULL 값을 확인하는 방법을 배웁니다. 다음으로, 여러 쿼리 결과를 결합하는 집합 연산인 UNION, INTERSECT, EXCEPT를 살펴봅니다. 각 연산이 기본적으로 중복을 제거하며, ALL 키워드를 사용하여 중복을 유지하는 방법을 설명합니다. 특히 MySQL에서 INTERSECT와 EXCEPT가 직접 지원되지 않을 때 JOIN 또는 NOT IN을 사용하여 에뮬레이션하는 기법을 소개합니다. 이어서, 문자열 패턴 매칭을 위한 LIKE 연산자와 '%' (모든 부분 문자열), '_' (단일 문자) 특수 문자의 사용법을 다룹니다. 백슬래시를 이용한 이스케이프 문자 처리, 패턴 매칭의 대소문자 구분, 그리고 연결, 대소문자 변환, 길이 확인, 부분 문자열 추출 등 다양한 SQL 문자열 함수를 소개합니다. 마지막으로, ORDER BY 절을 사용하여 쿼리 결과를 특정 속성을 기준으로 오름차순(ASC) 또는 내림차순(DESC)으로 정렬하는 방법을 학습하며, 여러 속성을 기준으로 정렬하는 예시도 제시합니다.",
                "chapter_full_text": "ECE30030/ITP30010 Database Systems29\nNULL Values•It is possible for tuples to have a NULL value for some of their attributes•NULL signifies an unknown value or that a value does not exist•The result of any arithmetic expression involving NULL is NULL•E.g.,  5 + NULL returns NULL\nECE30030/ITP30010 Database Systems30\nIS NULL / IS NOT NULL•The predicate IS NULL can be used to check for NULL values•E.g., Find all instructors whose salary is null SELECT name FROM instructor WHERE salary IS NULL•The predicate IS NOT NULL succeeds if the value on which it is applied is not null\nECE30030/ITP30010 Database Systems31\nECE30030/ITP30010 Database Systems32\nSet Operations•Set operations UNION, INTERSECT, and EXCEPT•Each of the above operations automatically eliminates duplicates•To retain all duplicates, use ALL:•UNION ALL•INTERSECT ALL•EXCEPT ALL\n•C.f., SELECT retains all duplicates by default\nECE30030/ITP30010 Database Systems33\nSet Operations: UNION•Find courses that ran in Fall 2017 or in Spring 2018•(SELECT course_id  FROM teaches WHERE semester = 'Fall' AND year = 2017)UNION(SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018)\nECE30030/ITP30010 Database Systems34\nSet Operations: INTERSECT•Find courses that ran in Fall 2017 and in Spring 2018•(SELECT course_id  FROM teaches WHERE semester = 'Fall' AND year = 2017)INTERSECT(SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018)•C.f., MySQL does NOT support INTERSECT•One can emulate INTERSECT using JOIN (we’ll study JOIN later)•SELECT LT.course_idFROM (SELECT course_id FROM teaches WHERE semester = 'Fall' AND year = 2017) AS LTJOIN (SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018) AS RTON LT.course_id=RT.course_id;\nECE30030/ITP30010 Database Systems35\nSet Operations: EXCEPT•Find courses that ran in Fall 2017 but not in Spring 2018•(SELECT course_id  FROM teaches WHERE semester = 'Fall' AND year = 2017)EXCEPT(SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018)•C.f., MySQL does NOT support EXCEPT•One can emulate EXCEPT using NOT IN•SELECT course_id FROM teaches WHERE semester = 'Fall' AND year = 2017AND course_id NOT IN(SELECT course_id  FROM teaches  WHERE semester = 'Spring' AND year = 2018);\nECE30030/ITP30010 Database Systems36\nECE30030/ITP30010 Database Systems37\nString Operations•SQL includes a string-matching operator for comparisons on character strings•The operator LIKE uses patterns that are described using two special characters:•percent (%) – The % character matches any substring•underscore (_) – The _ character matches any character•Find the names of all instructors whose name includes the substring “ri” SELECT name FROM instructor WHERE name LIKE ‘%ri%'\nECE30030/ITP30010 Database Systems38\nString Operations•Escape character: Use backslash (\\) as the escape character•E.g., Match the string “100%” LIKE '100 \\%’ ESCAPE  ‘\\’\nECE30030/ITP30010 Database Systems39\nString Operations•Patterns are case sensitive•Pattern matching examples:•'Intro%' matches any string beginning with “Intro”•'%Comp%' matches any string containing “Comp” as a substring•'_ _ _' matches any string of exactly three characters•'_ _ _ %' matches any string of at least three characters•SQL supports a variety of string operations such as•concatenation (using “||”)•converting from upper to lower case (and vice versa)•finding string length, extracting substrings, etc.\nECE30030/ITP30010 Database Systems40\nOrdering the Display of Tuples•List in alphabetic order the names of all instructors•SELECT DISTINCT nameFROM instructorORDER BY name\nECE30030/ITP30010 Database Systems41\nOrdering the Display of Tuples•Can sort on multiple attributes•E.g., SELECT dept_name, name     FROM instructor      ORDER BY dept_name, name\nECE30030/ITP30010 Database Systems42\nOrdering the Display of Tuples•We may specify DESC for descending order or ASC for ascending order, for each attribute; ascending order is the default•E.g., ORDER BY name DESC\nECE30030/ITP30010 Database Systems43"
              },
              {
                "chapter_title": "SQL DML 집계 함수 및 데이터 수정 (INSERT, UPDATE, DELETE)",
                "source_pdf_filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf",
                "chapter_content_summary": "이 장에서는 SQL 데이터 조작 언어(DML)의 고급 기능인 집계 함수와 데이터를 수정하는 명령어를 다룹니다. AVG, MIN, MAX, SUM, COUNT와 같은 집계 함수를 사용하여 컬럼 값의 멀티셋에 대한 통계 값을 계산하는 방법을 학습합니다. 특히 GROUP BY 절을 이용한 데이터 그룹화와 HAVING 절을 이용한 그룹별 필터링을 심층적으로 다루며, WHERE 절과의 차이점을 명확히 설명합니다. 또한, DML의 핵심 명령인 INSERT, UPDATE, DELETE에 대해 자세히 알아봅니다. INSERT 명령을 통해 테이블에 새로운 튜플을 추가하는 다양한 방법(모든 컬럼, 선택된 컬럼, NULL 값 처리, SELECT 쿼리 결과 삽입)과 외래 키 제약 조건의 중요성을 강조합니다. UPDATE 명령으로는 기존 데이터를 수정하는 기본 구문, 조건부 업데이트, CASE 문을 사용한 복잡한 조건 처리, 스칼라 서브쿼리 활용법을 배웁니다. 마지막으로 DELETE 명령을 통해 테이블에서 특정 행 또는 모든 행을 삭제하는 방법과 TRUNCATE 명령의 차이점, 그리고 삭제 시 서브쿼리 사용 시의 고려사항을 설명합니다.",
                "chapter_full_text": "ECE30030/ITP30010 Database Systems44\nAggregate Functions•These functions operate on the multiset of values of a column of a relation, and return a value•AVG:  average value•MIN:  minimum value•MAX:  maximum value•SUM:  sum of values•COUNT:  number of values\nECE30030/ITP30010 Database Systems45\nAggregate Functions Examples•Find the average salary of instructors in the Computer Science department•SELECT AVG(salary)FROM instructorWHERE dept_name= 'Comp. Sci.';•Find the total number of instructors who teach a course in the Spring 2018 semester•SELECT COUNT(DISTINCT ID)FROM teachesWHERE semester = 'Spring’ AND year = 2018;•Find the number of tuples in the teaches relation•SELECT COUNT (*)FROM teaches;\nECE30030/ITP30010 Database Systems46\nAggregate Functions: Group By•Find the average salary of instructors in each department•SELECT dept_name, AVG(salary) AS avg_salaryFROM instructorGROUP BY dept_name;\nECE30030/ITP30010 Database Systems47\nAggregation•Attributes in SELECT clause outside of aggregate functions must appear in GROUP BY list•/* erroneous query */SELECT dept_name, ID, AVG(salary)FROM instructorGROUP BY dept_name;\nECE30030/ITP30010 Database Systems48\nAggregate Functions – Having Clause•Find the names and average salaries of all departments whose average salary is greater than 65000•SELECT dept_name, AVG(salary) AS avg_salaryFROM instructorGROUP BY dept_nameHAVING AVG(salary) > 65000;\nECE30030/ITP30010 Database Systems49\nAggregate Functions – Having Clause•Note: predicates in the HAVING clause are applied after the formation of groups whereas predicates in the WHERE clause are applied before forming groups\nECE30030/ITP30010 Database Systems50\nSELECT dept_name, AVG(salary) AS avg_salaryFROM instructorGROUP BY dept_nameHAVING AVG(salary) > 65000;\nSELECT dept_name, AVG(salary) AS avg_salaryFROM instructorWHERE salary > 65000GROUP BY dept_name;\nSQL Commands\nSQLDMLSELECTINSERTUPDATEDELETE\nDDLCREATEALTERDROP\nECE30030/ITP30010 Database Systems51\nINSERT•Basic syntax•Insert data into every column:•INSERT INTO tablenameVALUES (col1_value, col2_value, …)•Must list values in the same order as in the table schema•If some data values are unknown, must type NULL •For character sequences, use quotation marks•Single quotation marks are preferred (but double quotation marks are allowed)•Value in quotations is case-sensitive•Insert data into selected columns•INSERT INTO tablename (col1_name, col3_name, col4_name, …)VALUES (col1_value, col3_value, col4_value, …)\nECE30030/ITP30010 Database Systems52\nINSERT•Add a new tuple to course•INSERT INTO courseVALUES ('CS-437', 'Database Systems', 'Comp. Sci.', 4);•or equivalently•INSERT INTO course (course_id, title, dept_name, credits)VALUES ('CS-437', 'Database Systems', 'Comp. Sci.', 4);•Add a new tuple to student  with tot_creds set to null•INSERT INTO studentVALUES ('3003', 'Green', 'Finance', null);\nECE30030/ITP30010 Database Systems53\nINSERT•A foreign key specifies that an attribute from one relation has to map to a tuple in another relation•Value in one relation must appear in another relation\nECE30030/ITP30010 Database Systems54\nRelation: instructor\nRelation: department\nINSERT•A foreign key specifies that an attribute from one relation has to map to a tuple in another relation•Value in one relation must appear in another relation•Make sure all foreign keys that new row references have already been added to database•One cannot insert a foreign key value unless the corresponding value exists in the referenced relation\nECE30030/ITP30010 Database Systems55\nINSERT•Inserting results of other SELECT query•Make each student in the Music department who has earned more than 144 credit hours an instructor in the Music department with a salary of  $18,000•INSERT INTO instructor  SELECT ID, name, dept_name, 18000  FROM student   WHERE dept_name = 'Music’ AND total_cred > 144;•The SELECT FROM WHERE statement is evaluated fully before any of its results are inserted into the relation•Otherwise queries like  INSERT INTO table1 SELECT * FROM table1would cause problem\nECE30030/ITP30010 Database Systems56\nUPDATE•Basic syntax•Updating a table•UPDATE tablenameSET col1_name = new_col1_value, col2_name = new_col2_value, …;•Updating a table with conditions•UPDATE tablenameSET col1_name = new_col1_value, col2_name = new_col2_value, …WHERE predicate;\nECE30030/ITP30010 Database Systems57\nUPDATE•Give a 5% salary raise to all instructors•UPDATE instructorSET salary = salary * 1.05•Give a 5% salary raise to those instructors who earn less than 70000•UPDATE instructorSET salary = salary * 1.05WHERE salary < 70000;•Give a 5% salary raise to instructors whose salary is less than average•UPDATE instructorSET salary = salary * 1.05WHERE salary <  (SELECT AVG(salary) FROM instructor);\nECE30030/ITP30010 Database Systems58\nUPDATE•Increase salaries of instructors whose salary is over $100,000 by 3%, and all others by a 5%•Write two UPDATE statements:  UPDATE instructor  SET salary = salary * 1.03  WHERE salary > 100000;  UPDATE instructor  SET salary = salary * 1.05  WHERE salary <= 100000;•The order is important•Can be done better using the case statement (next slide)\nECE30030/ITP30010 Database Systems59\nCASE Statement for Conditional Update•The following query is equivalent to the previous UPDATE queries•UPDATE instructorSET salary = CASE                           WHEN salary <= 100000 THEN salary * 1.05                           ELSE salary * 1.03                       END\nECE30030/ITP30010 Database Systems60\nUPDATE with Scalar Subqueries•Recompute and update tot_creds value for all students•UPDATE student SSET tot_cred = (SELECT SUM(credits)                             FROM takes, course                             WHERE takes.course_id = course.course_id  AND                                            S.ID= takes.ID  AND                                            takes.grade <> 'F' AND                                            takes.grade IS NOT NULL);\nECE30030/ITP30010 Database Systems61\nDELETE•Basic syntax•To remove specific rows•DELETE FROM tablenameWHERE predicate;•To remove all rows•DELETE FROM tablename;•This is equivalent to TRUNCATE:TRUNCATE (TABLE) tablename;•One cannot truncate a table with foreign key constraints•Must disable the constraints first (we will cover ALTER when we study SQL DDL):ALTER TABLE tablenameDISABLE CONSTRAINT constraint_name;\nECE30030/ITP30010 Database Systems62\nDELETE•Delete all instructors•DELETE FROM instructor;•Delete all instructors from the Finance department•DELETE FROM instructorWHERE dept_name= 'Finance';•Delete all tuples in the instructor relation for those instructors associated with a department located in the Watson building•DELETE FROM instructorWHERE dept name IN (SELECT dept name        FROM department        WHERE building = 'Watson');\nECE30030/ITP30010 Database Systems63\nDELETE•Delete all instructors whose salary is less than the average salary of instructors•Example:  DELETE FROM instructor                WHERE salary < (SELECT AVG (salary)                  FROM instructor);•Issue:  as we delete tuples from instructor, the average salary changes•Solution used in SQL:1.First, compute AVG(salary) and find all tuples to delete2.Next, delete all tuples found above (without recomputing AVG or retesting the tuples)\nECE30030/ITP30010 Database Systems64"
              }
            ],
            "generated_content": [],
            "final_result": ""
          }
        },
        {
          "node": "start_processing",
          "status": "completed",
          "state_snapshot": {
            "run_id": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d",
            "pdf_file_paths": [
              "temp_pdf_uploads/cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_1a4c2f45-b482-4e82-826e-fa8945eb99c7_DB03 - mysql.pdf",
              "temp_pdf_uploads/cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf"
            ],
            "notebook_title": "",
            "holistic_chapters": [],
            "generated_content": [],
            "final_result": ""
          }
        },
        {
          "node": "start_processing",
          "status": "completed",
          "state_snapshot": {
            "run_id": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d",
            "pdf_file_paths": [
              "temp_pdf_uploads/cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_1a4c2f45-b482-4e82-826e-fa8945eb99c7_DB03 - mysql.pdf",
              "temp_pdf_uploads/cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf"
            ],
            "notebook_title": "",
            "holistic_chapters": [],
            "generated_content": [],
            "final_result": ""
          }
        },
        {
          "node": "analyze_overall_structure",
          "status": "completed",
          "state_snapshot": {
            "run_id": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d",
            "pdf_file_paths": [
              "temp_pdf_uploads/cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_1a4c2f45-b482-4e82-826e-fa8945eb99c7_DB03 - mysql.pdf",
              "temp_pdf_uploads/cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf"
            ],
            "notebook_title": "관계형 데이터베이스 시스템: MySQL 소개 및 SQL 심층 활용",
            "holistic_chapters": [
              {
                "chapter_title": "관계형 데이터베이스 시스템(R-DBMS) 개요 및 MySQL 소개",
                "source_pdf_filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_1a4c2f45-b482-4e82-826e-fa8945eb99c7_DB03 - mysql.pdf",
                "chapter_content_summary": "이 장에서는 관계형 데이터베이스 관리 시스템(R-DBMS)의 기본 개념을 소개하고, 대표적인 오픈소스 R-DBMS인 MySQL에 대해 심층적으로 다룹니다. MySQL의 정의, Oracle 소유권, 표준 SQL 호환성, 상업적 웹 서비스에서의 활용 사례, 기업 사용 통계, 그리고 MySQL의 인기 요인(다양한 운영체제 및 프로그래밍 언어 지원, 비용 효율성, 고성능)을 설명합니다. 또한, R-DBMS 시장에서의 MySQL의 트렌드와 인기도를 살펴보고, MySQL 5.x와 8.x 버전의 주요 차이점 및 MySQL 커뮤니티 버전을 다운로드하고 Docker 이미지를 활용하는 방법을 안내합니다. MySQL이 대규모 데이터 처리, 다중 사용자 지원, 효율성, 안정성, 보안성 측면에서 갖는 강점들을 강조합니다.",
                "chapter_full_text": "ECE30030/ITP30010 Database SystemsHandshaking with an R-DBMSCharmgil Hongcharmgil@handong.eduSpring, 2025Handong Global University\n1\nAgenda•Introduction to MySQL•SQL preview\nECE30030/ITP30010 Database Systems2\nMySQL•MySQL is an SQL-based relational database management system (DBMS)•Free and open-source R-DBMS (under GPL)•Owned by Oracle•Commercial version of MySQL is also provided (including technical support)•“My” came from the name of co-founder Michael Widenius’ daughter•C.f., MariaDB•Compatible with standard SQL•Frequently used for commercial web services\nECE30030/ITP30010 Database Systems3\n* Image src: https://en.wikipedia.org/wiki/MySQL\nMySQL•Companies using MySQL (a study by Enlyft)•“We have data on 199,498 (out of 1,409,176) companies that use MySQL”•Often used by companies with 10-50 employees and 1M-10M dollars in revenue•C.f., Oracle 12 is most often used by companies with 50-200 employees and >1000M dollars in revenue\nECE30030/ITP30010 Database Systems4* Source: https://enlyft.com/tech/products/mysql \nMySQL•Companies using MySQL (full list: https://www.mysql.com/customers/)\nECE30030/ITP30010 Database Systems5\n* Source: https://stackshare.io/mysql \nMySQL•Why MySQL?•Popular•Active discussions all over the Internet•Versatile: runs on Linux, Windows, Mac OS X, Solaris, FreeBSD, …•Supports wide range of programming languages (C/C++, Java, Python, .Net, …)•Cost starts from zero•High performance (fast and reliable)\nECE30030/ITP30010 Database Systems6* Image src: https://db-engines.com/en/ranking\nDBMS Trend Popularity\n•Score definition: https://db-engines.com/en/ranking_definition\nECE30030/ITP30010 Database Systems7* Image src: https://db-engines.com/en/ranking_trend \nMySQL•Why MySQL?•Popular•Active discussions all over the Internet•Versatile: runs on Linux, Windows, Mac OS X, Solaris, FreeBSD, …•Supports wide range of programming languages (C/C++, Java, Python, .Net, …)•Cost starts from zero•High performance (fast and reliable)\nECE30030/ITP30010 Database Systems8* Image src: https://dev.mysql.com/downloads/\nMySQL\nECE30030/ITP30010 Database Systems9\n•Massive•Convenient•Multi-user•Safe•Efficient•Reliable\nCan handle terabytes of dataSupports high-level query languageSupports concurrent data accessSupports transactionsCan handle thousands of queries/second99.99% up-time in many real-world products\nMySQL Versions•MySQL 5.x vs 8.x\nECE30030/ITP30010 Database Systems10\nVersion 5.x-Most popular version of MySQL-More stable and conventionalVersion 8.x-Current version-Provides up-to-date DB functionalities (better storage engine, faster, more secure)\n* Source: https://www.eversql.com/mysql-8-adoption-usage-rate/#:~:text=MySQL%205.7%20is%20still%20the,17%25%20are%20using%20MySQL%208. \nMySQL Versions•MySQL 5.x vs 8.x\nECE30030/ITP30010 Database Systems11\nVersion 5.x-Most popular version of MySQL-More stable and conventionalVersion 8.x-Current version-Provides up-to-date DB functionalities (better storage engine, faster, more secure)\n* Source: https://severalnines.com/database-blog/mysql-performance-benchmarking-mysql-57-vs-mysql-80 \nMySQL Versions•MySQL 5.x vs 8.x\nECE30030/ITP30010 Database Systems12\nVersion 5.x-Most popular version of MySQL-More stable and conventionalVersion 8.x-Current version-Provides up-to-date DB functionalities (better storage engine, faster, more secure)\n* Source: https://severalnines.com/database-blog/mysql-performance-benchmarking-mysql-57-vs-mysql-80 \nWhere to Get MySQL?•https://dev.mysql.com/downloads/•Look for the “Community” versions – the branch that is available for free•”Enterprise” versions are the commercial ones•We have prepared a Docker image for the course•Consists of Ubuntu Server, MySQL, example databases for course activities\nECE30030/ITP30010 Database Systems13* Image src: https://www.docker.com \nWhere to Get MySQL?\nECE30030/ITP30010 Database Systems14\n* Image source: https://baumannalexj.medium.com/connect-your-db-tool-to-a-dockerized-mysql-server-container-bc18853524ed   https://www.jetbrains.com/datagrip/features/look_and_feel.html"
              },
              {
                "chapter_title": "SQL(구조적 질의어)의 이해: 기본 개념과 역사",
                "source_pdf_filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf",
                "chapter_content_summary": "SQL(Structured Query Language)의 정의와 관계형 데이터베이스를 조작하는 주된 언어로서의 역할을 설명합니다. SQL이 '무엇을 할지'를 명시하는 고수준 언어이며, DBMS가 '어떻게 할지'를 결정하는 쿼리 최적화 과정을 다룹니다. 또한, SQL의 두 가지 주요 측면인 데이터 정의 언어(DDL)와 데이터 조작 언어(DML)를 소개하고, 무결성, 뷰 정의, 트랜잭션 제어, 내장 SQL 및 동적 SQL, 권한 부여와 같은 SQL의 다양한 구성 요소를 살펴봅니다. 마지막으로, IBM SEQUEL에서 시작하여 Oracle V2를 거쳐 ANSI 및 ISO 표준으로 발전한 SQL의 간략한 역사를 소개하고, 기본적인 SQL 쿼리 구조(SELECT, FROM, WHERE)를 설명합니다.",
                "chapter_full_text": "ECE30030/ITP30010 Database SystemsStructured Query LanguageReading: Chapter 3\nCharmgil Hongcharmgil@handong.eduSpring, 2025Handong Global University\n1\nAgenda•Structured query language (SQL)•SQL data manipulation language (DML)•SELECT, FROM, WHERE•NULL values•Set operations•String operations, ordering•Aggregate functions, aggregation•SQL data definition language (DDL)   --   NEXT CLASS\nECE30030/ITP30010 Database Systems2\nStructured Query Language (SQL)•SQL: Structured Query Language•The principal language used to describe and manipulate relational databases•Very high-level•Say “what to do” rather than “how to do it”•SQL is not specifying data-manipulation details•DBMSs figure out the “best” way to execute queries•Called “query optimization”•Two aspects to SQL•Data definition: for declaring database schemas (DDL)•Data manipulation: for querying (asking questions about) databases and for modifying the database (DML)\nECE30030/ITP30010 Database Systems3\nSQL Parts•DML – provides the ability to query information from the database and to insert tuples into, delete tuples from, and modify tuples in the database•Integrity – the DDL includes commands for specifying integrity constraints•View definition – the DDL includes commands for defining views•Transaction control – includes commands for specifying the beginning and ending of transactions•Embedded SQL and dynamic SQL – define how SQL statements can be embedded within general-purpose programming language•Authorization – includes commands for specifying access rights to relations and viewsECE30030/ITP30010 Database Systems4\nA Brief History•IBM SEQUEL (Structured English Query Language) was developed as a part of the System R project (Chamberlin and Boyce, early 1970s)•Later on, SEQUEL was renamed SQL (structured query language)•System R à System/38 (1979), SQL/DS (1981), DB2 (1983)•Relational Software, Inc released the first commercial implementation of SQL, Oracle V2 for VAX computers•Relational Software, Inc is now Oracle Corporation•ANSI and ISO standardized SQL:•SQL-86,  SQL-89,  SQL-92,  SQL:1999,  …,  SQL:2011,  SQL:2016 (current)•SQL-92 is supported by the most of database systems\nECE30030/ITP30010 Database Systems5\nBasic Query Structure•A typical SQL query has the form:   SELECT A1, A2, ..., An FROM r1, r2, ..., rm WHERE P•Ai represents an attribute•Ri represents a relation•P is a predicate\n•The result of an SQL query is a relation\nECE30030/ITP30010 Database Systems6"
              },
              {
                "chapter_title": "SQL 데이터 조작 언어(DML) 기초: SELECT, FROM, WHERE 절",
                "source_pdf_filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf",
                "chapter_content_summary": "이 장에서는 SQL 데이터 조작 언어(DML)의 핵심 구성 요소인 SELECT, FROM, WHERE 절을 상세히 다룹니다. 'instructor' 및 'teaches'와 같은 예시 관계(테이블)를 사용하여 실제 쿼리 작성 방법을 시연합니다. SELECT 절을 통해 원하는 속성을 선택하고, 중복을 포함하거나 제거하는 방법(ALL, DISTINCT), 모든 속성을 선택하는 '*' 사용법, 리터럴 및 산술 표현식 활용, 그리고 AS 키워드를 사용한 속성 이름 변경 방법을 학습합니다. WHERE 절에서는 논리 연산자(AND, OR, NOT) 및 비교 연산자(<, <=, >, >=, =, <>, BETWEEN)를 사용하여 조건을 지정하고, 튜플 비교를 수행하는 방법을 설명합니다. 마지막으로 FROM 절을 통해 쿼리에 포함될 관계를 지정하고, 카르테시안 곱을 이해하며, WHERE 절과 결합하여 JOIN 연산을 구현하는 방법을 구체적인 예시와 함께 제시합니다. 또한, AS 키워드를 이용한 관계 및 속성 이름 변경(별칭 지정)을 다룹니다.",
                "chapter_full_text": "ECE30030/ITP30010 Database Systems7\nSQL Data Manipulation Language•The SQL data-manipulation language (DML) allows querying (ask questions about) and modifying the databases\nECE30030/ITP30010 Database Systems8\nRunning Examples•Relations (tables): instructor, teaches\nECE30030/ITP30010 Database Systems9\nInstructor relationteaches relation\nBasic Query Structure•A typical SQL query has the form:   SELECT A1, A2, ..., An FROM r1, r2, ..., rm WHERE P•Ai represents an attribute•Ri represents a relation•P is a predicate\n•The result of an SQL query is a relation\nECE30030/ITP30010 Database Systems10\nThe SELECT Clause•The SELECT clause lists the attributes desired in the result of a query•Corresponds to the projection operation of the relational algebra\n•Example: Find the names of all instructors•SQL: SELECT name FROM instructor;\nECE30030/ITP30010 Database Systems11\nNote•Note: SQL names are case insensitive•E.g., Name ≡ NAME ≡ name•SQL commands (SELECT, FROM, WHERE, …) are written in upper case (just a convention)•MySQL has an option flag, lower_case_table_names•Link: https://dev.mysql.com/doc/refman/8.0/en/identifier-case-sensitivity.html \nECE30030/ITP30010 Database Systems12\nThe SELECT Clause•SQL allows duplicates in relations as well as in query results•The keyword ALL specifies that duplicates should not be removed SELECT ALL dept_name FROM instructor\nECE30030/ITP30010 Database Systems13\nThe SELECT Clause•SQL allows duplicates in relations as well as in query results•The keyword ALL specifies that duplicates should not be removed SELECT ALL dept_name FROM instructor•To force the elimination of duplicates, insert the keyword DISTINCT after SELECT•Find the department names of all instructor, removing duplicates: SELECT DISTINCT dept_name FROM instructor;\nECE30030/ITP30010 Database Systems14\nThe SELECT Clause•An asterisk in the select clause denotes “all attributes” SELECT * FROM instructor;•An attribute can be a literal with no FROM clause SELECT ‘437’;•Result is a table with one column and a single row with value “437”•Can give the column a name using AS: SELECT ‘437’ AS FOO\nECE30030/ITP30010 Database Systems15\nThe SELECT Clause•An attribute can be a literal with FROM clause SELECT 'A' FROM instructor•Result is a table with one column and N rows (number of tuples in the instructor table), each row with value “A”\nECE30030/ITP30010 Database Systems16\nThe SELECT Clause•The SELECT clause can contain arithmetic expressions involving the operation, +, –, *, and /, and operating on constants or attributes of tuples•The query:     SELECT ID, name, salary/12      FROM instructorwould return a relation that is the same as the instructor relation,except that the value of the attribute salary is divided by 12\n17\nThe SELECT Clause•The SELECT clause can contain arithmetic expressions involving the operation, +, –, *, and /, and operating on constants or attributes of tuples•Can rename “salary/12” using the AS clause:  SELECT ID, name, salary/12 AS monthly_salary   FROM instructor\n18\nThe WHERE Clause•The WHERE clause specifies conditions that the result must satisfy•Corresponds to the selection predicate of the relational algebra•E.g., To find all instructors in Comp. Sci. dept: SELECT name FROM instructor  WHERE dept_name = 'Comp. Sci.';\nECE30030/ITP30010 Database Systems19\nThe WHERE Clause•SQL allows the use of the logical connectives AND, OR, and NOT•The operands of the logical connectives can be expressions involving the comparison operators <, <=, >, >=, =, and <>•<> means not equal (there is no != in SQL)•Comparisons can be applied to results of arithmetic expressions•E.g., To find all instructors in Comp. Sci. with salary > 70,000: SELECT name FROM instructor WHERE dept_name = 'Comp. Sci.' AND salary > 70000;\nECE30030/ITP30010 Database Systems20\nThe WHERE Clause•SQL includes a BETWEEN comparison operator•Example: Find the names of all instructors with salary between $90,000 and $100,000 (that is, ³ $90,000 and £ $100,000)•SELECT nameFROM instructorWHERE salary BETWEEN 90000 AND 100000\nECE30030/ITP30010 Database Systems21\nThe WHERE Clause•Tuple comparison: makes comparisons per tuple•SELECT name, course_idFROM instructor, teachesWHERE (instructor.ID, dept_name) = (teaches.ID, 'Biology');\nECE30030/ITP30010 Database Systems22\nThe FROM Clause•The FROM clause lists the relations involved in the query•Corresponds to the Cartesian-product operation of the relational algebra•Find the Cartesian-product instructor × teaches SELECT * FROM instructor, teaches;•Generates every possible instructor-teaches pairs, with all attributes from both relations•For common attributes (e.g., ID), the attributes in the resulting table are renamed using the relation name (e.g., instructor.ID)\nECE30030/ITP30010 Database Systems23\nThe FROM Clause•Find the Cartesian-product instructor X teaches SELECT * FROM instructor, teaches;\n24\ninstructor.IDnamedept_namesalaryteaches.IDcourse_idsec_idsemesteryear10101SrinivasanComp. Sci.6500076766BIO-101 1Summer201712121WuFinance9000076766BIO-101 1Summer201715151MozartMusic4000076766BIO-101 1Summer201722222EinsteinPhysics9500076766BIO-101 1Summer201732343El SaidHistory6000076766BIO-101 1Summer2017… … … … … … … … …10101SrinivasanComp. Sci.6500010101CS-101 1Fall 201712121WuFinance9000010101CS-101 1Fall 201715151MozartMusic4000010101CS-101 1Fall 201722222EinsteinPhysics9500010101CS-101 1Fall 201732343El SaidHistory6000010101CS-101 1Fall 2017… … … … … … … … …… … … … … … … … …10101SrinivasanComp. Sci.6500083821CS-190 2Spring201712121WuFinance9000083821CS-190 2Spring201715151MozartMusic4000083821CS-190 2Spring2017… … … … … … … … …10101SrinivasanComp. Sci.6500010101CS-315 1Spring201812121WuFinance9000010101CS-315 1Spring201815151MozartMusic4000010101CS-315 1Spring2018… … … … … … … … …… … … … … … … … …\nImplementing JOIN•Cartesian-product is not very useful directly; but useful combined with WHERE-clause condition (selection operation in relational algebra)•Cartesian-product + selection = join•E.g., Find the names of all instructors who have taught some course and the course_id SELECT name, course_id FROM instructor , teaches WHERE instructor.ID = teaches.ID\nECE30030/ITP30010 Database Systems25\nImplementing JOIN•Cartesian-product is not very useful directly; but useful combined with WHERE-clause condition (selection operation in relational algebra)•Cartesian-product + selection = join•Find the names of all instructors in the Music department who have taught some course and the course_id SELECT name, course_id FROM instructor , teaches WHERE instructor.ID = teaches.ID  AND instructor. dept_name = 'Music'\nECE30030/ITP30010 Database Systems26\nThe Rename Operation•The SQL allows renaming relations and attributes using the AS clause:   old-name AS new-name•Find the names of all instructors who have a higher salary than some instructor in ‘Comp. Sci.’•SELECT DISTINCT T.nameFROM instructor AS T, instructor AS SWHERE T.salary > S.salary AND S.dept_name = 'Comp. Sci.'\nECE30030/ITP30010 Database Systems27\nThe Rename Operation•The SQL allows renaming relations and attributes using the AS clause:   old-name AS new-name•Find the names of all instructors who have a higher salary than some instructor in ‘Comp. Sci.’•SELECT DISTINCT T.nameFROM instructor AS T, instructor AS SWHERE T.salary > S.salary AND S.dept_name = 'Comp. Sci.'•Keyword AS is optional and may be omitted  instructor AS T  ≡  instructor T\nECE30030/ITP30010 Database Systems28"
              },
              {
                "chapter_title": "SQL DML 고급 기능: NULL 값, 집합 연산, 문자열 처리 및 정렬",
                "source_pdf_filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf",
                "chapter_content_summary": "이 장에서는 SQL DML의 고급 기능을 탐구합니다. 먼저, 알려지지 않거나 존재하지 않는 값을 나타내는 NULL 값의 특성을 이해하고, 산술 연산에서의 NULL 동작 및 IS NULL / IS NOT NULL 술어를 사용하여 NULL 값을 확인하는 방법을 배웁니다. 다음으로, 여러 쿼리 결과를 결합하는 집합 연산인 UNION, INTERSECT, EXCEPT를 살펴봅니다. 각 연산이 기본적으로 중복을 제거하며, ALL 키워드를 사용하여 중복을 유지하는 방법을 설명합니다. 특히 MySQL에서 INTERSECT와 EXCEPT가 직접 지원되지 않을 때 JOIN 또는 NOT IN을 사용하여 에뮬레이션하는 기법을 소개합니다. 이어서, 문자열 패턴 매칭을 위한 LIKE 연산자와 '%' (모든 부분 문자열), '_' (단일 문자) 특수 문자의 사용법을 다룹니다. 백슬래시를 이용한 이스케이프 문자 처리, 패턴 매칭의 대소문자 구분, 그리고 연결, 대소문자 변환, 길이 확인, 부분 문자열 추출 등 다양한 SQL 문자열 함수를 소개합니다. 마지막으로, ORDER BY 절을 사용하여 쿼리 결과를 특정 속성을 기준으로 오름차순(ASC) 또는 내림차순(DESC)으로 정렬하는 방법을 학습하며, 여러 속성을 기준으로 정렬하는 예시도 제시합니다.",
                "chapter_full_text": "ECE30030/ITP30010 Database Systems29\nNULL Values•It is possible for tuples to have a NULL value for some of their attributes•NULL signifies an unknown value or that a value does not exist•The result of any arithmetic expression involving NULL is NULL•E.g.,  5 + NULL returns NULL\nECE30030/ITP30010 Database Systems30\nIS NULL / IS NOT NULL•The predicate IS NULL can be used to check for NULL values•E.g., Find all instructors whose salary is null SELECT name FROM instructor WHERE salary IS NULL•The predicate IS NOT NULL succeeds if the value on which it is applied is not null\nECE30030/ITP30010 Database Systems31\nECE30030/ITP30010 Database Systems32\nSet Operations•Set operations UNION, INTERSECT, and EXCEPT•Each of the above operations automatically eliminates duplicates•To retain all duplicates, use ALL:•UNION ALL•INTERSECT ALL•EXCEPT ALL\n•C.f., SELECT retains all duplicates by default\nECE30030/ITP30010 Database Systems33\nSet Operations: UNION•Find courses that ran in Fall 2017 or in Spring 2018•(SELECT course_id  FROM teaches WHERE semester = 'Fall' AND year = 2017)UNION(SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018)\nECE30030/ITP30010 Database Systems34\nSet Operations: INTERSECT•Find courses that ran in Fall 2017 and in Spring 2018•(SELECT course_id  FROM teaches WHERE semester = 'Fall' AND year = 2017)INTERSECT(SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018)•C.f., MySQL does NOT support INTERSECT•One can emulate INTERSECT using JOIN (we’ll study JOIN later)•SELECT LT.course_idFROM (SELECT course_id FROM teaches WHERE semester = 'Fall' AND year = 2017) AS LTJOIN (SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018) AS RTON LT.course_id=RT.course_id;\nECE30030/ITP30010 Database Systems35\nSet Operations: EXCEPT•Find courses that ran in Fall 2017 but not in Spring 2018•(SELECT course_id  FROM teaches WHERE semester = 'Fall' AND year = 2017)EXCEPT(SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018)•C.f., MySQL does NOT support EXCEPT•One can emulate EXCEPT using NOT IN•SELECT course_id FROM teaches WHERE semester = 'Fall' AND year = 2017AND course_id NOT IN(SELECT course_id  FROM teaches  WHERE semester = 'Spring' AND year = 2018);\nECE30030/ITP30010 Database Systems36\nECE30030/ITP30010 Database Systems37\nString Operations•SQL includes a string-matching operator for comparisons on character strings•The operator LIKE uses patterns that are described using two special characters:•percent (%) – The % character matches any substring•underscore (_) – The _ character matches any character•Find the names of all instructors whose name includes the substring “ri” SELECT name FROM instructor WHERE name LIKE ‘%ri%'\nECE30030/ITP30010 Database Systems38\nString Operations•Escape character: Use backslash (\\) as the escape character•E.g., Match the string “100%” LIKE '100 \\%’ ESCAPE  ‘\\’\nECE30030/ITP30010 Database Systems39\nString Operations•Patterns are case sensitive•Pattern matching examples:•'Intro%' matches any string beginning with “Intro”•'%Comp%' matches any string containing “Comp” as a substring•'_ _ _' matches any string of exactly three characters•'_ _ _ %' matches any string of at least three characters•SQL supports a variety of string operations such as•concatenation (using “||”)•converting from upper to lower case (and vice versa)•finding string length, extracting substrings, etc.\nECE30030/ITP30010 Database Systems40\nOrdering the Display of Tuples•List in alphabetic order the names of all instructors•SELECT DISTINCT nameFROM instructorORDER BY name\nECE30030/ITP30010 Database Systems41\nOrdering the Display of Tuples•Can sort on multiple attributes•E.g., SELECT dept_name, name     FROM instructor      ORDER BY dept_name, name\nECE30030/ITP30010 Database Systems42\nOrdering the Display of Tuples•We may specify DESC for descending order or ASC for ascending order, for each attribute; ascending order is the default•E.g., ORDER BY name DESC\nECE30030/ITP30010 Database Systems43"
              },
              {
                "chapter_title": "SQL DML 집계 함수 및 데이터 수정 (INSERT, UPDATE, DELETE)",
                "source_pdf_filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf",
                "chapter_content_summary": "이 장에서는 SQL 데이터 조작 언어(DML)의 고급 기능인 집계 함수와 데이터를 수정하는 명령어를 다룹니다. AVG, MIN, MAX, SUM, COUNT와 같은 집계 함수를 사용하여 컬럼 값의 멀티셋에 대한 통계 값을 계산하는 방법을 학습합니다. 특히 GROUP BY 절을 이용한 데이터 그룹화와 HAVING 절을 이용한 그룹별 필터링을 심층적으로 다루며, WHERE 절과의 차이점을 명확히 설명합니다. 또한, DML의 핵심 명령인 INSERT, UPDATE, DELETE에 대해 자세히 알아봅니다. INSERT 명령을 통해 테이블에 새로운 튜플을 추가하는 다양한 방법(모든 컬럼, 선택된 컬럼, NULL 값 처리, SELECT 쿼리 결과 삽입)과 외래 키 제약 조건의 중요성을 강조합니다. UPDATE 명령으로는 기존 데이터를 수정하는 기본 구문, 조건부 업데이트, CASE 문을 사용한 복잡한 조건 처리, 스칼라 서브쿼리 활용법을 배웁니다. 마지막으로 DELETE 명령을 통해 테이블에서 특정 행 또는 모든 행을 삭제하는 방법과 TRUNCATE 명령의 차이점, 그리고 삭제 시 서브쿼리 사용 시의 고려사항을 설명합니다.",
                "chapter_full_text": "ECE30030/ITP30010 Database Systems44\nAggregate Functions•These functions operate on the multiset of values of a column of a relation, and return a value•AVG:  average value•MIN:  minimum value•MAX:  maximum value•SUM:  sum of values•COUNT:  number of values\nECE30030/ITP30010 Database Systems45\nAggregate Functions Examples•Find the average salary of instructors in the Computer Science department•SELECT AVG(salary)FROM instructorWHERE dept_name= 'Comp. Sci.';•Find the total number of instructors who teach a course in the Spring 2018 semester•SELECT COUNT(DISTINCT ID)FROM teachesWHERE semester = 'Spring’ AND year = 2018;•Find the number of tuples in the teaches relation•SELECT COUNT (*)FROM teaches;\nECE30030/ITP30010 Database Systems46\nAggregate Functions: Group By•Find the average salary of instructors in each department•SELECT dept_name, AVG(salary) AS avg_salaryFROM instructorGROUP BY dept_name;\nECE30030/ITP30010 Database Systems47\nAggregation•Attributes in SELECT clause outside of aggregate functions must appear in GROUP BY list•/* erroneous query */SELECT dept_name, ID, AVG(salary)FROM instructorGROUP BY dept_name;\nECE30030/ITP30010 Database Systems48\nAggregate Functions – Having Clause•Find the names and average salaries of all departments whose average salary is greater than 65000•SELECT dept_name, AVG(salary) AS avg_salaryFROM instructorGROUP BY dept_nameHAVING AVG(salary) > 65000;\nECE30030/ITP30010 Database Systems49\nAggregate Functions – Having Clause•Note: predicates in the HAVING clause are applied after the formation of groups whereas predicates in the WHERE clause are applied before forming groups\nECE30030/ITP30010 Database Systems50\nSELECT dept_name, AVG(salary) AS avg_salaryFROM instructorGROUP BY dept_nameHAVING AVG(salary) > 65000;\nSELECT dept_name, AVG(salary) AS avg_salaryFROM instructorWHERE salary > 65000GROUP BY dept_name;\nSQL Commands\nSQLDMLSELECTINSERTUPDATEDELETE\nDDLCREATEALTERDROP\nECE30030/ITP30010 Database Systems51\nINSERT•Basic syntax•Insert data into every column:•INSERT INTO tablenameVALUES (col1_value, col2_value, …)•Must list values in the same order as in the table schema•If some data values are unknown, must type NULL •For character sequences, use quotation marks•Single quotation marks are preferred (but double quotation marks are allowed)•Value in quotations is case-sensitive•Insert data into selected columns•INSERT INTO tablename (col1_name, col3_name, col4_name, …)VALUES (col1_value, col3_value, col4_value, …)\nECE30030/ITP30010 Database Systems52\nINSERT•Add a new tuple to course•INSERT INTO courseVALUES ('CS-437', 'Database Systems', 'Comp. Sci.', 4);•or equivalently•INSERT INTO course (course_id, title, dept_name, credits)VALUES ('CS-437', 'Database Systems', 'Comp. Sci.', 4);•Add a new tuple to student  with tot_creds set to null•INSERT INTO studentVALUES ('3003', 'Green', 'Finance', null);\nECE30030/ITP30010 Database Systems53\nINSERT•A foreign key specifies that an attribute from one relation has to map to a tuple in another relation•Value in one relation must appear in another relation\nECE30030/ITP30010 Database Systems54\nRelation: instructor\nRelation: department\nINSERT•A foreign key specifies that an attribute from one relation has to map to a tuple in another relation•Value in one relation must appear in another relation•Make sure all foreign keys that new row references have already been added to database•One cannot insert a foreign key value unless the corresponding value exists in the referenced relation\nECE30030/ITP30010 Database Systems55\nINSERT•Inserting results of other SELECT query•Make each student in the Music department who has earned more than 144 credit hours an instructor in the Music department with a salary of  $18,000•INSERT INTO instructor  SELECT ID, name, dept_name, 18000  FROM student   WHERE dept_name = 'Music’ AND total_cred > 144;•The SELECT FROM WHERE statement is evaluated fully before any of its results are inserted into the relation•Otherwise queries like  INSERT INTO table1 SELECT * FROM table1would cause problem\nECE30030/ITP30010 Database Systems56\nUPDATE•Basic syntax•Updating a table•UPDATE tablenameSET col1_name = new_col1_value, col2_name = new_col2_value, …;•Updating a table with conditions•UPDATE tablenameSET col1_name = new_col1_value, col2_name = new_col2_value, …WHERE predicate;\nECE30030/ITP30010 Database Systems57\nUPDATE•Give a 5% salary raise to all instructors•UPDATE instructorSET salary = salary * 1.05•Give a 5% salary raise to those instructors who earn less than 70000•UPDATE instructorSET salary = salary * 1.05WHERE salary < 70000;•Give a 5% salary raise to instructors whose salary is less than average•UPDATE instructorSET salary = salary * 1.05WHERE salary <  (SELECT AVG(salary) FROM instructor);\nECE30030/ITP30010 Database Systems58\nUPDATE•Increase salaries of instructors whose salary is over $100,000 by 3%, and all others by a 5%•Write two UPDATE statements:  UPDATE instructor  SET salary = salary * 1.03  WHERE salary > 100000;  UPDATE instructor  SET salary = salary * 1.05  WHERE salary <= 100000;•The order is important•Can be done better using the case statement (next slide)\nECE30030/ITP30010 Database Systems59\nCASE Statement for Conditional Update•The following query is equivalent to the previous UPDATE queries•UPDATE instructorSET salary = CASE                           WHEN salary <= 100000 THEN salary * 1.05                           ELSE salary * 1.03                       END\nECE30030/ITP30010 Database Systems60\nUPDATE with Scalar Subqueries•Recompute and update tot_creds value for all students•UPDATE student SSET tot_cred = (SELECT SUM(credits)                             FROM takes, course                             WHERE takes.course_id = course.course_id  AND                                            S.ID= takes.ID  AND                                            takes.grade <> 'F' AND                                            takes.grade IS NOT NULL);\nECE30030/ITP30010 Database Systems61\nDELETE•Basic syntax•To remove specific rows•DELETE FROM tablenameWHERE predicate;•To remove all rows•DELETE FROM tablename;•This is equivalent to TRUNCATE:TRUNCATE (TABLE) tablename;•One cannot truncate a table with foreign key constraints•Must disable the constraints first (we will cover ALTER when we study SQL DDL):ALTER TABLE tablenameDISABLE CONSTRAINT constraint_name;\nECE30030/ITP30010 Database Systems62\nDELETE•Delete all instructors•DELETE FROM instructor;•Delete all instructors from the Finance department•DELETE FROM instructorWHERE dept_name= 'Finance';•Delete all tuples in the instructor relation for those instructors associated with a department located in the Watson building•DELETE FROM instructorWHERE dept name IN (SELECT dept name        FROM department        WHERE building = 'Watson');\nECE30030/ITP30010 Database Systems63\nDELETE•Delete all instructors whose salary is less than the average salary of instructors•Example:  DELETE FROM instructor                WHERE salary < (SELECT AVG (salary)                  FROM instructor);•Issue:  as we delete tuples from instructor, the average salary changes•Solution used in SQL:1.First, compute AVG(salary) and find all tuples to delete2.Next, delete all tuples found above (without recomputing AVG or retesting the tuples)\nECE30030/ITP30010 Database Systems64"
              }
            ],
            "generated_content": [],
            "final_result": ""
          }
        },
        {
          "node": "generate_chapter_content",
          "status": "completed",
          "state_snapshot": {
            "run_id": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d",
            "pdf_file_paths": [
              "temp_pdf_uploads/cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_1a4c2f45-b482-4e82-826e-fa8945eb99c7_DB03 - mysql.pdf",
              "temp_pdf_uploads/cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf"
            ],
            "all_pdf_texts": [
              {
                "filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_1a4c2f45-b482-4e82-826e-fa8945eb99c7_DB03 - mysql.pdf",
                "text": "ECE30030/ITP30010 Database SystemsHandshaking with an R-DBMSCharmgil Hongcharmgil@handong.eduSpring, 2025Handong Global University\n1\n\nAgenda•Introduction to MySQL•SQL preview\nECE30030/ITP30010 Database Systems2\nMySQL•MySQL is an SQL-based relational database management system (DBMS)•Free and open-source R-DBMS (under GPL)•Owned by Oracle•Commercial version of MySQL is also provided (including technical support)•“My” came from the name of co-founder Michael Widenius’ daughter•C.f., MariaDB•Compatible with standard SQL•Frequently used for commercial web services\nECE30030/ITP30010 Database Systems3\n* Image src: https://en.wikipedia.org/wiki/MySQL\nMySQL•Companies using MySQL (a study by Enlyft)•“We have data on 199,498 (out of 1,409,176) companies that use MySQL”•Often used by companies with 10-50 employees and 1M-10M dollars in revenue•C.f., Oracle 12 is most often used by companies with 50-200 employees and >1000M dollars in revenue\nECE30030/ITP30010 Database Systems4* Source: https://enlyft.com/tech/products/mysql \n\nMySQL•Companies using MySQL (full list: https://www.mysql.com/customers/)\nECE30030/ITP30010 Database Systems5\n* Source: https://stackshare.io/mysql \nMySQL•Why MySQL?•Popular•Active discussions all over the Internet•Versatile: runs on Linux, Windows, Mac OS X, Solaris, FreeBSD, …•Supports wide range of programming languages (C/C++, Java, Python, .Net, …)•Cost starts from zero•High performance (fast and reliable)\nECE30030/ITP30010 Database Systems6* Image src: https://db-engines.com/en/ranking\n\nDBMS Trend Popularity\n•Score definition: https://db-engines.com/en/ranking_definition\nECE30030/ITP30010 Database Systems7* Image src: https://db-engines.com/en/ranking_trend \n\nMySQL•Why MySQL?•Popular•Active discussions all over the Internet•Versatile: runs on Linux, Windows, Mac OS X, Solaris, FreeBSD, …•Supports wide range of programming languages (C/C++, Java, Python, .Net, …)•Cost starts from zero•High performance (fast and reliable)\nECE30030/ITP30010 Database Systems8* Image src: https://dev.mysql.com/downloads/\n\nMySQL\nECE30030/ITP30010 Database Systems9\n•Massive•Convenient•Multi-user•Safe•Efficient•Reliable\nCan handle terabytes of dataSupports high-level query languageSupports concurrent data accessSupports transactionsCan handle thousands of queries/second99.99% up-time in many real-world products\nMySQL Versions•MySQL 5.x vs 8.x\nECE30030/ITP30010 Database Systems10\nVersion 5.x-Most popular version of MySQL-More stable and conventionalVersion 8.x-Current version-Provides up-to-date DB functionalities (better storage engine, faster, more secure)\n* Source: https://www.eversql.com/mysql-8-adoption-usage-rate/#:~:text=MySQL%205.7%20is%20still%20the,17%25%20are%20using%20MySQL%208. \nMySQL Versions•MySQL 5.x vs 8.x\nECE30030/ITP30010 Database Systems11\nVersion 5.x-Most popular version of MySQL-More stable and conventionalVersion 8.x-Current version-Provides up-to-date DB functionalities (better storage engine, faster, more secure)\n* Source: https://severalnines.com/database-blog/mysql-performance-benchmarking-mysql-57-vs-mysql-80 \n\nMySQL Versions•MySQL 5.x vs 8.x\nECE30030/ITP30010 Database Systems12\nVersion 5.x-Most popular version of MySQL-More stable and conventionalVersion 8.x-Current version-Provides up-to-date DB functionalities (better storage engine, faster, more secure)\n* Source: https://severalnines.com/database-blog/mysql-performance-benchmarking-mysql-57-vs-mysql-80 \n\nWhere to Get MySQL?•https://dev.mysql.com/downloads/•Look for the “Community” versions – the branch that is available for free•”Enterprise” versions are the commercial ones•We have prepared a Docker image for the course•Consists of Ubuntu Server, MySQL, example databases for course activities\nECE30030/ITP30010 Database Systems13* Image src: https://www.docker.com \n\nWhere to Get MySQL?\nECE30030/ITP30010 Database Systems14\n* Image source: https://baumannalexj.medium.com/connect-your-db-tool-to-a-dockerized-mysql-server-container-bc18853524ed   https://www.jetbrains.com/datagrip/features/look_and_feel.html\n\nAgenda•Introduction to MySQL•SQL preview\nECE30030/ITP30010 Database Systems15\nStructured Query Language (SQL)•SQL: Structured Query Language•The principal language used to describe and manipulate relational databases•Very high-level•Say “what to do” rather than “how to do it”•SQL is not specifying data-manipulation details•DBMSs figure out the “best” way to execute queries•Called “query optimization”•Two aspects to SQL•Data definition: for declaring database schemas (DDL)•Data manipulation: for querying (asking questions about) databases and for modifying the database (DML)\nECE30030/ITP30010 Database Systems16\nSQL Parts•DML – provides the ability to query information from the database and to insert tuples into, delete tuples from, and modify tuples in the database•Integrity – the DDL includes commands for specifying integrity constraints•Vide definition – the DDL includes commands for defining views•Transaction control – includes commands for specifying the beginning and ending of transactions•Embedded SQL and dynamic SQL – define how SQL statements can be embedded within general-purpose programming language•Authorization – includes commands for specifying access rights to relations and viewsECE30030/ITP30010 Database Systems17\nA Brief History•IBM SEQUEL (Structured English Query Language) was developed as a part of the System R project (Chamberlin and Boyce, early 1970s)•Later on, SEQUEL was renamed SQL (structured query language)•System R à System/38 (1979), SQL/DS (1981), DB2 (1983)•Relational Software, Inc released the first commercial implementation of SQL, Oracle V2 for VAX computers•Relational Software, Inc is now Oracle Corporation•ANSI and ISO standardized SQL:•SQL-86,  SQL-89,  SQL-92,  SQL:1999,  …,  SQL:2011,  SQL:2016 (current)•SQL-92 is supported by the most of database systems\nECE30030/ITP30010 Database Systems18\nBasic Query Structure•A typical SQL query has the form:   SELECT A1, A2, ..., An FROM r1, r2, ..., rm WHERE P•Ai represents an attribute•Ri represents a relation•P is a predicate\n•The result of an SQL query is a relation\nECE30030/ITP30010 Database Systems19\nEOF•Coming next:•Structured Query Language\nECE30030/ITP30010 Database Systems20"
              },
              {
                "filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf",
                "text": "ECE30030/ITP30010 Database SystemsStructured Query LanguageReading: Chapter 3\nCharmgil Hongcharmgil@handong.eduSpring, 2025Handong Global University\n1\n\nAgenda•Structured query language (SQL)•SQL data manipulation language (DML)•SELECT, FROM, WHERE•NULL values•Set operations•String operations, ordering•Aggregate functions, aggregation•SQL data definition language (DDL)   --   NEXT CLASS\nECE30030/ITP30010 Database Systems2\nStructured Query Language (SQL)•SQL: Structured Query Language•The principal language used to describe and manipulate relational databases•Very high-level•Say “what to do” rather than “how to do it”•SQL is not specifying data-manipulation details•DBMSs figure out the “best” way to execute queries•Called “query optimization”•Two aspects to SQL•Data definition: for declaring database schemas (DDL)•Data manipulation: for querying (asking questions about) databases and for modifying the database (DML)\nECE30030/ITP30010 Database Systems3\nSQL Parts•DML – provides the ability to query information from the database and to insert tuples into, delete tuples from, and modify tuples in the database•Integrity – the DDL includes commands for specifying integrity constraints•View definition – the DDL includes commands for defining views•Transaction control – includes commands for specifying the beginning and ending of transactions•Embedded SQL and dynamic SQL – define how SQL statements can be embedded within general-purpose programming language•Authorization – includes commands for specifying access rights to relations and viewsECE30030/ITP30010 Database Systems4\nA Brief History•IBM SEQUEL (Structured English Query Language) was developed as a part of the System R project (Chamberlin and Boyce, early 1970s)•Later on, SEQUEL was renamed SQL (structured query language)•System R à System/38 (1979), SQL/DS (1981), DB2 (1983)•Relational Software, Inc released the first commercial implementation of SQL, Oracle V2 for VAX computers•Relational Software, Inc is now Oracle Corporation•ANSI and ISO standardized SQL:•SQL-86,  SQL-89,  SQL-92,  SQL:1999,  …,  SQL:2011,  SQL:2016 (current)•SQL-92 is supported by the most of database systems\nECE30030/ITP30010 Database Systems5\nBasic Query Structure•A typical SQL query has the form:   SELECT A1, A2, ..., An FROM r1, r2, ..., rm WHERE P•Ai represents an attribute•Ri represents a relation•P is a predicate\n•The result of an SQL query is a relation\nECE30030/ITP30010 Database Systems6\nAgenda•Structured query language (SQL)•SQL data manipulation language (DML)•SELECT, FROM, WHERE•NULL values•Set operations•String operations, ordering•Aggregate functions, aggregation•SQL data definition language (DDL)\nECE30030/ITP30010 Database Systems7\nSQL Data Manipulation Language•The SQL data-manipulation language (DML) allows querying (ask questions about) and modifying the databases\nECE30030/ITP30010 Database Systems8\nRunning Examples•Relations (tables): instructor, teaches\nECE30030/ITP30010 Database Systems9\nInstructor relationteaches relation\nBasic Query Structure•A typical SQL query has the form:   SELECT A1, A2, ..., An FROM r1, r2, ..., rm WHERE P•Ai represents an attribute•Ri represents a relation•P is a predicate\n•The result of an SQL query is a relation\nECE30030/ITP30010 Database Systems10\nThe SELECT Clause•The SELECT clause lists the attributes desired in the result of a query•Corresponds to the projection operation of the relational algebra\n•Example: Find the names of all instructors•SQL: SELECT name FROM instructor;\nECE30030/ITP30010 Database Systems11\n\nNote•Note: SQL names are case insensitive•E.g., Name ≡ NAME ≡ name•SQL commands (SELECT, FROM, WHERE, …) are written in upper case (just a convention)•MySQL has an option flag, lower_case_table_names•Link: https://dev.mysql.com/doc/refman/8.0/en/identifier-case-sensitivity.html \nECE30030/ITP30010 Database Systems12\nThe SELECT Clause•SQL allows duplicates in relations as well as in query results•The keyword ALL specifies that duplicates should not be removed SELECT ALL dept_name FROM instructor\nECE30030/ITP30010 Database Systems13\n\nThe SELECT Clause•SQL allows duplicates in relations as well as in query results•The keyword ALL specifies that duplicates should not be removed SELECT ALL dept_name FROM instructor•To force the elimination of duplicates, insert the keyword DISTINCT after SELECT•Find the department names of all instructor, removing duplicates: SELECT DISTINCT dept_name FROM instructor;\nECE30030/ITP30010 Database Systems14\n\nThe SELECT Clause•An asterisk in the select clause denotes “all attributes” SELECT * FROM instructor;•An attribute can be a literal with no FROM clause SELECT ‘437’;•Result is a table with one column and a single row with value “437”•Can give the column a name using AS: SELECT ‘437’ AS FOO\nECE30030/ITP30010 Database Systems15\n\nThe SELECT Clause•An attribute can be a literal with FROM clause SELECT 'A' FROM instructor•Result is a table with one column and N rows (number of tuples in the instructor table), each row with value “A”\nECE30030/ITP30010 Database Systems16\n\nThe SELECT Clause•The SELECT clause can contain arithmetic expressions involving the operation, +, –, *, and /, and operating on constants or attributes of tuples•The query:     SELECT ID, name, salary/12      FROM instructorwould return a relation that is the same as the instructor relation,except that the value of the attribute salary is divided by 12\n17\n\nThe SELECT Clause•The SELECT clause can contain arithmetic expressions involving the operation, +, –, *, and /, and operating on constants or attributes of tuples•Can rename “salary/12” using the AS clause:  SELECT ID, name, salary/12 AS monthly_salary   FROM instructor\n18\n\nThe WHERE Clause•The WHERE clause specifies conditions that the result must satisfy•Corresponds to the selection predicate of the relational algebra•E.g., To find all instructors in Comp. Sci. dept: SELECT name FROM instructor  WHERE dept_name = 'Comp. Sci.';\nECE30030/ITP30010 Database Systems19\n\nThe WHERE Clause•SQL allows the use of the logical connectives AND, OR, and NOT•The operands of the logical connectives can be expressions involving the comparison operators <, <=, >, >=, =, and <>•<> means not equal (there is no != in SQL)•Comparisons can be applied to results of arithmetic expressions•E.g., To find all instructors in Comp. Sci. with salary > 70,000: SELECT name FROM instructor WHERE dept_name = 'Comp. Sci.' AND salary > 70000;\nECE30030/ITP30010 Database Systems20\n\nThe WHERE Clause•SQL includes a BETWEEN comparison operator•Example: Find the names of all instructors with salary between $90,000 and $100,000 (that is, ³ $90,000 and £ $100,000)•SELECT nameFROM instructorWHERE salary BETWEEN 90000 AND 100000\nECE30030/ITP30010 Database Systems21\n\nThe WHERE Clause•Tuple comparison: makes comparisons per tuple•SELECT name, course_idFROM instructor, teachesWHERE (instructor.ID, dept_name) = (teaches.ID, 'Biology');\nECE30030/ITP30010 Database Systems22\n\nThe FROM Clause•The FROM clause lists the relations involved in the query•Corresponds to the Cartesian-product operation of the relational algebra•Find the Cartesian-product instructor × teaches SELECT * FROM instructor, teaches;•Generates every possible instructor-teaches pairs, with all attributes from both relations•For common attributes (e.g., ID), the attributes in the resulting table are renamed using the relation name (e.g., instructor.ID)\nECE30030/ITP30010 Database Systems23\nThe FROM Clause•Find the Cartesian-product instructor X teaches SELECT * FROM instructor, teaches;\n24\ninstructor.IDnamedept_namesalaryteaches.IDcourse_idsec_idsemesteryear10101SrinivasanComp. Sci.6500076766BIO-101 1Summer201712121WuFinance9000076766BIO-101 1Summer201715151MozartMusic4000076766BIO-101 1Summer201722222EinsteinPhysics9500076766BIO-101 1Summer201732343El SaidHistory6000076766BIO-101 1Summer2017… … … … … … … … …10101SrinivasanComp. Sci.6500010101CS-101 1Fall 201712121WuFinance9000010101CS-101 1Fall 201715151MozartMusic4000010101CS-101 1Fall 201722222EinsteinPhysics9500010101CS-101 1Fall 201732343El SaidHistory6000010101CS-101 1Fall 2017… … … … … … … … …… … … … … … … … …10101SrinivasanComp. Sci.6500083821CS-190 2Spring201712121WuFinance9000083821CS-190 2Spring201715151MozartMusic4000083821CS-190 2Spring2017… … … … … … … … …10101SrinivasanComp. Sci.6500010101CS-315 1Spring201812121WuFinance9000010101CS-315 1Spring201815151MozartMusic4000010101CS-315 1Spring2018… … … … … … … … …… … … … … … … … …\nImplementing JOIN•Cartesian-product is not very useful directly; but useful combined with WHERE-clause condition (selection operation in relational algebra)•Cartesian-product + selection = join•E.g., Find the names of all instructors who have taught some course and the course_id SELECT name, course_id FROM instructor , teaches WHERE instructor.ID = teaches.ID\nECE30030/ITP30010 Database Systems25\n\nImplementing JOIN•Cartesian-product is not very useful directly; but useful combined with WHERE-clause condition (selection operation in relational algebra)•Cartesian-product + selection = join•Find the names of all instructors in the Music department who have taught some course and the course_id SELECT name, course_id FROM instructor , teaches WHERE instructor.ID = teaches.ID  AND instructor. dept_name = 'Music'\nECE30030/ITP30010 Database Systems26\n\nThe Rename Operation•The SQL allows renaming relations and attributes using the AS clause:   old-name AS new-name•Find the names of all instructors who have a higher salary than some instructor in ‘Comp. Sci.’•SELECT DISTINCT T.nameFROM instructor AS T, instructor AS SWHERE T.salary > S.salary AND S.dept_name = 'Comp. Sci.'\nECE30030/ITP30010 Database Systems27\n\nThe Rename Operation•The SQL allows renaming relations and attributes using the AS clause:   old-name AS new-name•Find the names of all instructors who have a higher salary than some instructor in ‘Comp. Sci.’•SELECT DISTINCT T.nameFROM instructor AS T, instructor AS SWHERE T.salary > S.salary AND S.dept_name = 'Comp. Sci.'•Keyword AS is optional and may be omitted  instructor AS T  ≡  instructor T\nECE30030/ITP30010 Database Systems28\nAgenda•Structured query language (SQL)•SQL data manipulation language (DML)•SELECT, FROM, WHERE•NULL values•Set operations•String operations, ordering•Aggregate functions, aggregation•SQL data definition language (DDL)\nECE30030/ITP30010 Database Systems29\nNULL Values•It is possible for tuples to have a NULL value for some of their attributes•NULL signifies an unknown value or that a value does not exist•The result of any arithmetic expression involving NULL is NULL•E.g.,  5 + NULL returns NULL\nECE30030/ITP30010 Database Systems30\nIS NULL / IS NOT NULL•The predicate IS NULL can be used to check for NULL values•E.g., Find all instructors whose salary is null SELECT name FROM instructor WHERE salary IS NULL•The predicate IS NOT NULL succeeds if the value on which it is applied is not null\nECE30030/ITP30010 Database Systems31\nAgenda•Structured query language (SQL)•SQL data manipulation language (DML)•SELECT, FROM, WHERE•NULL values•Set operations•String operations, ordering•Aggregate functions, aggregation•SQL data definition language (DDL)\nECE30030/ITP30010 Database Systems32\nSet Operations•Set operations UNION, INTERSECT, and EXCEPT•Each of the above operations automatically eliminates duplicates•To retain all duplicates, use ALL:•UNION ALL•INTERSECT ALL•EXCEPT ALL\n•C.f., SELECT retains all duplicates by default\nECE30030/ITP30010 Database Systems33\nSet Operations: UNION•Find courses that ran in Fall 2017 or in Spring 2018•(SELECT course_id  FROM teaches WHERE semester = 'Fall' AND year = 2017)UNION(SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018)\nECE30030/ITP30010 Database Systems34\n\nSet Operations: INTERSECT•Find courses that ran in Fall 2017 and in Spring 2018•(SELECT course_id  FROM teaches WHERE semester = 'Fall' AND year = 2017)INTERSECT(SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018)•C.f., MySQL does NOT support INTERSECT•One can emulate INTERSECT using JOIN (we’ll study JOIN later)•SELECT LT.course_idFROM (SELECT course_id FROM teaches WHERE semester = 'Fall' AND year = 2017) AS LTJOIN (SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018) AS RTON LT.course_id=RT.course_id;\nECE30030/ITP30010 Database Systems35\n\nSet Operations: EXCEPT•Find courses that ran in Fall 2017 but not in Spring 2018•(SELECT course_id  FROM teaches WHERE semester = 'Fall' AND year = 2017)EXCEPT(SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018)•C.f., MySQL does NOT support EXCEPT•One can emulate EXCEPT using NOT IN•SELECT course_id FROM teaches WHERE semester = 'Fall' AND year = 2017AND course_id NOT IN(SELECT course_id  FROM teaches  WHERE semester = 'Spring' AND year = 2018);\nECE30030/ITP30010 Database Systems36\n\nAgenda•Structured query language (SQL)•SQL data manipulation language (DML)•SELECT, FROM, WHERE•NULL values•Set operations•String operations, ordering•Aggregate functions, aggregation•SQL data definition language (DDL)\nECE30030/ITP30010 Database Systems37\nString Operations•SQL includes a string-matching operator for comparisons on character strings•The operator LIKE uses patterns that are described using two special characters:•percent (%) – The % character matches any substring•underscore (_) – The _ character matches any character•Find the names of all instructors whose name includes the substring “ri” SELECT name FROM instructor WHERE name LIKE ‘%ri%'\nECE30030/ITP30010 Database Systems38\n\nString Operations•Escape character: Use backslash (\\) as the escape character•E.g., Match the string “100%” LIKE '100 \\%’ ESCAPE  ‘\\’\nECE30030/ITP30010 Database Systems39\nString Operations•Patterns are case sensitive•Pattern matching examples:•'Intro%' matches any string beginning with “Intro”•'%Comp%' matches any string containing “Comp” as a substring•'_ _ _' matches any string of exactly three characters•'_ _ _ %' matches any string of at least three characters•SQL supports a variety of string operations such as•concatenation (using “||”)•converting from upper to lower case (and vice versa)•finding string length, extracting substrings, etc.\nECE30030/ITP30010 Database Systems40\nOrdering the Display of Tuples•List in alphabetic order the names of all instructors•SELECT DISTINCT nameFROM instructorORDER BY name\nECE30030/ITP30010 Database Systems41\n\nOrdering the Display of Tuples•Can sort on multiple attributes•E.g., SELECT dept_name, name     FROM instructor      ORDER BY dept_name, name\nECE30030/ITP30010 Database Systems42\n\nOrdering the Display of Tuples•We may specify DESC for descending order or ASC for ascending order, for each attribute; ascending order is the default•E.g., ORDER BY name DESC\nECE30030/ITP30010 Database Systems43\n\nAgenda•Structured query language (SQL)•SQL data manipulation language (DML)•SELECT, FROM, WHERE•NULL values•Set operations•String operations, ordering•Aggregate functions, aggregation•SQL data definition language (DDL)\nECE30030/ITP30010 Database Systems44\nAggregate Functions•These functions operate on the multiset of values of a column of a relation, and return a value•AVG:  average value•MIN:  minimum value•MAX:  maximum value•SUM:  sum of values•COUNT:  number of values\nECE30030/ITP30010 Database Systems45\nAggregate Functions Examples•Find the average salary of instructors in the Computer Science department•SELECT AVG(salary)FROM instructorWHERE dept_name= 'Comp. Sci.';•Find the total number of instructors who teach a course in the Spring 2018 semester•SELECT COUNT(DISTINCT ID)FROM teachesWHERE semester = 'Spring’ AND year = 2018;•Find the number of tuples in the teaches relation•SELECT COUNT (*)FROM teaches;\nECE30030/ITP30010 Database Systems46\n\nAggregate Functions: Group By•Find the average salary of instructors in each department•SELECT dept_name, AVG(salary) AS avg_salaryFROM instructorGROUP BY dept_name;\nECE30030/ITP30010 Database Systems47\n\nAggregation•Attributes in SELECT clause outside of aggregate functions must appear in GROUP BY list•/* erroneous query */SELECT dept_name, ID, AVG(salary)FROM instructorGROUP BY dept_name;\nECE30030/ITP30010 Database Systems48\n\nAggregate Functions – Having Clause•Find the names and average salaries of all departments whose average salary is greater than 65000•SELECT dept_name, AVG(salary) AS avg_salaryFROM instructorGROUP BY dept_nameHAVING AVG(salary) > 65000;\nECE30030/ITP30010 Database Systems49\n\nAggregate Functions – Having Clause•Note: predicates in the HAVING clause are applied after the formation of groups whereas predicates in the WHERE clause are applied before forming groups\nECE30030/ITP30010 Database Systems50\nSELECT dept_name, AVG(salary) AS avg_salaryFROM instructorGROUP BY dept_nameHAVING AVG(salary) > 65000;\nSELECT dept_name, AVG(salary) AS avg_salaryFROM instructorWHERE salary > 65000GROUP BY dept_name;\n\nSQL Commands\nSQLDMLSELECTINSERTUPDATEDELETE\nDDLCREATEALTERDROP\nECE30030/ITP30010 Database Systems51\nINSERT•Basic syntax•Insert data into every column:•INSERT INTO tablenameVALUES (col1_value, col2_value, …)•Must list values in the same order as in the table schema•If some data values are unknown, must type NULL •For character sequences, use quotation marks•Single quotation marks are preferred (but double quotation marks are allowed)•Value in quotations is case-sensitive•Insert data into selected columns•INSERT INTO tablename (col1_name, col3_name, col4_name, …)VALUES (col1_value, col3_value, col4_value, …)\nECE30030/ITP30010 Database Systems52\nINSERT•Add a new tuple to course•INSERT INTO courseVALUES ('CS-437', 'Database Systems', 'Comp. Sci.', 4);•or equivalently•INSERT INTO course (course_id, title, dept_name, credits)VALUES ('CS-437', 'Database Systems', 'Comp. Sci.', 4);•Add a new tuple to student  with tot_creds set to null•INSERT INTO studentVALUES ('3003', 'Green', 'Finance', null);\nECE30030/ITP30010 Database Systems53\nINSERT•A foreign key specifies that an attribute from one relation has to map to a tuple in another relation•Value in one relation must appear in another relation\nECE30030/ITP30010 Database Systems54\nRelation: instructor\nRelation: department\nINSERT•A foreign key specifies that an attribute from one relation has to map to a tuple in another relation•Value in one relation must appear in another relation•Make sure all foreign keys that new row references have already been added to database•One cannot insert a foreign key value unless the corresponding value exists in the referenced relation\nECE30030/ITP30010 Database Systems55\nINSERT•Inserting results of other SELECT query•Make each student in the Music department who has earned more than 144 credit hours an instructor in the Music department with a salary of  $18,000•INSERT INTO instructor  SELECT ID, name, dept_name, 18000  FROM student   WHERE dept_name = 'Music’ AND total_cred > 144;•The SELECT FROM WHERE statement is evaluated fully before any of its results are inserted into the relation•Otherwise queries like  INSERT INTO table1 SELECT * FROM table1would cause problem\nECE30030/ITP30010 Database Systems56\nUPDATE•Basic syntax•Updating a table•UPDATE tablenameSET col1_name = new_col1_value, col2_name = new_col2_value, …;•Updating a table with conditions•UPDATE tablenameSET col1_name = new_col1_value, col2_name = new_col2_value, …WHERE predicate;\nECE30030/ITP30010 Database Systems57\nUPDATE•Give a 5% salary raise to all instructors•UPDATE instructorSET salary = salary * 1.05•Give a 5% salary raise to those instructors who earn less than 70000•UPDATE instructorSET salary = salary * 1.05WHERE salary < 70000;•Give a 5% salary raise to instructors whose salary is less than average•UPDATE instructorSET salary = salary * 1.05WHERE salary <  (SELECT AVG(salary) FROM instructor);\nECE30030/ITP30010 Database Systems58\nUPDATE•Increase salaries of instructors whose salary is over $100,000 by 3%, and all others by a 5%•Write two UPDATE statements:  UPDATE instructor  SET salary = salary * 1.03  WHERE salary > 100000;  UPDATE instructor  SET salary = salary * 1.05  WHERE salary <= 100000;•The order is important•Can be done better using the case statement (next slide)\nECE30030/ITP30010 Database Systems59\nCASE Statement for Conditional Update•The following query is equivalent to the previous UPDATE queries•UPDATE instructorSET salary = CASE                           WHEN salary <= 100000 THEN salary * 1.05                           ELSE salary * 1.03                       END\nECE30030/ITP30010 Database Systems60\nUPDATE with Scalar Subqueries•Recompute and update tot_creds value for all students•UPDATE student SSET tot_cred = (SELECT SUM(credits)                             FROM takes, course                             WHERE takes.course_id = course.course_id  AND                                            S.ID= takes.ID  AND                                            takes.grade <> 'F' AND                                            takes.grade IS NOT NULL);\nECE30030/ITP30010 Database Systems61\nDELETE•Basic syntax•To remove specific rows•DELETE FROM tablenameWHERE predicate;•To remove all rows•DELETE FROM tablename;•This is equivalent to TRUNCATE:TRUNCATE (TABLE) tablename;•One cannot truncate a table with foreign key constraints•Must disable the constraints first (we will cover ALTER when we study SQL DDL):ALTER TABLE tablenameDISABLE CONSTRAINT constraint_name;\nECE30030/ITP30010 Database Systems62\nDELETE•Delete all instructors•DELETE FROM instructor;•Delete all instructors from the Finance department•DELETE FROM instructorWHERE dept_name= 'Finance';•Delete all tuples in the instructor relation for those instructors associated with a department located in the Watson building•DELETE FROM instructorWHERE dept name IN (SELECT dept name        FROM department        WHERE building = 'Watson');\nECE30030/ITP30010 Database Systems63\nDELETE•Delete all instructors whose salary is less than the average salary of instructors•Example:  DELETE FROM instructor                WHERE salary < (SELECT AVG (salary)                  FROM instructor);•Issue:  as we delete tuples from instructor, the average salary changes•Solution used in SQL:1.First, compute AVG(salary) and find all tuples to delete2.Next, delete all tuples found above (without recomputing AVG or retesting the tuples)\nECE30030/ITP30010 Database Systems64\nEOF•Coming next:•More on Structured Query Language\nECE30030/ITP30010 Database Systems65"
              }
            ],
            "notebook_title": "관계형 데이터베이스 시스템: MySQL 소개 및 SQL 심층 활용",
            "holistic_chapters": [
              {
                "chapter_title": "관계형 데이터베이스 시스템(R-DBMS) 개요 및 MySQL 소개",
                "source_pdf_filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_1a4c2f45-b482-4e82-826e-fa8945eb99c7_DB03 - mysql.pdf",
                "chapter_content_summary": "이 장에서는 관계형 데이터베이스 관리 시스템(R-DBMS)의 기본 개념을 소개하고, 대표적인 오픈소스 R-DBMS인 MySQL에 대해 심층적으로 다룹니다. MySQL의 정의, Oracle 소유권, 표준 SQL 호환성, 상업적 웹 서비스에서의 활용 사례, 기업 사용 통계, 그리고 MySQL의 인기 요인(다양한 운영체제 및 프로그래밍 언어 지원, 비용 효율성, 고성능)을 설명합니다. 또한, R-DBMS 시장에서의 MySQL의 트렌드와 인기도를 살펴보고, MySQL 5.x와 8.x 버전의 주요 차이점 및 MySQL 커뮤니티 버전을 다운로드하고 Docker 이미지를 활용하는 방법을 안내합니다. MySQL이 대규모 데이터 처리, 다중 사용자 지원, 효율성, 안정성, 보안성 측면에서 갖는 강점들을 강조합니다.",
                "chapter_full_text": "ECE30030/ITP30010 Database SystemsHandshaking with an R-DBMSCharmgil Hongcharmgil@handong.eduSpring, 2025Handong Global University\n1\nAgenda•Introduction to MySQL•SQL preview\nECE30030/ITP30010 Database Systems2\nMySQL•MySQL is an SQL-based relational database management system (DBMS)•Free and open-source R-DBMS (under GPL)•Owned by Oracle•Commercial version of MySQL is also provided (including technical support)•“My” came from the name of co-founder Michael Widenius’ daughter•C.f., MariaDB•Compatible with standard SQL•Frequently used for commercial web services\nECE30030/ITP30010 Database Systems3\n* Image src: https://en.wikipedia.org/wiki/MySQL\nMySQL•Companies using MySQL (a study by Enlyft)•“We have data on 199,498 (out of 1,409,176) companies that use MySQL”•Often used by companies with 10-50 employees and 1M-10M dollars in revenue•C.f., Oracle 12 is most often used by companies with 50-200 employees and >1000M dollars in revenue\nECE30030/ITP30010 Database Systems4* Source: https://enlyft.com/tech/products/mysql \nMySQL•Companies using MySQL (full list: https://www.mysql.com/customers/)\nECE30030/ITP30010 Database Systems5\n* Source: https://stackshare.io/mysql \nMySQL•Why MySQL?•Popular•Active discussions all over the Internet•Versatile: runs on Linux, Windows, Mac OS X, Solaris, FreeBSD, …•Supports wide range of programming languages (C/C++, Java, Python, .Net, …)•Cost starts from zero•High performance (fast and reliable)\nECE30030/ITP30010 Database Systems6* Image src: https://db-engines.com/en/ranking\nDBMS Trend Popularity\n•Score definition: https://db-engines.com/en/ranking_definition\nECE30030/ITP30010 Database Systems7* Image src: https://db-engines.com/en/ranking_trend \nMySQL•Why MySQL?•Popular•Active discussions all over the Internet•Versatile: runs on Linux, Windows, Mac OS X, Solaris, FreeBSD, …•Supports wide range of programming languages (C/C++, Java, Python, .Net, …)•Cost starts from zero•High performance (fast and reliable)\nECE30030/ITP30010 Database Systems8* Image src: https://dev.mysql.com/downloads/\nMySQL\nECE30030/ITP30010 Database Systems9\n•Massive•Convenient•Multi-user•Safe•Efficient•Reliable\nCan handle terabytes of dataSupports high-level query languageSupports concurrent data accessSupports transactionsCan handle thousands of queries/second99.99% up-time in many real-world products\nMySQL Versions•MySQL 5.x vs 8.x\nECE30030/ITP30010 Database Systems10\nVersion 5.x-Most popular version of MySQL-More stable and conventionalVersion 8.x-Current version-Provides up-to-date DB functionalities (better storage engine, faster, more secure)\n* Source: https://www.eversql.com/mysql-8-adoption-usage-rate/#:~:text=MySQL%205.7%20is%20still%20the,17%25%20are%20using%20MySQL%208. \nMySQL Versions•MySQL 5.x vs 8.x\nECE30030/ITP30010 Database Systems11\nVersion 5.x-Most popular version of MySQL-More stable and conventionalVersion 8.x-Current version-Provides up-to-date DB functionalities (better storage engine, faster, more secure)\n* Source: https://severalnines.com/database-blog/mysql-performance-benchmarking-mysql-57-vs-mysql-80 \nMySQL Versions•MySQL 5.x vs 8.x\nECE30030/ITP30010 Database Systems12\nVersion 5.x-Most popular version of MySQL-More stable and conventionalVersion 8.x-Current version-Provides up-to-date DB functionalities (better storage engine, faster, more secure)\n* Source: https://severalnines.com/database-blog/mysql-performance-benchmarking-mysql-57-vs-mysql-80 \nWhere to Get MySQL?•https://dev.mysql.com/downloads/•Look for the “Community” versions – the branch that is available for free•”Enterprise” versions are the commercial ones•We have prepared a Docker image for the course•Consists of Ubuntu Server, MySQL, example databases for course activities\nECE30030/ITP30010 Database Systems13* Image src: https://www.docker.com \nWhere to Get MySQL?\nECE30030/ITP30010 Database Systems14\n* Image source: https://baumannalexj.medium.com/connect-your-db-tool-to-a-dockerized-mysql-server-container-bc18853524ed   https://www.jetbrains.com/datagrip/features/look_and_feel.html"
              },
              {
                "chapter_title": "SQL(구조적 질의어)의 이해: 기본 개념과 역사",
                "source_pdf_filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf",
                "chapter_content_summary": "SQL(Structured Query Language)의 정의와 관계형 데이터베이스를 조작하는 주된 언어로서의 역할을 설명합니다. SQL이 '무엇을 할지'를 명시하는 고수준 언어이며, DBMS가 '어떻게 할지'를 결정하는 쿼리 최적화 과정을 다룹니다. 또한, SQL의 두 가지 주요 측면인 데이터 정의 언어(DDL)와 데이터 조작 언어(DML)를 소개하고, 무결성, 뷰 정의, 트랜잭션 제어, 내장 SQL 및 동적 SQL, 권한 부여와 같은 SQL의 다양한 구성 요소를 살펴봅니다. 마지막으로, IBM SEQUEL에서 시작하여 Oracle V2를 거쳐 ANSI 및 ISO 표준으로 발전한 SQL의 간략한 역사를 소개하고, 기본적인 SQL 쿼리 구조(SELECT, FROM, WHERE)를 설명합니다.",
                "chapter_full_text": "ECE30030/ITP30010 Database SystemsStructured Query LanguageReading: Chapter 3\nCharmgil Hongcharmgil@handong.eduSpring, 2025Handong Global University\n1\nAgenda•Structured query language (SQL)•SQL data manipulation language (DML)•SELECT, FROM, WHERE•NULL values•Set operations•String operations, ordering•Aggregate functions, aggregation•SQL data definition language (DDL)   --   NEXT CLASS\nECE30030/ITP30010 Database Systems2\nStructured Query Language (SQL)•SQL: Structured Query Language•The principal language used to describe and manipulate relational databases•Very high-level•Say “what to do” rather than “how to do it”•SQL is not specifying data-manipulation details•DBMSs figure out the “best” way to execute queries•Called “query optimization”•Two aspects to SQL•Data definition: for declaring database schemas (DDL)•Data manipulation: for querying (asking questions about) databases and for modifying the database (DML)\nECE30030/ITP30010 Database Systems3\nSQL Parts•DML – provides the ability to query information from the database and to insert tuples into, delete tuples from, and modify tuples in the database•Integrity – the DDL includes commands for specifying integrity constraints•View definition – the DDL includes commands for defining views•Transaction control – includes commands for specifying the beginning and ending of transactions•Embedded SQL and dynamic SQL – define how SQL statements can be embedded within general-purpose programming language•Authorization – includes commands for specifying access rights to relations and viewsECE30030/ITP30010 Database Systems4\nA Brief History•IBM SEQUEL (Structured English Query Language) was developed as a part of the System R project (Chamberlin and Boyce, early 1970s)•Later on, SEQUEL was renamed SQL (structured query language)•System R à System/38 (1979), SQL/DS (1981), DB2 (1983)•Relational Software, Inc released the first commercial implementation of SQL, Oracle V2 for VAX computers•Relational Software, Inc is now Oracle Corporation•ANSI and ISO standardized SQL:•SQL-86,  SQL-89,  SQL-92,  SQL:1999,  …,  SQL:2011,  SQL:2016 (current)•SQL-92 is supported by the most of database systems\nECE30030/ITP30010 Database Systems5\nBasic Query Structure•A typical SQL query has the form:   SELECT A1, A2, ..., An FROM r1, r2, ..., rm WHERE P•Ai represents an attribute•Ri represents a relation•P is a predicate\n•The result of an SQL query is a relation\nECE30030/ITP30010 Database Systems6"
              },
              {
                "chapter_title": "SQL 데이터 조작 언어(DML) 기초: SELECT, FROM, WHERE 절",
                "source_pdf_filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf",
                "chapter_content_summary": "이 장에서는 SQL 데이터 조작 언어(DML)의 핵심 구성 요소인 SELECT, FROM, WHERE 절을 상세히 다룹니다. 'instructor' 및 'teaches'와 같은 예시 관계(테이블)를 사용하여 실제 쿼리 작성 방법을 시연합니다. SELECT 절을 통해 원하는 속성을 선택하고, 중복을 포함하거나 제거하는 방법(ALL, DISTINCT), 모든 속성을 선택하는 '*' 사용법, 리터럴 및 산술 표현식 활용, 그리고 AS 키워드를 사용한 속성 이름 변경 방법을 학습합니다. WHERE 절에서는 논리 연산자(AND, OR, NOT) 및 비교 연산자(<, <=, >, >=, =, <>, BETWEEN)를 사용하여 조건을 지정하고, 튜플 비교를 수행하는 방법을 설명합니다. 마지막으로 FROM 절을 통해 쿼리에 포함될 관계를 지정하고, 카르테시안 곱을 이해하며, WHERE 절과 결합하여 JOIN 연산을 구현하는 방법을 구체적인 예시와 함께 제시합니다. 또한, AS 키워드를 이용한 관계 및 속성 이름 변경(별칭 지정)을 다룹니다.",
                "chapter_full_text": "ECE30030/ITP30010 Database Systems7\nSQL Data Manipulation Language•The SQL data-manipulation language (DML) allows querying (ask questions about) and modifying the databases\nECE30030/ITP30010 Database Systems8\nRunning Examples•Relations (tables): instructor, teaches\nECE30030/ITP30010 Database Systems9\nInstructor relationteaches relation\nBasic Query Structure•A typical SQL query has the form:   SELECT A1, A2, ..., An FROM r1, r2, ..., rm WHERE P•Ai represents an attribute•Ri represents a relation•P is a predicate\n•The result of an SQL query is a relation\nECE30030/ITP30010 Database Systems10\nThe SELECT Clause•The SELECT clause lists the attributes desired in the result of a query•Corresponds to the projection operation of the relational algebra\n•Example: Find the names of all instructors•SQL: SELECT name FROM instructor;\nECE30030/ITP30010 Database Systems11\nNote•Note: SQL names are case insensitive•E.g., Name ≡ NAME ≡ name•SQL commands (SELECT, FROM, WHERE, …) are written in upper case (just a convention)•MySQL has an option flag, lower_case_table_names•Link: https://dev.mysql.com/doc/refman/8.0/en/identifier-case-sensitivity.html \nECE30030/ITP30010 Database Systems12\nThe SELECT Clause•SQL allows duplicates in relations as well as in query results•The keyword ALL specifies that duplicates should not be removed SELECT ALL dept_name FROM instructor\nECE30030/ITP30010 Database Systems13\nThe SELECT Clause•SQL allows duplicates in relations as well as in query results•The keyword ALL specifies that duplicates should not be removed SELECT ALL dept_name FROM instructor•To force the elimination of duplicates, insert the keyword DISTINCT after SELECT•Find the department names of all instructor, removing duplicates: SELECT DISTINCT dept_name FROM instructor;\nECE30030/ITP30010 Database Systems14\nThe SELECT Clause•An asterisk in the select clause denotes “all attributes” SELECT * FROM instructor;•An attribute can be a literal with no FROM clause SELECT ‘437’;•Result is a table with one column and a single row with value “437”•Can give the column a name using AS: SELECT ‘437’ AS FOO\nECE30030/ITP30010 Database Systems15\nThe SELECT Clause•An attribute can be a literal with FROM clause SELECT 'A' FROM instructor•Result is a table with one column and N rows (number of tuples in the instructor table), each row with value “A”\nECE30030/ITP30010 Database Systems16\nThe SELECT Clause•The SELECT clause can contain arithmetic expressions involving the operation, +, –, *, and /, and operating on constants or attributes of tuples•The query:     SELECT ID, name, salary/12      FROM instructorwould return a relation that is the same as the instructor relation,except that the value of the attribute salary is divided by 12\n17\nThe SELECT Clause•The SELECT clause can contain arithmetic expressions involving the operation, +, –, *, and /, and operating on constants or attributes of tuples•Can rename “salary/12” using the AS clause:  SELECT ID, name, salary/12 AS monthly_salary   FROM instructor\n18\nThe WHERE Clause•The WHERE clause specifies conditions that the result must satisfy•Corresponds to the selection predicate of the relational algebra•E.g., To find all instructors in Comp. Sci. dept: SELECT name FROM instructor  WHERE dept_name = 'Comp. Sci.';\nECE30030/ITP30010 Database Systems19\nThe WHERE Clause•SQL allows the use of the logical connectives AND, OR, and NOT•The operands of the logical connectives can be expressions involving the comparison operators <, <=, >, >=, =, and <>•<> means not equal (there is no != in SQL)•Comparisons can be applied to results of arithmetic expressions•E.g., To find all instructors in Comp. Sci. with salary > 70,000: SELECT name FROM instructor WHERE dept_name = 'Comp. Sci.' AND salary > 70000;\nECE30030/ITP30010 Database Systems20\nThe WHERE Clause•SQL includes a BETWEEN comparison operator•Example: Find the names of all instructors with salary between $90,000 and $100,000 (that is, ³ $90,000 and £ $100,000)•SELECT nameFROM instructorWHERE salary BETWEEN 90000 AND 100000\nECE30030/ITP30010 Database Systems21\nThe WHERE Clause•Tuple comparison: makes comparisons per tuple•SELECT name, course_idFROM instructor, teachesWHERE (instructor.ID, dept_name) = (teaches.ID, 'Biology');\nECE30030/ITP30010 Database Systems22\nThe FROM Clause•The FROM clause lists the relations involved in the query•Corresponds to the Cartesian-product operation of the relational algebra•Find the Cartesian-product instructor × teaches SELECT * FROM instructor, teaches;•Generates every possible instructor-teaches pairs, with all attributes from both relations•For common attributes (e.g., ID), the attributes in the resulting table are renamed using the relation name (e.g., instructor.ID)\nECE30030/ITP30010 Database Systems23\nThe FROM Clause•Find the Cartesian-product instructor X teaches SELECT * FROM instructor, teaches;\n24\ninstructor.IDnamedept_namesalaryteaches.IDcourse_idsec_idsemesteryear10101SrinivasanComp. Sci.6500076766BIO-101 1Summer201712121WuFinance9000076766BIO-101 1Summer201715151MozartMusic4000076766BIO-101 1Summer201722222EinsteinPhysics9500076766BIO-101 1Summer201732343El SaidHistory6000076766BIO-101 1Summer2017… … … … … … … … …10101SrinivasanComp. Sci.6500010101CS-101 1Fall 201712121WuFinance9000010101CS-101 1Fall 201715151MozartMusic4000010101CS-101 1Fall 201722222EinsteinPhysics9500010101CS-101 1Fall 201732343El SaidHistory6000010101CS-101 1Fall 2017… … … … … … … … …… … … … … … … … …10101SrinivasanComp. Sci.6500083821CS-190 2Spring201712121WuFinance9000083821CS-190 2Spring201715151MozartMusic4000083821CS-190 2Spring2017… … … … … … … … …10101SrinivasanComp. Sci.6500010101CS-315 1Spring201812121WuFinance9000010101CS-315 1Spring201815151MozartMusic4000010101CS-315 1Spring2018… … … … … … … … …… … … … … … … … …\nImplementing JOIN•Cartesian-product is not very useful directly; but useful combined with WHERE-clause condition (selection operation in relational algebra)•Cartesian-product + selection = join•E.g., Find the names of all instructors who have taught some course and the course_id SELECT name, course_id FROM instructor , teaches WHERE instructor.ID = teaches.ID\nECE30030/ITP30010 Database Systems25\nImplementing JOIN•Cartesian-product is not very useful directly; but useful combined with WHERE-clause condition (selection operation in relational algebra)•Cartesian-product + selection = join•Find the names of all instructors in the Music department who have taught some course and the course_id SELECT name, course_id FROM instructor , teaches WHERE instructor.ID = teaches.ID  AND instructor. dept_name = 'Music'\nECE30030/ITP30010 Database Systems26\nThe Rename Operation•The SQL allows renaming relations and attributes using the AS clause:   old-name AS new-name•Find the names of all instructors who have a higher salary than some instructor in ‘Comp. Sci.’•SELECT DISTINCT T.nameFROM instructor AS T, instructor AS SWHERE T.salary > S.salary AND S.dept_name = 'Comp. Sci.'\nECE30030/ITP30010 Database Systems27\nThe Rename Operation•The SQL allows renaming relations and attributes using the AS clause:   old-name AS new-name•Find the names of all instructors who have a higher salary than some instructor in ‘Comp. Sci.’•SELECT DISTINCT T.nameFROM instructor AS T, instructor AS SWHERE T.salary > S.salary AND S.dept_name = 'Comp. Sci.'•Keyword AS is optional and may be omitted  instructor AS T  ≡  instructor T\nECE30030/ITP30010 Database Systems28"
              },
              {
                "chapter_title": "SQL DML 고급 기능: NULL 값, 집합 연산, 문자열 처리 및 정렬",
                "source_pdf_filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf",
                "chapter_content_summary": "이 장에서는 SQL DML의 고급 기능을 탐구합니다. 먼저, 알려지지 않거나 존재하지 않는 값을 나타내는 NULL 값의 특성을 이해하고, 산술 연산에서의 NULL 동작 및 IS NULL / IS NOT NULL 술어를 사용하여 NULL 값을 확인하는 방법을 배웁니다. 다음으로, 여러 쿼리 결과를 결합하는 집합 연산인 UNION, INTERSECT, EXCEPT를 살펴봅니다. 각 연산이 기본적으로 중복을 제거하며, ALL 키워드를 사용하여 중복을 유지하는 방법을 설명합니다. 특히 MySQL에서 INTERSECT와 EXCEPT가 직접 지원되지 않을 때 JOIN 또는 NOT IN을 사용하여 에뮬레이션하는 기법을 소개합니다. 이어서, 문자열 패턴 매칭을 위한 LIKE 연산자와 '%' (모든 부분 문자열), '_' (단일 문자) 특수 문자의 사용법을 다룹니다. 백슬래시를 이용한 이스케이프 문자 처리, 패턴 매칭의 대소문자 구분, 그리고 연결, 대소문자 변환, 길이 확인, 부분 문자열 추출 등 다양한 SQL 문자열 함수를 소개합니다. 마지막으로, ORDER BY 절을 사용하여 쿼리 결과를 특정 속성을 기준으로 오름차순(ASC) 또는 내림차순(DESC)으로 정렬하는 방법을 학습하며, 여러 속성을 기준으로 정렬하는 예시도 제시합니다.",
                "chapter_full_text": "ECE30030/ITP30010 Database Systems29\nNULL Values•It is possible for tuples to have a NULL value for some of their attributes•NULL signifies an unknown value or that a value does not exist•The result of any arithmetic expression involving NULL is NULL•E.g.,  5 + NULL returns NULL\nECE30030/ITP30010 Database Systems30\nIS NULL / IS NOT NULL•The predicate IS NULL can be used to check for NULL values•E.g., Find all instructors whose salary is null SELECT name FROM instructor WHERE salary IS NULL•The predicate IS NOT NULL succeeds if the value on which it is applied is not null\nECE30030/ITP30010 Database Systems31\nECE30030/ITP30010 Database Systems32\nSet Operations•Set operations UNION, INTERSECT, and EXCEPT•Each of the above operations automatically eliminates duplicates•To retain all duplicates, use ALL:•UNION ALL•INTERSECT ALL•EXCEPT ALL\n•C.f., SELECT retains all duplicates by default\nECE30030/ITP30010 Database Systems33\nSet Operations: UNION•Find courses that ran in Fall 2017 or in Spring 2018•(SELECT course_id  FROM teaches WHERE semester = 'Fall' AND year = 2017)UNION(SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018)\nECE30030/ITP30010 Database Systems34\nSet Operations: INTERSECT•Find courses that ran in Fall 2017 and in Spring 2018•(SELECT course_id  FROM teaches WHERE semester = 'Fall' AND year = 2017)INTERSECT(SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018)•C.f., MySQL does NOT support INTERSECT•One can emulate INTERSECT using JOIN (we’ll study JOIN later)•SELECT LT.course_idFROM (SELECT course_id FROM teaches WHERE semester = 'Fall' AND year = 2017) AS LTJOIN (SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018) AS RTON LT.course_id=RT.course_id;\nECE30030/ITP30010 Database Systems35\nSet Operations: EXCEPT•Find courses that ran in Fall 2017 but not in Spring 2018•(SELECT course_id  FROM teaches WHERE semester = 'Fall' AND year = 2017)EXCEPT(SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018)•C.f., MySQL does NOT support EXCEPT•One can emulate EXCEPT using NOT IN•SELECT course_id FROM teaches WHERE semester = 'Fall' AND year = 2017AND course_id NOT IN(SELECT course_id  FROM teaches  WHERE semester = 'Spring' AND year = 2018);\nECE30030/ITP30010 Database Systems36\nECE30030/ITP30010 Database Systems37\nString Operations•SQL includes a string-matching operator for comparisons on character strings•The operator LIKE uses patterns that are described using two special characters:•percent (%) – The % character matches any substring•underscore (_) – The _ character matches any character•Find the names of all instructors whose name includes the substring “ri” SELECT name FROM instructor WHERE name LIKE ‘%ri%'\nECE30030/ITP30010 Database Systems38\nString Operations•Escape character: Use backslash (\\) as the escape character•E.g., Match the string “100%” LIKE '100 \\%’ ESCAPE  ‘\\’\nECE30030/ITP30010 Database Systems39\nString Operations•Patterns are case sensitive•Pattern matching examples:•'Intro%' matches any string beginning with “Intro”•'%Comp%' matches any string containing “Comp” as a substring•'_ _ _' matches any string of exactly three characters•'_ _ _ %' matches any string of at least three characters•SQL supports a variety of string operations such as•concatenation (using “||”)•converting from upper to lower case (and vice versa)•finding string length, extracting substrings, etc.\nECE30030/ITP30010 Database Systems40\nOrdering the Display of Tuples•List in alphabetic order the names of all instructors•SELECT DISTINCT nameFROM instructorORDER BY name\nECE30030/ITP30010 Database Systems41\nOrdering the Display of Tuples•Can sort on multiple attributes•E.g., SELECT dept_name, name     FROM instructor      ORDER BY dept_name, name\nECE30030/ITP30010 Database Systems42\nOrdering the Display of Tuples•We may specify DESC for descending order or ASC for ascending order, for each attribute; ascending order is the default•E.g., ORDER BY name DESC\nECE30030/ITP30010 Database Systems43"
              },
              {
                "chapter_title": "SQL DML 집계 함수 및 데이터 수정 (INSERT, UPDATE, DELETE)",
                "source_pdf_filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf",
                "chapter_content_summary": "이 장에서는 SQL 데이터 조작 언어(DML)의 고급 기능인 집계 함수와 데이터를 수정하는 명령어를 다룹니다. AVG, MIN, MAX, SUM, COUNT와 같은 집계 함수를 사용하여 컬럼 값의 멀티셋에 대한 통계 값을 계산하는 방법을 학습합니다. 특히 GROUP BY 절을 이용한 데이터 그룹화와 HAVING 절을 이용한 그룹별 필터링을 심층적으로 다루며, WHERE 절과의 차이점을 명확히 설명합니다. 또한, DML의 핵심 명령인 INSERT, UPDATE, DELETE에 대해 자세히 알아봅니다. INSERT 명령을 통해 테이블에 새로운 튜플을 추가하는 다양한 방법(모든 컬럼, 선택된 컬럼, NULL 값 처리, SELECT 쿼리 결과 삽입)과 외래 키 제약 조건의 중요성을 강조합니다. UPDATE 명령으로는 기존 데이터를 수정하는 기본 구문, 조건부 업데이트, CASE 문을 사용한 복잡한 조건 처리, 스칼라 서브쿼리 활용법을 배웁니다. 마지막으로 DELETE 명령을 통해 테이블에서 특정 행 또는 모든 행을 삭제하는 방법과 TRUNCATE 명령의 차이점, 그리고 삭제 시 서브쿼리 사용 시의 고려사항을 설명합니다.",
                "chapter_full_text": "ECE30030/ITP30010 Database Systems44\nAggregate Functions•These functions operate on the multiset of values of a column of a relation, and return a value•AVG:  average value•MIN:  minimum value•MAX:  maximum value•SUM:  sum of values•COUNT:  number of values\nECE30030/ITP30010 Database Systems45\nAggregate Functions Examples•Find the average salary of instructors in the Computer Science department•SELECT AVG(salary)FROM instructorWHERE dept_name= 'Comp. Sci.';•Find the total number of instructors who teach a course in the Spring 2018 semester•SELECT COUNT(DISTINCT ID)FROM teachesWHERE semester = 'Spring’ AND year = 2018;•Find the number of tuples in the teaches relation•SELECT COUNT (*)FROM teaches;\nECE30030/ITP30010 Database Systems46\nAggregate Functions: Group By•Find the average salary of instructors in each department•SELECT dept_name, AVG(salary) AS avg_salaryFROM instructorGROUP BY dept_name;\nECE30030/ITP30010 Database Systems47\nAggregation•Attributes in SELECT clause outside of aggregate functions must appear in GROUP BY list•/* erroneous query */SELECT dept_name, ID, AVG(salary)FROM instructorGROUP BY dept_name;\nECE30030/ITP30010 Database Systems48\nAggregate Functions – Having Clause•Find the names and average salaries of all departments whose average salary is greater than 65000•SELECT dept_name, AVG(salary) AS avg_salaryFROM instructorGROUP BY dept_nameHAVING AVG(salary) > 65000;\nECE30030/ITP30010 Database Systems49\nAggregate Functions – Having Clause•Note: predicates in the HAVING clause are applied after the formation of groups whereas predicates in the WHERE clause are applied before forming groups\nECE30030/ITP30010 Database Systems50\nSELECT dept_name, AVG(salary) AS avg_salaryFROM instructorGROUP BY dept_nameHAVING AVG(salary) > 65000;\nSELECT dept_name, AVG(salary) AS avg_salaryFROM instructorWHERE salary > 65000GROUP BY dept_name;\nSQL Commands\nSQLDMLSELECTINSERTUPDATEDELETE\nDDLCREATEALTERDROP\nECE30030/ITP30010 Database Systems51\nINSERT•Basic syntax•Insert data into every column:•INSERT INTO tablenameVALUES (col1_value, col2_value, …)•Must list values in the same order as in the table schema•If some data values are unknown, must type NULL •For character sequences, use quotation marks•Single quotation marks are preferred (but double quotation marks are allowed)•Value in quotations is case-sensitive•Insert data into selected columns•INSERT INTO tablename (col1_name, col3_name, col4_name, …)VALUES (col1_value, col3_value, col4_value, …)\nECE30030/ITP30010 Database Systems52\nINSERT•Add a new tuple to course•INSERT INTO courseVALUES ('CS-437', 'Database Systems', 'Comp. Sci.', 4);•or equivalently•INSERT INTO course (course_id, title, dept_name, credits)VALUES ('CS-437', 'Database Systems', 'Comp. Sci.', 4);•Add a new tuple to student  with tot_creds set to null•INSERT INTO studentVALUES ('3003', 'Green', 'Finance', null);\nECE30030/ITP30010 Database Systems53\nINSERT•A foreign key specifies that an attribute from one relation has to map to a tuple in another relation•Value in one relation must appear in another relation\nECE30030/ITP30010 Database Systems54\nRelation: instructor\nRelation: department\nINSERT•A foreign key specifies that an attribute from one relation has to map to a tuple in another relation•Value in one relation must appear in another relation•Make sure all foreign keys that new row references have already been added to database•One cannot insert a foreign key value unless the corresponding value exists in the referenced relation\nECE30030/ITP30010 Database Systems55\nINSERT•Inserting results of other SELECT query•Make each student in the Music department who has earned more than 144 credit hours an instructor in the Music department with a salary of  $18,000•INSERT INTO instructor  SELECT ID, name, dept_name, 18000  FROM student   WHERE dept_name = 'Music’ AND total_cred > 144;•The SELECT FROM WHERE statement is evaluated fully before any of its results are inserted into the relation•Otherwise queries like  INSERT INTO table1 SELECT * FROM table1would cause problem\nECE30030/ITP30010 Database Systems56\nUPDATE•Basic syntax•Updating a table•UPDATE tablenameSET col1_name = new_col1_value, col2_name = new_col2_value, …;•Updating a table with conditions•UPDATE tablenameSET col1_name = new_col1_value, col2_name = new_col2_value, …WHERE predicate;\nECE30030/ITP30010 Database Systems57\nUPDATE•Give a 5% salary raise to all instructors•UPDATE instructorSET salary = salary * 1.05•Give a 5% salary raise to those instructors who earn less than 70000•UPDATE instructorSET salary = salary * 1.05WHERE salary < 70000;•Give a 5% salary raise to instructors whose salary is less than average•UPDATE instructorSET salary = salary * 1.05WHERE salary <  (SELECT AVG(salary) FROM instructor);\nECE30030/ITP30010 Database Systems58\nUPDATE•Increase salaries of instructors whose salary is over $100,000 by 3%, and all others by a 5%•Write two UPDATE statements:  UPDATE instructor  SET salary = salary * 1.03  WHERE salary > 100000;  UPDATE instructor  SET salary = salary * 1.05  WHERE salary <= 100000;•The order is important•Can be done better using the case statement (next slide)\nECE30030/ITP30010 Database Systems59\nCASE Statement for Conditional Update•The following query is equivalent to the previous UPDATE queries•UPDATE instructorSET salary = CASE                           WHEN salary <= 100000 THEN salary * 1.05                           ELSE salary * 1.03                       END\nECE30030/ITP30010 Database Systems60\nUPDATE with Scalar Subqueries•Recompute and update tot_creds value for all students•UPDATE student SSET tot_cred = (SELECT SUM(credits)                             FROM takes, course                             WHERE takes.course_id = course.course_id  AND                                            S.ID= takes.ID  AND                                            takes.grade <> 'F' AND                                            takes.grade IS NOT NULL);\nECE30030/ITP30010 Database Systems61\nDELETE•Basic syntax•To remove specific rows•DELETE FROM tablenameWHERE predicate;•To remove all rows•DELETE FROM tablename;•This is equivalent to TRUNCATE:TRUNCATE (TABLE) tablename;•One cannot truncate a table with foreign key constraints•Must disable the constraints first (we will cover ALTER when we study SQL DDL):ALTER TABLE tablenameDISABLE CONSTRAINT constraint_name;\nECE30030/ITP30010 Database Systems62\nDELETE•Delete all instructors•DELETE FROM instructor;•Delete all instructors from the Finance department•DELETE FROM instructorWHERE dept_name= 'Finance';•Delete all tuples in the instructor relation for those instructors associated with a department located in the Watson building•DELETE FROM instructorWHERE dept name IN (SELECT dept name        FROM department        WHERE building = 'Watson');\nECE30030/ITP30010 Database Systems63\nDELETE•Delete all instructors whose salary is less than the average salary of instructors•Example:  DELETE FROM instructor                WHERE salary < (SELECT AVG (salary)                  FROM instructor);•Issue:  as we delete tuples from instructor, the average salary changes•Solution used in SQL:1.First, compute AVG(salary) and find all tuples to delete2.Next, delete all tuples found above (without recomputing AVG or retesting the tuples)\nECE30030/ITP30010 Database Systems64"
              }
            ],
            "generated_content": [
              {
                "title": "관계형 데이터베이스 시스템(R-DBMS) 개요 및 MySQL 소개",
                "metadata": "Source: cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_1a4c2f45-b482-4e82-826e-fa8945eb99c7_DB03 - mysql.pdf, Text length: 2496 chars",
                "documentContent": [
                  {
                    "type": "heading",
                    "content": "목차",
                    "level": 1
                  },
                  {
                    "type": "paragraph",
                    "content": "MySQL 소개",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "SQL 미리보기",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "MySQL",
                    "level": 1
                  },
                  {
                    "type": "paragraph",
                    "content": "MySQL은 SQL 기반의 관계형 데이터베이스 관리 시스템(DBMS)입니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "GPL 라이선스 하의 무료 오픈소스 R-DBMS입니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "오라클이 소유하고 있습니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "상업용 MySQL 버전도 제공됩니다(기술 지원 포함).",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "“My”는 공동 창립자 Michael Widenius의 딸 이름에서 유래했습니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "참고: MariaDB",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "표준 SQL과 호환됩니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "상업용 웹 서비스에 자주 사용됩니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "MySQL 사용 기업",
                    "level": 1
                  },
                  {
                    "type": "paragraph",
                    "content": "Enlyft의 연구에 따르면, MySQL을 사용하는 1,409,176개 회사 중 199,498개 회사에 대한 데이터를 보유하고 있습니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "주로 직원 수 10-50명, 매출 100만-1000만 달러 규모의 회사에서 사용됩니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "참고: Oracle 12는 직원 수 50-200명, 매출 10억 달러 이상 규모의 회사에서 가장 많이 사용됩니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "MySQL을 사용하는 회사 전체 목록은 https://www.mysql.com/customers/ 에서 확인할 수 있습니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "MySQL을 사용하는 이유",
                    "level": 1
                  },
                  {
                    "type": "paragraph",
                    "content": "인기 많음",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "인터넷 전반에 걸쳐 활발한 토론이 이루어집니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "다재다능함: Linux, Windows, Mac OS X, Solaris, FreeBSD 등 다양한 운영체제에서 실행됩니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "다양한 프로그래밍 언어(C/C++, Java, Python, .Net 등)를 지원합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "비용이 0부터 시작합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "고성능 (빠르고 신뢰할 수 있음)",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "DBMS 인기 추세",
                    "level": 1
                  },
                  {
                    "type": "paragraph",
                    "content": "점수 정의: https://db-engines.com/en/ranking_definition",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "MySQL의 주요 특징",
                    "level": 1
                  },
                  {
                    "type": "paragraph",
                    "content": "방대함: 테라바이트 단위의 데이터를 처리할 수 있습니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "편리함: 고수준 질의어를 지원합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "다중 사용자: 동시 데이터 접근을 지원합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "안전함: 트랜잭션을 지원합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "효율적임: 초당 수천 건의 질의를 처리할 수 있습니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "신뢰성: 많은 실제 제품에서 99.99%의 가동 시간을 자랑합니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "MySQL 버전",
                    "level": 1
                  },
                  {
                    "type": "paragraph",
                    "content": "MySQL 5.x 대 8.x",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "버전 5.x: MySQL의 가장 인기 있는 버전이며, 더 안정적이고 보편적입니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "버전 8.x: 현재 버전으로, 최신 DB 기능(더 나은 스토리지 엔진, 더 빠른 속도, 더 강력한 보안)을 제공합니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "MySQL 얻는 방법",
                    "level": 1
                  },
                  {
                    "type": "paragraph",
                    "content": "https://dev.mysql.com/downloads/",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "무료로 사용 가능한 \"커뮤니티\" 버전을 찾아보세요.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "”엔터프라이즈” 버전은 상업용입니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "이 강의를 위해 Docker 이미지가 준비되어 있습니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "Ubuntu 서버, MySQL, 그리고 강의 활동을 위한 예제 데이터베이스로 구성되어 있습니다.",
                    "level": null
                  }
                ],
                "aiNotes": {
                  "summary": "본 문서는 관계형 데이터베이스 관리 시스템(R-DBMS)의 개요와 MySQL에 대해 소개합니다. MySQL이 SQL 기반의 무료 오픈소스 R-DBMS이며, 오라클이 소유하고 있음을 설명합니다. 또한 MySQL의 광범위한 사용 현황, 다양한 운영체제 및 프로그래밍 언어 지원, 고성능, 안정성 등의 장점을 강조합니다. MySQL 5.x와 8.x 버전의 주요 차이점을 비교하고, MySQL을 다운로드하고 활용할 수 있는 방법을 안내합니다.",
                  "keyConcepts": [
                    {
                      "term": "관계형 데이터베이스 관리 시스템 (R-DBMS)",
                      "definition": "SQL 기반으로 데이터를 관계형 모델에 따라 저장, 관리, 검색하는 시스템입니다."
                    },
                    {
                      "term": "MySQL",
                      "definition": "오라클이 소유한 SQL 기반의 오픈소스 R-DBMS로, 상업용 웹 서비스에 널리 사용되며 높은 성능과 안정성을 제공합니다."
                    },
                    {
                      "term": "오픈소스 소프트웨어",
                      "definition": "소스 코드가 공개되어 누구나 자유롭게 사용, 수정, 배포할 수 있는 소프트웨어입니다."
                    },
                    {
                      "term": "SQL (Structured Query Language)",
                      "definition": "관계형 데이터베이스와 상호작용하고 데이터를 정의, 조작, 제어하기 위한 표준 언어입니다."
                    },
                    {
                      "term": "MySQL 버전 5.x vs 8.x",
                      "definition": "5.x는 가장 대중적이고 안정적인 버전이며, 8.x는 현재 버전으로 최신 기능, 향상된 스토리지 엔진, 속도 및 보안을 제공합니다."
                    }
                  ],
                  "importantTerms": [
                    {
                      "term": "DBMS",
                      "definition": "데이터베이스 관리 시스템(Database Management System)의 약자로, 데이터베이스를 효율적으로 관리하는 소프트웨어입니다."
                    },
                    {
                      "term": "GPL",
                      "definition": "General Public License의 약자로, 자유 소프트웨어 라이선스의 일종이며, 소프트웨어의 복사, 배포, 수정 권한을 부여합니다."
                    },
                    {
                      "term": "MariaDB",
                      "definition": "MySQL의 한 포크(fork)로, MySQL과 높은 호환성을 가지며 오픈소스 커뮤니티에 의해 개발되고 있습니다."
                    },
                    {
                      "term": "트랜잭션",
                      "definition": "데이터베이스의 논리적인 작업 단위로, 데이터의 무결성을 보장하기 위해 전부 실행되거나 전혀 실행되지 않아야 하는 일련의 연산입니다."
                    },
                    {
                      "term": "스토리지 엔진",
                      "definition": "데이터베이스 시스템 내에서 데이터를 디스크에 저장하고 검색하는 방식을 담당하는 구성 요소입니다."
                    },
                    {
                      "term": "Docker",
                      "definition": "애플리케이션을 컨테이너라는 격리된 환경에서 개발, 배포, 실행할 수 있게 해주는 플랫폼입니다."
                    }
                  ],
                  "outline": [
                    {
                      "text": "목차",
                      "id": "목차",
                      "children": null
                    },
                    {
                      "text": "MySQL",
                      "id": "mysql",
                      "children": [
                        {
                          "text": "MySQL 정의 및 특징",
                          "id": "mysql-정의-및-특징",
                          "children": null
                        },
                        {
                          "text": "MySQL 사용 기업",
                          "id": "mysql-사용-기업",
                          "children": null
                        },
                        {
                          "text": "MySQL을 사용하는 이유",
                          "id": "mysql을-사용하는-이유",
                          "children": null
                        },
                        {
                          "text": "MySQL의 주요 특징",
                          "id": "mysql의-주요-특징",
                          "children": null
                        }
                      ]
                    },
                    {
                      "text": "DBMS 인기 추세",
                      "id": "dbms-인기-추세",
                      "children": null
                    },
                    {
                      "text": "MySQL 버전",
                      "id": "mysql-버전",
                      "children": null
                    },
                    {
                      "text": "MySQL 얻는 방법",
                      "id": "mysql-얻는-방법",
                      "children": null
                    }
                  ]
                },
                "quiz": [
                  {
                    "question": "MySQL의 주요 특징이 아닌 것은 무엇인가요?",
                    "options": [
                      "오라클이 소유한 상용 소프트웨어이다.",
                      "SQL 기반의 관계형 데이터베이스 관리 시스템이다.",
                      "GPL 라이선스 하에 무료 오픈소스 버전이 제공된다.",
                      "다양한 운영체제와 프로그래밍 언어를 지원한다."
                    ],
                    "answerIndex": 0,
                    "explanation": "MySQL은 오라클이 소유하고 있지만, GPL 라이선스 하에 무료 오픈소스 버전이 제공되며 상용 버전도 별도로 존재합니다. 따라서 '오라클이 소유한 상용 소프트웨어이다'는 MySQL의 모든 특징을 포괄하지 않습니다."
                  },
                  {
                    "question": "MySQL 5.x 버전과 8.x 버전의 주요 차이점은 무엇인가요?",
                    "options": [
                      "5.x는 최신 기능에 중점을 둔 반면 8.x는 안정성에 중점을 둡니다.",
                      "5.x는 현재 버전이고 8.x는 이전 버전입니다.",
                      "5.x는 더 안정적이고 대중적이며, 8.x는 최신 기능과 향상된 성능을 제공합니다.",
                      "5.x는 유료 버전이고 8.x는 무료 버전입니다."
                    ],
                    "answerIndex": 2,
                    "explanation": "MySQL 5.x는 가장 대중적이고 안정적인 버전으로 남아있지만, 8.x는 최신 버전으로서 더 나은 스토리지 엔진, 속도 및 보안 등 최신 기능을 제공합니다."
                  },
                  {
                    "question": "다음 중 MySQL을 얻을 수 있는 방법으로 본문에 언급되지 않은 것은 무엇인가요?",
                    "options": [
                      "dev.mysql.com/downloads/에서 커뮤니티 버전 다운로드",
                      "MySQL 엔터프라이즈 버전 구매",
                      "Docker 이미지를 통해 구축",
                      "CD-ROM으로 설치"
                    ],
                    "answerIndex": 3,
                    "explanation": "본문에서는 공식 다운로드 페이지에서 커뮤니티 버전 다운로드, 엔터프라이즈 버전 구매, 그리고 Docker 이미지 활용 방법이 언급되었으나, CD-ROM을 통한 설치는 언급되지 않았습니다."
                  }
                ]
              },
              {
                "title": "SQL(구조적 질의어)의 이해: 기본 개념과 역사",
                "metadata": "Source: cd0e465a-9cfa-47bf-93fa-9eb3748fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf, Text length: 1968 chars",
                "documentContent": [
                  {
                    "type": "heading",
                    "content": "서론",
                    "level": 1
                  },
                  {
                    "type": "paragraph",
                    "content": "이 문서는 관계형 데이터베이스를 다루는 핵심 언어인 SQL(구조적 질의어)의 기본 개념과 역사, 그리고 주요 구성 요소에 대해 설명합니다. SQL은 데이터베이스에 '무엇을 할지'를 지시하는 높은 수준의 언어로, '어떻게 할지'에 대한 세부 사항은 DBMS(데이터베이스 관리 시스템)의 질의 최적화 기능에 맡깁니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "구조적 질의어 (SQL) 개요",
                    "level": 1
                  },
                  {
                    "type": "heading",
                    "content": "SQL의 정의 및 특징",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "SQL은 관계형 데이터베이스를 기술하고 조작하는 데 사용되는 주요 언어입니다. SQL은 매우 높은 수준의 언어로, 사용자에게 데이터 조작의 세부 사항을 명시하는 대신 '무엇을 할지'를 지시하도록 합니다. DBMS는 질의 최적화(query optimization)를 통해 질의를 실행하는 '최적의' 방법을 찾아냅니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "SQL의 주요 구성 요소",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "SQL은 크게 두 가지 주요 측면으로 나뉩니다:",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "데이터 정의: 데이터베이스 스키마를 선언하는 데 사용되는 DDL(Data Definition Language).",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "데이터 조작: 데이터베이스에 질의하고(질문을 던지고) 데이터베이스를 수정하는 데 사용되는 DML(Data Manipulation Language).",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "SQL의 다양한 기능",
                    "level": 1
                  },
                  {
                    "type": "heading",
                    "content": "데이터 조작 언어 (DML)",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "DML은 데이터베이스에서 정보를 질의하고, 튜플을 삽입, 삭제, 수정하는 기능을 제공합니다. `SELECT`, `FROM`, `WHERE`와 같은 구문이 DML의 핵심을 이룹니다. 또한, NULL 값 처리, 집합 연산, 문자열 연산, 정렬, 그리고 집계 함수와 같은 고급 기능도 포함됩니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "기타 SQL 기능",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "SQL은 DML 외에도 다양한 기능을 포함합니다:",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "무결성: DDL은 무결성 제약 조건을 명시하기 위한 명령어를 포함합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "뷰 정의: DDL은 뷰를 정의하기 위한 명령어를 포함합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "트랜잭션 제어: 트랜잭션의 시작과 끝을 명시하기 위한 명령어를 포함합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "임베디드 SQL 및 동적 SQL: SQL 문을 범용 프로그래밍 언어 내에 포함하는 방법을 정의합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "권한 부여: 관계 및 뷰에 대한 접근 권한을 명시하기 위한 명령어를 포함합니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "SQL의 간략한 역사",
                    "level": 1
                  },
                  {
                    "type": "heading",
                    "content": "초기 개발: IBM SEQUEL과 System R",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "SQL의 전신인 IBM SEQUEL(Structured English Query Language)은 1970년대 초 Chamberlin과 Boyce에 의해 System R 프로젝트의 일환으로 개발되었습니다. 이후 SEQUEL은 SQL(Structured Query Language)로 이름이 변경되었습니다. System R은 System/38(1979), SQL/DS(1981), DB2(1983)로 발전했습니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "상업적 구현 및 표준화",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "Relational Software, Inc.(현재 Oracle Corporation)는 VAX 컴퓨터용 Oracle V2를 출시하며 최초의 상업적 SQL 구현을 선보였습니다. ANSI와 ISO는 SQL을 표준화했으며, SQL-86을 시작으로 SQL-89, SQL-92, SQL:1999 등을 거쳐 현재는 SQL:2016에 이르렀습니다. 특히 SQL-92는 대부분의 데이터베이스 시스템에서 지원됩니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "기본 질의 구조",
                    "level": 1
                  },
                  {
                    "type": "heading",
                    "content": "SELECT-FROM-WHERE 구문",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "전형적인 SQL 질의는 다음과 같은 형태를 가집니다:",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "SELECT A1, A2, ..., An\nFROM r1, r2, ..., rm\nWHERE P",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "여기서 Ai는 속성(attribute)을 나타내고, Ri는 관계(relation)를 나타내며, P는 술어(predicate)입니다. SQL 질의의 결과는 항상 관계(테이블)입니다.",
                    "level": null
                  }
                ],
                "aiNotes": {
                  "summary": "이 문서는 관계형 데이터베이스의 핵심 언어인 SQL(구조적 질의어)에 대해 설명합니다. SQL의 정의와 특징, 데이터 정의 언어(DDL)와 데이터 조작 언어(DML)로의 구분, 그리고 무결성 제약 조건, 뷰 정의, 트랜잭션 제어 등 다양한 기능을 다룹니다. 또한, IBM의 SEQUEL 개발부터 Oracle의 상업적 구현, 그리고 ANSI 및 ISO 표준화에 이르는 SQL의 간략한 역사와 함께, `SELECT-FROM-WHERE`로 대표되는 SQL의 기본 질의 구조를 소개합니다.",
                  "keyConcepts": [
                    {
                      "term": "SQL (구조적 질의어)",
                      "definition": {
                        "easy": null,
                        "medium": "관계형 데이터베이스를 기술하고 조작하는 데 사용되는 주요 언어로, '무엇을 할지'를 지시하는 높은 수준의 언어입니다.",
                        "hard": null
                      }
                    },
                    {
                      "term": "DML (데이터 조작 언어)",
                      "definition": {
                        "easy": null,
                        "medium": "데이터베이스에서 정보를 질의하고, 튜플을 삽입, 삭제, 수정하는 기능을 제공하는 SQL의 한 부분입니다.",
                        "hard": null
                      }
                    },
                    {
                      "term": "DDL (데이터 정의 언어)",
                      "definition": {
                        "easy": null,
                        "medium": "데이터베이스 스키마를 선언하고 무결성 제약 조건 및 뷰 정의와 같은 데이터베이스 구조 관련 기능을 담당하는 SQL의 한 부분입니다.",
                        "hard": null
                      }
                    },
                    {
                      "term": "질의 최적화",
                      "definition": {
                        "easy": null,
                        "medium": "DBMS가 SQL 질의를 효율적으로 실행하기 위해 '최적의' 실행 계획을 찾는 과정입니다.",
                        "hard": null
                      }
                    }
                  ],
                  "importantTerms": [
                    {
                      "term": "SQL",
                      "definition": "Structured Query Language의 약자로, 관계형 데이터베이스를 관리하는 표준 언어입니다."
                    },
                    {
                      "term": "DML",
                      "definition": "Data Manipulation Language의 약자로, 데이터 검색, 삽입, 수정, 삭제 등 데이터 조작에 사용되는 SQL 명령어 집합입니다."
                    },
                    {
                      "term": "DDL",
                      "definition": "Data Definition Language의 약자로, 데이터베이스 스키마 정의, 테이블 생성 및 수정, 뷰 생성 등 데이터 구조 정의에 사용되는 SQL 명령어 집합입니다."
                    },
                    {
                      "term": "SEQUEL",
                      "definition": "Structured English Query Language의 약자로, SQL의 초기 명칭이자 IBM System R 프로젝트에서 개발되었습니다."
                    },
                    {
                      "term": "System R",
                      "definition": "IBM에서 1970년대 초에 개발한 관계형 데이터베이스 시스템 연구 프로젝트로, SQL의 기원이 되었습니다."
                    },
                    {
                      "term": "질의 최적화 (Query Optimization)",
                      "definition": "DBMS가 SQL 질의를 가장 효율적으로 실행하기 위한 방법을 결정하는 과정입니다."
                    },
                    {
                      "term": "SELECT-FROM-WHERE",
                      "definition": "SQL에서 데이터를 질의하는 가장 기본적인 구문 형태입니다."
                    }
                  ],
                  "outline": [
                    {
                      "text": "서론",
                      "id": "서론",
                      "children": null
                    },
                    {
                      "text": "구조적 질의어 (SQL) 개요",
                      "id": "구조적-질의어-sql-개요",
                      "children": [
                        {
                          "text": "SQL의 정의 및 특징",
                          "id": "sql의-정의-및-특징",
                          "children": null
                        },
                        {
                          "text": "SQL의 주요 구성 요소",
                          "id": "sql의-주요-구성-요소",
                          "children": null
                        }
                      ]
                    },
                    {
                      "text": "SQL의 다양한 기능",
                      "id": "sql의-다양한-기능",
                      "children": [
                        {
                          "text": "데이터 조작 언어 (DML)",
                          "id": "데이터-조작-언어-dml",
                          "children": null
                        },
                        {
                          "text": "기타 SQL 기능",
                          "id": "기타-sql-기능",
                          "children": null
                        }
                      ]
                    },
                    {
                      "text": "SQL의 간략한 역사",
                      "id": "sql의-간략한-역사",
                      "children": [
                        {
                          "text": "초기 개발: IBM SEQUEL과 System R",
                          "id": "초기-개발-ibm-sequel과-system-r",
                          "children": null
                        },
                        {
                          "text": "상업적 구현 및 표준화",
                          "id": "상업적-구현-및-표준화",
                          "children": null
                        }
                      ]
                    },
                    {
                      "text": "기본 질의 구조",
                      "id": "기본-질의-구조",
                      "children": [
                        {
                          "text": "SELECT-FROM-WHERE 구문",
                          "id": "select-from-where-구문",
                          "children": null
                        }
                      ]
                    }
                  ]
                },
                "quiz": [
                  {
                    "question": "SQL의 주요 특징 중 하나는 무엇입니까?",
                    "options": [
                      "데이터 조작의 세부 사항을 명시합니다.",
                      "데이터베이스에 '무엇을 할지'보다 '어떻게 할지'를 지시합니다.",
                      "DBMS가 질의 실행 방법을 최적화하도록 합니다.",
                      "비관계형 데이터베이스를 조작하는 데 주로 사용됩니다."
                    ],
                    "answerIndex": 2,
                    "explanation": "SQL은 '무엇을 할지'를 명시하며, '어떻게 할지'에 대한 세부 사항은 DBMS의 질의 최적화 기능에 맡깁니다."
                  },
                  {
                    "question": "최초의 상업적 SQL 구현을 출시한 회사는 어디입니까?",
                    "options": [
                      "IBM",
                      "Microsoft",
                      "Relational Software, Inc. (현재 Oracle Corporation)",
                      "ANSI"
                    ],
                    "answerIndex": 2,
                    "explanation": "Relational Software, Inc. (현재 Oracle Corporation)가 VAX 컴퓨터용 Oracle V2를 통해 최초의 상업적 SQL 구현을 출시했습니다."
                  },
                  {
                    "question": "SQL의 구성 요소 중 데이터베이스 스키마를 선언하고 무결성 제약 조건 및 뷰를 정의하는 역할을 하는 것은 무엇입니까?",
                    "options": [
                      "DML (Data Manipulation Language)",
                      "DDL (Data Definition Language)",
                      "Transaction Control (트랜잭션 제어)",
                      "Authorization (권한 부여)"
                    ],
                    "answerIndex": 1,
                    "explanation": "DDL(데이터 정의 언어)은 데이터베이스 스키마를 선언하고 무결성 제약 조건 및 뷰를 정의하는 데 사용됩니다."
                  }
                ]
              },
              {
                "title": "SQL 데이터 조작 언어(DML) 기초: SELECT, FROM, WHERE 절",
                "metadata": "Source: cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf, Text length: 4209 chars",
                "documentContent": [
                  {
                    "type": "heading",
                    "content": "SQL 데이터 조작 언어(DML)",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "SQL 데이터 조작 언어(DML)는 데이터베이스를 질의(질문)하고 수정할 수 있도록 합니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "실행 예시",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "관계(테이블): instructor, teaches",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "Instructor 관계 및 Teaches 관계",
                    "level": 2
                  },
                  {
                    "type": "heading",
                    "content": "기본 질의 구조",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "일반적인 SQL 질의는 다음과 같은 형태를 가집니다: SELECT A1, A2, ..., An FROM r1, r2, ..., rm WHERE P",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "Ai는 속성을 나타냅니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "Ri는 관계를 나타냅니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "P는 술어(predicate)입니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "SQL 질의의 결과는 관계(relation)입니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "SELECT 절",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "SELECT 절은 질의 결과에 필요한 속성들을 나열합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "관계 대수의 프로젝션(projection) 연산에 해당합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "예시: 모든 강사의 이름을 찾기",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "SQL: SELECT name FROM instructor;",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "참고",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "참고: SQL 이름은 대소문자를 구분하지 않습니다. 예: Name ≡ NAME ≡ name",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "SQL 명령(SELECT, FROM, WHERE 등)은 대문자로 작성하는 것이 일반적인 관례입니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "MySQL에는 lower_case_table_names라는 옵션 플래그가 있습니다. 링크: https://dev.mysql.com/doc/refman/8.0/en/identifier-case-sensitivity.html",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "SELECT 절: 중복 처리",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "SQL은 관계뿐만 아니라 질의 결과에서도 중복을 허용합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "ALL 키워드는 중복을 제거하지 않도록 지정합니다. SELECT ALL dept_name FROM instructor",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "중복 제거를 강제하려면 SELECT 뒤에 DISTINCT 키워드를 삽입합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "모든 강사의 부서 이름을 중복 없이 찾기: SELECT DISTINCT dept_name FROM instructor;",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "SELECT 절: 모든 속성 및 리터럴 사용",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "SELECT 절의 별표(*)는 “모든 속성”을 의미합니다. SELECT * FROM instructor;",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "속성은 FROM 절 없이 리터럴(상수)이 될 수 있습니다. SELECT ‘437’;",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "결과는 하나의 열과 “437” 값을 가진 단일 행으로 구성된 테이블입니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "AS를 사용하여 열에 이름을 부여할 수 있습니다: SELECT ‘437’ AS FOO",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "속성은 FROM 절을 포함하는 리터럴이 될 수 있습니다. SELECT 'A' FROM instructor",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "결과는 하나의 열과 N개의 행(instructor 테이블의 튜플 수)으로 구성된 테이블이며, 각 행은 “A” 값을 가집니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "SELECT 절: 산술 표현식",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "SELECT 절은 +, –, *, / 연산을 포함하는 산술 표현식을 포함할 수 있으며, 상수 또는 튜플의 속성에 대해 작동합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "질의: SELECT ID, name, salary/12 FROM instructor는 instructor 관계와 동일한 관계를 반환하지만, salary 속성 값이 12로 나뉘어 표시됩니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "AS 절을 사용하여 “salary/12”의 이름을 변경할 수 있습니다: SELECT ID, name, salary/12 AS monthly_salary FROM instructor",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "WHERE 절",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "WHERE 절은 결과가 만족해야 하는 조건을 지정합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "관계 대수의 선택(selection) 술어에 해당합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "예시: ‘Comp. Sci.’ 부서의 모든 강사를 찾으려면: SELECT name FROM instructor WHERE dept_name = 'Comp. Sci.';",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "WHERE 절: 논리 연산자와 비교 연산자",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "SQL은 AND, OR, NOT 논리 연결자를 사용할 수 있도록 합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "논리 연결자의 피연산자는 <, <=, >, >=, =, <>와 같은 비교 연산자를 포함하는 표현식일 수 있습니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "<>는 같지 않음을 의미합니다 (SQL에는 !=가 없습니다).",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "비교는 산술 표현식의 결과에도 적용될 수 있습니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "예시: ‘Comp. Sci.’ 부서에 속하며 급여가 70,000보다 많은 모든 강사를 찾으려면: SELECT name FROM instructor WHERE dept_name = 'Comp. Sci.' AND salary > 70000;",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "WHERE 절: BETWEEN 연산자",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "SQL에는 BETWEEN 비교 연산자가 포함되어 있습니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "예시: 급여가 $90,000에서 $100,000 사이(즉, $90,000 이상 $100,000 이하)인 모든 강사의 이름을 찾으려면:",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "SELECT name FROM instructor WHERE salary BETWEEN 90000 AND 100000",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "WHERE 절: 튜플 비교",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "튜플 비교: 튜플별로 비교를 수행합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "SELECT name, course_id FROM instructor, teaches WHERE (instructor.ID, dept_name) = (teaches.ID, 'Biology');",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "FROM 절",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "FROM 절은 질의에 관련된 관계(테이블)들을 나열합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "관계 대수의 카티션 곱(Cartesian-product) 연산에 해당합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "예시: instructor × teaches의 카티션 곱을 찾으려면: SELECT * FROM instructor, teaches;",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "두 관계의 모든 속성을 포함하여 가능한 모든 instructor-teaches 쌍을 생성합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "공통 속성(예: ID)의 경우, 결과 테이블의 속성 이름은 관계 이름(예: instructor.ID)을 사용하여 변경됩니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "FROM 절: 카티션 곱 예시",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "instructor X teaches의 카티션 곱을 찾으려면: SELECT * FROM instructor, teaches;",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "결과 테이블은 instructor와 teaches 관계의 모든 속성을 포함하며, 각 instructor 튜플과 각 teaches 튜플의 모든 가능한 조합을 생성합니다. 예를 들어, instructor.ID, name, dept_name, salary와 teaches.ID, course_id, sec_id, semester, year와 같은 속성들이 조합되어 나타납니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "조인 구현",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "카티션 곱은 직접적으로는 유용하지 않지만, WHERE 절 조건(관계 대수의 선택 연산)과 결합하면 유용합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "카티션 곱 + 선택 = 조인(join)",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "예시: 어떤 과목을 가르친 모든 강사의 이름과 course_id를 찾으려면: SELECT name, course_id FROM instructor , teaches WHERE instructor.ID = teaches.ID",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "음악과에 속하며 어떤 과목을 가르친 모든 강사의 이름과 course_id를 찾으려면: SELECT name, course_id FROM instructor , teaches WHERE instructor.ID = teaches.ID AND instructor. dept_name = 'Music'",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "이름 변경(Rename) 연산",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "SQL은 AS 절을 사용하여 관계와 속성의 이름을 변경할 수 있도록 합니다: old-name AS new-name",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "예시: 'Comp. Sci.' 부서의 어떤 강사보다 급여가 높은 모든 강사의 이름을 찾으려면:",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "SELECT DISTINCT T.name FROM instructor AS T, instructor AS S WHERE T.salary > S.salary AND S.dept_name = 'Comp. Sci.'",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "AS 키워드는 선택 사항이며 생략될 수 있습니다. instructor AS T ≡ instructor T",
                    "level": null
                  }
                ],
                "aiNotes": {
                  "summary": "본 문서는 SQL 데이터 조작 언어(DML)의 핵심 구성 요소인 SELECT, FROM, WHERE 절의 기초를 다룹니다. 각 절의 기본적인 기능과 함께 중복 처리(ALL, DISTINCT), 산술 표현식, 조건 필터링(AND, OR, NOT, BETWEEN), 테이블 간의 조인(JOIN) 구현, 그리고 테이블 및 속성 이름 변경(AS)과 같은 다양한 활용 방법을 예시와 함께 설명합니다. 또한 SQL 이름의 대소문자 구분 규칙에 대한 내용도 포함되어 있습니다.",
                  "keyConcepts": [
                    {
                      "term": "SQL DML",
                      "definition": "데이터베이스에서 데이터를 질의하고 수정하는 데 사용되는 언어입니다."
                    },
                    {
                      "term": "SELECT 절",
                      "definition": "질의 결과에 포함할 속성(컬럼)을 지정하는 부분으로, 관계 대수의 프로젝션(Projection) 연산에 해당합니다."
                    },
                    {
                      "term": "FROM 절",
                      "definition": "데이터를 검색할 관계(테이블)를 지정하는 부분으로, 관계 대수의 카티션 곱(Cartesian Product) 연산에 해당합니다."
                    },
                    {
                      "term": "WHERE 절",
                      "definition": "질의 결과가 만족해야 할 조건을 지정하는 부분으로, 관계 대수의 선택(Selection) 연산에 해당합니다."
                    },
                    {
                      "term": "조인 (JOIN)",
                      "definition": "FROM 절의 카티션 곱과 WHERE 절의 선택 조건을 결합하여 두 개 이상의 테이블에서 관련 튜플을 연결하여 새로운 테이블을 생성하는 연산입니다."
                    }
                  ],
                  "importantTerms": [
                    {
                      "term": "DML (Data Manipulation Language)",
                      "definition": "데이터베이스에서 데이터를 검색, 삽입, 삭제, 수정하는 데 사용되는 언어."
                    },
                    {
                      "term": "SELECT",
                      "definition": "SQL 쿼리의 결과를 정의하는 절로, 어떤 컬럼을 반환할지 지정."
                    },
                    {
                      "term": "FROM",
                      "definition": "SQL 쿼리에서 데이터를 검색할 테이블을 지정하는 절."
                    },
                    {
                      "term": "WHERE",
                      "definition": "SQL 쿼리에서 특정 조건을 만족하는 행만 선택하도록 필터링하는 절."
                    },
                    {
                      "term": "DISTINCT",
                      "definition": "SELECT 절에서 중복된 결과를 제거할 때 사용하는 키워드."
                    },
                    {
                      "term": "AS",
                      "definition": "SQL에서 테이블이나 컬럼의 이름을 변경(별칭 지정)할 때 사용하는 키워드."
                    },
                    {
                      "term": "카티션 곱 (Cartesian Product)",
                      "definition": "두 테이블의 모든 가능한 행 조합을 생성하는 연산."
                    }
                  ],
                  "outline": [
                    {
                      "text": "SQL 데이터 조작 언어(DML) 개요",
                      "id": "sql-데이터-조작-언어-dml-개요",
                      "children": null
                    },
                    {
                      "text": "기본 질의 구조",
                      "id": "기본-질의-구조",
                      "children": null
                    },
                    {
                      "text": "SELECT 절의 활용",
                      "id": "select-절의-활용",
                      "children": [
                        {
                          "text": "속성 선택 및 프로젝션",
                          "id": "속성-선택-및-프로젝션",
                          "children": null
                        },
                        {
                          "text": "대소문자 구분 및 SQL 명령 규칙",
                          "id": "대소문자-구분-및-sql-명령-규칙",
                          "children": null
                        },
                        {
                          "text": "중복 처리 (ALL, DISTINCT)",
                          "id": "중복-처리-all-distinct",
                          "children": null
                        },
                        {
                          "text": "모든 속성 선택 (*) 및 리터럴 사용",
                          "id": "모든-속성-선택-및-리터럴-사용",
                          "children": null
                        },
                        {
                          "text": "산술 표현식 및 결과 이름 변경 (AS)",
                          "id": "산술-표현식-및-결과-이름-변경-as",
                          "children": null
                        }
                      ]
                    },
                    {
                      "text": "WHERE 절의 활용",
                      "id": "where-절의-활용",
                      "children": [
                        {
                          "text": "조건 지정 및 선택 연산",
                          "id": "조건-지정-및-선택-연산",
                          "children": null
                        },
                        {
                          "text": "논리 연산자 (AND, OR, NOT) 및 비교 연산자",
                          "id": "논리-연산자-and-or-not-및-비교-연산자",
                          "children": null
                        },
                        {
                          "text": "BETWEEN 연산자",
                          "id": "between-연산자",
                          "children": null
                        },
                        {
                          "text": "튜플 비교",
                          "id": "튜플-비교",
                          "children": null
                        }
                      ]
                    },
                    {
                      "text": "FROM 절의 활용",
                      "id": "from-절의-활용",
                      "children": [
                        {
                          "text": "관계 지정 및 카티션 곱",
                          "id": "관계-지정-및-카티션-곱",
                          "children": null
                        },
                        {
                          "text": "조인 구현 (Cartesian-product + selection)",
                          "id": "조인-구현-cartesian-product-selection",
                          "children": null
                        }
                      ]
                    },
                    {
                      "text": "이름 변경 (AS) 연산",
                      "id": "이름-변경-as-연산",
                      "children": null
                    }
                  ]
                },
                "quiz": [
                  {
                    "question": "중복된 값을 제거하고 강사들의 부서 이름을 검색하는 올바른 SQL 쿼리는 무엇입니까?",
                    "options": [
                      "SELECT ALL dept_name FROM instructor;",
                      "SELECT dept_name FROM instructor;",
                      "SELECT DISTINCT dept_name FROM instructor;",
                      "SELECT UNIQUE dept_name FROM instructor;"
                    ],
                    "answerIndex": 2,
                    "explanation": "`DISTINCT` 키워드는 SELECT 절에서 중복된 결과를 제거하는 데 사용됩니다."
                  },
                  {
                    "question": "'Comp. Sci.' 부서에 속하며 급여가 70,000보다 많은 모든 강사의 이름을 찾는 SQL 쿼리로 가장 적절한 것은 무엇입니까?",
                    "options": [
                      "SELECT name FROM instructor WHERE dept_name = 'Comp. Sci.' OR salary > 70000;",
                      "SELECT name FROM instructor WHERE dept_name = 'Comp. Sci.' AND salary > 70000;",
                      "SELECT name FROM instructor WHERE dept_name <> 'Comp. Sci.' AND salary <= 70000;",
                      "SELECT name FROM instructor WHERE dept_name = 'Comp. Sci.' BETWEEN salary 70000;"
                    ],
                    "answerIndex": 1,
                    "explanation": "`AND` 논리 연산자는 두 조건을 모두 만족하는 경우를 찾을 때 사용됩니다."
                  },
                  {
                    "question": "다음 SQL 쿼리 `SELECT DISTINCT T.name FROM instructor AS T, instructor AS S WHERE T.salary > S.salary AND S.dept_name = 'Comp. Sci.'`에 대한 설명으로 옳은 것은 무엇입니까?",
                    "options": [
                      "이 쿼리는 'Comp. Sci.' 부서 강사들 중 가장 높은 급여를 받는 강사의 이름을 찾습니다.",
                      "이 쿼리는 'Comp. Sci.' 부서의 특정 강사보다 급여가 높은 다른 강사들의 이름을 찾습니다.",
                      "이 쿼리는 'Comp. Sci.' 부서의 모든 강사 이름을 나열합니다.",
                      "이 쿼리는 두 개의 다른 테이블에서 강사 정보를 조인합니다."
                    ],
                    "answerIndex": 1,
                    "explanation": "`FROM instructor AS T, instructor AS S`는 instructor 테이블을 두 개의 별칭(T와 S)으로 사용하여 자체 조인(self-join)을 수행하며, `WHERE T.salary > S.salary AND S.dept_name = 'Comp. Sci.'` 조건은 'Comp. Sci.' 부서의 어떤 강사(S)보다 급여가 높은 강사(T)를 찾습니다."
                  }
                ]
              },
              {
                "title": "SQL DML 고급 기능: NULL 값, 집합 연산, 문자열 처리 및 정렬",
                "metadata": "Source: cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf, Text length: 3206 chars",
                "documentContent": [
                  {
                    "type": "heading",
                    "content": "NULL 값",
                    "level": 1
                  },
                  {
                    "type": "paragraph",
                    "content": "튜플에 일부 속성에 대해 NULL 값이 있을 수 있습니다. NULL은 알 수 없거나 값이 존재하지 않음을 의미합니다. NULL이 포함된 모든 산술 표현식의 결과는 NULL입니다. 예를 들어, '5 + NULL'은 NULL을 반환합니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "IS NULL / IS NOT NULL",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "술어 `IS NULL`은 NULL 값을 확인하는 데 사용됩니다. 예를 들어, `SELECT name FROM instructor WHERE salary IS NULL`은 급여가 NULL인 모든 강사의 이름을 찾습니다. `IS NOT NULL` 술어는 적용된 값이 NULL이 아닐 때 성공합니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "집합 연산",
                    "level": 1
                  },
                  {
                    "type": "paragraph",
                    "content": "`UNION`, `INTERSECT`, `EXCEPT`와 같은 집합 연산이 있습니다. 이 연산들은 각각 자동으로 중복을 제거합니다. 모든 중복을 유지하려면 `ALL` 키워드를 사용합니다(예: `UNION ALL`, `INTERSECT ALL`, `EXCEPT ALL`). 참고로 `SELECT` 문은 기본적으로 모든 중복을 유지합니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "UNION",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "`UNION`은 두 쿼리의 결과를 결합합니다. 예를 들어, 2017년 가을 또는 2018년 봄에 개설된 강좌를 찾을 수 있습니다. (`SELECT course_id FROM teaches WHERE semester = 'Fall' AND year = 2017) UNION (SELECT course_id FROM teaches WHERE semester = 'Spring' AND year = 2018`).",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "INTERSECT",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "`INTERSECT`는 두 쿼리 결과의 공통 부분을 찾습니다. 예를 들어, 2017년 가을과 2018년 봄 모두에 개설된 강좌를 찾을 수 있습니다. MySQL은 `INTERSECT`를 직접 지원하지 않으므로, `JOIN`을 사용하여 에뮬레이션할 수 있습니다. (`SELECT LT.course_id FROM (SELECT course_id FROM teaches WHERE semester = 'Fall' AND year = 2017) AS LT JOIN (SELECT course_id FROM teaches WHERE semester = 'Spring' AND year = 2018) AS RT ON LT.course_id=RT.course_id;`)",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "EXCEPT",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "`EXCEPT`는 첫 번째 쿼리 결과에서 두 번째 쿼리 결과를 제외한 부분을 찾습니다. 예를 들어, 2017년 가을에 개설되었지만 2018년 봄에는 개설되지 않은 강좌를 찾을 수 있습니다. MySQL은 `EXCEPT`를 직접 지원하지 않으므로, `NOT IN`을 사용하여 에뮬레이션할 수 있습니다. (`SELECT course_id FROM teaches WHERE semester = 'Fall' AND year = 2017 AND course_id NOT IN(SELECT course_id FROM teaches WHERE semester = 'Spring' AND year = 2018);`)",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "문자열 연산",
                    "level": 1
                  },
                  {
                    "type": "paragraph",
                    "content": "SQL은 문자열 비교를 위한 문자열 일치 연산자를 포함합니다. `LIKE` 연산자는 두 가지 특수 문자를 사용하여 패턴을 설명합니다. 퍼센트(`%`) 문자는 모든 부분 문자열과 일치하고, 밑줄(`_`) 문자는 모든 단일 문자와 일치합니다. 예를 들어, `SELECT name FROM instructor WHERE name LIKE ‘%ri%'`는 이름에 \"ri\" 부분 문자열이 포함된 모든 강사의 이름을 찾습니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "이스케이프 문자(예: 백슬래시 `\\`)를 사용하여 특수 문자를 리터럴로 일치시킬 수 있습니다. 예를 들어, \"100%\" 문자열과 일치시키려면 `LIKE '100 \\%' ESCAPE '\\'`를 사용합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "패턴은 대소문자를 구분합니다. 패턴 일치 예시: 'Intro%'는 \"Intro\"로 시작하는 모든 문자열과 일치하고, '%Comp%'는 \"Comp\"를 포함하는 모든 문자열과 일치하며, '_ _ _'는 정확히 세 문자로 된 모든 문자열과 일치하고, '_ _ _ %'는 최소 세 문자로 된 모든 문자열과 일치합니다. SQL은 연결(`||`), 대소문자 변환, 문자열 길이 찾기, 부분 문자열 추출 등 다양한 문자열 연산을 지원합니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "튜플 표시 정렬",
                    "level": 1
                  },
                  {
                    "type": "paragraph",
                    "content": "`ORDER BY` 절을 사용하여 튜플의 표시 순서를 정렬할 수 있습니다. 예를 들어, 모든 강사의 이름을 알파벳 순서로 나열하려면 `SELECT DISTINCT name FROM instructor ORDER BY name`을 사용합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "여러 속성을 기준으로 정렬할 수 있습니다. 예를 들어, `SELECT dept_name, name FROM instructor ORDER BY dept_name, name`과 같이 부서 이름과 이름 순으로 정렬할 수 있습니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "각 속성에 대해 내림차순(`DESC`) 또는 오름차순(`ASC`)을 지정할 수 있으며, 오름차순이 기본값입니다. 예를 들어, `ORDER BY name DESC`는 이름을 내림차순으로 정렬합니다.",
                    "level": null
                  }
                ],
                "aiNotes": {
                  "summary": "이 문서는 SQL DML의 고급 기능을 다룹니다. NULL 값의 개념과 `IS NULL`, `IS NOT NULL`을 이용한 처리 방법을 설명합니다. 또한 `UNION`, `INTERSECT`, `EXCEPT`와 같은 집합 연산의 사용법과 `ALL` 키워드를 통한 중복 유지 방법, 그리고 MySQL에서의 에뮬레이션 방안을 제시합니다. 마지막으로 `LIKE` 연산자를 활용한 문자열 패턴 매칭과 `ORDER BY` 절을 이용한 결과 정렬 방법에 대해 자세히 설명합니다.",
                  "keyConcepts": [
                    {
                      "term": "NULL 값 처리",
                      "definition": "데이터베이스에서 알 수 없거나 존재하지 않는 값을 나타내는 NULL을 다루는 방법과 관련된 SQL 기능."
                    },
                    {
                      "term": "SQL 집합 연산",
                      "definition": "여러 쿼리 결과를 `UNION`, `INTERSECT`, `EXCEPT`를 사용하여 결합하거나 비교하는 기능."
                    },
                    {
                      "term": "문자열 패턴 매칭",
                      "definition": "`LIKE` 연산자와 `%`, `_` 특수 문자를 사용하여 문자열 내의 특정 패턴을 검색하는 방법."
                    },
                    {
                      "term": "결과 집합 정렬",
                      "definition": "`ORDER BY` 절을 사용하여 쿼리 결과 튜플의 표시 순서를 오름차순(`ASC`) 또는 내림차순(`DESC`)으로 지정하는 방법."
                    }
                  ],
                  "importantTerms": [
                    {
                      "term": "NULL",
                      "definition": "알 수 없거나 존재하지 않는 값."
                    },
                    {
                      "term": "IS NULL / IS NOT NULL",
                      "definition": "NULL 값을 확인하는 데 사용되는 술어."
                    },
                    {
                      "term": "UNION",
                      "definition": "두 쿼리 결과를 합치는 집합 연산자이며, 기본적으로 중복을 제거한다."
                    },
                    {
                      "term": "LIKE",
                      "definition": "문자열 패턴 매칭에 사용되는 연산자."
                    },
                    {
                      "term": "%",
                      "definition": "`LIKE` 연산자에서 임의의 부분 문자열과 일치하는 특수 문자."
                    },
                    {
                      "term": "_",
                      "definition": "`LIKE` 연산자에서 임의의 단일 문자와 일치하는 특수 문자."
                    },
                    {
                      "term": "ORDER BY",
                      "definition": "쿼리 결과의 정렬 순서를 지정하는 절."
                    }
                  ],
                  "outline": [
                    {
                      "text": "NULL 값",
                      "id": "null-값",
                      "children": [
                        {
                          "text": "NULL 값의 정의 및 특징",
                          "id": "null-값의-정의-및-특징",
                          "children": null
                        },
                        {
                          "text": "IS NULL / IS NOT NULL 술어",
                          "id": "is-null-is-not-null-술어",
                          "children": null
                        }
                      ]
                    },
                    {
                      "text": "집합 연산",
                      "id": "집합-연산",
                      "children": [
                        {
                          "text": "집합 연산의 종류 (UNION, INTERSECT, EXCEPT)",
                          "id": "집합-연산의-종류",
                          "children": null
                        },
                        {
                          "text": "중복 제거 및 ALL 키워드",
                          "id": "중복-제거-및-all-키워드",
                          "children": null
                        },
                        {
                          "text": "UNION 예시",
                          "id": "union-예시",
                          "children": null
                        },
                        {
                          "text": "INTERSECT 예시 및 MySQL 에뮬레이션",
                          "id": "intersect-예시-및-mysql-에뮬레이션",
                          "children": null
                        },
                        {
                          "text": "EXCEPT 예시 및 MySQL 에뮬레이션",
                          "id": "except-예시-및-mysql-에뮬레이션",
                          "children": null
                        }
                      ]
                    },
                    {
                      "text": "문자열 연산",
                      "id": "문자열-연산",
                      "children": [
                        {
                          "text": "LIKE 연산자 및 패턴 매칭 특수 문자 (%, _)",
                          "id": "like-연산자-및-패턴-매칭-특수-문자",
                          "children": null
                        },
                        {
                          "text": "이스케이프 문자",
                          "id": "이스케이프-문자",
                          "children": null
                        },
                        {
                          "text": "패턴 매칭 예시 및 특징 (대소문자 구분)",
                          "id": "패턴-매칭-예시-및-특징",
                          "children": null
                        },
                        {
                          "text": "기타 문자열 함수",
                          "id": "기타-문자열-함수",
                          "children": null
                        }
                      ]
                    },
                    {
                      "text": "튜플 표시 정렬",
                      "id": "튜플-표시-정렬",
                      "children": [
                        {
                          "text": "ORDER BY 절 기본 사용법",
                          "id": "order-by-절-기본-사용법",
                          "children": null
                        },
                        {
                          "text": "여러 속성으로 정렬",
                          "id": "여러-속성으로-정렬",
                          "children": null
                        },
                        {
                          "text": "오름차순 (ASC) 및 내림차순 (DESC) 지정",
                          "id": "오름차순-및-내림차순-지정",
                          "children": null
                        }
                      ]
                    }
                  ]
                },
                "quiz": [
                  {
                    "question": "SQL에서 NULL 값이 포함된 산술 연산의 결과는 무엇입니까?",
                    "options": [
                      "0",
                      "1",
                      "NULL",
                      "오류"
                    ],
                    "answerIndex": 2,
                    "explanation": "NULL이 포함된 산술 표현식의 결과는 항상 NULL입니다."
                  },
                  {
                    "question": "다음 중 두 쿼리 결과의 중복을 포함하여 합치는 SQL 집합 연산자는 무엇입니까?",
                    "options": [
                      "UNION",
                      "INTERSECT ALL",
                      "UNION ALL",
                      "EXCEPT"
                    ],
                    "answerIndex": 2,
                    "explanation": "`UNION`은 중복을 제거하지만, `UNION ALL`은 모든 중복을 유지하면서 두 쿼리 결과를 합칩니다."
                  },
                  {
                    "question": "`LIKE` 연산자에서 임의의 단일 문자와 일치하는 특수 문자는 무엇입니까?",
                    "options": [
                      "%",
                      "_",
                      "\\",
                      "?"
                    ],
                    "answerIndex": 1,
                    "explanation": "`%`는 임의의 부분 문자열과 일치하고, `_`는 임의의 단일 문자와 일치합니다."
                  }
                ]
              },
              {
                "title": "SQL DML: 집계 함수 및 데이터 수정 (INSERT, UPDATE, DELETE)",
                "metadata": "Source: cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf, Text length: 5040 chars",
                "documentContent": [
                  {
                    "type": "heading",
                    "content": "집계 함수 (Aggregate Functions)",
                    "level": 1
                  },
                  {
                    "type": "paragraph",
                    "content": "집계 함수는 릴레이션의 특정 컬럼 값들의 멀티셋에 대해 작동하며 단일 값을 반환합니다. 주요 집계 함수는 다음과 같습니다:",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **AVG**: 평균값",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **MIN**: 최솟값",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **MAX**: 최댓값",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **SUM**: 합계",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **COUNT**: 값의 개수",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "집계 함수 예시",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "집계 함수는 다양한 질의에 사용될 수 있습니다. 예를 들어, 컴퓨터 공학과 강사들의 평균 급여를 찾거나, 2018년 봄 학기에 강의를 가르친 강사의 총 수를 세거나, `teaches` 릴레이션의 튜플 수를 세는 데 활용됩니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **컴퓨터 공학과 강사들의 평균 급여 찾기:**",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "SELECT AVG(salary)\nFROM instructor\nWHERE dept_name= 'Comp. Sci.';",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **2018년 봄 학기에 강의를 가르친 강사의 총 수 찾기:**",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "SELECT COUNT(DISTINCT ID)\nFROM teaches\nWHERE semester = 'Spring’ AND year = 2018;",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **`teaches` 릴레이션의 튜플 수 찾기:**",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "SELECT COUNT (*)\nFROM teaches;",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "GROUP BY 절",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "`GROUP BY` 절은 특정 컬럼의 값을 기준으로 행들을 그룹으로 묶고, 각 그룹에 대해 집계 함수를 적용할 때 사용됩니다. 예를 들어, 각 부서의 강사 평균 급여를 찾을 수 있습니다.",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "SELECT dept_name, AVG(salary) AS avg_salary\nFROM instructor\nGROUP BY dept_name;",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "GROUP BY 규칙",
                    "level": 3
                  },
                  {
                    "type": "paragraph",
                    "content": "`SELECT` 절에 집계 함수 외에 사용된 모든 속성은 반드시 `GROUP BY` 목록에 포함되어야 합니다. 그렇지 않으면 오류가 발생합니다.",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "/* 오류가 발생하는 질의 */\nSELECT dept_name, ID, AVG(salary)\nFROM instructor\nGROUP BY dept_name;",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "HAVING 절",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "`HAVING` 절은 `GROUP BY` 절에 의해 생성된 그룹에 조건을 적용하여 결과를 필터링하는 데 사용됩니다. 예를 들어, 평균 급여가 65000을 초과하는 모든 부서의 이름과 평균 급여를 찾을 수 있습니다.",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "SELECT dept_name, AVG(salary) AS avg_salary\nFROM instructor\nGROUP BY dept_name\nHAVING AVG(salary) > 65000;",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "HAVING과 WHERE의 차이",
                    "level": 3
                  },
                  {
                    "type": "paragraph",
                    "content": "`HAVING` 절의 조건은 그룹이 형성된 **후**에 적용되는 반면, `WHERE` 절의 조건은 그룹을 형성하기 **전**에 적용됩니다. 이는 데이터 필터링 시점의 중요한 차이입니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "SQL DML 명령어",
                    "level": 1
                  },
                  {
                    "type": "paragraph",
                    "content": "SQL 데이터 조작 언어(DML)는 데이터베이스 내의 데이터를 검색, 삽입, 수정, 삭제하는 데 사용됩니다. 주요 DML 명령어는 `SELECT`, `INSERT`, `UPDATE`, `DELETE`입니다. 데이터 정의 언어(DDL)는 `CREATE`, `ALTER`, `DROP`과 같이 데이터베이스 스키마를 정의하고 관리하는 데 사용됩니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "INSERT (데이터 삽입)",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "`INSERT` 문은 테이블에 새로운 행(튜플)을 추가하는 데 사용됩니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "기본 문법",
                    "level": 3
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **모든 컬럼에 데이터 삽입:**",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "INSERT INTO tablename\nVALUES (col1_value, col2_value, …)",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "    *   값은 테이블 스키마와 동일한 순서로 나열되어야 합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "    *   알 수 없는 데이터 값은 `NULL`로 지정해야 합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "    *   문자열은 따옴표를 사용하며, 작은따옴표(')가 권장됩니다. 따옴표 안의 값은 대소문자를 구분합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **선택한 컬럼에 데이터 삽입:**",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "INSERT INTO tablename (col1_name, col3_name, col4_name, …)\nVALUES (col1_value, col3_value, col4_value, …)",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "INSERT 예시",
                    "level": 3
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **`course` 테이블에 새로운 튜플 추가:**",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "INSERT INTO course\nVALUES ('CS-437', 'Database Systems', 'Comp. Sci.', 4);",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "    또는 동일하게:",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "INSERT INTO course (course_id, title, dept_name, credits)\nVALUES ('CS-437', 'Database Systems', 'Comp. Sci.', 4);",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **`student` 테이블에 `tot_creds`가 NULL인 새로운 튜플 추가:**",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "INSERT INTO student\nVALUES ('3003', 'Green', 'Finance', null);",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "외래 키 제약 조건과 INSERT",
                    "level": 3
                  },
                  {
                    "type": "paragraph",
                    "content": "외래 키는 한 릴레이션의 속성이 다른 릴레이션의 튜플에 매핑되어야 함을 지정합니다. 즉, 한 릴레이션의 값이 다른 릴레이션에 존재해야 합니다. 새로운 행을 삽입할 때는 해당 행이 참조하는 모든 외래 키가 데이터베이스에 이미 추가되어 있는지 확인해야 합니다. 참조된 릴레이션에 해당 값이 존재하지 않으면 외래 키 값을 삽입할 수 없습니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "다른 SELECT 쿼리 결과 삽입",
                    "level": 3
                  },
                  {
                    "type": "paragraph",
                    "content": "`SELECT` 쿼리의 결과를 다른 테이블에 삽입할 수 있습니다. 이때 `SELECT FROM WHERE` 문은 그 결과가 릴레이션에 삽입되기 전에 완전히 평가됩니다. 이는 `INSERT INTO table1 SELECT * FROM table1`과 같은 질의에서 발생할 수 있는 문제를 방지합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **음악학과 학생 중 144학점 이상을 이수한 학생들을 $18,000 급여의 음악학과 강사로 추가:**",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "INSERT INTO instructor\n  SELECT ID, name, dept_name, 18000\n  FROM student\n  WHERE dept_name = 'Music’ AND total_cred > 144;",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "UPDATE (데이터 수정)",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "`UPDATE` 문은 테이블의 기존 데이터를 수정하는 데 사용됩니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "기본 문법",
                    "level": 3
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **테이블 업데이트 (조건 없음):** 모든 행의 지정된 컬럼을 수정합니다.",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "UPDATE tablename\nSET col1_name = new_col1_value, col2_name = new_col2_value, …;",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **조건 있는 테이블 업데이트:** `WHERE` 절의 조건과 일치하는 행만 수정합니다.",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "UPDATE tablename\nSET col1_name = new_col1_value, col2_name = new_col2_value, …\nWHERE predicate;",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "UPDATE 예시",
                    "level": 3
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **모든 강사의 급여를 5% 인상:**",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "UPDATE instructor\nSET salary = salary * 1.05",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **급여가 70000 미만인 강사의 급여를 5% 인상:**",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "UPDATE instructor\nSET salary = salary * 1.05\nWHERE salary < 70000;",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **급여가 평균 급여 미만인 강사의 급여를 5% 인상:**",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "UPDATE instructor\nSET salary = salary * 1.05\nWHERE salary <  (SELECT AVG(salary) FROM instructor);",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "CASE 문을 이용한 조건부 UPDATE",
                    "level": 3
                  },
                  {
                    "type": "paragraph",
                    "content": "여러 조건에 따라 다른 값을 적용해야 할 경우 `CASE` 문을 사용할 수 있습니다. 이는 여러 `UPDATE` 문을 사용하는 것보다 효율적이며, 실행 순서에 따른 문제를 방지할 수 있습니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **급여가 $100,000 초과인 강사는 3% 인상, 그 외는 5% 인상:**",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "UPDATE instructor\nSET salary = CASE\n                           WHEN salary <= 100000 THEN salary * 1.05\n                           ELSE salary * 1.03\n                       END",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "스칼라 서브쿼리를 이용한 UPDATE",
                    "level": 3
                  },
                  {
                    "type": "paragraph",
                    "content": "스칼라 서브쿼리(단일 값을 반환하는 서브쿼리)를 사용하여 컬럼 값을 업데이트할 수 있습니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **모든 학생의 `tot_creds` 값을 재계산하여 업데이트:**",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "UPDATE student S\nSET tot_cred = (SELECT SUM(credits)\n                             FROM takes, course\n                             WHERE takes.course_id = course.course_id  AND\n                                            S.ID= takes.ID  AND\n                                            takes.grade <> 'F' AND\n                                            takes.grade IS NOT NULL);",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "DELETE (데이터 삭제)",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "`DELETE` 문은 테이블에서 행을 제거하는 데 사용됩니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "기본 문법",
                    "level": 3
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **특정 행 제거:** `WHERE` 절의 조건과 일치하는 행을 제거합니다.",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "DELETE FROM tablename\nWHERE predicate;",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **모든 행 제거:** 테이블의 모든 행을 제거합니다.",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "DELETE FROM tablename;",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "TRUNCATE와의 비교",
                    "level": 3
                  },
                  {
                    "type": "paragraph",
                    "content": "`DELETE FROM tablename;`는 `TRUNCATE (TABLE) tablename;`와 기능적으로 유사하게 테이블의 모든 행을 제거합니다. 그러나 `TRUNCATE`는 외래 키 제약 조건이 있는 테이블에서는 사용할 수 없습니다. 외래 키 제약 조건이 있는 테이블을 `TRUNCATE`하려면 먼저 제약 조건을 비활성화해야 합니다.",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "ALTER TABLE tablename\nDISABLE CONSTRAINT constraint_name;",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "DELETE 예시",
                    "level": 3
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **모든 강사 삭제:**",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "DELETE FROM instructor;",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **재무학과 강사 모두 삭제:**",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "DELETE FROM instructor\nWHERE dept_name= 'Finance';",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **Watson 건물에 위치한 부서에 소속된 강사 모두 삭제:**",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "DELETE FROM instructor\nWHERE dept_name IN (SELECT dept_name\n        FROM department\n        WHERE building = 'Watson');",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "서브쿼리를 이용한 DELETE 시 주의사항",
                    "level": 3
                  },
                  {
                    "type": "paragraph",
                    "content": "서브쿼리를 사용하여 `DELETE` 작업을 수행할 때, 삭제되는 튜플이 서브쿼리의 결과에 영향을 미칠 수 있습니다. 예를 들어, 강사 평균 급여보다 낮은 급여를 가진 강사를 삭제하는 경우, 강사가 삭제됨에 따라 평균 급여가 변경될 수 있습니다.",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "DELETE FROM instructor\nWHERE salary < (SELECT AVG (salary) FROM instructor);",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "SQL에서는 이러한 문제를 해결하기 위해 다음과 같은 방식을 사용합니다. 먼저 `AVG(salary)`를 계산하고 삭제할 모든 튜플을 찾은 다음, 평균을 재계산하거나 튜플을 재확인하지 않고 찾아진 모든 튜플을 삭제합니다.",
                    "level": null
                  }
                ],
                "aiNotes": {
                  "summary": "이 문서는 SQL의 데이터 조작 언어(DML) 중 집계 함수와 데이터 수정 명령어(INSERT, UPDATE, DELETE)에 대해 설명합니다. 집계 함수의 종류(AVG, MIN, MAX, SUM, COUNT)와 사용 예시를 제시하며, GROUP BY 및 HAVING 절의 사용법과 WHERE 절과의 차이점을 강조합니다. 또한, INSERT 명령어를 이용한 데이터 삽입 방법, 외래 키 제약 조건과의 관계, 그리고 SELECT 쿼리 결과 삽입에 대해 다룹니다. UPDATE 명령어의 기본 문법, 다양한 조건부 업데이트 예시, 그리고 CASE 문 및 스칼라 서브쿼리 활용법을 설명합니다. 마지막으로 DELETE 명령어의 기본 문법, TRUNCATE와의 차이점, 외래 키 제약 조건, 그리고 서브쿼리를 사용한 삭제 시의 처리 방식에 대해 상세히 기술합니다.",
                  "keyConcepts": [
                    {
                      "term": "집계 함수 (Aggregate Functions)",
                      "definition": "릴레이션의 컬럼 값들의 멀티셋에 대해 작동하여 단일 값을 반환하는 함수 (예: AVG, MIN, MAX, SUM, COUNT)."
                    },
                    {
                      "term": "GROUP BY",
                      "definition": "SQL에서 특정 컬럼의 값을 기준으로 행들을 그룹으로 묶어 각 그룹에 대해 집계 함수를 적용할 수 있게 하는 절."
                    },
                    {
                      "term": "HAVING 절",
                      "definition": "GROUP BY 절에 의해 생성된 그룹에 조건을 적용하여 결과를 필터링하는 데 사용되는 절. WHERE 절과 달리 그룹화 후에 적용된다."
                    },
                    {
                      "term": "INSERT",
                      "definition": "SQL에서 테이블에 새로운 행(튜플)을 추가하는 데 사용되는 DML 명령어."
                    },
                    {
                      "term": "UPDATE",
                      "definition": "SQL에서 테이블의 기존 데이터를 수정하는 데 사용되는 DML 명령어."
                    },
                    {
                      "term": "DELETE",
                      "definition": "SQL에서 테이블의 행을 제거하는 데 사용되는 DML 명령어."
                    }
                  ],
                  "importantTerms": [
                    {
                      "term": "멀티셋 (Multiset)",
                      "definition": "중복된 값을 허용하는 집합."
                    },
                    {
                      "term": "튜플 (Tuple)",
                      "definition": "릴레이션(테이블)의 한 행을 의미한다."
                    },
                    {
                      "term": "외래 키 (Foreign Key)",
                      "definition": "한 릴레이션의 속성이 다른 릴레이션의 기본 키를 참조하여 두 릴레이션 간의 관계를 설정하는 제약 조건."
                    },
                    {
                      "term": "스칼라 서브쿼리 (Scalar Subquery)",
                      "definition": "단일 행, 단일 컬럼의 값을 반환하는 서브쿼리."
                    },
                    {
                      "term": "TRUNCATE",
                      "definition": "테이블의 모든 행을 빠르게 제거하는 DDL 명령어. DELETE와 달리 외래 키 제약 조건이 있는 테이블에는 직접 적용할 수 없다."
                    }
                  ],
                  "outline": [
                    {
                      "text": "집계 함수 (Aggregate Functions)",
                      "id": "집계-함수-aggregate-functions",
                      "children": [
                        {
                          "text": "집계 함수 예시",
                          "id": "집계-함수-예시",
                          "children": null
                        },
                        {
                          "text": "GROUP BY 절",
                          "id": "group-by-절",
                          "children": [
                            {
                              "text": "GROUP BY 규칙",
                              "id": "group-by-규칙",
                              "children": null
                            }
                          ]
                        },
                        {
                          "text": "HAVING 절",
                          "id": "having-절",
                          "children": [
                            {
                              "text": "HAVING과 WHERE의 차이",
                              "id": "having과-where의-차이",
                              "children": null
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "text": "SQL DML 명령어",
                      "id": "sql-dml-명령어",
                      "children": [
                        {
                          "text": "INSERT (데이터 삽입)",
                          "id": "insert-데이터-삽입",
                          "children": [
                            {
                              "text": "기본 문법",
                              "id": "기본-문법",
                              "children": null
                            },
                            {
                              "text": "INSERT 예시",
                              "id": "insert-예시",
                              "children": null
                            },
                            {
                              "text": "외래 키 제약 조건과 INSERT",
                              "id": "외래-키-제약-조건과-insert",
                              "children": null
                            },
                            {
                              "text": "다른 SELECT 쿼리 결과 삽입",
                              "id": "다른-select-쿼리-결과-삽입",
                              "children": null
                            }
                          ]
                        },
                        {
                          "text": "UPDATE (데이터 수정)",
                          "id": "update-데이터-수정",
                          "children": [
                            {
                              "text": "기본 문법",
                              "id": "기본-문법-1",
                              "children": null
                            },
                            {
                              "text": "UPDATE 예시",
                              "id": "update-예시",
                              "children": null
                            },
                            {
                              "text": "CASE 문을 이용한 조건부 UPDATE",
                              "id": "case-문을-이용한-조건부-update",
                              "children": null
                            },
                            {
                              "text": "스칼라 서브쿼리를 이용한 UPDATE",
                              "id": "스칼라-서브쿼리를-이용한-update",
                              "children": null
                            }
                          ]
                        },
                        {
                          "text": "DELETE (데이터 삭제)",
                          "id": "delete-데이터-삭제",
                          "children": [
                            {
                              "text": "기본 문법",
                              "id": "기본-문법-2",
                              "children": null
                            },
                            {
                              "text": "TRUNCATE와의 비교",
                              "id": "truncate와의-비교",
                              "children": null
                            },
                            {
                              "text": "DELETE 예시",
                              "id": "delete-예시",
                              "children": null
                            },
                            {
                              "text": "서브쿼리를 이용한 DELETE 시 주의사항",
                              "id": "서브쿼리를-이용한-delete-시-주의사항",
                              "children": null
                            }
                          ]
                        }
                      ]
                    }
                  ]
                },
                "quiz": [
                  {
                    "question": "다음 중 SQL의 `HAVING` 절에 대한 설명으로 올바른 것은 무엇입니까?",
                    "options": [
                      "그룹을 형성하기 전에 개별 행에 조건을 적용합니다.",
                      "집계 함수가 적용된 그룹에 조건을 적용합니다.",
                      "테이블에서 데이터를 삭제할 때 사용됩니다.",
                      "새로운 행을 테이블에 삽입할 때 사용됩니다."
                    ],
                    "answerIndex": 1,
                    "explanation": "`HAVING` 절은 `GROUP BY` 절에 의해 생성된 그룹에 조건을 적용하여 필터링하는 데 사용됩니다. `WHERE` 절과 달리 그룹화가 완료된 후에 적용됩니다."
                  },
                  {
                    "question": "SQL `INSERT` 문을 사용하여 새 행을 삽입할 때, 외래 키(Foreign Key) 제약 조건과 관련하여 반드시 지켜야 할 사항은 무엇입니까?",
                    "options": [
                      "외래 키 값은 항상 NULL로 설정되어야 합니다.",
                      "새로운 행의 외래 키 값이 참조하는 릴레이션에 이미 존재해야 합니다.",
                      "외래 키 값은 삽입 후 자동으로 생성됩니다.",
                      "외래 키 제약 조건은 `INSERT` 작업에 영향을 미치지 않습니다."
                    ],
                    "answerIndex": 1,
                    "explanation": "외래 키는 다른 릴레이션의 기본 키를 참조하므로, 새로운 행을 삽입할 때 해당 외래 키 값이 참조하는 릴레이션에 이미 존재해야 참조 무결성이 유지됩니다."
                  },
                  {
                    "question": "다음 SQL `UPDATE` 문 중, 급여가 $100,000 이하인 강사의 급여는 5% 인상하고, $100,000 초과인 강사의 급여는 3% 인상하는 올바른 방법은 무엇입니까?",
                    "options": [
                      "UPDATE instructor SET salary = salary * 1.05 WHERE salary <= 100000; UPDATE instructor SET salary = salary * 1.03 WHERE salary > 100000;",
                      "UPDATE instructor SET salary = CASE WHEN salary <= 100000 THEN salary * 1.05 ELSE salary * 1.03 END;",
                      "UPDATE instructor SET salary = salary * 1.03 OR salary * 1.05;",
                      "UPDATE instructor WHERE salary <= 100000 SET salary = salary * 1.05; ELSE SET salary = salary * 1.03;"
                    ],
                    "answerIndex": 1,
                    "explanation": "`CASE` 문은 여러 조건에 따라 다른 값을 적용할 때 사용되는 효율적인 방법입니다. 제시된 `CASE` 문은 주어진 조건에 따라 급여 인상률을 정확하게 적용합니다. 두 개의 `UPDATE` 문을 사용하는 첫 번째 옵션도 가능하지만, 순서에 따라 결과가 달라질 수 있고 `CASE` 문이 더 간결하고 안전한 방법입니다."
                  }
                ]
              }
            ],
            "final_result": ""
          }
        }
      ],
      "final_result": ""
    }
  },
  {
    "node": "finish_processing",
    "status": "completed",
    "state_snapshot": {
      "run_id": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d",
      "pdf_file_paths": [
        "temp_pdf_uploads/cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_1a4c2f45-b482-4e82-826e-fa8945eb99c7_DB03 - mysql.pdf",
        "temp_pdf_uploads/cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf"
      ],
      "all_pdf_texts": [
        {
          "filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_1a4c2f45-b482-4e82-826e-fa8945eb99c7_DB03 - mysql.pdf",
          "text": "ECE30030/ITP30010 Database SystemsHandshaking with an R-DBMSCharmgil Hongcharmgil@handong.eduSpring, 2025Handong Global University\n1\n\nAgenda•Introduction to MySQL•SQL preview\nECE30030/ITP30010 Database Systems2\nMySQL•MySQL is an SQL-based relational database management system (DBMS)•Free and open-source R-DBMS (under GPL)•Owned by Oracle•Commercial version of MySQL is also provided (including technical support)•“My” came from the name of co-founder Michael Widenius’ daughter•C.f., MariaDB•Compatible with standard SQL•Frequently used for commercial web services\nECE30030/ITP30010 Database Systems3\n* Image src: https://en.wikipedia.org/wiki/MySQL\nMySQL•Companies using MySQL (a study by Enlyft)•“We have data on 199,498 (out of 1,409,176) companies that use MySQL”•Often used by companies with 10-50 employees and 1M-10M dollars in revenue•C.f., Oracle 12 is most often used by companies with 50-200 employees and >1000M dollars in revenue\nECE30030/ITP30010 Database Systems4* Source: https://enlyft.com/tech/products/mysql \n\nMySQL•Companies using MySQL (full list: https://www.mysql.com/customers/)\nECE30030/ITP30010 Database Systems5\n* Source: https://stackshare.io/mysql \nMySQL•Why MySQL?•Popular•Active discussions all over the Internet•Versatile: runs on Linux, Windows, Mac OS X, Solaris, FreeBSD, …•Supports wide range of programming languages (C/C++, Java, Python, .Net, …)•Cost starts from zero•High performance (fast and reliable)\nECE30030/ITP30010 Database Systems6* Image src: https://db-engines.com/en/ranking\n\nDBMS Trend Popularity\n•Score definition: https://db-engines.com/en/ranking_definition\nECE30030/ITP30010 Database Systems7* Image src: https://db-engines.com/en/ranking_trend \n\nMySQL•Why MySQL?•Popular•Active discussions all over the Internet•Versatile: runs on Linux, Windows, Mac OS X, Solaris, FreeBSD, …•Supports wide range of programming languages (C/C++, Java, Python, .Net, …)•Cost starts from zero•High performance (fast and reliable)\nECE30030/ITP30010 Database Systems8* Image src: https://dev.mysql.com/downloads/\n\nMySQL\nECE30030/ITP30010 Database Systems9\n•Massive•Convenient•Multi-user•Safe•Efficient•Reliable\nCan handle terabytes of dataSupports high-level query languageSupports concurrent data accessSupports transactionsCan handle thousands of queries/second99.99% up-time in many real-world products\nMySQL Versions•MySQL 5.x vs 8.x\nECE30030/ITP30010 Database Systems10\nVersion 5.x-Most popular version of MySQL-More stable and conventionalVersion 8.x-Current version-Provides up-to-date DB functionalities (better storage engine, faster, more secure)\n* Source: https://www.eversql.com/mysql-8-adoption-usage-rate/#:~:text=MySQL%205.7%20is%20still%20the,17%25%20are%20using%20MySQL%208. \nMySQL Versions•MySQL 5.x vs 8.x\nECE30030/ITP30010 Database Systems11\nVersion 5.x-Most popular version of MySQL-More stable and conventionalVersion 8.x-Current version-Provides up-to-date DB functionalities (better storage engine, faster, more secure)\n* Source: https://severalnines.com/database-blog/mysql-performance-benchmarking-mysql-57-vs-mysql-80 \n\nMySQL Versions•MySQL 5.x vs 8.x\nECE30030/ITP30010 Database Systems12\nVersion 5.x-Most popular version of MySQL-More stable and conventionalVersion 8.x-Current version-Provides up-to-date DB functionalities (better storage engine, faster, more secure)\n* Source: https://severalnines.com/database-blog/mysql-performance-benchmarking-mysql-57-vs-mysql-80 \n\nWhere to Get MySQL?•https://dev.mysql.com/downloads/•Look for the “Community” versions – the branch that is available for free•”Enterprise” versions are the commercial ones•We have prepared a Docker image for the course•Consists of Ubuntu Server, MySQL, example databases for course activities\nECE30030/ITP30010 Database Systems13* Image src: https://www.docker.com \n\nWhere to Get MySQL?\nECE30030/ITP30010 Database Systems14\n* Image source: https://baumannalexj.medium.com/connect-your-db-tool-to-a-dockerized-mysql-server-container-bc18853524ed   https://www.jetbrains.com/datagrip/features/look_and_feel.html\n\nAgenda•Introduction to MySQL•SQL preview\nECE30030/ITP30010 Database Systems15\nStructured Query Language (SQL)•SQL: Structured Query Language•The principal language used to describe and manipulate relational databases•Very high-level•Say “what to do” rather than “how to do it”•SQL is not specifying data-manipulation details•DBMSs figure out the “best” way to execute queries•Called “query optimization”•Two aspects to SQL•Data definition: for declaring database schemas (DDL)•Data manipulation: for querying (asking questions about) databases and for modifying the database (DML)\nECE30030/ITP30010 Database Systems16\nSQL Parts•DML – provides the ability to query information from the database and to insert tuples into, delete tuples from, and modify tuples in the database•Integrity – the DDL includes commands for specifying integrity constraints•Vide definition – the DDL includes commands for defining views•Transaction control – includes commands for specifying the beginning and ending of transactions•Embedded SQL and dynamic SQL – define how SQL statements can be embedded within general-purpose programming language•Authorization – includes commands for specifying access rights to relations and viewsECE30030/ITP30010 Database Systems17\nA Brief History•IBM SEQUEL (Structured English Query Language) was developed as a part of the System R project (Chamberlin and Boyce, early 1970s)•Later on, SEQUEL was renamed SQL (structured query language)•System R à System/38 (1979), SQL/DS (1981), DB2 (1983)•Relational Software, Inc released the first commercial implementation of SQL, Oracle V2 for VAX computers•Relational Software, Inc is now Oracle Corporation•ANSI and ISO standardized SQL:•SQL-86,  SQL-89,  SQL-92,  SQL:1999,  …,  SQL:2011,  SQL:2016 (current)•SQL-92 is supported by the most of database systems\nECE30030/ITP30010 Database Systems18\nBasic Query Structure•A typical SQL query has the form:   SELECT A1, A2, ..., An FROM r1, r2, ..., rm WHERE P•Ai represents an attribute•Ri represents a relation•P is a predicate\n•The result of an SQL query is a relation\nECE30030/ITP30010 Database Systems19\nEOF•Coming next:•Structured Query Language\nECE30030/ITP30010 Database Systems20"
        },
        {
          "filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf",
          "text": "ECE30030/ITP30010 Database SystemsStructured Query LanguageReading: Chapter 3\nCharmgil Hongcharmgil@handong.eduSpring, 2025Handong Global University\n1\n\nAgenda•Structured query language (SQL)•SQL data manipulation language (DML)•SELECT, FROM, WHERE•NULL values•Set operations•String operations, ordering•Aggregate functions, aggregation•SQL data definition language (DDL)   --   NEXT CLASS\nECE30030/ITP30010 Database Systems2\nStructured Query Language (SQL)•SQL: Structured Query Language•The principal language used to describe and manipulate relational databases•Very high-level•Say “what to do” rather than “how to do it”•SQL is not specifying data-manipulation details•DBMSs figure out the “best” way to execute queries•Called “query optimization”•Two aspects to SQL•Data definition: for declaring database schemas (DDL)•Data manipulation: for querying (asking questions about) databases and for modifying the database (DML)\nECE30030/ITP30010 Database Systems3\nSQL Parts•DML – provides the ability to query information from the database and to insert tuples into, delete tuples from, and modify tuples in the database•Integrity – the DDL includes commands for specifying integrity constraints•View definition – the DDL includes commands for defining views•Transaction control – includes commands for specifying the beginning and ending of transactions•Embedded SQL and dynamic SQL – define how SQL statements can be embedded within general-purpose programming language•Authorization – includes commands for specifying access rights to relations and viewsECE30030/ITP30010 Database Systems4\nA Brief History•IBM SEQUEL (Structured English Query Language) was developed as a part of the System R project (Chamberlin and Boyce, early 1970s)•Later on, SEQUEL was renamed SQL (structured query language)•System R à System/38 (1979), SQL/DS (1981), DB2 (1983)•Relational Software, Inc released the first commercial implementation of SQL, Oracle V2 for VAX computers•Relational Software, Inc is now Oracle Corporation•ANSI and ISO standardized SQL:•SQL-86,  SQL-89,  SQL-92,  SQL:1999,  …,  SQL:2011,  SQL:2016 (current)•SQL-92 is supported by the most of database systems\nECE30030/ITP30010 Database Systems5\nBasic Query Structure•A typical SQL query has the form:   SELECT A1, A2, ..., An FROM r1, r2, ..., rm WHERE P•Ai represents an attribute•Ri represents a relation•P is a predicate\n•The result of an SQL query is a relation\nECE30030/ITP30010 Database Systems6\nAgenda•Structured query language (SQL)•SQL data manipulation language (DML)•SELECT, FROM, WHERE•NULL values•Set operations•String operations, ordering•Aggregate functions, aggregation•SQL data definition language (DDL)\nECE30030/ITP30010 Database Systems7\nSQL Data Manipulation Language•The SQL data-manipulation language (DML) allows querying (ask questions about) and modifying the databases\nECE30030/ITP30010 Database Systems8\nRunning Examples•Relations (tables): instructor, teaches\nECE30030/ITP30010 Database Systems9\nInstructor relationteaches relation\nBasic Query Structure•A typical SQL query has the form:   SELECT A1, A2, ..., An FROM r1, r2, ..., rm WHERE P•Ai represents an attribute•Ri represents a relation•P is a predicate\n•The result of an SQL query is a relation\nECE30030/ITP30010 Database Systems10\nThe SELECT Clause•The SELECT clause lists the attributes desired in the result of a query•Corresponds to the projection operation of the relational algebra\n•Example: Find the names of all instructors•SQL: SELECT name FROM instructor;\nECE30030/ITP30010 Database Systems11\n\nNote•Note: SQL names are case insensitive•E.g., Name ≡ NAME ≡ name•SQL commands (SELECT, FROM, WHERE, …) are written in upper case (just a convention)•MySQL has an option flag, lower_case_table_names•Link: https://dev.mysql.com/doc/refman/8.0/en/identifier-case-sensitivity.html \nECE30030/ITP30010 Database Systems12\nThe SELECT Clause•SQL allows duplicates in relations as well as in query results•The keyword ALL specifies that duplicates should not be removed SELECT ALL dept_name FROM instructor\nECE30030/ITP30010 Database Systems13\n\nThe SELECT Clause•SQL allows duplicates in relations as well as in query results•The keyword ALL specifies that duplicates should not be removed SELECT ALL dept_name FROM instructor•To force the elimination of duplicates, insert the keyword DISTINCT after SELECT•Find the department names of all instructor, removing duplicates: SELECT DISTINCT dept_name FROM instructor;\nECE30030/ITP30010 Database Systems14\n\nThe SELECT Clause•An asterisk in the select clause denotes “all attributes” SELECT * FROM instructor;•An attribute can be a literal with no FROM clause SELECT ‘437’;•Result is a table with one column and a single row with value “437”•Can give the column a name using AS: SELECT ‘437’ AS FOO\nECE30030/ITP30010 Database Systems15\n\nThe SELECT Clause•An attribute can be a literal with FROM clause SELECT 'A' FROM instructor•Result is a table with one column and N rows (number of tuples in the instructor table), each row with value “A”\nECE30030/ITP30010 Database Systems16\n\nThe SELECT Clause•The SELECT clause can contain arithmetic expressions involving the operation, +, –, *, and /, and operating on constants or attributes of tuples•The query:     SELECT ID, name, salary/12      FROM instructorwould return a relation that is the same as the instructor relation,except that the value of the attribute salary is divided by 12\n17\n\nThe SELECT Clause•The SELECT clause can contain arithmetic expressions involving the operation, +, –, *, and /, and operating on constants or attributes of tuples•Can rename “salary/12” using the AS clause:  SELECT ID, name, salary/12 AS monthly_salary   FROM instructor\n18\n\nThe WHERE Clause•The WHERE clause specifies conditions that the result must satisfy•Corresponds to the selection predicate of the relational algebra•E.g., To find all instructors in Comp. Sci. dept: SELECT name FROM instructor  WHERE dept_name = 'Comp. Sci.';\nECE30030/ITP30010 Database Systems19\n\nThe WHERE Clause•SQL allows the use of the logical connectives AND, OR, and NOT•The operands of the logical connectives can be expressions involving the comparison operators <, <=, >, >=, =, and <>•<> means not equal (there is no != in SQL)•Comparisons can be applied to results of arithmetic expressions•E.g., To find all instructors in Comp. Sci. with salary > 70,000: SELECT name FROM instructor WHERE dept_name = 'Comp. Sci.' AND salary > 70000;\nECE30030/ITP30010 Database Systems20\n\nThe WHERE Clause•SQL includes a BETWEEN comparison operator•Example: Find the names of all instructors with salary between $90,000 and $100,000 (that is, ³ $90,000 and £ $100,000)•SELECT nameFROM instructorWHERE salary BETWEEN 90000 AND 100000\nECE30030/ITP30010 Database Systems21\n\nThe WHERE Clause•Tuple comparison: makes comparisons per tuple•SELECT name, course_idFROM instructor, teachesWHERE (instructor.ID, dept_name) = (teaches.ID, 'Biology');\nECE30030/ITP30010 Database Systems22\n\nThe FROM Clause•The FROM clause lists the relations involved in the query•Corresponds to the Cartesian-product operation of the relational algebra•Find the Cartesian-product instructor × teaches SELECT * FROM instructor, teaches;•Generates every possible instructor-teaches pairs, with all attributes from both relations•For common attributes (e.g., ID), the attributes in the resulting table are renamed using the relation name (e.g., instructor.ID)\nECE30030/ITP30010 Database Systems23\nThe FROM Clause•Find the Cartesian-product instructor X teaches SELECT * FROM instructor, teaches;\n24\ninstructor.IDnamedept_namesalaryteaches.IDcourse_idsec_idsemesteryear10101SrinivasanComp. Sci.6500076766BIO-101 1Summer201712121WuFinance9000076766BIO-101 1Summer201715151MozartMusic4000076766BIO-101 1Summer201722222EinsteinPhysics9500076766BIO-101 1Summer201732343El SaidHistory6000076766BIO-101 1Summer2017… … … … … … … … …10101SrinivasanComp. Sci.6500010101CS-101 1Fall 201712121WuFinance9000010101CS-101 1Fall 201715151MozartMusic4000010101CS-101 1Fall 201722222EinsteinPhysics9500010101CS-101 1Fall 201732343El SaidHistory6000010101CS-101 1Fall 2017… … … … … … … … …… … … … … … … … …10101SrinivasanComp. Sci.6500083821CS-190 2Spring201712121WuFinance9000083821CS-190 2Spring201715151MozartMusic4000083821CS-190 2Spring2017… … … … … … … … …10101SrinivasanComp. Sci.6500010101CS-315 1Spring201812121WuFinance9000010101CS-315 1Spring201815151MozartMusic4000010101CS-315 1Spring2018… … … … … … … … …… … … … … … … … …\nImplementing JOIN•Cartesian-product is not very useful directly; but useful combined with WHERE-clause condition (selection operation in relational algebra)•Cartesian-product + selection = join•E.g., Find the names of all instructors who have taught some course and the course_id SELECT name, course_id FROM instructor , teaches WHERE instructor.ID = teaches.ID\nECE30030/ITP30010 Database Systems25\n\nImplementing JOIN•Cartesian-product is not very useful directly; but useful combined with WHERE-clause condition (selection operation in relational algebra)•Cartesian-product + selection = join•Find the names of all instructors in the Music department who have taught some course and the course_id SELECT name, course_id FROM instructor , teaches WHERE instructor.ID = teaches.ID  AND instructor. dept_name = 'Music'\nECE30030/ITP30010 Database Systems26\n\nThe Rename Operation•The SQL allows renaming relations and attributes using the AS clause:   old-name AS new-name•Find the names of all instructors who have a higher salary than some instructor in ‘Comp. Sci.’•SELECT DISTINCT T.nameFROM instructor AS T, instructor AS SWHERE T.salary > S.salary AND S.dept_name = 'Comp. Sci.'\nECE30030/ITP30010 Database Systems27\n\nThe Rename Operation•The SQL allows renaming relations and attributes using the AS clause:   old-name AS new-name•Find the names of all instructors who have a higher salary than some instructor in ‘Comp. Sci.’•SELECT DISTINCT T.nameFROM instructor AS T, instructor AS SWHERE T.salary > S.salary AND S.dept_name = 'Comp. Sci.'•Keyword AS is optional and may be omitted  instructor AS T  ≡  instructor T\nECE30030/ITP30010 Database Systems28\nAgenda•Structured query language (SQL)•SQL data manipulation language (DML)•SELECT, FROM, WHERE•NULL values•Set operations•String operations, ordering•Aggregate functions, aggregation•SQL data definition language (DDL)\nECE30030/ITP30010 Database Systems29\nNULL Values•It is possible for tuples to have a NULL value for some of their attributes•NULL signifies an unknown value or that a value does not exist•The result of any arithmetic expression involving NULL is NULL•E.g.,  5 + NULL returns NULL\nECE30030/ITP30010 Database Systems30\nIS NULL / IS NOT NULL•The predicate IS NULL can be used to check for NULL values•E.g., Find all instructors whose salary is null SELECT name FROM instructor WHERE salary IS NULL•The predicate IS NOT NULL succeeds if the value on which it is applied is not null\nECE30030/ITP30010 Database Systems31\nAgenda•Structured query language (SQL)•SQL data manipulation language (DML)•SELECT, FROM, WHERE•NULL values•Set operations•String operations, ordering•Aggregate functions, aggregation•SQL data definition language (DDL)\nECE30030/ITP30010 Database Systems32\nSet Operations•Set operations UNION, INTERSECT, and EXCEPT•Each of the above operations automatically eliminates duplicates•To retain all duplicates, use ALL:•UNION ALL•INTERSECT ALL•EXCEPT ALL\n•C.f., SELECT retains all duplicates by default\nECE30030/ITP30010 Database Systems33\nSet Operations: UNION•Find courses that ran in Fall 2017 or in Spring 2018•(SELECT course_id  FROM teaches WHERE semester = 'Fall' AND year = 2017)UNION(SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018)\nECE30030/ITP30010 Database Systems34\n\nSet Operations: INTERSECT•Find courses that ran in Fall 2017 and in Spring 2018•(SELECT course_id  FROM teaches WHERE semester = 'Fall' AND year = 2017)INTERSECT(SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018)•C.f., MySQL does NOT support INTERSECT•One can emulate INTERSECT using JOIN (we’ll study JOIN later)•SELECT LT.course_idFROM (SELECT course_id FROM teaches WHERE semester = 'Fall' AND year = 2017) AS LTJOIN (SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018) AS RTON LT.course_id=RT.course_id;\nECE30030/ITP30010 Database Systems35\n\nSet Operations: EXCEPT•Find courses that ran in Fall 2017 but not in Spring 2018•(SELECT course_id  FROM teaches WHERE semester = 'Fall' AND year = 2017)EXCEPT(SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018)•C.f., MySQL does NOT support EXCEPT•One can emulate EXCEPT using NOT IN•SELECT course_id FROM teaches WHERE semester = 'Fall' AND year = 2017AND course_id NOT IN(SELECT course_id  FROM teaches  WHERE semester = 'Spring' AND year = 2018);\nECE30030/ITP30010 Database Systems36\n\nAgenda•Structured query language (SQL)•SQL data manipulation language (DML)•SELECT, FROM, WHERE•NULL values•Set operations•String operations, ordering•Aggregate functions, aggregation•SQL data definition language (DDL)\nECE30030/ITP30010 Database Systems37\nString Operations•SQL includes a string-matching operator for comparisons on character strings•The operator LIKE uses patterns that are described using two special characters:•percent (%) – The % character matches any substring•underscore (_) – The _ character matches any character•Find the names of all instructors whose name includes the substring “ri” SELECT name FROM instructor WHERE name LIKE ‘%ri%'\nECE30030/ITP30010 Database Systems38\n\nString Operations•Escape character: Use backslash (\\) as the escape character•E.g., Match the string “100%” LIKE '100 \\%’ ESCAPE  ‘\\’\nECE30030/ITP30010 Database Systems39\nString Operations•Patterns are case sensitive•Pattern matching examples:•'Intro%' matches any string beginning with “Intro”•'%Comp%' matches any string containing “Comp” as a substring•'_ _ _' matches any string of exactly three characters•'_ _ _ %' matches any string of at least three characters•SQL supports a variety of string operations such as•concatenation (using “||”)•converting from upper to lower case (and vice versa)•finding string length, extracting substrings, etc.\nECE30030/ITP30010 Database Systems40\nOrdering the Display of Tuples•List in alphabetic order the names of all instructors•SELECT DISTINCT nameFROM instructorORDER BY name\nECE30030/ITP30010 Database Systems41\n\nOrdering the Display of Tuples•Can sort on multiple attributes•E.g., SELECT dept_name, name     FROM instructor      ORDER BY dept_name, name\nECE30030/ITP30010 Database Systems42\n\nOrdering the Display of Tuples•We may specify DESC for descending order or ASC for ascending order, for each attribute; ascending order is the default•E.g., ORDER BY name DESC\nECE30030/ITP30010 Database Systems43\n\nAgenda•Structured query language (SQL)•SQL data manipulation language (DML)•SELECT, FROM, WHERE•NULL values•Set operations•String operations, ordering•Aggregate functions, aggregation•SQL data definition language (DDL)\nECE30030/ITP30010 Database Systems44\nAggregate Functions•These functions operate on the multiset of values of a column of a relation, and return a value•AVG:  average value•MIN:  minimum value•MAX:  maximum value•SUM:  sum of values•COUNT:  number of values\nECE30030/ITP30010 Database Systems45\nAggregate Functions Examples•Find the average salary of instructors in the Computer Science department•SELECT AVG(salary)FROM instructorWHERE dept_name= 'Comp. Sci.';•Find the total number of instructors who teach a course in the Spring 2018 semester•SELECT COUNT(DISTINCT ID)FROM teachesWHERE semester = 'Spring’ AND year = 2018;•Find the number of tuples in the teaches relation•SELECT COUNT (*)FROM teaches;\nECE30030/ITP30010 Database Systems46\n\nAggregate Functions: Group By•Find the average salary of instructors in each department•SELECT dept_name, AVG(salary) AS avg_salaryFROM instructorGROUP BY dept_name;\nECE30030/ITP30010 Database Systems47\n\nAggregation•Attributes in SELECT clause outside of aggregate functions must appear in GROUP BY list•/* erroneous query */SELECT dept_name, ID, AVG(salary)FROM instructorGROUP BY dept_name;\nECE30030/ITP30010 Database Systems48\n\nAggregate Functions – Having Clause•Find the names and average salaries of all departments whose average salary is greater than 65000•SELECT dept_name, AVG(salary) AS avg_salaryFROM instructorGROUP BY dept_nameHAVING AVG(salary) > 65000;\nECE30030/ITP30010 Database Systems49\n\nAggregate Functions – Having Clause•Note: predicates in the HAVING clause are applied after the formation of groups whereas predicates in the WHERE clause are applied before forming groups\nECE30030/ITP30010 Database Systems50\nSELECT dept_name, AVG(salary) AS avg_salaryFROM instructorGROUP BY dept_nameHAVING AVG(salary) > 65000;\nSELECT dept_name, AVG(salary) AS avg_salaryFROM instructorWHERE salary > 65000GROUP BY dept_name;\n\nSQL Commands\nSQLDMLSELECTINSERTUPDATEDELETE\nDDLCREATEALTERDROP\nECE30030/ITP30010 Database Systems51\nINSERT•Basic syntax•Insert data into every column:•INSERT INTO tablenameVALUES (col1_value, col2_value, …)•Must list values in the same order as in the table schema•If some data values are unknown, must type NULL •For character sequences, use quotation marks•Single quotation marks are preferred (but double quotation marks are allowed)•Value in quotations is case-sensitive•Insert data into selected columns•INSERT INTO tablename (col1_name, col3_name, col4_name, …)VALUES (col1_value, col3_value, col4_value, …)\nECE30030/ITP30010 Database Systems52\nINSERT•Add a new tuple to course•INSERT INTO courseVALUES ('CS-437', 'Database Systems', 'Comp. Sci.', 4);•or equivalently•INSERT INTO course (course_id, title, dept_name, credits)VALUES ('CS-437', 'Database Systems', 'Comp. Sci.', 4);•Add a new tuple to student  with tot_creds set to null•INSERT INTO studentVALUES ('3003', 'Green', 'Finance', null);\nECE30030/ITP30010 Database Systems53\nINSERT•A foreign key specifies that an attribute from one relation has to map to a tuple in another relation•Value in one relation must appear in another relation\nECE30030/ITP30010 Database Systems54\nRelation: instructor\nRelation: department\nINSERT•A foreign key specifies that an attribute from one relation has to map to a tuple in another relation•Value in one relation must appear in another relation•Make sure all foreign keys that new row references have already been added to database•One cannot insert a foreign key value unless the corresponding value exists in the referenced relation\nECE30030/ITP30010 Database Systems55\nINSERT•Inserting results of other SELECT query•Make each student in the Music department who has earned more than 144 credit hours an instructor in the Music department with a salary of  $18,000•INSERT INTO instructor  SELECT ID, name, dept_name, 18000  FROM student   WHERE dept_name = 'Music’ AND total_cred > 144;•The SELECT FROM WHERE statement is evaluated fully before any of its results are inserted into the relation•Otherwise queries like  INSERT INTO table1 SELECT * FROM table1would cause problem\nECE30030/ITP30010 Database Systems56\nUPDATE•Basic syntax•Updating a table•UPDATE tablenameSET col1_name = new_col1_value, col2_name = new_col2_value, …;•Updating a table with conditions•UPDATE tablenameSET col1_name = new_col1_value, col2_name = new_col2_value, …WHERE predicate;\nECE30030/ITP30010 Database Systems57\nUPDATE•Give a 5% salary raise to all instructors•UPDATE instructorSET salary = salary * 1.05•Give a 5% salary raise to those instructors who earn less than 70000•UPDATE instructorSET salary = salary * 1.05WHERE salary < 70000;•Give a 5% salary raise to instructors whose salary is less than average•UPDATE instructorSET salary = salary * 1.05WHERE salary <  (SELECT AVG(salary) FROM instructor);\nECE30030/ITP30010 Database Systems58\nUPDATE•Increase salaries of instructors whose salary is over $100,000 by 3%, and all others by a 5%•Write two UPDATE statements:  UPDATE instructor  SET salary = salary * 1.03  WHERE salary > 100000;  UPDATE instructor  SET salary = salary * 1.05  WHERE salary <= 100000;•The order is important•Can be done better using the case statement (next slide)\nECE30030/ITP30010 Database Systems59\nCASE Statement for Conditional Update•The following query is equivalent to the previous UPDATE queries•UPDATE instructorSET salary = CASE                           WHEN salary <= 100000 THEN salary * 1.05                           ELSE salary * 1.03                       END\nECE30030/ITP30010 Database Systems60\nUPDATE with Scalar Subqueries•Recompute and update tot_creds value for all students•UPDATE student SSET tot_cred = (SELECT SUM(credits)                             FROM takes, course                             WHERE takes.course_id = course.course_id  AND                                            S.ID= takes.ID  AND                                            takes.grade <> 'F' AND                                            takes.grade IS NOT NULL);\nECE30030/ITP30010 Database Systems61\nDELETE•Basic syntax•To remove specific rows•DELETE FROM tablenameWHERE predicate;•To remove all rows•DELETE FROM tablename;•This is equivalent to TRUNCATE:TRUNCATE (TABLE) tablename;•One cannot truncate a table with foreign key constraints•Must disable the constraints first (we will cover ALTER when we study SQL DDL):ALTER TABLE tablenameDISABLE CONSTRAINT constraint_name;\nECE30030/ITP30010 Database Systems62\nDELETE•Delete all instructors•DELETE FROM instructor;•Delete all instructors from the Finance department•DELETE FROM instructorWHERE dept_name= 'Finance';•Delete all tuples in the instructor relation for those instructors associated with a department located in the Watson building•DELETE FROM instructorWHERE dept name IN (SELECT dept name        FROM department        WHERE building = 'Watson');\nECE30030/ITP30010 Database Systems63\nDELETE•Delete all instructors whose salary is less than the average salary of instructors•Example:  DELETE FROM instructor                WHERE salary < (SELECT AVG (salary)                  FROM instructor);•Issue:  as we delete tuples from instructor, the average salary changes•Solution used in SQL:1.First, compute AVG(salary) and find all tuples to delete2.Next, delete all tuples found above (without recomputing AVG or retesting the tuples)\nECE30030/ITP30010 Database Systems64\nEOF•Coming next:•More on Structured Query Language\nECE30030/ITP30010 Database Systems65"
        }
      ],
      "notebook_title": "관계형 데이터베이스 시스템: MySQL 소개 및 SQL 심층 활용",
      "holistic_chapters": [
        {
          "chapter_title": "관계형 데이터베이스 시스템(R-DBMS) 개요 및 MySQL 소개",
          "source_pdf_filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_1a4c2f45-b482-4e82-826e-fa8945eb99c7_DB03 - mysql.pdf",
          "chapter_content_summary": "이 장에서는 관계형 데이터베이스 관리 시스템(R-DBMS)의 기본 개념을 소개하고, 대표적인 오픈소스 R-DBMS인 MySQL에 대해 심층적으로 다룹니다. MySQL의 정의, Oracle 소유권, 표준 SQL 호환성, 상업적 웹 서비스에서의 활용 사례, 기업 사용 통계, 그리고 MySQL의 인기 요인(다양한 운영체제 및 프로그래밍 언어 지원, 비용 효율성, 고성능)을 설명합니다. 또한, R-DBMS 시장에서의 MySQL의 트렌드와 인기도를 살펴보고, MySQL 5.x와 8.x 버전의 주요 차이점 및 MySQL 커뮤니티 버전을 다운로드하고 Docker 이미지를 활용하는 방법을 안내합니다. MySQL이 대규모 데이터 처리, 다중 사용자 지원, 효율성, 안정성, 보안성 측면에서 갖는 강점들을 강조합니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database SystemsHandshaking with an R-DBMSCharmgil Hongcharmgil@handong.eduSpring, 2025Handong Global University\n1\nAgenda•Introduction to MySQL•SQL preview\nECE30030/ITP30010 Database Systems2\nMySQL•MySQL is an SQL-based relational database management system (DBMS)•Free and open-source R-DBMS (under GPL)•Owned by Oracle•Commercial version of MySQL is also provided (including technical support)•“My” came from the name of co-founder Michael Widenius’ daughter•C.f., MariaDB•Compatible with standard SQL•Frequently used for commercial web services\nECE30030/ITP30010 Database Systems3\n* Image src: https://en.wikipedia.org/wiki/MySQL\nMySQL•Companies using MySQL (a study by Enlyft)•“We have data on 199,498 (out of 1,409,176) companies that use MySQL”•Often used by companies with 10-50 employees and 1M-10M dollars in revenue•C.f., Oracle 12 is most often used by companies with 50-200 employees and >1000M dollars in revenue\nECE30030/ITP30010 Database Systems4* Source: https://enlyft.com/tech/products/mysql \nMySQL•Companies using MySQL (full list: https://www.mysql.com/customers/)\nECE30030/ITP30010 Database Systems5\n* Source: https://stackshare.io/mysql \nMySQL•Why MySQL?•Popular•Active discussions all over the Internet•Versatile: runs on Linux, Windows, Mac OS X, Solaris, FreeBSD, …•Supports wide range of programming languages (C/C++, Java, Python, .Net, …)•Cost starts from zero•High performance (fast and reliable)\nECE30030/ITP30010 Database Systems6* Image src: https://db-engines.com/en/ranking\nDBMS Trend Popularity\n•Score definition: https://db-engines.com/en/ranking_definition\nECE30030/ITP30010 Database Systems7* Image src: https://db-engines.com/en/ranking_trend \nMySQL•Why MySQL?•Popular•Active discussions all over the Internet•Versatile: runs on Linux, Windows, Mac OS X, Solaris, FreeBSD, …•Supports wide range of programming languages (C/C++, Java, Python, .Net, …)•Cost starts from zero•High performance (fast and reliable)\nECE30030/ITP30010 Database Systems8* Image src: https://dev.mysql.com/downloads/\nMySQL\nECE30030/ITP30010 Database Systems9\n•Massive•Convenient•Multi-user•Safe•Efficient•Reliable\nCan handle terabytes of dataSupports high-level query languageSupports concurrent data accessSupports transactionsCan handle thousands of queries/second99.99% up-time in many real-world products\nMySQL Versions•MySQL 5.x vs 8.x\nECE30030/ITP30010 Database Systems10\nVersion 5.x-Most popular version of MySQL-More stable and conventionalVersion 8.x-Current version-Provides up-to-date DB functionalities (better storage engine, faster, more secure)\n* Source: https://www.eversql.com/mysql-8-adoption-usage-rate/#:~:text=MySQL%205.7%20is%20still%20the,17%25%20are%20using%20MySQL%208. \nMySQL Versions•MySQL 5.x vs 8.x\nECE30030/ITP30010 Database Systems11\nVersion 5.x-Most popular version of MySQL-More stable and conventionalVersion 8.x-Current version-Provides up-to-date DB functionalities (better storage engine, faster, more secure)\n* Source: https://severalnines.com/database-blog/mysql-performance-benchmarking-mysql-57-vs-mysql-80 \nMySQL Versions•MySQL 5.x vs 8.x\nECE30030/ITP30010 Database Systems12\nVersion 5.x-Most popular version of MySQL-More stable and conventionalVersion 8.x-Current version-Provides up-to-date DB functionalities (better storage engine, faster, more secure)\n* Source: https://severalnines.com/database-blog/mysql-performance-benchmarking-mysql-57-vs-mysql-80 \nWhere to Get MySQL?•https://dev.mysql.com/downloads/•Look for the “Community” versions – the branch that is available for free•”Enterprise” versions are the commercial ones•We have prepared a Docker image for the course•Consists of Ubuntu Server, MySQL, example databases for course activities\nECE30030/ITP30010 Database Systems13* Image src: https://www.docker.com \nWhere to Get MySQL?\nECE30030/ITP30010 Database Systems14\n* Image source: https://baumannalexj.medium.com/connect-your-db-tool-to-a-dockerized-mysql-server-container-bc18853524ed   https://www.jetbrains.com/datagrip/features/look_and_feel.html"
        },
        {
          "chapter_title": "SQL(구조적 질의어)의 이해: 기본 개념과 역사",
          "source_pdf_filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf",
          "chapter_content_summary": "SQL(Structured Query Language)의 정의와 관계형 데이터베이스를 조작하는 주된 언어로서의 역할을 설명합니다. SQL이 '무엇을 할지'를 명시하는 고수준 언어이며, DBMS가 '어떻게 할지'를 결정하는 쿼리 최적화 과정을 다룹니다. 또한, SQL의 두 가지 주요 측면인 데이터 정의 언어(DDL)와 데이터 조작 언어(DML)를 소개하고, 무결성, 뷰 정의, 트랜잭션 제어, 내장 SQL 및 동적 SQL, 권한 부여와 같은 SQL의 다양한 구성 요소를 살펴봅니다. 마지막으로, IBM SEQUEL에서 시작하여 Oracle V2를 거쳐 ANSI 및 ISO 표준으로 발전한 SQL의 간략한 역사를 소개하고, 기본적인 SQL 쿼리 구조(SELECT, FROM, WHERE)를 설명합니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database SystemsStructured Query LanguageReading: Chapter 3\nCharmgil Hongcharmgil@handong.eduSpring, 2025Handong Global University\n1\nAgenda•Structured query language (SQL)•SQL data manipulation language (DML)•SELECT, FROM, WHERE•NULL values•Set operations•String operations, ordering•Aggregate functions, aggregation•SQL data definition language (DDL)   --   NEXT CLASS\nECE30030/ITP30010 Database Systems2\nStructured Query Language (SQL)•SQL: Structured Query Language•The principal language used to describe and manipulate relational databases•Very high-level•Say “what to do” rather than “how to do it”•SQL is not specifying data-manipulation details•DBMSs figure out the “best” way to execute queries•Called “query optimization”•Two aspects to SQL•Data definition: for declaring database schemas (DDL)•Data manipulation: for querying (asking questions about) databases and for modifying the database (DML)\nECE30030/ITP30010 Database Systems3\nSQL Parts•DML – provides the ability to query information from the database and to insert tuples into, delete tuples from, and modify tuples in the database•Integrity – the DDL includes commands for specifying integrity constraints•View definition – the DDL includes commands for defining views•Transaction control – includes commands for specifying the beginning and ending of transactions•Embedded SQL and dynamic SQL – define how SQL statements can be embedded within general-purpose programming language•Authorization – includes commands for specifying access rights to relations and viewsECE30030/ITP30010 Database Systems4\nA Brief History•IBM SEQUEL (Structured English Query Language) was developed as a part of the System R project (Chamberlin and Boyce, early 1970s)•Later on, SEQUEL was renamed SQL (structured query language)•System R à System/38 (1979), SQL/DS (1981), DB2 (1983)•Relational Software, Inc released the first commercial implementation of SQL, Oracle V2 for VAX computers•Relational Software, Inc is now Oracle Corporation•ANSI and ISO standardized SQL:•SQL-86,  SQL-89,  SQL-92,  SQL:1999,  …,  SQL:2011,  SQL:2016 (current)•SQL-92 is supported by the most of database systems\nECE30030/ITP30010 Database Systems5\nBasic Query Structure•A typical SQL query has the form:   SELECT A1, A2, ..., An FROM r1, r2, ..., rm WHERE P•Ai represents an attribute•Ri represents a relation•P is a predicate\n•The result of an SQL query is a relation\nECE30030/ITP30010 Database Systems6"
        },
        {
          "chapter_title": "SQL 데이터 조작 언어(DML) 기초: SELECT, FROM, WHERE 절",
          "source_pdf_filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf",
          "chapter_content_summary": "이 장에서는 SQL 데이터 조작 언어(DML)의 핵심 구성 요소인 SELECT, FROM, WHERE 절을 상세히 다룹니다. 'instructor' 및 'teaches'와 같은 예시 관계(테이블)를 사용하여 실제 쿼리 작성 방법을 시연합니다. SELECT 절을 통해 원하는 속성을 선택하고, 중복을 포함하거나 제거하는 방법(ALL, DISTINCT), 모든 속성을 선택하는 '*' 사용법, 리터럴 및 산술 표현식 활용, 그리고 AS 키워드를 사용한 속성 이름 변경 방법을 학습합니다. WHERE 절에서는 논리 연산자(AND, OR, NOT) 및 비교 연산자(<, <=, >, >=, =, <>, BETWEEN)를 사용하여 조건을 지정하고, 튜플 비교를 수행하는 방법을 설명합니다. 마지막으로 FROM 절을 통해 쿼리에 포함될 관계를 지정하고, 카르테시안 곱을 이해하며, WHERE 절과 결합하여 JOIN 연산을 구현하는 방법을 구체적인 예시와 함께 제시합니다. 또한, AS 키워드를 이용한 관계 및 속성 이름 변경(별칭 지정)을 다룹니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems7\nSQL Data Manipulation Language•The SQL data-manipulation language (DML) allows querying (ask questions about) and modifying the databases\nECE30030/ITP30010 Database Systems8\nRunning Examples•Relations (tables): instructor, teaches\nECE30030/ITP30010 Database Systems9\nInstructor relationteaches relation\nBasic Query Structure•A typical SQL query has the form:   SELECT A1, A2, ..., An FROM r1, r2, ..., rm WHERE P•Ai represents an attribute•Ri represents a relation•P is a predicate\n•The result of an SQL query is a relation\nECE30030/ITP30010 Database Systems10\nThe SELECT Clause•The SELECT clause lists the attributes desired in the result of a query•Corresponds to the projection operation of the relational algebra\n•Example: Find the names of all instructors•SQL: SELECT name FROM instructor;\nECE30030/ITP30010 Database Systems11\nNote•Note: SQL names are case insensitive•E.g., Name ≡ NAME ≡ name•SQL commands (SELECT, FROM, WHERE, …) are written in upper case (just a convention)•MySQL has an option flag, lower_case_table_names•Link: https://dev.mysql.com/doc/refman/8.0/en/identifier-case-sensitivity.html \nECE30030/ITP30010 Database Systems12\nThe SELECT Clause•SQL allows duplicates in relations as well as in query results•The keyword ALL specifies that duplicates should not be removed SELECT ALL dept_name FROM instructor\nECE30030/ITP30010 Database Systems13\nThe SELECT Clause•SQL allows duplicates in relations as well as in query results•The keyword ALL specifies that duplicates should not be removed SELECT ALL dept_name FROM instructor•To force the elimination of duplicates, insert the keyword DISTINCT after SELECT•Find the department names of all instructor, removing duplicates: SELECT DISTINCT dept_name FROM instructor;\nECE30030/ITP30010 Database Systems14\nThe SELECT Clause•An asterisk in the select clause denotes “all attributes” SELECT * FROM instructor;•An attribute can be a literal with no FROM clause SELECT ‘437’;•Result is a table with one column and a single row with value “437”•Can give the column a name using AS: SELECT ‘437’ AS FOO\nECE30030/ITP30010 Database Systems15\nThe SELECT Clause•An attribute can be a literal with FROM clause SELECT 'A' FROM instructor•Result is a table with one column and N rows (number of tuples in the instructor table), each row with value “A”\nECE30030/ITP30010 Database Systems16\nThe SELECT Clause•The SELECT clause can contain arithmetic expressions involving the operation, +, –, *, and /, and operating on constants or attributes of tuples•The query:     SELECT ID, name, salary/12      FROM instructorwould return a relation that is the same as the instructor relation,except that the value of the attribute salary is divided by 12\n17\nThe SELECT Clause•The SELECT clause can contain arithmetic expressions involving the operation, +, –, *, and /, and operating on constants or attributes of tuples•Can rename “salary/12” using the AS clause:  SELECT ID, name, salary/12 AS monthly_salary   FROM instructor\n18\nThe WHERE Clause•The WHERE clause specifies conditions that the result must satisfy•Corresponds to the selection predicate of the relational algebra•E.g., To find all instructors in Comp. Sci. dept: SELECT name FROM instructor  WHERE dept_name = 'Comp. Sci.';\nECE30030/ITP30010 Database Systems19\nThe WHERE Clause•SQL allows the use of the logical connectives AND, OR, and NOT•The operands of the logical connectives can be expressions involving the comparison operators <, <=, >, >=, =, and <>•<> means not equal (there is no != in SQL)•Comparisons can be applied to results of arithmetic expressions•E.g., To find all instructors in Comp. Sci. with salary > 70,000: SELECT name FROM instructor WHERE dept_name = 'Comp. Sci.' AND salary > 70000;\nECE30030/ITP30010 Database Systems20\nThe WHERE Clause•SQL includes a BETWEEN comparison operator•Example: Find the names of all instructors with salary between $90,000 and $100,000 (that is, ³ $90,000 and £ $100,000)•SELECT nameFROM instructorWHERE salary BETWEEN 90000 AND 100000\nECE30030/ITP30010 Database Systems21\nThe WHERE Clause•Tuple comparison: makes comparisons per tuple•SELECT name, course_idFROM instructor, teachesWHERE (instructor.ID, dept_name) = (teaches.ID, 'Biology');\nECE30030/ITP30010 Database Systems22\nThe FROM Clause•The FROM clause lists the relations involved in the query•Corresponds to the Cartesian-product operation of the relational algebra•Find the Cartesian-product instructor × teaches SELECT * FROM instructor, teaches;•Generates every possible instructor-teaches pairs, with all attributes from both relations•For common attributes (e.g., ID), the attributes in the resulting table are renamed using the relation name (e.g., instructor.ID)\nECE30030/ITP30010 Database Systems23\nThe FROM Clause•Find the Cartesian-product instructor X teaches SELECT * FROM instructor, teaches;\n24\ninstructor.IDnamedept_namesalaryteaches.IDcourse_idsec_idsemesteryear10101SrinivasanComp. Sci.6500076766BIO-101 1Summer201712121WuFinance9000076766BIO-101 1Summer201715151MozartMusic4000076766BIO-101 1Summer201722222EinsteinPhysics9500076766BIO-101 1Summer201732343El SaidHistory6000076766BIO-101 1Summer2017… … … … … … … … …10101SrinivasanComp. Sci.6500010101CS-101 1Fall 201712121WuFinance9000010101CS-101 1Fall 201715151MozartMusic4000010101CS-101 1Fall 201722222EinsteinPhysics9500010101CS-101 1Fall 201732343El SaidHistory6000010101CS-101 1Fall 2017… … … … … … … … …… … … … … … … … …10101SrinivasanComp. Sci.6500083821CS-190 2Spring201712121WuFinance9000083821CS-190 2Spring201715151MozartMusic4000083821CS-190 2Spring2017… … … … … … … … …10101SrinivasanComp. Sci.6500010101CS-315 1Spring201812121WuFinance9000010101CS-315 1Spring201815151MozartMusic4000010101CS-315 1Spring2018… … … … … … … … …… … … … … … … … …\nImplementing JOIN•Cartesian-product is not very useful directly; but useful combined with WHERE-clause condition (selection operation in relational algebra)•Cartesian-product + selection = join•E.g., Find the names of all instructors who have taught some course and the course_id SELECT name, course_id FROM instructor , teaches WHERE instructor.ID = teaches.ID\nECE30030/ITP30010 Database Systems25\nImplementing JOIN•Cartesian-product is not very useful directly; but useful combined with WHERE-clause condition (selection operation in relational algebra)•Cartesian-product + selection = join•Find the names of all instructors in the Music department who have taught some course and the course_id SELECT name, course_id FROM instructor , teaches WHERE instructor.ID = teaches.ID  AND instructor. dept_name = 'Music'\nECE30030/ITP30010 Database Systems26\nThe Rename Operation•The SQL allows renaming relations and attributes using the AS clause:   old-name AS new-name•Find the names of all instructors who have a higher salary than some instructor in ‘Comp. Sci.’•SELECT DISTINCT T.nameFROM instructor AS T, instructor AS SWHERE T.salary > S.salary AND S.dept_name = 'Comp. Sci.'\nECE30030/ITP30010 Database Systems27\nThe Rename Operation•The SQL allows renaming relations and attributes using the AS clause:   old-name AS new-name•Find the names of all instructors who have a higher salary than some instructor in ‘Comp. Sci.’•SELECT DISTINCT T.nameFROM instructor AS T, instructor AS SWHERE T.salary > S.salary AND S.dept_name = 'Comp. Sci.'•Keyword AS is optional and may be omitted  instructor AS T  ≡  instructor T\nECE30030/ITP30010 Database Systems28"
        },
        {
          "chapter_title": "SQL DML 고급 기능: NULL 값, 집합 연산, 문자열 처리 및 정렬",
          "source_pdf_filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf",
          "chapter_content_summary": "이 장에서는 SQL DML의 고급 기능을 탐구합니다. 먼저, 알려지지 않거나 존재하지 않는 값을 나타내는 NULL 값의 특성을 이해하고, 산술 연산에서의 NULL 동작 및 IS NULL / IS NOT NULL 술어를 사용하여 NULL 값을 확인하는 방법을 배웁니다. 다음으로, 여러 쿼리 결과를 결합하는 집합 연산인 UNION, INTERSECT, EXCEPT를 살펴봅니다. 각 연산이 기본적으로 중복을 제거하며, ALL 키워드를 사용하여 중복을 유지하는 방법을 설명합니다. 특히 MySQL에서 INTERSECT와 EXCEPT가 직접 지원되지 않을 때 JOIN 또는 NOT IN을 사용하여 에뮬레이션하는 기법을 소개합니다. 이어서, 문자열 패턴 매칭을 위한 LIKE 연산자와 '%' (모든 부분 문자열), '_' (단일 문자) 특수 문자의 사용법을 다룹니다. 백슬래시를 이용한 이스케이프 문자 처리, 패턴 매칭의 대소문자 구분, 그리고 연결, 대소문자 변환, 길이 확인, 부분 문자열 추출 등 다양한 SQL 문자열 함수를 소개합니다. 마지막으로, ORDER BY 절을 사용하여 쿼리 결과를 특정 속성을 기준으로 오름차순(ASC) 또는 내림차순(DESC)으로 정렬하는 방법을 학습하며, 여러 속성을 기준으로 정렬하는 예시도 제시합니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems29\nNULL Values•It is possible for tuples to have a NULL value for some of their attributes•NULL signifies an unknown value or that a value does not exist•The result of any arithmetic expression involving NULL is NULL•E.g.,  5 + NULL returns NULL\nECE30030/ITP30010 Database Systems30\nIS NULL / IS NOT NULL•The predicate IS NULL can be used to check for NULL values•E.g., Find all instructors whose salary is null SELECT name FROM instructor WHERE salary IS NULL•The predicate IS NOT NULL succeeds if the value on which it is applied is not null\nECE30030/ITP30010 Database Systems31\nECE30030/ITP30010 Database Systems32\nSet Operations•Set operations UNION, INTERSECT, and EXCEPT•Each of the above operations automatically eliminates duplicates•To retain all duplicates, use ALL:•UNION ALL•INTERSECT ALL•EXCEPT ALL\n•C.f., SELECT retains all duplicates by default\nECE30030/ITP30010 Database Systems33\nSet Operations: UNION•Find courses that ran in Fall 2017 or in Spring 2018•(SELECT course_id  FROM teaches WHERE semester = 'Fall' AND year = 2017)UNION(SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018)\nECE30030/ITP30010 Database Systems34\nSet Operations: INTERSECT•Find courses that ran in Fall 2017 and in Spring 2018•(SELECT course_id  FROM teaches WHERE semester = 'Fall' AND year = 2017)INTERSECT(SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018)•C.f., MySQL does NOT support INTERSECT•One can emulate INTERSECT using JOIN (we’ll study JOIN later)•SELECT LT.course_idFROM (SELECT course_id FROM teaches WHERE semester = 'Fall' AND year = 2017) AS LTJOIN (SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018) AS RTON LT.course_id=RT.course_id;\nECE30030/ITP30010 Database Systems35\nSet Operations: EXCEPT•Find courses that ran in Fall 2017 but not in Spring 2018•(SELECT course_id  FROM teaches WHERE semester = 'Fall' AND year = 2017)EXCEPT(SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018)•C.f., MySQL does NOT support EXCEPT•One can emulate EXCEPT using NOT IN•SELECT course_id FROM teaches WHERE semester = 'Fall' AND year = 2017AND course_id NOT IN(SELECT course_id  FROM teaches  WHERE semester = 'Spring' AND year = 2018);\nECE30030/ITP30010 Database Systems36\nECE30030/ITP30010 Database Systems37\nString Operations•SQL includes a string-matching operator for comparisons on character strings•The operator LIKE uses patterns that are described using two special characters:•percent (%) – The % character matches any substring•underscore (_) – The _ character matches any character•Find the names of all instructors whose name includes the substring “ri” SELECT name FROM instructor WHERE name LIKE ‘%ri%'\nECE30030/ITP30010 Database Systems38\nString Operations•Escape character: Use backslash (\\) as the escape character•E.g., Match the string “100%” LIKE '100 \\%’ ESCAPE  ‘\\’\nECE30030/ITP30010 Database Systems39\nString Operations•Patterns are case sensitive•Pattern matching examples:•'Intro%' matches any string beginning with “Intro”•'%Comp%' matches any string containing “Comp” as a substring•'_ _ _' matches any string of exactly three characters•'_ _ _ %' matches any string of at least three characters•SQL supports a variety of string operations such as•concatenation (using “||”)•converting from upper to lower case (and vice versa)•finding string length, extracting substrings, etc.\nECE30030/ITP30010 Database Systems40\nOrdering the Display of Tuples•List in alphabetic order the names of all instructors•SELECT DISTINCT nameFROM instructorORDER BY name\nECE30030/ITP30010 Database Systems41\nOrdering the Display of Tuples•Can sort on multiple attributes•E.g., SELECT dept_name, name     FROM instructor      ORDER BY dept_name, name\nECE30030/ITP30010 Database Systems42\nOrdering the Display of Tuples•We may specify DESC for descending order or ASC for ascending order, for each attribute; ascending order is the default•E.g., ORDER BY name DESC\nECE30030/ITP30010 Database Systems43"
        },
        {
          "chapter_title": "SQL DML 집계 함수 및 데이터 수정 (INSERT, UPDATE, DELETE)",
          "source_pdf_filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf",
          "chapter_content_summary": "이 장에서는 SQL 데이터 조작 언어(DML)의 고급 기능인 집계 함수와 데이터를 수정하는 명령어를 다룹니다. AVG, MIN, MAX, SUM, COUNT와 같은 집계 함수를 사용하여 컬럼 값의 멀티셋에 대한 통계 값을 계산하는 방법을 학습합니다. 특히 GROUP BY 절을 이용한 데이터 그룹화와 HAVING 절을 이용한 그룹별 필터링을 심층적으로 다루며, WHERE 절과의 차이점을 명확히 설명합니다. 또한, DML의 핵심 명령인 INSERT, UPDATE, DELETE에 대해 자세히 알아봅니다. INSERT 명령을 통해 테이블에 새로운 튜플을 추가하는 다양한 방법(모든 컬럼, 선택된 컬럼, NULL 값 처리, SELECT 쿼리 결과 삽입)과 외래 키 제약 조건의 중요성을 강조합니다. UPDATE 명령으로는 기존 데이터를 수정하는 기본 구문, 조건부 업데이트, CASE 문을 사용한 복잡한 조건 처리, 스칼라 서브쿼리 활용법을 배웁니다. 마지막으로 DELETE 명령을 통해 테이블에서 특정 행 또는 모든 행을 삭제하는 방법과 TRUNCATE 명령의 차이점, 그리고 삭제 시 서브쿼리 사용 시의 고려사항을 설명합니다.",
          "chapter_full_text": "ECE30030/ITP30010 Database Systems44\nAggregate Functions•These functions operate on the multiset of values of a column of a relation, and return a value•AVG:  average value•MIN:  minimum value•MAX:  maximum value•SUM:  sum of values•COUNT:  number of values\nECE30030/ITP30010 Database Systems45\nAggregate Functions Examples•Find the average salary of instructors in the Computer Science department•SELECT AVG(salary)FROM instructorWHERE dept_name= 'Comp. Sci.';•Find the total number of instructors who teach a course in the Spring 2018 semester•SELECT COUNT(DISTINCT ID)FROM teachesWHERE semester = 'Spring’ AND year = 2018;•Find the number of tuples in the teaches relation•SELECT COUNT (*)FROM teaches;\nECE30030/ITP30010 Database Systems46\nAggregate Functions: Group By•Find the average salary of instructors in each department•SELECT dept_name, AVG(salary) AS avg_salaryFROM instructorGROUP BY dept_name;\nECE30030/ITP30010 Database Systems47\nAggregation•Attributes in SELECT clause outside of aggregate functions must appear in GROUP BY list•/* erroneous query */SELECT dept_name, ID, AVG(salary)FROM instructorGROUP BY dept_name;\nECE30030/ITP30010 Database Systems48\nAggregate Functions – Having Clause•Find the names and average salaries of all departments whose average salary is greater than 65000•SELECT dept_name, AVG(salary) AS avg_salaryFROM instructorGROUP BY dept_nameHAVING AVG(salary) > 65000;\nECE30030/ITP30010 Database Systems49\nAggregate Functions – Having Clause•Note: predicates in the HAVING clause are applied after the formation of groups whereas predicates in the WHERE clause are applied before forming groups\nECE30030/ITP30010 Database Systems50\nSELECT dept_name, AVG(salary) AS avg_salaryFROM instructorGROUP BY dept_nameHAVING AVG(salary) > 65000;\nSELECT dept_name, AVG(salary) AS avg_salaryFROM instructorWHERE salary > 65000GROUP BY dept_name;\nSQL Commands\nSQLDMLSELECTINSERTUPDATEDELETE\nDDLCREATEALTERDROP\nECE30030/ITP30010 Database Systems51\nINSERT•Basic syntax•Insert data into every column:•INSERT INTO tablenameVALUES (col1_value, col2_value, …)•Must list values in the same order as in the table schema•If some data values are unknown, must type NULL •For character sequences, use quotation marks•Single quotation marks are preferred (but double quotation marks are allowed)•Value in quotations is case-sensitive•Insert data into selected columns•INSERT INTO tablename (col1_name, col3_name, col4_name, …)VALUES (col1_value, col3_value, col4_value, …)\nECE30030/ITP30010 Database Systems52\nINSERT•Add a new tuple to course•INSERT INTO courseVALUES ('CS-437', 'Database Systems', 'Comp. Sci.', 4);•or equivalently•INSERT INTO course (course_id, title, dept_name, credits)VALUES ('CS-437', 'Database Systems', 'Comp. Sci.', 4);•Add a new tuple to student  with tot_creds set to null•INSERT INTO studentVALUES ('3003', 'Green', 'Finance', null);\nECE30030/ITP30010 Database Systems53\nINSERT•A foreign key specifies that an attribute from one relation has to map to a tuple in another relation•Value in one relation must appear in another relation\nECE30030/ITP30010 Database Systems54\nRelation: instructor\nRelation: department\nINSERT•A foreign key specifies that an attribute from one relation has to map to a tuple in another relation•Value in one relation must appear in another relation•Make sure all foreign keys that new row references have already been added to database•One cannot insert a foreign key value unless the corresponding value exists in the referenced relation\nECE30030/ITP30010 Database Systems55\nINSERT•Inserting results of other SELECT query•Make each student in the Music department who has earned more than 144 credit hours an instructor in the Music department with a salary of  $18,000•INSERT INTO instructor  SELECT ID, name, dept_name, 18000  FROM student   WHERE dept_name = 'Music’ AND total_cred > 144;•The SELECT FROM WHERE statement is evaluated fully before any of its results are inserted into the relation•Otherwise queries like  INSERT INTO table1 SELECT * FROM table1would cause problem\nECE30030/ITP30010 Database Systems56\nUPDATE•Basic syntax•Updating a table•UPDATE tablenameSET col1_name = new_col1_value, col2_name = new_col2_value, …;•Updating a table with conditions•UPDATE tablenameSET col1_name = new_col1_value, col2_name = new_col2_value, …WHERE predicate;\nECE30030/ITP30010 Database Systems57\nUPDATE•Give a 5% salary raise to all instructors•UPDATE instructorSET salary = salary * 1.05•Give a 5% salary raise to those instructors who earn less than 70000•UPDATE instructorSET salary = salary * 1.05WHERE salary < 70000;•Give a 5% salary raise to instructors whose salary is less than average•UPDATE instructorSET salary = salary * 1.05WHERE salary <  (SELECT AVG(salary) FROM instructor);\nECE30030/ITP30010 Database Systems58\nUPDATE•Increase salaries of instructors whose salary is over $100,000 by 3%, and all others by a 5%•Write two UPDATE statements:  UPDATE instructor  SET salary = salary * 1.03  WHERE salary > 100000;  UPDATE instructor  SET salary = salary * 1.05  WHERE salary <= 100000;•The order is important•Can be done better using the case statement (next slide)\nECE30030/ITP30010 Database Systems59\nCASE Statement for Conditional Update•The following query is equivalent to the previous UPDATE queries•UPDATE instructorSET salary = CASE                           WHEN salary <= 100000 THEN salary * 1.05                           ELSE salary * 1.03                       END\nECE30030/ITP30010 Database Systems60\nUPDATE with Scalar Subqueries•Recompute and update tot_creds value for all students•UPDATE student SSET tot_cred = (SELECT SUM(credits)                             FROM takes, course                             WHERE takes.course_id = course.course_id  AND                                            S.ID= takes.ID  AND                                            takes.grade <> 'F' AND                                            takes.grade IS NOT NULL);\nECE30030/ITP30010 Database Systems61\nDELETE•Basic syntax•To remove specific rows•DELETE FROM tablenameWHERE predicate;•To remove all rows•DELETE FROM tablename;•This is equivalent to TRUNCATE:TRUNCATE (TABLE) tablename;•One cannot truncate a table with foreign key constraints•Must disable the constraints first (we will cover ALTER when we study SQL DDL):ALTER TABLE tablenameDISABLE CONSTRAINT constraint_name;\nECE30030/ITP30010 Database Systems62\nDELETE•Delete all instructors•DELETE FROM instructor;•Delete all instructors from the Finance department•DELETE FROM instructorWHERE dept_name= 'Finance';•Delete all tuples in the instructor relation for those instructors associated with a department located in the Watson building•DELETE FROM instructorWHERE dept name IN (SELECT dept name        FROM department        WHERE building = 'Watson');\nECE30030/ITP30010 Database Systems63\nDELETE•Delete all instructors whose salary is less than the average salary of instructors•Example:  DELETE FROM instructor                WHERE salary < (SELECT AVG (salary)                  FROM instructor);•Issue:  as we delete tuples from instructor, the average salary changes•Solution used in SQL:1.First, compute AVG(salary) and find all tuples to delete2.Next, delete all tuples found above (without recomputing AVG or retesting the tuples)\nECE30030/ITP30010 Database Systems64"
        }
      ],
      "generated_content": [
        {
          "title": "관계형 데이터베이스 시스템(R-DBMS) 개요 및 MySQL 소개",
          "metadata": "Source: cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_1a4c2f45-b482-4e82-826e-fa8945eb99c7_DB03 - mysql.pdf, Text length: 2496 chars",
          "documentContent": [
            {
              "type": "heading",
              "content": "목차",
              "level": 1
            },
            {
              "type": "paragraph",
              "content": "MySQL 소개",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "SQL 미리보기",
              "level": null
            },
            {
              "type": "heading",
              "content": "MySQL",
              "level": 1
            },
            {
              "type": "paragraph",
              "content": "MySQL은 SQL 기반의 관계형 데이터베이스 관리 시스템(DBMS)입니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "GPL 라이선스 하의 무료 오픈소스 R-DBMS입니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "오라클이 소유하고 있습니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "상업용 MySQL 버전도 제공됩니다(기술 지원 포함).",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "“My”는 공동 창립자 Michael Widenius의 딸 이름에서 유래했습니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "참고: MariaDB",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "표준 SQL과 호환됩니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "상업용 웹 서비스에 자주 사용됩니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "MySQL 사용 기업",
              "level": 1
            },
            {
              "type": "paragraph",
              "content": "Enlyft의 연구에 따르면, MySQL을 사용하는 1,409,176개 회사 중 199,498개 회사에 대한 데이터를 보유하고 있습니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "주로 직원 수 10-50명, 매출 100만-1000만 달러 규모의 회사에서 사용됩니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "참고: Oracle 12는 직원 수 50-200명, 매출 10억 달러 이상 규모의 회사에서 가장 많이 사용됩니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "MySQL을 사용하는 회사 전체 목록은 https://www.mysql.com/customers/ 에서 확인할 수 있습니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "MySQL을 사용하는 이유",
              "level": 1
            },
            {
              "type": "paragraph",
              "content": "인기 많음",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "인터넷 전반에 걸쳐 활발한 토론이 이루어집니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "다재다능함: Linux, Windows, Mac OS X, Solaris, FreeBSD 등 다양한 운영체제에서 실행됩니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "다양한 프로그래밍 언어(C/C++, Java, Python, .Net 등)를 지원합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "비용이 0부터 시작합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "고성능 (빠르고 신뢰할 수 있음)",
              "level": null
            },
            {
              "type": "heading",
              "content": "DBMS 인기 추세",
              "level": 1
            },
            {
              "type": "paragraph",
              "content": "점수 정의: https://db-engines.com/en/ranking_definition",
              "level": null
            },
            {
              "type": "heading",
              "content": "MySQL의 주요 특징",
              "level": 1
            },
            {
              "type": "paragraph",
              "content": "방대함: 테라바이트 단위의 데이터를 처리할 수 있습니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "편리함: 고수준 질의어를 지원합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "다중 사용자: 동시 데이터 접근을 지원합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "안전함: 트랜잭션을 지원합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "효율적임: 초당 수천 건의 질의를 처리할 수 있습니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "신뢰성: 많은 실제 제품에서 99.99%의 가동 시간을 자랑합니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "MySQL 버전",
              "level": 1
            },
            {
              "type": "paragraph",
              "content": "MySQL 5.x 대 8.x",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "버전 5.x: MySQL의 가장 인기 있는 버전이며, 더 안정적이고 보편적입니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "버전 8.x: 현재 버전으로, 최신 DB 기능(더 나은 스토리지 엔진, 더 빠른 속도, 더 강력한 보안)을 제공합니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "MySQL 얻는 방법",
              "level": 1
            },
            {
              "type": "paragraph",
              "content": "https://dev.mysql.com/downloads/",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "무료로 사용 가능한 \"커뮤니티\" 버전을 찾아보세요.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "”엔터프라이즈” 버전은 상업용입니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "이 강의를 위해 Docker 이미지가 준비되어 있습니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "Ubuntu 서버, MySQL, 그리고 강의 활동을 위한 예제 데이터베이스로 구성되어 있습니다.",
              "level": null
            }
          ],
          "aiNotes": {
            "summary": "본 문서는 관계형 데이터베이스 관리 시스템(R-DBMS)의 개요와 MySQL에 대해 소개합니다. MySQL이 SQL 기반의 무료 오픈소스 R-DBMS이며, 오라클이 소유하고 있음을 설명합니다. 또한 MySQL의 광범위한 사용 현황, 다양한 운영체제 및 프로그래밍 언어 지원, 고성능, 안정성 등의 장점을 강조합니다. MySQL 5.x와 8.x 버전의 주요 차이점을 비교하고, MySQL을 다운로드하고 활용할 수 있는 방법을 안내합니다.",
            "keyConcepts": [
              {
                "term": "관계형 데이터베이스 관리 시스템 (R-DBMS)",
                "definition": "SQL 기반으로 데이터를 관계형 모델에 따라 저장, 관리, 검색하는 시스템입니다."
              },
              {
                "term": "MySQL",
                "definition": "오라클이 소유한 SQL 기반의 오픈소스 R-DBMS로, 상업용 웹 서비스에 널리 사용되며 높은 성능과 안정성을 제공합니다."
              },
              {
                "term": "오픈소스 소프트웨어",
                "definition": "소스 코드가 공개되어 누구나 자유롭게 사용, 수정, 배포할 수 있는 소프트웨어입니다."
              },
              {
                "term": "SQL (Structured Query Language)",
                "definition": "관계형 데이터베이스와 상호작용하고 데이터를 정의, 조작, 제어하기 위한 표준 언어입니다."
              },
              {
                "term": "MySQL 버전 5.x vs 8.x",
                "definition": "5.x는 가장 대중적이고 안정적인 버전이며, 8.x는 현재 버전으로 최신 기능, 향상된 스토리지 엔진, 속도 및 보안을 제공합니다."
              }
            ],
            "importantTerms": [
              {
                "term": "DBMS",
                "definition": "데이터베이스 관리 시스템(Database Management System)의 약자로, 데이터베이스를 효율적으로 관리하는 소프트웨어입니다."
              },
              {
                "term": "GPL",
                "definition": "General Public License의 약자로, 자유 소프트웨어 라이선스의 일종이며, 소프트웨어의 복사, 배포, 수정 권한을 부여합니다."
              },
              {
                "term": "MariaDB",
                "definition": "MySQL의 한 포크(fork)로, MySQL과 높은 호환성을 가지며 오픈소스 커뮤니티에 의해 개발되고 있습니다."
              },
              {
                "term": "트랜잭션",
                "definition": "데이터베이스의 논리적인 작업 단위로, 데이터의 무결성을 보장하기 위해 전부 실행되거나 전혀 실행되지 않아야 하는 일련의 연산입니다."
              },
              {
                "term": "스토리지 엔진",
                "definition": "데이터베이스 시스템 내에서 데이터를 디스크에 저장하고 검색하는 방식을 담당하는 구성 요소입니다."
              },
              {
                "term": "Docker",
                "definition": "애플리케이션을 컨테이너라는 격리된 환경에서 개발, 배포, 실행할 수 있게 해주는 플랫폼입니다."
              }
            ],
            "outline": [
              {
                "text": "목차",
                "id": "목차",
                "children": null
              },
              {
                "text": "MySQL",
                "id": "mysql",
                "children": [
                  {
                    "text": "MySQL 정의 및 특징",
                    "id": "mysql-정의-및-특징",
                    "children": null
                  },
                  {
                    "text": "MySQL 사용 기업",
                    "id": "mysql-사용-기업",
                    "children": null
                  },
                  {
                    "text": "MySQL을 사용하는 이유",
                    "id": "mysql을-사용하는-이유",
                    "children": null
                  },
                  {
                    "text": "MySQL의 주요 특징",
                    "id": "mysql의-주요-특징",
                    "children": null
                  }
                ]
              },
              {
                "text": "DBMS 인기 추세",
                "id": "dbms-인기-추세",
                "children": null
              },
              {
                "text": "MySQL 버전",
                "id": "mysql-버전",
                "children": null
              },
              {
                "text": "MySQL 얻는 방법",
                "id": "mysql-얻는-방법",
                "children": null
              }
            ]
          },
          "quiz": [
            {
              "question": "MySQL의 주요 특징이 아닌 것은 무엇인가요?",
              "options": [
                "오라클이 소유한 상용 소프트웨어이다.",
                "SQL 기반의 관계형 데이터베이스 관리 시스템이다.",
                "GPL 라이선스 하에 무료 오픈소스 버전이 제공된다.",
                "다양한 운영체제와 프로그래밍 언어를 지원한다."
              ],
              "answerIndex": 0,
              "explanation": "MySQL은 오라클이 소유하고 있지만, GPL 라이선스 하에 무료 오픈소스 버전이 제공되며 상용 버전도 별도로 존재합니다. 따라서 '오라클이 소유한 상용 소프트웨어이다'는 MySQL의 모든 특징을 포괄하지 않습니다."
            },
            {
              "question": "MySQL 5.x 버전과 8.x 버전의 주요 차이점은 무엇인가요?",
              "options": [
                "5.x는 최신 기능에 중점을 둔 반면 8.x는 안정성에 중점을 둡니다.",
                "5.x는 현재 버전이고 8.x는 이전 버전입니다.",
                "5.x는 더 안정적이고 대중적이며, 8.x는 최신 기능과 향상된 성능을 제공합니다.",
                "5.x는 유료 버전이고 8.x는 무료 버전입니다."
              ],
              "answerIndex": 2,
              "explanation": "MySQL 5.x는 가장 대중적이고 안정적인 버전으로 남아있지만, 8.x는 최신 버전으로서 더 나은 스토리지 엔진, 속도 및 보안 등 최신 기능을 제공합니다."
            },
            {
              "question": "다음 중 MySQL을 얻을 수 있는 방법으로 본문에 언급되지 않은 것은 무엇인가요?",
              "options": [
                "dev.mysql.com/downloads/에서 커뮤니티 버전 다운로드",
                "MySQL 엔터프라이즈 버전 구매",
                "Docker 이미지를 통해 구축",
                "CD-ROM으로 설치"
              ],
              "answerIndex": 3,
              "explanation": "본문에서는 공식 다운로드 페이지에서 커뮤니티 버전 다운로드, 엔터프라이즈 버전 구매, 그리고 Docker 이미지 활용 방법이 언급되었으나, CD-ROM을 통한 설치는 언급되지 않았습니다."
            }
          ]
        },
        {
          "title": "SQL(구조적 질의어)의 이해: 기본 개념과 역사",
          "metadata": "Source: cd0e465a-9cfa-47bf-93fa-9eb3748fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf, Text length: 1968 chars",
          "documentContent": [
            {
              "type": "heading",
              "content": "서론",
              "level": 1
            },
            {
              "type": "paragraph",
              "content": "이 문서는 관계형 데이터베이스를 다루는 핵심 언어인 SQL(구조적 질의어)의 기본 개념과 역사, 그리고 주요 구성 요소에 대해 설명합니다. SQL은 데이터베이스에 '무엇을 할지'를 지시하는 높은 수준의 언어로, '어떻게 할지'에 대한 세부 사항은 DBMS(데이터베이스 관리 시스템)의 질의 최적화 기능에 맡깁니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "구조적 질의어 (SQL) 개요",
              "level": 1
            },
            {
              "type": "heading",
              "content": "SQL의 정의 및 특징",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "SQL은 관계형 데이터베이스를 기술하고 조작하는 데 사용되는 주요 언어입니다. SQL은 매우 높은 수준의 언어로, 사용자에게 데이터 조작의 세부 사항을 명시하는 대신 '무엇을 할지'를 지시하도록 합니다. DBMS는 질의 최적화(query optimization)를 통해 질의를 실행하는 '최적의' 방법을 찾아냅니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "SQL의 주요 구성 요소",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "SQL은 크게 두 가지 주요 측면으로 나뉩니다:",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "데이터 정의: 데이터베이스 스키마를 선언하는 데 사용되는 DDL(Data Definition Language).",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "데이터 조작: 데이터베이스에 질의하고(질문을 던지고) 데이터베이스를 수정하는 데 사용되는 DML(Data Manipulation Language).",
              "level": null
            },
            {
              "type": "heading",
              "content": "SQL의 다양한 기능",
              "level": 1
            },
            {
              "type": "heading",
              "content": "데이터 조작 언어 (DML)",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "DML은 데이터베이스에서 정보를 질의하고, 튜플을 삽입, 삭제, 수정하는 기능을 제공합니다. `SELECT`, `FROM`, `WHERE`와 같은 구문이 DML의 핵심을 이룹니다. 또한, NULL 값 처리, 집합 연산, 문자열 연산, 정렬, 그리고 집계 함수와 같은 고급 기능도 포함됩니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "기타 SQL 기능",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "SQL은 DML 외에도 다양한 기능을 포함합니다:",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "무결성: DDL은 무결성 제약 조건을 명시하기 위한 명령어를 포함합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "뷰 정의: DDL은 뷰를 정의하기 위한 명령어를 포함합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "트랜잭션 제어: 트랜잭션의 시작과 끝을 명시하기 위한 명령어를 포함합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "임베디드 SQL 및 동적 SQL: SQL 문을 범용 프로그래밍 언어 내에 포함하는 방법을 정의합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "권한 부여: 관계 및 뷰에 대한 접근 권한을 명시하기 위한 명령어를 포함합니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "SQL의 간략한 역사",
              "level": 1
            },
            {
              "type": "heading",
              "content": "초기 개발: IBM SEQUEL과 System R",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "SQL의 전신인 IBM SEQUEL(Structured English Query Language)은 1970년대 초 Chamberlin과 Boyce에 의해 System R 프로젝트의 일환으로 개발되었습니다. 이후 SEQUEL은 SQL(Structured Query Language)로 이름이 변경되었습니다. System R은 System/38(1979), SQL/DS(1981), DB2(1983)로 발전했습니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "상업적 구현 및 표준화",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "Relational Software, Inc.(현재 Oracle Corporation)는 VAX 컴퓨터용 Oracle V2를 출시하며 최초의 상업적 SQL 구현을 선보였습니다. ANSI와 ISO는 SQL을 표준화했으며, SQL-86을 시작으로 SQL-89, SQL-92, SQL:1999 등을 거쳐 현재는 SQL:2016에 이르렀습니다. 특히 SQL-92는 대부분의 데이터베이스 시스템에서 지원됩니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "기본 질의 구조",
              "level": 1
            },
            {
              "type": "heading",
              "content": "SELECT-FROM-WHERE 구문",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "전형적인 SQL 질의는 다음과 같은 형태를 가집니다:",
              "level": null
            },
            {
              "type": "code",
              "content": "SELECT A1, A2, ..., An\nFROM r1, r2, ..., rm\nWHERE P",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "여기서 Ai는 속성(attribute)을 나타내고, Ri는 관계(relation)를 나타내며, P는 술어(predicate)입니다. SQL 질의의 결과는 항상 관계(테이블)입니다.",
              "level": null
            }
          ],
          "aiNotes": {
            "summary": "이 문서는 관계형 데이터베이스의 핵심 언어인 SQL(구조적 질의어)에 대해 설명합니다. SQL의 정의와 특징, 데이터 정의 언어(DDL)와 데이터 조작 언어(DML)로의 구분, 그리고 무결성 제약 조건, 뷰 정의, 트랜잭션 제어 등 다양한 기능을 다룹니다. 또한, IBM의 SEQUEL 개발부터 Oracle의 상업적 구현, 그리고 ANSI 및 ISO 표준화에 이르는 SQL의 간략한 역사와 함께, `SELECT-FROM-WHERE`로 대표되는 SQL의 기본 질의 구조를 소개합니다.",
            "keyConcepts": [
              {
                "term": "SQL (구조적 질의어)",
                "definition": {
                  "easy": null,
                  "medium": "관계형 데이터베이스를 기술하고 조작하는 데 사용되는 주요 언어로, '무엇을 할지'를 지시하는 높은 수준의 언어입니다.",
                  "hard": null
                }
              },
              {
                "term": "DML (데이터 조작 언어)",
                "definition": {
                  "easy": null,
                  "medium": "데이터베이스에서 정보를 질의하고, 튜플을 삽입, 삭제, 수정하는 기능을 제공하는 SQL의 한 부분입니다.",
                  "hard": null
                }
              },
              {
                "term": "DDL (데이터 정의 언어)",
                "definition": {
                  "easy": null,
                  "medium": "데이터베이스 스키마를 선언하고 무결성 제약 조건 및 뷰 정의와 같은 데이터베이스 구조 관련 기능을 담당하는 SQL의 한 부분입니다.",
                  "hard": null
                }
              },
              {
                "term": "질의 최적화",
                "definition": {
                  "easy": null,
                  "medium": "DBMS가 SQL 질의를 효율적으로 실행하기 위해 '최적의' 실행 계획을 찾는 과정입니다.",
                  "hard": null
                }
              }
            ],
            "importantTerms": [
              {
                "term": "SQL",
                "definition": "Structured Query Language의 약자로, 관계형 데이터베이스를 관리하는 표준 언어입니다."
              },
              {
                "term": "DML",
                "definition": "Data Manipulation Language의 약자로, 데이터 검색, 삽입, 수정, 삭제 등 데이터 조작에 사용되는 SQL 명령어 집합입니다."
              },
              {
                "term": "DDL",
                "definition": "Data Definition Language의 약자로, 데이터베이스 스키마 정의, 테이블 생성 및 수정, 뷰 생성 등 데이터 구조 정의에 사용되는 SQL 명령어 집합입니다."
              },
              {
                "term": "SEQUEL",
                "definition": "Structured English Query Language의 약자로, SQL의 초기 명칭이자 IBM System R 프로젝트에서 개발되었습니다."
              },
              {
                "term": "System R",
                "definition": "IBM에서 1970년대 초에 개발한 관계형 데이터베이스 시스템 연구 프로젝트로, SQL의 기원이 되었습니다."
              },
              {
                "term": "질의 최적화 (Query Optimization)",
                "definition": "DBMS가 SQL 질의를 가장 효율적으로 실행하기 위한 방법을 결정하는 과정입니다."
              },
              {
                "term": "SELECT-FROM-WHERE",
                "definition": "SQL에서 데이터를 질의하는 가장 기본적인 구문 형태입니다."
              }
            ],
            "outline": [
              {
                "text": "서론",
                "id": "서론",
                "children": null
              },
              {
                "text": "구조적 질의어 (SQL) 개요",
                "id": "구조적-질의어-sql-개요",
                "children": [
                  {
                    "text": "SQL의 정의 및 특징",
                    "id": "sql의-정의-및-특징",
                    "children": null
                  },
                  {
                    "text": "SQL의 주요 구성 요소",
                    "id": "sql의-주요-구성-요소",
                    "children": null
                  }
                ]
              },
              {
                "text": "SQL의 다양한 기능",
                "id": "sql의-다양한-기능",
                "children": [
                  {
                    "text": "데이터 조작 언어 (DML)",
                    "id": "데이터-조작-언어-dml",
                    "children": null
                  },
                  {
                    "text": "기타 SQL 기능",
                    "id": "기타-sql-기능",
                    "children": null
                  }
                ]
              },
              {
                "text": "SQL의 간략한 역사",
                "id": "sql의-간략한-역사",
                "children": [
                  {
                    "text": "초기 개발: IBM SEQUEL과 System R",
                    "id": "초기-개발-ibm-sequel과-system-r",
                    "children": null
                  },
                  {
                    "text": "상업적 구현 및 표준화",
                    "id": "상업적-구현-및-표준화",
                    "children": null
                  }
                ]
              },
              {
                "text": "기본 질의 구조",
                "id": "기본-질의-구조",
                "children": [
                  {
                    "text": "SELECT-FROM-WHERE 구문",
                    "id": "select-from-where-구문",
                    "children": null
                  }
                ]
              }
            ]
          },
          "quiz": [
            {
              "question": "SQL의 주요 특징 중 하나는 무엇입니까?",
              "options": [
                "데이터 조작의 세부 사항을 명시합니다.",
                "데이터베이스에 '무엇을 할지'보다 '어떻게 할지'를 지시합니다.",
                "DBMS가 질의 실행 방법을 최적화하도록 합니다.",
                "비관계형 데이터베이스를 조작하는 데 주로 사용됩니다."
              ],
              "answerIndex": 2,
              "explanation": "SQL은 '무엇을 할지'를 명시하며, '어떻게 할지'에 대한 세부 사항은 DBMS의 질의 최적화 기능에 맡깁니다."
            },
            {
              "question": "최초의 상업적 SQL 구현을 출시한 회사는 어디입니까?",
              "options": [
                "IBM",
                "Microsoft",
                "Relational Software, Inc. (현재 Oracle Corporation)",
                "ANSI"
              ],
              "answerIndex": 2,
              "explanation": "Relational Software, Inc. (현재 Oracle Corporation)가 VAX 컴퓨터용 Oracle V2를 통해 최초의 상업적 SQL 구현을 출시했습니다."
            },
            {
              "question": "SQL의 구성 요소 중 데이터베이스 스키마를 선언하고 무결성 제약 조건 및 뷰를 정의하는 역할을 하는 것은 무엇입니까?",
              "options": [
                "DML (Data Manipulation Language)",
                "DDL (Data Definition Language)",
                "Transaction Control (트랜잭션 제어)",
                "Authorization (권한 부여)"
              ],
              "answerIndex": 1,
              "explanation": "DDL(데이터 정의 언어)은 데이터베이스 스키마를 선언하고 무결성 제약 조건 및 뷰를 정의하는 데 사용됩니다."
            }
          ]
        },
        {
          "title": "SQL 데이터 조작 언어(DML) 기초: SELECT, FROM, WHERE 절",
          "metadata": "Source: cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf, Text length: 4209 chars",
          "documentContent": [
            {
              "type": "heading",
              "content": "SQL 데이터 조작 언어(DML)",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "SQL 데이터 조작 언어(DML)는 데이터베이스를 질의(질문)하고 수정할 수 있도록 합니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "실행 예시",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "관계(테이블): instructor, teaches",
              "level": null
            },
            {
              "type": "heading",
              "content": "Instructor 관계 및 Teaches 관계",
              "level": 2
            },
            {
              "type": "heading",
              "content": "기본 질의 구조",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "일반적인 SQL 질의는 다음과 같은 형태를 가집니다: SELECT A1, A2, ..., An FROM r1, r2, ..., rm WHERE P",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "Ai는 속성을 나타냅니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "Ri는 관계를 나타냅니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "P는 술어(predicate)입니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "SQL 질의의 결과는 관계(relation)입니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "SELECT 절",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "SELECT 절은 질의 결과에 필요한 속성들을 나열합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "관계 대수의 프로젝션(projection) 연산에 해당합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "예시: 모든 강사의 이름을 찾기",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "SQL: SELECT name FROM instructor;",
              "level": null
            },
            {
              "type": "heading",
              "content": "참고",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "참고: SQL 이름은 대소문자를 구분하지 않습니다. 예: Name ≡ NAME ≡ name",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "SQL 명령(SELECT, FROM, WHERE 등)은 대문자로 작성하는 것이 일반적인 관례입니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "MySQL에는 lower_case_table_names라는 옵션 플래그가 있습니다. 링크: https://dev.mysql.com/doc/refman/8.0/en/identifier-case-sensitivity.html",
              "level": null
            },
            {
              "type": "heading",
              "content": "SELECT 절: 중복 처리",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "SQL은 관계뿐만 아니라 질의 결과에서도 중복을 허용합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "ALL 키워드는 중복을 제거하지 않도록 지정합니다. SELECT ALL dept_name FROM instructor",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "중복 제거를 강제하려면 SELECT 뒤에 DISTINCT 키워드를 삽입합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "모든 강사의 부서 이름을 중복 없이 찾기: SELECT DISTINCT dept_name FROM instructor;",
              "level": null
            },
            {
              "type": "heading",
              "content": "SELECT 절: 모든 속성 및 리터럴 사용",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "SELECT 절의 별표(*)는 “모든 속성”을 의미합니다. SELECT * FROM instructor;",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "속성은 FROM 절 없이 리터럴(상수)이 될 수 있습니다. SELECT ‘437’;",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "결과는 하나의 열과 “437” 값을 가진 단일 행으로 구성된 테이블입니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "AS를 사용하여 열에 이름을 부여할 수 있습니다: SELECT ‘437’ AS FOO",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "속성은 FROM 절을 포함하는 리터럴이 될 수 있습니다. SELECT 'A' FROM instructor",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "결과는 하나의 열과 N개의 행(instructor 테이블의 튜플 수)으로 구성된 테이블이며, 각 행은 “A” 값을 가집니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "SELECT 절: 산술 표현식",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "SELECT 절은 +, –, *, / 연산을 포함하는 산술 표현식을 포함할 수 있으며, 상수 또는 튜플의 속성에 대해 작동합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "질의: SELECT ID, name, salary/12 FROM instructor는 instructor 관계와 동일한 관계를 반환하지만, salary 속성 값이 12로 나뉘어 표시됩니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "AS 절을 사용하여 “salary/12”의 이름을 변경할 수 있습니다: SELECT ID, name, salary/12 AS monthly_salary FROM instructor",
              "level": null
            },
            {
              "type": "heading",
              "content": "WHERE 절",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "WHERE 절은 결과가 만족해야 하는 조건을 지정합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "관계 대수의 선택(selection) 술어에 해당합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "예시: ‘Comp. Sci.’ 부서의 모든 강사를 찾으려면: SELECT name FROM instructor WHERE dept_name = 'Comp. Sci.';",
              "level": null
            },
            {
              "type": "heading",
              "content": "WHERE 절: 논리 연산자와 비교 연산자",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "SQL은 AND, OR, NOT 논리 연결자를 사용할 수 있도록 합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "논리 연결자의 피연산자는 <, <=, >, >=, =, <>와 같은 비교 연산자를 포함하는 표현식일 수 있습니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "<>는 같지 않음을 의미합니다 (SQL에는 !=가 없습니다).",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "비교는 산술 표현식의 결과에도 적용될 수 있습니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "예시: ‘Comp. Sci.’ 부서에 속하며 급여가 70,000보다 많은 모든 강사를 찾으려면: SELECT name FROM instructor WHERE dept_name = 'Comp. Sci.' AND salary > 70000;",
              "level": null
            },
            {
              "type": "heading",
              "content": "WHERE 절: BETWEEN 연산자",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "SQL에는 BETWEEN 비교 연산자가 포함되어 있습니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "예시: 급여가 $90,000에서 $100,000 사이(즉, $90,000 이상 $100,000 이하)인 모든 강사의 이름을 찾으려면:",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "SELECT name FROM instructor WHERE salary BETWEEN 90000 AND 100000",
              "level": null
            },
            {
              "type": "heading",
              "content": "WHERE 절: 튜플 비교",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "튜플 비교: 튜플별로 비교를 수행합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "SELECT name, course_id FROM instructor, teaches WHERE (instructor.ID, dept_name) = (teaches.ID, 'Biology');",
              "level": null
            },
            {
              "type": "heading",
              "content": "FROM 절",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "FROM 절은 질의에 관련된 관계(테이블)들을 나열합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "관계 대수의 카티션 곱(Cartesian-product) 연산에 해당합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "예시: instructor × teaches의 카티션 곱을 찾으려면: SELECT * FROM instructor, teaches;",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "두 관계의 모든 속성을 포함하여 가능한 모든 instructor-teaches 쌍을 생성합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "공통 속성(예: ID)의 경우, 결과 테이블의 속성 이름은 관계 이름(예: instructor.ID)을 사용하여 변경됩니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "FROM 절: 카티션 곱 예시",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "instructor X teaches의 카티션 곱을 찾으려면: SELECT * FROM instructor, teaches;",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "결과 테이블은 instructor와 teaches 관계의 모든 속성을 포함하며, 각 instructor 튜플과 각 teaches 튜플의 모든 가능한 조합을 생성합니다. 예를 들어, instructor.ID, name, dept_name, salary와 teaches.ID, course_id, sec_id, semester, year와 같은 속성들이 조합되어 나타납니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "조인 구현",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "카티션 곱은 직접적으로는 유용하지 않지만, WHERE 절 조건(관계 대수의 선택 연산)과 결합하면 유용합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "카티션 곱 + 선택 = 조인(join)",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "예시: 어떤 과목을 가르친 모든 강사의 이름과 course_id를 찾으려면: SELECT name, course_id FROM instructor , teaches WHERE instructor.ID = teaches.ID",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "음악과에 속하며 어떤 과목을 가르친 모든 강사의 이름과 course_id를 찾으려면: SELECT name, course_id FROM instructor , teaches WHERE instructor.ID = teaches.ID AND instructor. dept_name = 'Music'",
              "level": null
            },
            {
              "type": "heading",
              "content": "이름 변경(Rename) 연산",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "SQL은 AS 절을 사용하여 관계와 속성의 이름을 변경할 수 있도록 합니다: old-name AS new-name",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "예시: 'Comp. Sci.' 부서의 어떤 강사보다 급여가 높은 모든 강사의 이름을 찾으려면:",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "SELECT DISTINCT T.name FROM instructor AS T, instructor AS S WHERE T.salary > S.salary AND S.dept_name = 'Comp. Sci.'",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "AS 키워드는 선택 사항이며 생략될 수 있습니다. instructor AS T ≡ instructor T",
              "level": null
            }
          ],
          "aiNotes": {
            "summary": "본 문서는 SQL 데이터 조작 언어(DML)의 핵심 구성 요소인 SELECT, FROM, WHERE 절의 기초를 다룹니다. 각 절의 기본적인 기능과 함께 중복 처리(ALL, DISTINCT), 산술 표현식, 조건 필터링(AND, OR, NOT, BETWEEN), 테이블 간의 조인(JOIN) 구현, 그리고 테이블 및 속성 이름 변경(AS)과 같은 다양한 활용 방법을 예시와 함께 설명합니다. 또한 SQL 이름의 대소문자 구분 규칙에 대한 내용도 포함되어 있습니다.",
            "keyConcepts": [
              {
                "term": "SQL DML",
                "definition": "데이터베이스에서 데이터를 질의하고 수정하는 데 사용되는 언어입니다."
              },
              {
                "term": "SELECT 절",
                "definition": "질의 결과에 포함할 속성(컬럼)을 지정하는 부분으로, 관계 대수의 프로젝션(Projection) 연산에 해당합니다."
              },
              {
                "term": "FROM 절",
                "definition": "데이터를 검색할 관계(테이블)를 지정하는 부분으로, 관계 대수의 카티션 곱(Cartesian Product) 연산에 해당합니다."
              },
              {
                "term": "WHERE 절",
                "definition": "질의 결과가 만족해야 할 조건을 지정하는 부분으로, 관계 대수의 선택(Selection) 연산에 해당합니다."
              },
              {
                "term": "조인 (JOIN)",
                "definition": "FROM 절의 카티션 곱과 WHERE 절의 선택 조건을 결합하여 두 개 이상의 테이블에서 관련 튜플을 연결하여 새로운 테이블을 생성하는 연산입니다."
              }
            ],
            "importantTerms": [
              {
                "term": "DML (Data Manipulation Language)",
                "definition": "데이터베이스에서 데이터를 검색, 삽입, 삭제, 수정하는 데 사용되는 언어."
              },
              {
                "term": "SELECT",
                "definition": "SQL 쿼리의 결과를 정의하는 절로, 어떤 컬럼을 반환할지 지정."
              },
              {
                "term": "FROM",
                "definition": "SQL 쿼리에서 데이터를 검색할 테이블을 지정하는 절."
              },
              {
                "term": "WHERE",
                "definition": "SQL 쿼리에서 특정 조건을 만족하는 행만 선택하도록 필터링하는 절."
              },
              {
                "term": "DISTINCT",
                "definition": "SELECT 절에서 중복된 결과를 제거할 때 사용하는 키워드."
              },
              {
                "term": "AS",
                "definition": "SQL에서 테이블이나 컬럼의 이름을 변경(별칭 지정)할 때 사용하는 키워드."
              },
              {
                "term": "카티션 곱 (Cartesian Product)",
                "definition": "두 테이블의 모든 가능한 행 조합을 생성하는 연산."
              }
            ],
            "outline": [
              {
                "text": "SQL 데이터 조작 언어(DML) 개요",
                "id": "sql-데이터-조작-언어-dml-개요",
                "children": null
              },
              {
                "text": "기본 질의 구조",
                "id": "기본-질의-구조",
                "children": null
              },
              {
                "text": "SELECT 절의 활용",
                "id": "select-절의-활용",
                "children": [
                  {
                    "text": "속성 선택 및 프로젝션",
                    "id": "속성-선택-및-프로젝션",
                    "children": null
                  },
                  {
                    "text": "대소문자 구분 및 SQL 명령 규칙",
                    "id": "대소문자-구분-및-sql-명령-규칙",
                    "children": null
                  },
                  {
                    "text": "중복 처리 (ALL, DISTINCT)",
                    "id": "중복-처리-all-distinct",
                    "children": null
                  },
                  {
                    "text": "모든 속성 선택 (*) 및 리터럴 사용",
                    "id": "모든-속성-선택-및-리터럴-사용",
                    "children": null
                  },
                  {
                    "text": "산술 표현식 및 결과 이름 변경 (AS)",
                    "id": "산술-표현식-및-결과-이름-변경-as",
                    "children": null
                  }
                ]
              },
              {
                "text": "WHERE 절의 활용",
                "id": "where-절의-활용",
                "children": [
                  {
                    "text": "조건 지정 및 선택 연산",
                    "id": "조건-지정-및-선택-연산",
                    "children": null
                  },
                  {
                    "text": "논리 연산자 (AND, OR, NOT) 및 비교 연산자",
                    "id": "논리-연산자-and-or-not-및-비교-연산자",
                    "children": null
                  },
                  {
                    "text": "BETWEEN 연산자",
                    "id": "between-연산자",
                    "children": null
                  },
                  {
                    "text": "튜플 비교",
                    "id": "튜플-비교",
                    "children": null
                  }
                ]
              },
              {
                "text": "FROM 절의 활용",
                "id": "from-절의-활용",
                "children": [
                  {
                    "text": "관계 지정 및 카티션 곱",
                    "id": "관계-지정-및-카티션-곱",
                    "children": null
                  },
                  {
                    "text": "조인 구현 (Cartesian-product + selection)",
                    "id": "조인-구현-cartesian-product-selection",
                    "children": null
                  }
                ]
              },
              {
                "text": "이름 변경 (AS) 연산",
                "id": "이름-변경-as-연산",
                "children": null
              }
            ]
          },
          "quiz": [
            {
              "question": "중복된 값을 제거하고 강사들의 부서 이름을 검색하는 올바른 SQL 쿼리는 무엇입니까?",
              "options": [
                "SELECT ALL dept_name FROM instructor;",
                "SELECT dept_name FROM instructor;",
                "SELECT DISTINCT dept_name FROM instructor;",
                "SELECT UNIQUE dept_name FROM instructor;"
              ],
              "answerIndex": 2,
              "explanation": "`DISTINCT` 키워드는 SELECT 절에서 중복된 결과를 제거하는 데 사용됩니다."
            },
            {
              "question": "'Comp. Sci.' 부서에 속하며 급여가 70,000보다 많은 모든 강사의 이름을 찾는 SQL 쿼리로 가장 적절한 것은 무엇입니까?",
              "options": [
                "SELECT name FROM instructor WHERE dept_name = 'Comp. Sci.' OR salary > 70000;",
                "SELECT name FROM instructor WHERE dept_name = 'Comp. Sci.' AND salary > 70000;",
                "SELECT name FROM instructor WHERE dept_name <> 'Comp. Sci.' AND salary <= 70000;",
                "SELECT name FROM instructor WHERE dept_name = 'Comp. Sci.' BETWEEN salary 70000;"
              ],
              "answerIndex": 1,
              "explanation": "`AND` 논리 연산자는 두 조건을 모두 만족하는 경우를 찾을 때 사용됩니다."
            },
            {
              "question": "다음 SQL 쿼리 `SELECT DISTINCT T.name FROM instructor AS T, instructor AS S WHERE T.salary > S.salary AND S.dept_name = 'Comp. Sci.'`에 대한 설명으로 옳은 것은 무엇입니까?",
              "options": [
                "이 쿼리는 'Comp. Sci.' 부서 강사들 중 가장 높은 급여를 받는 강사의 이름을 찾습니다.",
                "이 쿼리는 'Comp. Sci.' 부서의 특정 강사보다 급여가 높은 다른 강사들의 이름을 찾습니다.",
                "이 쿼리는 'Comp. Sci.' 부서의 모든 강사 이름을 나열합니다.",
                "이 쿼리는 두 개의 다른 테이블에서 강사 정보를 조인합니다."
              ],
              "answerIndex": 1,
              "explanation": "`FROM instructor AS T, instructor AS S`는 instructor 테이블을 두 개의 별칭(T와 S)으로 사용하여 자체 조인(self-join)을 수행하며, `WHERE T.salary > S.salary AND S.dept_name = 'Comp. Sci.'` 조건은 'Comp. Sci.' 부서의 어떤 강사(S)보다 급여가 높은 강사(T)를 찾습니다."
            }
          ]
        },
        {
          "title": "SQL DML 고급 기능: NULL 값, 집합 연산, 문자열 처리 및 정렬",
          "metadata": "Source: cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf, Text length: 3206 chars",
          "documentContent": [
            {
              "type": "heading",
              "content": "NULL 값",
              "level": 1
            },
            {
              "type": "paragraph",
              "content": "튜플에 일부 속성에 대해 NULL 값이 있을 수 있습니다. NULL은 알 수 없거나 값이 존재하지 않음을 의미합니다. NULL이 포함된 모든 산술 표현식의 결과는 NULL입니다. 예를 들어, '5 + NULL'은 NULL을 반환합니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "IS NULL / IS NOT NULL",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "술어 `IS NULL`은 NULL 값을 확인하는 데 사용됩니다. 예를 들어, `SELECT name FROM instructor WHERE salary IS NULL`은 급여가 NULL인 모든 강사의 이름을 찾습니다. `IS NOT NULL` 술어는 적용된 값이 NULL이 아닐 때 성공합니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "집합 연산",
              "level": 1
            },
            {
              "type": "paragraph",
              "content": "`UNION`, `INTERSECT`, `EXCEPT`와 같은 집합 연산이 있습니다. 이 연산들은 각각 자동으로 중복을 제거합니다. 모든 중복을 유지하려면 `ALL` 키워드를 사용합니다(예: `UNION ALL`, `INTERSECT ALL`, `EXCEPT ALL`). 참고로 `SELECT` 문은 기본적으로 모든 중복을 유지합니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "UNION",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "`UNION`은 두 쿼리의 결과를 결합합니다. 예를 들어, 2017년 가을 또는 2018년 봄에 개설된 강좌를 찾을 수 있습니다. (`SELECT course_id FROM teaches WHERE semester = 'Fall' AND year = 2017) UNION (SELECT course_id FROM teaches WHERE semester = 'Spring' AND year = 2018`).",
              "level": null
            },
            {
              "type": "heading",
              "content": "INTERSECT",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "`INTERSECT`는 두 쿼리 결과의 공통 부분을 찾습니다. 예를 들어, 2017년 가을과 2018년 봄 모두에 개설된 강좌를 찾을 수 있습니다. MySQL은 `INTERSECT`를 직접 지원하지 않으므로, `JOIN`을 사용하여 에뮬레이션할 수 있습니다. (`SELECT LT.course_id FROM (SELECT course_id FROM teaches WHERE semester = 'Fall' AND year = 2017) AS LT JOIN (SELECT course_id FROM teaches WHERE semester = 'Spring' AND year = 2018) AS RT ON LT.course_id=RT.course_id;`)",
              "level": null
            },
            {
              "type": "heading",
              "content": "EXCEPT",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "`EXCEPT`는 첫 번째 쿼리 결과에서 두 번째 쿼리 결과를 제외한 부분을 찾습니다. 예를 들어, 2017년 가을에 개설되었지만 2018년 봄에는 개설되지 않은 강좌를 찾을 수 있습니다. MySQL은 `EXCEPT`를 직접 지원하지 않으므로, `NOT IN`을 사용하여 에뮬레이션할 수 있습니다. (`SELECT course_id FROM teaches WHERE semester = 'Fall' AND year = 2017 AND course_id NOT IN(SELECT course_id FROM teaches WHERE semester = 'Spring' AND year = 2018);`)",
              "level": null
            },
            {
              "type": "heading",
              "content": "문자열 연산",
              "level": 1
            },
            {
              "type": "paragraph",
              "content": "SQL은 문자열 비교를 위한 문자열 일치 연산자를 포함합니다. `LIKE` 연산자는 두 가지 특수 문자를 사용하여 패턴을 설명합니다. 퍼센트(`%`) 문자는 모든 부분 문자열과 일치하고, 밑줄(`_`) 문자는 모든 단일 문자와 일치합니다. 예를 들어, `SELECT name FROM instructor WHERE name LIKE ‘%ri%'`는 이름에 \"ri\" 부분 문자열이 포함된 모든 강사의 이름을 찾습니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "이스케이프 문자(예: 백슬래시 `\\`)를 사용하여 특수 문자를 리터럴로 일치시킬 수 있습니다. 예를 들어, \"100%\" 문자열과 일치시키려면 `LIKE '100 \\%' ESCAPE '\\'`를 사용합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "패턴은 대소문자를 구분합니다. 패턴 일치 예시: 'Intro%'는 \"Intro\"로 시작하는 모든 문자열과 일치하고, '%Comp%'는 \"Comp\"를 포함하는 모든 문자열과 일치하며, '_ _ _'는 정확히 세 문자로 된 모든 문자열과 일치하고, '_ _ _ %'는 최소 세 문자로 된 모든 문자열과 일치합니다. SQL은 연결(`||`), 대소문자 변환, 문자열 길이 찾기, 부분 문자열 추출 등 다양한 문자열 연산을 지원합니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "튜플 표시 정렬",
              "level": 1
            },
            {
              "type": "paragraph",
              "content": "`ORDER BY` 절을 사용하여 튜플의 표시 순서를 정렬할 수 있습니다. 예를 들어, 모든 강사의 이름을 알파벳 순서로 나열하려면 `SELECT DISTINCT name FROM instructor ORDER BY name`을 사용합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "여러 속성을 기준으로 정렬할 수 있습니다. 예를 들어, `SELECT dept_name, name FROM instructor ORDER BY dept_name, name`과 같이 부서 이름과 이름 순으로 정렬할 수 있습니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "각 속성에 대해 내림차순(`DESC`) 또는 오름차순(`ASC`)을 지정할 수 있으며, 오름차순이 기본값입니다. 예를 들어, `ORDER BY name DESC`는 이름을 내림차순으로 정렬합니다.",
              "level": null
            }
          ],
          "aiNotes": {
            "summary": "이 문서는 SQL DML의 고급 기능을 다룹니다. NULL 값의 개념과 `IS NULL`, `IS NOT NULL`을 이용한 처리 방법을 설명합니다. 또한 `UNION`, `INTERSECT`, `EXCEPT`와 같은 집합 연산의 사용법과 `ALL` 키워드를 통한 중복 유지 방법, 그리고 MySQL에서의 에뮬레이션 방안을 제시합니다. 마지막으로 `LIKE` 연산자를 활용한 문자열 패턴 매칭과 `ORDER BY` 절을 이용한 결과 정렬 방법에 대해 자세히 설명합니다.",
            "keyConcepts": [
              {
                "term": "NULL 값 처리",
                "definition": "데이터베이스에서 알 수 없거나 존재하지 않는 값을 나타내는 NULL을 다루는 방법과 관련된 SQL 기능."
              },
              {
                "term": "SQL 집합 연산",
                "definition": "여러 쿼리 결과를 `UNION`, `INTERSECT`, `EXCEPT`를 사용하여 결합하거나 비교하는 기능."
              },
              {
                "term": "문자열 패턴 매칭",
                "definition": "`LIKE` 연산자와 `%`, `_` 특수 문자를 사용하여 문자열 내의 특정 패턴을 검색하는 방법."
              },
              {
                "term": "결과 집합 정렬",
                "definition": "`ORDER BY` 절을 사용하여 쿼리 결과 튜플의 표시 순서를 오름차순(`ASC`) 또는 내림차순(`DESC`)으로 지정하는 방법."
              }
            ],
            "importantTerms": [
              {
                "term": "NULL",
                "definition": "알 수 없거나 존재하지 않는 값."
              },
              {
                "term": "IS NULL / IS NOT NULL",
                "definition": "NULL 값을 확인하는 데 사용되는 술어."
              },
              {
                "term": "UNION",
                "definition": "두 쿼리 결과를 합치는 집합 연산자이며, 기본적으로 중복을 제거한다."
              },
              {
                "term": "LIKE",
                "definition": "문자열 패턴 매칭에 사용되는 연산자."
              },
              {
                "term": "%",
                "definition": "`LIKE` 연산자에서 임의의 부분 문자열과 일치하는 특수 문자."
              },
              {
                "term": "_",
                "definition": "`LIKE` 연산자에서 임의의 단일 문자와 일치하는 특수 문자."
              },
              {
                "term": "ORDER BY",
                "definition": "쿼리 결과의 정렬 순서를 지정하는 절."
              }
            ],
            "outline": [
              {
                "text": "NULL 값",
                "id": "null-값",
                "children": [
                  {
                    "text": "NULL 값의 정의 및 특징",
                    "id": "null-값의-정의-및-특징",
                    "children": null
                  },
                  {
                    "text": "IS NULL / IS NOT NULL 술어",
                    "id": "is-null-is-not-null-술어",
                    "children": null
                  }
                ]
              },
              {
                "text": "집합 연산",
                "id": "집합-연산",
                "children": [
                  {
                    "text": "집합 연산의 종류 (UNION, INTERSECT, EXCEPT)",
                    "id": "집합-연산의-종류",
                    "children": null
                  },
                  {
                    "text": "중복 제거 및 ALL 키워드",
                    "id": "중복-제거-및-all-키워드",
                    "children": null
                  },
                  {
                    "text": "UNION 예시",
                    "id": "union-예시",
                    "children": null
                  },
                  {
                    "text": "INTERSECT 예시 및 MySQL 에뮬레이션",
                    "id": "intersect-예시-및-mysql-에뮬레이션",
                    "children": null
                  },
                  {
                    "text": "EXCEPT 예시 및 MySQL 에뮬레이션",
                    "id": "except-예시-및-mysql-에뮬레이션",
                    "children": null
                  }
                ]
              },
              {
                "text": "문자열 연산",
                "id": "문자열-연산",
                "children": [
                  {
                    "text": "LIKE 연산자 및 패턴 매칭 특수 문자 (%, _)",
                    "id": "like-연산자-및-패턴-매칭-특수-문자",
                    "children": null
                  },
                  {
                    "text": "이스케이프 문자",
                    "id": "이스케이프-문자",
                    "children": null
                  },
                  {
                    "text": "패턴 매칭 예시 및 특징 (대소문자 구분)",
                    "id": "패턴-매칭-예시-및-특징",
                    "children": null
                  },
                  {
                    "text": "기타 문자열 함수",
                    "id": "기타-문자열-함수",
                    "children": null
                  }
                ]
              },
              {
                "text": "튜플 표시 정렬",
                "id": "튜플-표시-정렬",
                "children": [
                  {
                    "text": "ORDER BY 절 기본 사용법",
                    "id": "order-by-절-기본-사용법",
                    "children": null
                  },
                  {
                    "text": "여러 속성으로 정렬",
                    "id": "여러-속성으로-정렬",
                    "children": null
                  },
                  {
                    "text": "오름차순 (ASC) 및 내림차순 (DESC) 지정",
                    "id": "오름차순-및-내림차순-지정",
                    "children": null
                  }
                ]
              }
            ]
          },
          "quiz": [
            {
              "question": "SQL에서 NULL 값이 포함된 산술 연산의 결과는 무엇입니까?",
              "options": [
                "0",
                "1",
                "NULL",
                "오류"
              ],
              "answerIndex": 2,
              "explanation": "NULL이 포함된 산술 표현식의 결과는 항상 NULL입니다."
            },
            {
              "question": "다음 중 두 쿼리 결과의 중복을 포함하여 합치는 SQL 집합 연산자는 무엇입니까?",
              "options": [
                "UNION",
                "INTERSECT ALL",
                "UNION ALL",
                "EXCEPT"
              ],
              "answerIndex": 2,
              "explanation": "`UNION`은 중복을 제거하지만, `UNION ALL`은 모든 중복을 유지하면서 두 쿼리 결과를 합칩니다."
            },
            {
              "question": "`LIKE` 연산자에서 임의의 단일 문자와 일치하는 특수 문자는 무엇입니까?",
              "options": [
                "%",
                "_",
                "\\",
                "?"
              ],
              "answerIndex": 1,
              "explanation": "`%`는 임의의 부분 문자열과 일치하고, `_`는 임의의 단일 문자와 일치합니다."
            }
          ]
        },
        {
          "title": "SQL DML: 집계 함수 및 데이터 수정 (INSERT, UPDATE, DELETE)",
          "metadata": "Source: cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf, Text length: 5040 chars",
          "documentContent": [
            {
              "type": "heading",
              "content": "집계 함수 (Aggregate Functions)",
              "level": 1
            },
            {
              "type": "paragraph",
              "content": "집계 함수는 릴레이션의 특정 컬럼 값들의 멀티셋에 대해 작동하며 단일 값을 반환합니다. 주요 집계 함수는 다음과 같습니다:",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "•   **AVG**: 평균값",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "•   **MIN**: 최솟값",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "•   **MAX**: 최댓값",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "•   **SUM**: 합계",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "•   **COUNT**: 값의 개수",
              "level": null
            },
            {
              "type": "heading",
              "content": "집계 함수 예시",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "집계 함수는 다양한 질의에 사용될 수 있습니다. 예를 들어, 컴퓨터 공학과 강사들의 평균 급여를 찾거나, 2018년 봄 학기에 강의를 가르친 강사의 총 수를 세거나, `teaches` 릴레이션의 튜플 수를 세는 데 활용됩니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "•   **컴퓨터 공학과 강사들의 평균 급여 찾기:**",
              "level": null
            },
            {
              "type": "code",
              "content": "SELECT AVG(salary)\nFROM instructor\nWHERE dept_name= 'Comp. Sci.';",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "•   **2018년 봄 학기에 강의를 가르친 강사의 총 수 찾기:**",
              "level": null
            },
            {
              "type": "code",
              "content": "SELECT COUNT(DISTINCT ID)\nFROM teaches\nWHERE semester = 'Spring’ AND year = 2018;",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "•   **`teaches` 릴레이션의 튜플 수 찾기:**",
              "level": null
            },
            {
              "type": "code",
              "content": "SELECT COUNT (*)\nFROM teaches;",
              "level": null
            },
            {
              "type": "heading",
              "content": "GROUP BY 절",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "`GROUP BY` 절은 특정 컬럼의 값을 기준으로 행들을 그룹으로 묶고, 각 그룹에 대해 집계 함수를 적용할 때 사용됩니다. 예를 들어, 각 부서의 강사 평균 급여를 찾을 수 있습니다.",
              "level": null
            },
            {
              "type": "code",
              "content": "SELECT dept_name, AVG(salary) AS avg_salary\nFROM instructor\nGROUP BY dept_name;",
              "level": null
            },
            {
              "type": "heading",
              "content": "GROUP BY 규칙",
              "level": 3
            },
            {
              "type": "paragraph",
              "content": "`SELECT` 절에 집계 함수 외에 사용된 모든 속성은 반드시 `GROUP BY` 목록에 포함되어야 합니다. 그렇지 않으면 오류가 발생합니다.",
              "level": null
            },
            {
              "type": "code",
              "content": "/* 오류가 발생하는 질의 */\nSELECT dept_name, ID, AVG(salary)\nFROM instructor\nGROUP BY dept_name;",
              "level": null
            },
            {
              "type": "heading",
              "content": "HAVING 절",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "`HAVING` 절은 `GROUP BY` 절에 의해 생성된 그룹에 조건을 적용하여 결과를 필터링하는 데 사용됩니다. 예를 들어, 평균 급여가 65000을 초과하는 모든 부서의 이름과 평균 급여를 찾을 수 있습니다.",
              "level": null
            },
            {
              "type": "code",
              "content": "SELECT dept_name, AVG(salary) AS avg_salary\nFROM instructor\nGROUP BY dept_name\nHAVING AVG(salary) > 65000;",
              "level": null
            },
            {
              "type": "heading",
              "content": "HAVING과 WHERE의 차이",
              "level": 3
            },
            {
              "type": "paragraph",
              "content": "`HAVING` 절의 조건은 그룹이 형성된 **후**에 적용되는 반면, `WHERE` 절의 조건은 그룹을 형성하기 **전**에 적용됩니다. 이는 데이터 필터링 시점의 중요한 차이입니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "SQL DML 명령어",
              "level": 1
            },
            {
              "type": "paragraph",
              "content": "SQL 데이터 조작 언어(DML)는 데이터베이스 내의 데이터를 검색, 삽입, 수정, 삭제하는 데 사용됩니다. 주요 DML 명령어는 `SELECT`, `INSERT`, `UPDATE`, `DELETE`입니다. 데이터 정의 언어(DDL)는 `CREATE`, `ALTER`, `DROP`과 같이 데이터베이스 스키마를 정의하고 관리하는 데 사용됩니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "INSERT (데이터 삽입)",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "`INSERT` 문은 테이블에 새로운 행(튜플)을 추가하는 데 사용됩니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "기본 문법",
              "level": 3
            },
            {
              "type": "paragraph",
              "content": "•   **모든 컬럼에 데이터 삽입:**",
              "level": null
            },
            {
              "type": "code",
              "content": "INSERT INTO tablename\nVALUES (col1_value, col2_value, …)",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "    *   값은 테이블 스키마와 동일한 순서로 나열되어야 합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "    *   알 수 없는 데이터 값은 `NULL`로 지정해야 합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "    *   문자열은 따옴표를 사용하며, 작은따옴표(')가 권장됩니다. 따옴표 안의 값은 대소문자를 구분합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "•   **선택한 컬럼에 데이터 삽입:**",
              "level": null
            },
            {
              "type": "code",
              "content": "INSERT INTO tablename (col1_name, col3_name, col4_name, …)\nVALUES (col1_value, col3_value, col4_value, …)",
              "level": null
            },
            {
              "type": "heading",
              "content": "INSERT 예시",
              "level": 3
            },
            {
              "type": "paragraph",
              "content": "•   **`course` 테이블에 새로운 튜플 추가:**",
              "level": null
            },
            {
              "type": "code",
              "content": "INSERT INTO course\nVALUES ('CS-437', 'Database Systems', 'Comp. Sci.', 4);",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "    또는 동일하게:",
              "level": null
            },
            {
              "type": "code",
              "content": "INSERT INTO course (course_id, title, dept_name, credits)\nVALUES ('CS-437', 'Database Systems', 'Comp. Sci.', 4);",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "•   **`student` 테이블에 `tot_creds`가 NULL인 새로운 튜플 추가:**",
              "level": null
            },
            {
              "type": "code",
              "content": "INSERT INTO student\nVALUES ('3003', 'Green', 'Finance', null);",
              "level": null
            },
            {
              "type": "heading",
              "content": "외래 키 제약 조건과 INSERT",
              "level": 3
            },
            {
              "type": "paragraph",
              "content": "외래 키는 한 릴레이션의 속성이 다른 릴레이션의 튜플에 매핑되어야 함을 지정합니다. 즉, 한 릴레이션의 값이 다른 릴레이션에 존재해야 합니다. 새로운 행을 삽입할 때는 해당 행이 참조하는 모든 외래 키가 데이터베이스에 이미 추가되어 있는지 확인해야 합니다. 참조된 릴레이션에 해당 값이 존재하지 않으면 외래 키 값을 삽입할 수 없습니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "다른 SELECT 쿼리 결과 삽입",
              "level": 3
            },
            {
              "type": "paragraph",
              "content": "`SELECT` 쿼리의 결과를 다른 테이블에 삽입할 수 있습니다. 이때 `SELECT FROM WHERE` 문은 그 결과가 릴레이션에 삽입되기 전에 완전히 평가됩니다. 이는 `INSERT INTO table1 SELECT * FROM table1`과 같은 질의에서 발생할 수 있는 문제를 방지합니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "•   **음악학과 학생 중 144학점 이상을 이수한 학생들을 $18,000 급여의 음악학과 강사로 추가:**",
              "level": null
            },
            {
              "type": "code",
              "content": "INSERT INTO instructor\n  SELECT ID, name, dept_name, 18000\n  FROM student\n  WHERE dept_name = 'Music’ AND total_cred > 144;",
              "level": null
            },
            {
              "type": "heading",
              "content": "UPDATE (데이터 수정)",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "`UPDATE` 문은 테이블의 기존 데이터를 수정하는 데 사용됩니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "기본 문법",
              "level": 3
            },
            {
              "type": "paragraph",
              "content": "•   **테이블 업데이트 (조건 없음):** 모든 행의 지정된 컬럼을 수정합니다.",
              "level": null
            },
            {
              "type": "code",
              "content": "UPDATE tablename\nSET col1_name = new_col1_value, col2_name = new_col2_value, …;",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "•   **조건 있는 테이블 업데이트:** `WHERE` 절의 조건과 일치하는 행만 수정합니다.",
              "level": null
            },
            {
              "type": "code",
              "content": "UPDATE tablename\nSET col1_name = new_col1_value, col2_name = new_col2_value, …\nWHERE predicate;",
              "level": null
            },
            {
              "type": "heading",
              "content": "UPDATE 예시",
              "level": 3
            },
            {
              "type": "paragraph",
              "content": "•   **모든 강사의 급여를 5% 인상:**",
              "level": null
            },
            {
              "type": "code",
              "content": "UPDATE instructor\nSET salary = salary * 1.05",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "•   **급여가 70000 미만인 강사의 급여를 5% 인상:**",
              "level": null
            },
            {
              "type": "code",
              "content": "UPDATE instructor\nSET salary = salary * 1.05\nWHERE salary < 70000;",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "•   **급여가 평균 급여 미만인 강사의 급여를 5% 인상:**",
              "level": null
            },
            {
              "type": "code",
              "content": "UPDATE instructor\nSET salary = salary * 1.05\nWHERE salary <  (SELECT AVG(salary) FROM instructor);",
              "level": null
            },
            {
              "type": "heading",
              "content": "CASE 문을 이용한 조건부 UPDATE",
              "level": 3
            },
            {
              "type": "paragraph",
              "content": "여러 조건에 따라 다른 값을 적용해야 할 경우 `CASE` 문을 사용할 수 있습니다. 이는 여러 `UPDATE` 문을 사용하는 것보다 효율적이며, 실행 순서에 따른 문제를 방지할 수 있습니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "•   **급여가 $100,000 초과인 강사는 3% 인상, 그 외는 5% 인상:**",
              "level": null
            },
            {
              "type": "code",
              "content": "UPDATE instructor\nSET salary = CASE\n                           WHEN salary <= 100000 THEN salary * 1.05\n                           ELSE salary * 1.03\n                       END",
              "level": null
            },
            {
              "type": "heading",
              "content": "스칼라 서브쿼리를 이용한 UPDATE",
              "level": 3
            },
            {
              "type": "paragraph",
              "content": "스칼라 서브쿼리(단일 값을 반환하는 서브쿼리)를 사용하여 컬럼 값을 업데이트할 수 있습니다.",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "•   **모든 학생의 `tot_creds` 값을 재계산하여 업데이트:**",
              "level": null
            },
            {
              "type": "code",
              "content": "UPDATE student S\nSET tot_cred = (SELECT SUM(credits)\n                             FROM takes, course\n                             WHERE takes.course_id = course.course_id  AND\n                                            S.ID= takes.ID  AND\n                                            takes.grade <> 'F' AND\n                                            takes.grade IS NOT NULL);",
              "level": null
            },
            {
              "type": "heading",
              "content": "DELETE (데이터 삭제)",
              "level": 2
            },
            {
              "type": "paragraph",
              "content": "`DELETE` 문은 테이블에서 행을 제거하는 데 사용됩니다.",
              "level": null
            },
            {
              "type": "heading",
              "content": "기본 문법",
              "level": 3
            },
            {
              "type": "paragraph",
              "content": "•   **특정 행 제거:** `WHERE` 절의 조건과 일치하는 행을 제거합니다.",
              "level": null
            },
            {
              "type": "code",
              "content": "DELETE FROM tablename\nWHERE predicate;",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "•   **모든 행 제거:** 테이블의 모든 행을 제거합니다.",
              "level": null
            },
            {
              "type": "code",
              "content": "DELETE FROM tablename;",
              "level": null
            },
            {
              "type": "heading",
              "content": "TRUNCATE와의 비교",
              "level": 3
            },
            {
              "type": "paragraph",
              "content": "`DELETE FROM tablename;`는 `TRUNCATE (TABLE) tablename;`와 기능적으로 유사하게 테이블의 모든 행을 제거합니다. 그러나 `TRUNCATE`는 외래 키 제약 조건이 있는 테이블에서는 사용할 수 없습니다. 외래 키 제약 조건이 있는 테이블을 `TRUNCATE`하려면 먼저 제약 조건을 비활성화해야 합니다.",
              "level": null
            },
            {
              "type": "code",
              "content": "ALTER TABLE tablename\nDISABLE CONSTRAINT constraint_name;",
              "level": null
            },
            {
              "type": "heading",
              "content": "DELETE 예시",
              "level": 3
            },
            {
              "type": "paragraph",
              "content": "•   **모든 강사 삭제:**",
              "level": null
            },
            {
              "type": "code",
              "content": "DELETE FROM instructor;",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "•   **재무학과 강사 모두 삭제:**",
              "level": null
            },
            {
              "type": "code",
              "content": "DELETE FROM instructor\nWHERE dept_name= 'Finance';",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "•   **Watson 건물에 위치한 부서에 소속된 강사 모두 삭제:**",
              "level": null
            },
            {
              "type": "code",
              "content": "DELETE FROM instructor\nWHERE dept_name IN (SELECT dept_name\n        FROM department\n        WHERE building = 'Watson');",
              "level": null
            },
            {
              "type": "heading",
              "content": "서브쿼리를 이용한 DELETE 시 주의사항",
              "level": 3
            },
            {
              "type": "paragraph",
              "content": "서브쿼리를 사용하여 `DELETE` 작업을 수행할 때, 삭제되는 튜플이 서브쿼리의 결과에 영향을 미칠 수 있습니다. 예를 들어, 강사 평균 급여보다 낮은 급여를 가진 강사를 삭제하는 경우, 강사가 삭제됨에 따라 평균 급여가 변경될 수 있습니다.",
              "level": null
            },
            {
              "type": "code",
              "content": "DELETE FROM instructor\nWHERE salary < (SELECT AVG (salary) FROM instructor);",
              "level": null
            },
            {
              "type": "paragraph",
              "content": "SQL에서는 이러한 문제를 해결하기 위해 다음과 같은 방식을 사용합니다. 먼저 `AVG(salary)`를 계산하고 삭제할 모든 튜플을 찾은 다음, 평균을 재계산하거나 튜플을 재확인하지 않고 찾아진 모든 튜플을 삭제합니다.",
              "level": null
            }
          ],
          "aiNotes": {
            "summary": "이 문서는 SQL의 데이터 조작 언어(DML) 중 집계 함수와 데이터 수정 명령어(INSERT, UPDATE, DELETE)에 대해 설명합니다. 집계 함수의 종류(AVG, MIN, MAX, SUM, COUNT)와 사용 예시를 제시하며, GROUP BY 및 HAVING 절의 사용법과 WHERE 절과의 차이점을 강조합니다. 또한, INSERT 명령어를 이용한 데이터 삽입 방법, 외래 키 제약 조건과의 관계, 그리고 SELECT 쿼리 결과 삽입에 대해 다룹니다. UPDATE 명령어의 기본 문법, 다양한 조건부 업데이트 예시, 그리고 CASE 문 및 스칼라 서브쿼리 활용법을 설명합니다. 마지막으로 DELETE 명령어의 기본 문법, TRUNCATE와의 차이점, 외래 키 제약 조건, 그리고 서브쿼리를 사용한 삭제 시의 처리 방식에 대해 상세히 기술합니다.",
            "keyConcepts": [
              {
                "term": "집계 함수 (Aggregate Functions)",
                "definition": "릴레이션의 컬럼 값들의 멀티셋에 대해 작동하여 단일 값을 반환하는 함수 (예: AVG, MIN, MAX, SUM, COUNT)."
              },
              {
                "term": "GROUP BY",
                "definition": "SQL에서 특정 컬럼의 값을 기준으로 행들을 그룹으로 묶어 각 그룹에 대해 집계 함수를 적용할 수 있게 하는 절."
              },
              {
                "term": "HAVING 절",
                "definition": "GROUP BY 절에 의해 생성된 그룹에 조건을 적용하여 결과를 필터링하는 데 사용되는 절. WHERE 절과 달리 그룹화 후에 적용된다."
              },
              {
                "term": "INSERT",
                "definition": "SQL에서 테이블에 새로운 행(튜플)을 추가하는 데 사용되는 DML 명령어."
              },
              {
                "term": "UPDATE",
                "definition": "SQL에서 테이블의 기존 데이터를 수정하는 데 사용되는 DML 명령어."
              },
              {
                "term": "DELETE",
                "definition": "SQL에서 테이블의 행을 제거하는 데 사용되는 DML 명령어."
              }
            ],
            "importantTerms": [
              {
                "term": "멀티셋 (Multiset)",
                "definition": "중복된 값을 허용하는 집합."
              },
              {
                "term": "튜플 (Tuple)",
                "definition": "릴레이션(테이블)의 한 행을 의미한다."
              },
              {
                "term": "외래 키 (Foreign Key)",
                "definition": "한 릴레이션의 속성이 다른 릴레이션의 기본 키를 참조하여 두 릴레이션 간의 관계를 설정하는 제약 조건."
              },
              {
                "term": "스칼라 서브쿼리 (Scalar Subquery)",
                "definition": "단일 행, 단일 컬럼의 값을 반환하는 서브쿼리."
              },
              {
                "term": "TRUNCATE",
                "definition": "테이블의 모든 행을 빠르게 제거하는 DDL 명령어. DELETE와 달리 외래 키 제약 조건이 있는 테이블에는 직접 적용할 수 없다."
              }
            ],
            "outline": [
              {
                "text": "집계 함수 (Aggregate Functions)",
                "id": "집계-함수-aggregate-functions",
                "children": [
                  {
                    "text": "집계 함수 예시",
                    "id": "집계-함수-예시",
                    "children": null
                  },
                  {
                    "text": "GROUP BY 절",
                    "id": "group-by-절",
                    "children": [
                      {
                        "text": "GROUP BY 규칙",
                        "id": "group-by-규칙",
                        "children": null
                      }
                    ]
                  },
                  {
                    "text": "HAVING 절",
                    "id": "having-절",
                    "children": [
                      {
                        "text": "HAVING과 WHERE의 차이",
                        "id": "having과-where의-차이",
                        "children": null
                      }
                    ]
                  }
                ]
              },
              {
                "text": "SQL DML 명령어",
                "id": "sql-dml-명령어",
                "children": [
                  {
                    "text": "INSERT (데이터 삽입)",
                    "id": "insert-데이터-삽입",
                    "children": [
                      {
                        "text": "기본 문법",
                        "id": "기본-문법",
                        "children": null
                      },
                      {
                        "text": "INSERT 예시",
                        "id": "insert-예시",
                        "children": null
                      },
                      {
                        "text": "외래 키 제약 조건과 INSERT",
                        "id": "외래-키-제약-조건과-insert",
                        "children": null
                      },
                      {
                        "text": "다른 SELECT 쿼리 결과 삽입",
                        "id": "다른-select-쿼리-결과-삽입",
                        "children": null
                      }
                    ]
                  },
                  {
                    "text": "UPDATE (데이터 수정)",
                    "id": "update-데이터-수정",
                    "children": [
                      {
                        "text": "기본 문법",
                        "id": "기본-문법-1",
                        "children": null
                      },
                      {
                        "text": "UPDATE 예시",
                        "id": "update-예시",
                        "children": null
                      },
                      {
                        "text": "CASE 문을 이용한 조건부 UPDATE",
                        "id": "case-문을-이용한-조건부-update",
                        "children": null
                      },
                      {
                        "text": "스칼라 서브쿼리를 이용한 UPDATE",
                        "id": "스칼라-서브쿼리를-이용한-update",
                        "children": null
                      }
                    ]
                  },
                  {
                    "text": "DELETE (데이터 삭제)",
                    "id": "delete-데이터-삭제",
                    "children": [
                      {
                        "text": "기본 문법",
                        "id": "기본-문법-2",
                        "children": null
                      },
                      {
                        "text": "TRUNCATE와의 비교",
                        "id": "truncate와의-비교",
                        "children": null
                      },
                      {
                        "text": "DELETE 예시",
                        "id": "delete-예시",
                        "children": null
                      },
                      {
                        "text": "서브쿼리를 이용한 DELETE 시 주의사항",
                        "id": "서브쿼리를-이용한-delete-시-주의사항",
                        "children": null
                      }
                    ]
                  }
                ]
              }
            ]
          },
          "quiz": [
            {
              "question": "다음 중 SQL의 `HAVING` 절에 대한 설명으로 올바른 것은 무엇입니까?",
              "options": [
                "그룹을 형성하기 전에 개별 행에 조건을 적용합니다.",
                "집계 함수가 적용된 그룹에 조건을 적용합니다.",
                "테이블에서 데이터를 삭제할 때 사용됩니다.",
                "새로운 행을 테이블에 삽입할 때 사용됩니다."
              ],
              "answerIndex": 1,
              "explanation": "`HAVING` 절은 `GROUP BY` 절에 의해 생성된 그룹에 조건을 적용하여 필터링하는 데 사용됩니다. `WHERE` 절과 달리 그룹화가 완료된 후에 적용됩니다."
            },
            {
              "question": "SQL `INSERT` 문을 사용하여 새 행을 삽입할 때, 외래 키(Foreign Key) 제약 조건과 관련하여 반드시 지켜야 할 사항은 무엇입니까?",
              "options": [
                "외래 키 값은 항상 NULL로 설정되어야 합니다.",
                "새로운 행의 외래 키 값이 참조하는 릴레이션에 이미 존재해야 합니다.",
                "외래 키 값은 삽입 후 자동으로 생성됩니다.",
                "외래 키 제약 조건은 `INSERT` 작업에 영향을 미치지 않습니다."
              ],
              "answerIndex": 1,
              "explanation": "외래 키는 다른 릴레이션의 기본 키를 참조하므로, 새로운 행을 삽입할 때 해당 외래 키 값이 참조하는 릴레이션에 이미 존재해야 참조 무결성이 유지됩니다."
            },
            {
              "question": "다음 SQL `UPDATE` 문 중, 급여가 $100,000 이하인 강사의 급여는 5% 인상하고, $100,000 초과인 강사의 급여는 3% 인상하는 올바른 방법은 무엇입니까?",
              "options": [
                "UPDATE instructor SET salary = salary * 1.05 WHERE salary <= 100000; UPDATE instructor SET salary = salary * 1.03 WHERE salary > 100000;",
                "UPDATE instructor SET salary = CASE WHEN salary <= 100000 THEN salary * 1.05 ELSE salary * 1.03 END;",
                "UPDATE instructor SET salary = salary * 1.03 OR salary * 1.05;",
                "UPDATE instructor WHERE salary <= 100000 SET salary = salary * 1.05; ELSE SET salary = salary * 1.03;"
              ],
              "answerIndex": 1,
              "explanation": "`CASE` 문은 여러 조건에 따라 다른 값을 적용할 때 사용되는 효율적인 방법입니다. 제시된 `CASE` 문은 주어진 조건에 따라 급여 인상률을 정확하게 적용합니다. 두 개의 `UPDATE` 문을 사용하는 첫 번째 옵션도 가능하지만, 순서에 따라 결과가 달라질 수 있고 `CASE` 문이 더 간결하고 안전한 방법입니다."
            }
          ]
        }
      ],
      "log_entries": [
        {
          "node": "start_processing",
          "status": "completed",
          "state_snapshot": {
            "run_id": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d",
            "pdf_file_paths": [
              "temp_pdf_uploads/cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_1a4c2f45-b482-4e82-826e-fa8945eb99c7_DB03 - mysql.pdf",
              "temp_pdf_uploads/cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf"
            ],
            "notebook_title": "",
            "holistic_chapters": [],
            "generated_content": [],
            "final_result": ""
          }
        },
        {
          "node": "start_processing",
          "status": "completed",
          "state_snapshot": {
            "run_id": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d",
            "pdf_file_paths": [
              "temp_pdf_uploads/cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_1a4c2f45-b482-4e82-826e-fa8945eb99c7_DB03 - mysql.pdf",
              "temp_pdf_uploads/cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf"
            ],
            "notebook_title": "",
            "holistic_chapters": [],
            "generated_content": [],
            "final_result": ""
          }
        },
        {
          "node": "analyze_overall_structure",
          "status": "completed",
          "state_snapshot": {
            "run_id": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d",
            "pdf_file_paths": [
              "temp_pdf_uploads/cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_1a4c2f45-b482-4e82-826e-fa8945eb99c7_DB03 - mysql.pdf",
              "temp_pdf_uploads/cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf"
            ],
            "notebook_title": "관계형 데이터베이스 시스템: MySQL 소개 및 SQL 심층 활용",
            "holistic_chapters": [
              {
                "chapter_title": "관계형 데이터베이스 시스템(R-DBMS) 개요 및 MySQL 소개",
                "source_pdf_filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_1a4c2f45-b482-4e82-826e-fa8945eb99c7_DB03 - mysql.pdf",
                "chapter_content_summary": "이 장에서는 관계형 데이터베이스 관리 시스템(R-DBMS)의 기본 개념을 소개하고, 대표적인 오픈소스 R-DBMS인 MySQL에 대해 심층적으로 다룹니다. MySQL의 정의, Oracle 소유권, 표준 SQL 호환성, 상업적 웹 서비스에서의 활용 사례, 기업 사용 통계, 그리고 MySQL의 인기 요인(다양한 운영체제 및 프로그래밍 언어 지원, 비용 효율성, 고성능)을 설명합니다. 또한, R-DBMS 시장에서의 MySQL의 트렌드와 인기도를 살펴보고, MySQL 5.x와 8.x 버전의 주요 차이점 및 MySQL 커뮤니티 버전을 다운로드하고 Docker 이미지를 활용하는 방법을 안내합니다. MySQL이 대규모 데이터 처리, 다중 사용자 지원, 효율성, 안정성, 보안성 측면에서 갖는 강점들을 강조합니다.",
                "chapter_full_text": "ECE30030/ITP30010 Database SystemsHandshaking with an R-DBMSCharmgil Hongcharmgil@handong.eduSpring, 2025Handong Global University\n1\nAgenda•Introduction to MySQL•SQL preview\nECE30030/ITP30010 Database Systems2\nMySQL•MySQL is an SQL-based relational database management system (DBMS)•Free and open-source R-DBMS (under GPL)•Owned by Oracle•Commercial version of MySQL is also provided (including technical support)•“My” came from the name of co-founder Michael Widenius’ daughter•C.f., MariaDB•Compatible with standard SQL•Frequently used for commercial web services\nECE30030/ITP30010 Database Systems3\n* Image src: https://en.wikipedia.org/wiki/MySQL\nMySQL•Companies using MySQL (a study by Enlyft)•“We have data on 199,498 (out of 1,409,176) companies that use MySQL”•Often used by companies with 10-50 employees and 1M-10M dollars in revenue•C.f., Oracle 12 is most often used by companies with 50-200 employees and >1000M dollars in revenue\nECE30030/ITP30010 Database Systems4* Source: https://enlyft.com/tech/products/mysql \nMySQL•Companies using MySQL (full list: https://www.mysql.com/customers/)\nECE30030/ITP30010 Database Systems5\n* Source: https://stackshare.io/mysql \nMySQL•Why MySQL?•Popular•Active discussions all over the Internet•Versatile: runs on Linux, Windows, Mac OS X, Solaris, FreeBSD, …•Supports wide range of programming languages (C/C++, Java, Python, .Net, …)•Cost starts from zero•High performance (fast and reliable)\nECE30030/ITP30010 Database Systems6* Image src: https://db-engines.com/en/ranking\nDBMS Trend Popularity\n•Score definition: https://db-engines.com/en/ranking_definition\nECE30030/ITP30010 Database Systems7* Image src: https://db-engines.com/en/ranking_trend \nMySQL•Why MySQL?•Popular•Active discussions all over the Internet•Versatile: runs on Linux, Windows, Mac OS X, Solaris, FreeBSD, …•Supports wide range of programming languages (C/C++, Java, Python, .Net, …)•Cost starts from zero•High performance (fast and reliable)\nECE30030/ITP30010 Database Systems8* Image src: https://dev.mysql.com/downloads/\nMySQL\nECE30030/ITP30010 Database Systems9\n•Massive•Convenient•Multi-user•Safe•Efficient•Reliable\nCan handle terabytes of dataSupports high-level query languageSupports concurrent data accessSupports transactionsCan handle thousands of queries/second99.99% up-time in many real-world products\nMySQL Versions•MySQL 5.x vs 8.x\nECE30030/ITP30010 Database Systems10\nVersion 5.x-Most popular version of MySQL-More stable and conventionalVersion 8.x-Current version-Provides up-to-date DB functionalities (better storage engine, faster, more secure)\n* Source: https://www.eversql.com/mysql-8-adoption-usage-rate/#:~:text=MySQL%205.7%20is%20still%20the,17%25%20are%20using%20MySQL%208. \nMySQL Versions•MySQL 5.x vs 8.x\nECE30030/ITP30010 Database Systems11\nVersion 5.x-Most popular version of MySQL-More stable and conventionalVersion 8.x-Current version-Provides up-to-date DB functionalities (better storage engine, faster, more secure)\n* Source: https://severalnines.com/database-blog/mysql-performance-benchmarking-mysql-57-vs-mysql-80 \nMySQL Versions•MySQL 5.x vs 8.x\nECE30030/ITP30010 Database Systems12\nVersion 5.x-Most popular version of MySQL-More stable and conventionalVersion 8.x-Current version-Provides up-to-date DB functionalities (better storage engine, faster, more secure)\n* Source: https://severalnines.com/database-blog/mysql-performance-benchmarking-mysql-57-vs-mysql-80 \nWhere to Get MySQL?•https://dev.mysql.com/downloads/•Look for the “Community” versions – the branch that is available for free•”Enterprise” versions are the commercial ones•We have prepared a Docker image for the course•Consists of Ubuntu Server, MySQL, example databases for course activities\nECE30030/ITP30010 Database Systems13* Image src: https://www.docker.com \nWhere to Get MySQL?\nECE30030/ITP30010 Database Systems14\n* Image source: https://baumannalexj.medium.com/connect-your-db-tool-to-a-dockerized-mysql-server-container-bc18853524ed   https://www.jetbrains.com/datagrip/features/look_and_feel.html"
              },
              {
                "chapter_title": "SQL(구조적 질의어)의 이해: 기본 개념과 역사",
                "source_pdf_filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf",
                "chapter_content_summary": "SQL(Structured Query Language)의 정의와 관계형 데이터베이스를 조작하는 주된 언어로서의 역할을 설명합니다. SQL이 '무엇을 할지'를 명시하는 고수준 언어이며, DBMS가 '어떻게 할지'를 결정하는 쿼리 최적화 과정을 다룹니다. 또한, SQL의 두 가지 주요 측면인 데이터 정의 언어(DDL)와 데이터 조작 언어(DML)를 소개하고, 무결성, 뷰 정의, 트랜잭션 제어, 내장 SQL 및 동적 SQL, 권한 부여와 같은 SQL의 다양한 구성 요소를 살펴봅니다. 마지막으로, IBM SEQUEL에서 시작하여 Oracle V2를 거쳐 ANSI 및 ISO 표준으로 발전한 SQL의 간략한 역사를 소개하고, 기본적인 SQL 쿼리 구조(SELECT, FROM, WHERE)를 설명합니다.",
                "chapter_full_text": "ECE30030/ITP30010 Database SystemsStructured Query LanguageReading: Chapter 3\nCharmgil Hongcharmgil@handong.eduSpring, 2025Handong Global University\n1\nAgenda•Structured query language (SQL)•SQL data manipulation language (DML)•SELECT, FROM, WHERE•NULL values•Set operations•String operations, ordering•Aggregate functions, aggregation•SQL data definition language (DDL)   --   NEXT CLASS\nECE30030/ITP30010 Database Systems2\nStructured Query Language (SQL)•SQL: Structured Query Language•The principal language used to describe and manipulate relational databases•Very high-level•Say “what to do” rather than “how to do it”•SQL is not specifying data-manipulation details•DBMSs figure out the “best” way to execute queries•Called “query optimization”•Two aspects to SQL•Data definition: for declaring database schemas (DDL)•Data manipulation: for querying (asking questions about) databases and for modifying the database (DML)\nECE30030/ITP30010 Database Systems3\nSQL Parts•DML – provides the ability to query information from the database and to insert tuples into, delete tuples from, and modify tuples in the database•Integrity – the DDL includes commands for specifying integrity constraints•View definition – the DDL includes commands for defining views•Transaction control – includes commands for specifying the beginning and ending of transactions•Embedded SQL and dynamic SQL – define how SQL statements can be embedded within general-purpose programming language•Authorization – includes commands for specifying access rights to relations and viewsECE30030/ITP30010 Database Systems4\nA Brief History•IBM SEQUEL (Structured English Query Language) was developed as a part of the System R project (Chamberlin and Boyce, early 1970s)•Later on, SEQUEL was renamed SQL (structured query language)•System R à System/38 (1979), SQL/DS (1981), DB2 (1983)•Relational Software, Inc released the first commercial implementation of SQL, Oracle V2 for VAX computers•Relational Software, Inc is now Oracle Corporation•ANSI and ISO standardized SQL:•SQL-86,  SQL-89,  SQL-92,  SQL:1999,  …,  SQL:2011,  SQL:2016 (current)•SQL-92 is supported by the most of database systems\nECE30030/ITP30010 Database Systems5\nBasic Query Structure•A typical SQL query has the form:   SELECT A1, A2, ..., An FROM r1, r2, ..., rm WHERE P•Ai represents an attribute•Ri represents a relation•P is a predicate\n•The result of an SQL query is a relation\nECE30030/ITP30010 Database Systems6"
              },
              {
                "chapter_title": "SQL 데이터 조작 언어(DML) 기초: SELECT, FROM, WHERE 절",
                "source_pdf_filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf",
                "chapter_content_summary": "이 장에서는 SQL 데이터 조작 언어(DML)의 핵심 구성 요소인 SELECT, FROM, WHERE 절을 상세히 다룹니다. 'instructor' 및 'teaches'와 같은 예시 관계(테이블)를 사용하여 실제 쿼리 작성 방법을 시연합니다. SELECT 절을 통해 원하는 속성을 선택하고, 중복을 포함하거나 제거하는 방법(ALL, DISTINCT), 모든 속성을 선택하는 '*' 사용법, 리터럴 및 산술 표현식 활용, 그리고 AS 키워드를 사용한 속성 이름 변경 방법을 학습합니다. WHERE 절에서는 논리 연산자(AND, OR, NOT) 및 비교 연산자(<, <=, >, >=, =, <>, BETWEEN)를 사용하여 조건을 지정하고, 튜플 비교를 수행하는 방법을 설명합니다. 마지막으로 FROM 절을 통해 쿼리에 포함될 관계를 지정하고, 카르테시안 곱을 이해하며, WHERE 절과 결합하여 JOIN 연산을 구현하는 방법을 구체적인 예시와 함께 제시합니다. 또한, AS 키워드를 이용한 관계 및 속성 이름 변경(별칭 지정)을 다룹니다.",
                "chapter_full_text": "ECE30030/ITP30010 Database Systems7\nSQL Data Manipulation Language•The SQL data-manipulation language (DML) allows querying (ask questions about) and modifying the databases\nECE30030/ITP30010 Database Systems8\nRunning Examples•Relations (tables): instructor, teaches\nECE30030/ITP30010 Database Systems9\nInstructor relationteaches relation\nBasic Query Structure•A typical SQL query has the form:   SELECT A1, A2, ..., An FROM r1, r2, ..., rm WHERE P•Ai represents an attribute•Ri represents a relation•P is a predicate\n•The result of an SQL query is a relation\nECE30030/ITP30010 Database Systems10\nThe SELECT Clause•The SELECT clause lists the attributes desired in the result of a query•Corresponds to the projection operation of the relational algebra\n•Example: Find the names of all instructors•SQL: SELECT name FROM instructor;\nECE30030/ITP30010 Database Systems11\nNote•Note: SQL names are case insensitive•E.g., Name ≡ NAME ≡ name•SQL commands (SELECT, FROM, WHERE, …) are written in upper case (just a convention)•MySQL has an option flag, lower_case_table_names•Link: https://dev.mysql.com/doc/refman/8.0/en/identifier-case-sensitivity.html \nECE30030/ITP30010 Database Systems12\nThe SELECT Clause•SQL allows duplicates in relations as well as in query results•The keyword ALL specifies that duplicates should not be removed SELECT ALL dept_name FROM instructor\nECE30030/ITP30010 Database Systems13\nThe SELECT Clause•SQL allows duplicates in relations as well as in query results•The keyword ALL specifies that duplicates should not be removed SELECT ALL dept_name FROM instructor•To force the elimination of duplicates, insert the keyword DISTINCT after SELECT•Find the department names of all instructor, removing duplicates: SELECT DISTINCT dept_name FROM instructor;\nECE30030/ITP30010 Database Systems14\nThe SELECT Clause•An asterisk in the select clause denotes “all attributes” SELECT * FROM instructor;•An attribute can be a literal with no FROM clause SELECT ‘437’;•Result is a table with one column and a single row with value “437”•Can give the column a name using AS: SELECT ‘437’ AS FOO\nECE30030/ITP30010 Database Systems15\nThe SELECT Clause•An attribute can be a literal with FROM clause SELECT 'A' FROM instructor•Result is a table with one column and N rows (number of tuples in the instructor table), each row with value “A”\nECE30030/ITP30010 Database Systems16\nThe SELECT Clause•The SELECT clause can contain arithmetic expressions involving the operation, +, –, *, and /, and operating on constants or attributes of tuples•The query:     SELECT ID, name, salary/12      FROM instructorwould return a relation that is the same as the instructor relation,except that the value of the attribute salary is divided by 12\n17\nThe SELECT Clause•The SELECT clause can contain arithmetic expressions involving the operation, +, –, *, and /, and operating on constants or attributes of tuples•Can rename “salary/12” using the AS clause:  SELECT ID, name, salary/12 AS monthly_salary   FROM instructor\n18\nThe WHERE Clause•The WHERE clause specifies conditions that the result must satisfy•Corresponds to the selection predicate of the relational algebra•E.g., To find all instructors in Comp. Sci. dept: SELECT name FROM instructor  WHERE dept_name = 'Comp. Sci.';\nECE30030/ITP30010 Database Systems19\nThe WHERE Clause•SQL allows the use of the logical connectives AND, OR, and NOT•The operands of the logical connectives can be expressions involving the comparison operators <, <=, >, >=, =, and <>•<> means not equal (there is no != in SQL)•Comparisons can be applied to results of arithmetic expressions•E.g., To find all instructors in Comp. Sci. with salary > 70,000: SELECT name FROM instructor WHERE dept_name = 'Comp. Sci.' AND salary > 70000;\nECE30030/ITP30010 Database Systems20\nThe WHERE Clause•SQL includes a BETWEEN comparison operator•Example: Find the names of all instructors with salary between $90,000 and $100,000 (that is, ³ $90,000 and £ $100,000)•SELECT nameFROM instructorWHERE salary BETWEEN 90000 AND 100000\nECE30030/ITP30010 Database Systems21\nThe WHERE Clause•Tuple comparison: makes comparisons per tuple•SELECT name, course_idFROM instructor, teachesWHERE (instructor.ID, dept_name) = (teaches.ID, 'Biology');\nECE30030/ITP30010 Database Systems22\nThe FROM Clause•The FROM clause lists the relations involved in the query•Corresponds to the Cartesian-product operation of the relational algebra•Find the Cartesian-product instructor × teaches SELECT * FROM instructor, teaches;•Generates every possible instructor-teaches pairs, with all attributes from both relations•For common attributes (e.g., ID), the attributes in the resulting table are renamed using the relation name (e.g., instructor.ID)\nECE30030/ITP30010 Database Systems23\nThe FROM Clause•Find the Cartesian-product instructor X teaches SELECT * FROM instructor, teaches;\n24\ninstructor.IDnamedept_namesalaryteaches.IDcourse_idsec_idsemesteryear10101SrinivasanComp. Sci.6500076766BIO-101 1Summer201712121WuFinance9000076766BIO-101 1Summer201715151MozartMusic4000076766BIO-101 1Summer201722222EinsteinPhysics9500076766BIO-101 1Summer201732343El SaidHistory6000076766BIO-101 1Summer2017… … … … … … … … …10101SrinivasanComp. Sci.6500010101CS-101 1Fall 201712121WuFinance9000010101CS-101 1Fall 201715151MozartMusic4000010101CS-101 1Fall 201722222EinsteinPhysics9500010101CS-101 1Fall 201732343El SaidHistory6000010101CS-101 1Fall 2017… … … … … … … … …… … … … … … … … …10101SrinivasanComp. Sci.6500083821CS-190 2Spring201712121WuFinance9000083821CS-190 2Spring201715151MozartMusic4000083821CS-190 2Spring2017… … … … … … … … …10101SrinivasanComp. Sci.6500010101CS-315 1Spring201812121WuFinance9000010101CS-315 1Spring201815151MozartMusic4000010101CS-315 1Spring2018… … … … … … … … …… … … … … … … … …\nImplementing JOIN•Cartesian-product is not very useful directly; but useful combined with WHERE-clause condition (selection operation in relational algebra)•Cartesian-product + selection = join•E.g., Find the names of all instructors who have taught some course and the course_id SELECT name, course_id FROM instructor , teaches WHERE instructor.ID = teaches.ID\nECE30030/ITP30010 Database Systems25\nImplementing JOIN•Cartesian-product is not very useful directly; but useful combined with WHERE-clause condition (selection operation in relational algebra)•Cartesian-product + selection = join•Find the names of all instructors in the Music department who have taught some course and the course_id SELECT name, course_id FROM instructor , teaches WHERE instructor.ID = teaches.ID  AND instructor. dept_name = 'Music'\nECE30030/ITP30010 Database Systems26\nThe Rename Operation•The SQL allows renaming relations and attributes using the AS clause:   old-name AS new-name•Find the names of all instructors who have a higher salary than some instructor in ‘Comp. Sci.’•SELECT DISTINCT T.nameFROM instructor AS T, instructor AS SWHERE T.salary > S.salary AND S.dept_name = 'Comp. Sci.'\nECE30030/ITP30010 Database Systems27\nThe Rename Operation•The SQL allows renaming relations and attributes using the AS clause:   old-name AS new-name•Find the names of all instructors who have a higher salary than some instructor in ‘Comp. Sci.’•SELECT DISTINCT T.nameFROM instructor AS T, instructor AS SWHERE T.salary > S.salary AND S.dept_name = 'Comp. Sci.'•Keyword AS is optional and may be omitted  instructor AS T  ≡  instructor T\nECE30030/ITP30010 Database Systems28"
              },
              {
                "chapter_title": "SQL DML 고급 기능: NULL 값, 집합 연산, 문자열 처리 및 정렬",
                "source_pdf_filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf",
                "chapter_content_summary": "이 장에서는 SQL DML의 고급 기능을 탐구합니다. 먼저, 알려지지 않거나 존재하지 않는 값을 나타내는 NULL 값의 특성을 이해하고, 산술 연산에서의 NULL 동작 및 IS NULL / IS NOT NULL 술어를 사용하여 NULL 값을 확인하는 방법을 배웁니다. 다음으로, 여러 쿼리 결과를 결합하는 집합 연산인 UNION, INTERSECT, EXCEPT를 살펴봅니다. 각 연산이 기본적으로 중복을 제거하며, ALL 키워드를 사용하여 중복을 유지하는 방법을 설명합니다. 특히 MySQL에서 INTERSECT와 EXCEPT가 직접 지원되지 않을 때 JOIN 또는 NOT IN을 사용하여 에뮬레이션하는 기법을 소개합니다. 이어서, 문자열 패턴 매칭을 위한 LIKE 연산자와 '%' (모든 부분 문자열), '_' (단일 문자) 특수 문자의 사용법을 다룹니다. 백슬래시를 이용한 이스케이프 문자 처리, 패턴 매칭의 대소문자 구분, 그리고 연결, 대소문자 변환, 길이 확인, 부분 문자열 추출 등 다양한 SQL 문자열 함수를 소개합니다. 마지막으로, ORDER BY 절을 사용하여 쿼리 결과를 특정 속성을 기준으로 오름차순(ASC) 또는 내림차순(DESC)으로 정렬하는 방법을 학습하며, 여러 속성을 기준으로 정렬하는 예시도 제시합니다.",
                "chapter_full_text": "ECE30030/ITP30010 Database Systems29\nNULL Values•It is possible for tuples to have a NULL value for some of their attributes•NULL signifies an unknown value or that a value does not exist•The result of any arithmetic expression involving NULL is NULL•E.g.,  5 + NULL returns NULL\nECE30030/ITP30010 Database Systems30\nIS NULL / IS NOT NULL•The predicate IS NULL can be used to check for NULL values•E.g., Find all instructors whose salary is null SELECT name FROM instructor WHERE salary IS NULL•The predicate IS NOT NULL succeeds if the value on which it is applied is not null\nECE30030/ITP30010 Database Systems31\nECE30030/ITP30010 Database Systems32\nSet Operations•Set operations UNION, INTERSECT, and EXCEPT•Each of the above operations automatically eliminates duplicates•To retain all duplicates, use ALL:•UNION ALL•INTERSECT ALL•EXCEPT ALL\n•C.f., SELECT retains all duplicates by default\nECE30030/ITP30010 Database Systems33\nSet Operations: UNION•Find courses that ran in Fall 2017 or in Spring 2018•(SELECT course_id  FROM teaches WHERE semester = 'Fall' AND year = 2017)UNION(SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018)\nECE30030/ITP30010 Database Systems34\nSet Operations: INTERSECT•Find courses that ran in Fall 2017 and in Spring 2018•(SELECT course_id  FROM teaches WHERE semester = 'Fall' AND year = 2017)INTERSECT(SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018)•C.f., MySQL does NOT support INTERSECT•One can emulate INTERSECT using JOIN (we’ll study JOIN later)•SELECT LT.course_idFROM (SELECT course_id FROM teaches WHERE semester = 'Fall' AND year = 2017) AS LTJOIN (SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018) AS RTON LT.course_id=RT.course_id;\nECE30030/ITP30010 Database Systems35\nSet Operations: EXCEPT•Find courses that ran in Fall 2017 but not in Spring 2018•(SELECT course_id  FROM teaches WHERE semester = 'Fall' AND year = 2017)EXCEPT(SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018)•C.f., MySQL does NOT support EXCEPT•One can emulate EXCEPT using NOT IN•SELECT course_id FROM teaches WHERE semester = 'Fall' AND year = 2017AND course_id NOT IN(SELECT course_id  FROM teaches  WHERE semester = 'Spring' AND year = 2018);\nECE30030/ITP30010 Database Systems36\nECE30030/ITP30010 Database Systems37\nString Operations•SQL includes a string-matching operator for comparisons on character strings•The operator LIKE uses patterns that are described using two special characters:•percent (%) – The % character matches any substring•underscore (_) – The _ character matches any character•Find the names of all instructors whose name includes the substring “ri” SELECT name FROM instructor WHERE name LIKE ‘%ri%'\nECE30030/ITP30010 Database Systems38\nString Operations•Escape character: Use backslash (\\) as the escape character•E.g., Match the string “100%” LIKE '100 \\%’ ESCAPE  ‘\\’\nECE30030/ITP30010 Database Systems39\nString Operations•Patterns are case sensitive•Pattern matching examples:•'Intro%' matches any string beginning with “Intro”•'%Comp%' matches any string containing “Comp” as a substring•'_ _ _' matches any string of exactly three characters•'_ _ _ %' matches any string of at least three characters•SQL supports a variety of string operations such as•concatenation (using “||”)•converting from upper to lower case (and vice versa)•finding string length, extracting substrings, etc.\nECE30030/ITP30010 Database Systems40\nOrdering the Display of Tuples•List in alphabetic order the names of all instructors•SELECT DISTINCT nameFROM instructorORDER BY name\nECE30030/ITP30010 Database Systems41\nOrdering the Display of Tuples•Can sort on multiple attributes•E.g., SELECT dept_name, name     FROM instructor      ORDER BY dept_name, name\nECE30030/ITP30010 Database Systems42\nOrdering the Display of Tuples•We may specify DESC for descending order or ASC for ascending order, for each attribute; ascending order is the default•E.g., ORDER BY name DESC\nECE30030/ITP30010 Database Systems43"
              },
              {
                "chapter_title": "SQL DML 집계 함수 및 데이터 수정 (INSERT, UPDATE, DELETE)",
                "source_pdf_filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf",
                "chapter_content_summary": "이 장에서는 SQL 데이터 조작 언어(DML)의 고급 기능인 집계 함수와 데이터를 수정하는 명령어를 다룹니다. AVG, MIN, MAX, SUM, COUNT와 같은 집계 함수를 사용하여 컬럼 값의 멀티셋에 대한 통계 값을 계산하는 방법을 학습합니다. 특히 GROUP BY 절을 이용한 데이터 그룹화와 HAVING 절을 이용한 그룹별 필터링을 심층적으로 다루며, WHERE 절과의 차이점을 명확히 설명합니다. 또한, DML의 핵심 명령인 INSERT, UPDATE, DELETE에 대해 자세히 알아봅니다. INSERT 명령을 통해 테이블에 새로운 튜플을 추가하는 다양한 방법(모든 컬럼, 선택된 컬럼, NULL 값 처리, SELECT 쿼리 결과 삽입)과 외래 키 제약 조건의 중요성을 강조합니다. UPDATE 명령으로는 기존 데이터를 수정하는 기본 구문, 조건부 업데이트, CASE 문을 사용한 복잡한 조건 처리, 스칼라 서브쿼리 활용법을 배웁니다. 마지막으로 DELETE 명령을 통해 테이블에서 특정 행 또는 모든 행을 삭제하는 방법과 TRUNCATE 명령의 차이점, 그리고 삭제 시 서브쿼리 사용 시의 고려사항을 설명합니다.",
                "chapter_full_text": "ECE30030/ITP30010 Database Systems44\nAggregate Functions•These functions operate on the multiset of values of a column of a relation, and return a value•AVG:  average value•MIN:  minimum value•MAX:  maximum value•SUM:  sum of values•COUNT:  number of values\nECE30030/ITP30010 Database Systems45\nAggregate Functions Examples•Find the average salary of instructors in the Computer Science department•SELECT AVG(salary)FROM instructorWHERE dept_name= 'Comp. Sci.';•Find the total number of instructors who teach a course in the Spring 2018 semester•SELECT COUNT(DISTINCT ID)FROM teachesWHERE semester = 'Spring’ AND year = 2018;•Find the number of tuples in the teaches relation•SELECT COUNT (*)FROM teaches;\nECE30030/ITP30010 Database Systems46\nAggregate Functions: Group By•Find the average salary of instructors in each department•SELECT dept_name, AVG(salary) AS avg_salaryFROM instructorGROUP BY dept_name;\nECE30030/ITP30010 Database Systems47\nAggregation•Attributes in SELECT clause outside of aggregate functions must appear in GROUP BY list•/* erroneous query */SELECT dept_name, ID, AVG(salary)FROM instructorGROUP BY dept_name;\nECE30030/ITP30010 Database Systems48\nAggregate Functions – Having Clause•Find the names and average salaries of all departments whose average salary is greater than 65000•SELECT dept_name, AVG(salary) AS avg_salaryFROM instructorGROUP BY dept_nameHAVING AVG(salary) > 65000;\nECE30030/ITP30010 Database Systems49\nAggregate Functions – Having Clause•Note: predicates in the HAVING clause are applied after the formation of groups whereas predicates in the WHERE clause are applied before forming groups\nECE30030/ITP30010 Database Systems50\nSELECT dept_name, AVG(salary) AS avg_salaryFROM instructorGROUP BY dept_nameHAVING AVG(salary) > 65000;\nSELECT dept_name, AVG(salary) AS avg_salaryFROM instructorWHERE salary > 65000GROUP BY dept_name;\nSQL Commands\nSQLDMLSELECTINSERTUPDATEDELETE\nDDLCREATEALTERDROP\nECE30030/ITP30010 Database Systems51\nINSERT•Basic syntax•Insert data into every column:•INSERT INTO tablenameVALUES (col1_value, col2_value, …)•Must list values in the same order as in the table schema•If some data values are unknown, must type NULL •For character sequences, use quotation marks•Single quotation marks are preferred (but double quotation marks are allowed)•Value in quotations is case-sensitive•Insert data into selected columns•INSERT INTO tablename (col1_name, col3_name, col4_name, …)VALUES (col1_value, col3_value, col4_value, …)\nECE30030/ITP30010 Database Systems52\nINSERT•Add a new tuple to course•INSERT INTO courseVALUES ('CS-437', 'Database Systems', 'Comp. Sci.', 4);•or equivalently•INSERT INTO course (course_id, title, dept_name, credits)VALUES ('CS-437', 'Database Systems', 'Comp. Sci.', 4);•Add a new tuple to student  with tot_creds set to null•INSERT INTO studentVALUES ('3003', 'Green', 'Finance', null);\nECE30030/ITP30010 Database Systems53\nINSERT•A foreign key specifies that an attribute from one relation has to map to a tuple in another relation•Value in one relation must appear in another relation\nECE30030/ITP30010 Database Systems54\nRelation: instructor\nRelation: department\nINSERT•A foreign key specifies that an attribute from one relation has to map to a tuple in another relation•Value in one relation must appear in another relation•Make sure all foreign keys that new row references have already been added to database•One cannot insert a foreign key value unless the corresponding value exists in the referenced relation\nECE30030/ITP30010 Database Systems55\nINSERT•Inserting results of other SELECT query•Make each student in the Music department who has earned more than 144 credit hours an instructor in the Music department with a salary of  $18,000•INSERT INTO instructor  SELECT ID, name, dept_name, 18000  FROM student   WHERE dept_name = 'Music’ AND total_cred > 144;•The SELECT FROM WHERE statement is evaluated fully before any of its results are inserted into the relation•Otherwise queries like  INSERT INTO table1 SELECT * FROM table1would cause problem\nECE30030/ITP30010 Database Systems56\nUPDATE•Basic syntax•Updating a table•UPDATE tablenameSET col1_name = new_col1_value, col2_name = new_col2_value, …;•Updating a table with conditions•UPDATE tablenameSET col1_name = new_col1_value, col2_name = new_col2_value, …WHERE predicate;\nECE30030/ITP30010 Database Systems57\nUPDATE•Give a 5% salary raise to all instructors•UPDATE instructorSET salary = salary * 1.05•Give a 5% salary raise to those instructors who earn less than 70000•UPDATE instructorSET salary = salary * 1.05WHERE salary < 70000;•Give a 5% salary raise to instructors whose salary is less than average•UPDATE instructorSET salary = salary * 1.05WHERE salary <  (SELECT AVG(salary) FROM instructor);\nECE30030/ITP30010 Database Systems58\nUPDATE•Increase salaries of instructors whose salary is over $100,000 by 3%, and all others by a 5%•Write two UPDATE statements:  UPDATE instructor  SET salary = salary * 1.03  WHERE salary > 100000;  UPDATE instructor  SET salary = salary * 1.05  WHERE salary <= 100000;•The order is important•Can be done better using the case statement (next slide)\nECE30030/ITP30010 Database Systems59\nCASE Statement for Conditional Update•The following query is equivalent to the previous UPDATE queries•UPDATE instructorSET salary = CASE                           WHEN salary <= 100000 THEN salary * 1.05                           ELSE salary * 1.03                       END\nECE30030/ITP30010 Database Systems60\nUPDATE with Scalar Subqueries•Recompute and update tot_creds value for all students•UPDATE student SSET tot_cred = (SELECT SUM(credits)                             FROM takes, course                             WHERE takes.course_id = course.course_id  AND                                            S.ID= takes.ID  AND                                            takes.grade <> 'F' AND                                            takes.grade IS NOT NULL);\nECE30030/ITP30010 Database Systems61\nDELETE•Basic syntax•To remove specific rows•DELETE FROM tablenameWHERE predicate;•To remove all rows•DELETE FROM tablename;•This is equivalent to TRUNCATE:TRUNCATE (TABLE) tablename;•One cannot truncate a table with foreign key constraints•Must disable the constraints first (we will cover ALTER when we study SQL DDL):ALTER TABLE tablenameDISABLE CONSTRAINT constraint_name;\nECE30030/ITP30010 Database Systems62\nDELETE•Delete all instructors•DELETE FROM instructor;•Delete all instructors from the Finance department•DELETE FROM instructorWHERE dept_name= 'Finance';•Delete all tuples in the instructor relation for those instructors associated with a department located in the Watson building•DELETE FROM instructorWHERE dept name IN (SELECT dept name        FROM department        WHERE building = 'Watson');\nECE30030/ITP30010 Database Systems63\nDELETE•Delete all instructors whose salary is less than the average salary of instructors•Example:  DELETE FROM instructor                WHERE salary < (SELECT AVG (salary)                  FROM instructor);•Issue:  as we delete tuples from instructor, the average salary changes•Solution used in SQL:1.First, compute AVG(salary) and find all tuples to delete2.Next, delete all tuples found above (without recomputing AVG or retesting the tuples)\nECE30030/ITP30010 Database Systems64"
              }
            ],
            "generated_content": [],
            "final_result": ""
          }
        },
        {
          "node": "start_processing",
          "status": "completed",
          "state_snapshot": {
            "run_id": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d",
            "pdf_file_paths": [
              "temp_pdf_uploads/cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_1a4c2f45-b482-4e82-826e-fa8945eb99c7_DB03 - mysql.pdf",
              "temp_pdf_uploads/cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf"
            ],
            "notebook_title": "",
            "holistic_chapters": [],
            "generated_content": [],
            "final_result": ""
          }
        },
        {
          "node": "start_processing",
          "status": "completed",
          "state_snapshot": {
            "run_id": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d",
            "pdf_file_paths": [
              "temp_pdf_uploads/cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_1a4c2f45-b482-4e82-826e-fa8945eb99c7_DB03 - mysql.pdf",
              "temp_pdf_uploads/cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf"
            ],
            "notebook_title": "",
            "holistic_chapters": [],
            "generated_content": [],
            "final_result": ""
          }
        },
        {
          "node": "analyze_overall_structure",
          "status": "completed",
          "state_snapshot": {
            "run_id": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d",
            "pdf_file_paths": [
              "temp_pdf_uploads/cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_1a4c2f45-b482-4e82-826e-fa8945eb99c7_DB03 - mysql.pdf",
              "temp_pdf_uploads/cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf"
            ],
            "notebook_title": "관계형 데이터베이스 시스템: MySQL 소개 및 SQL 심층 활용",
            "holistic_chapters": [
              {
                "chapter_title": "관계형 데이터베이스 시스템(R-DBMS) 개요 및 MySQL 소개",
                "source_pdf_filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_1a4c2f45-b482-4e82-826e-fa8945eb99c7_DB03 - mysql.pdf",
                "chapter_content_summary": "이 장에서는 관계형 데이터베이스 관리 시스템(R-DBMS)의 기본 개념을 소개하고, 대표적인 오픈소스 R-DBMS인 MySQL에 대해 심층적으로 다룹니다. MySQL의 정의, Oracle 소유권, 표준 SQL 호환성, 상업적 웹 서비스에서의 활용 사례, 기업 사용 통계, 그리고 MySQL의 인기 요인(다양한 운영체제 및 프로그래밍 언어 지원, 비용 효율성, 고성능)을 설명합니다. 또한, R-DBMS 시장에서의 MySQL의 트렌드와 인기도를 살펴보고, MySQL 5.x와 8.x 버전의 주요 차이점 및 MySQL 커뮤니티 버전을 다운로드하고 Docker 이미지를 활용하는 방법을 안내합니다. MySQL이 대규모 데이터 처리, 다중 사용자 지원, 효율성, 안정성, 보안성 측면에서 갖는 강점들을 강조합니다.",
                "chapter_full_text": "ECE30030/ITP30010 Database SystemsHandshaking with an R-DBMSCharmgil Hongcharmgil@handong.eduSpring, 2025Handong Global University\n1\nAgenda•Introduction to MySQL•SQL preview\nECE30030/ITP30010 Database Systems2\nMySQL•MySQL is an SQL-based relational database management system (DBMS)•Free and open-source R-DBMS (under GPL)•Owned by Oracle•Commercial version of MySQL is also provided (including technical support)•“My” came from the name of co-founder Michael Widenius’ daughter•C.f., MariaDB•Compatible with standard SQL•Frequently used for commercial web services\nECE30030/ITP30010 Database Systems3\n* Image src: https://en.wikipedia.org/wiki/MySQL\nMySQL•Companies using MySQL (a study by Enlyft)•“We have data on 199,498 (out of 1,409,176) companies that use MySQL”•Often used by companies with 10-50 employees and 1M-10M dollars in revenue•C.f., Oracle 12 is most often used by companies with 50-200 employees and >1000M dollars in revenue\nECE30030/ITP30010 Database Systems4* Source: https://enlyft.com/tech/products/mysql \nMySQL•Companies using MySQL (full list: https://www.mysql.com/customers/)\nECE30030/ITP30010 Database Systems5\n* Source: https://stackshare.io/mysql \nMySQL•Why MySQL?•Popular•Active discussions all over the Internet•Versatile: runs on Linux, Windows, Mac OS X, Solaris, FreeBSD, …•Supports wide range of programming languages (C/C++, Java, Python, .Net, …)•Cost starts from zero•High performance (fast and reliable)\nECE30030/ITP30010 Database Systems6* Image src: https://db-engines.com/en/ranking\nDBMS Trend Popularity\n•Score definition: https://db-engines.com/en/ranking_definition\nECE30030/ITP30010 Database Systems7* Image src: https://db-engines.com/en/ranking_trend \nMySQL•Why MySQL?•Popular•Active discussions all over the Internet•Versatile: runs on Linux, Windows, Mac OS X, Solaris, FreeBSD, …•Supports wide range of programming languages (C/C++, Java, Python, .Net, …)•Cost starts from zero•High performance (fast and reliable)\nECE30030/ITP30010 Database Systems8* Image src: https://dev.mysql.com/downloads/\nMySQL\nECE30030/ITP30010 Database Systems9\n•Massive•Convenient•Multi-user•Safe•Efficient•Reliable\nCan handle terabytes of dataSupports high-level query languageSupports concurrent data accessSupports transactionsCan handle thousands of queries/second99.99% up-time in many real-world products\nMySQL Versions•MySQL 5.x vs 8.x\nECE30030/ITP30010 Database Systems10\nVersion 5.x-Most popular version of MySQL-More stable and conventionalVersion 8.x-Current version-Provides up-to-date DB functionalities (better storage engine, faster, more secure)\n* Source: https://www.eversql.com/mysql-8-adoption-usage-rate/#:~:text=MySQL%205.7%20is%20still%20the,17%25%20are%20using%20MySQL%208. \nMySQL Versions•MySQL 5.x vs 8.x\nECE30030/ITP30010 Database Systems11\nVersion 5.x-Most popular version of MySQL-More stable and conventionalVersion 8.x-Current version-Provides up-to-date DB functionalities (better storage engine, faster, more secure)\n* Source: https://severalnines.com/database-blog/mysql-performance-benchmarking-mysql-57-vs-mysql-80 \nMySQL Versions•MySQL 5.x vs 8.x\nECE30030/ITP30010 Database Systems12\nVersion 5.x-Most popular version of MySQL-More stable and conventionalVersion 8.x-Current version-Provides up-to-date DB functionalities (better storage engine, faster, more secure)\n* Source: https://severalnines.com/database-blog/mysql-performance-benchmarking-mysql-57-vs-mysql-80 \nWhere to Get MySQL?•https://dev.mysql.com/downloads/•Look for the “Community” versions – the branch that is available for free•”Enterprise” versions are the commercial ones•We have prepared a Docker image for the course•Consists of Ubuntu Server, MySQL, example databases for course activities\nECE30030/ITP30010 Database Systems13* Image src: https://www.docker.com \nWhere to Get MySQL?\nECE30030/ITP30010 Database Systems14\n* Image source: https://baumannalexj.medium.com/connect-your-db-tool-to-a-dockerized-mysql-server-container-bc18853524ed   https://www.jetbrains.com/datagrip/features/look_and_feel.html"
              },
              {
                "chapter_title": "SQL(구조적 질의어)의 이해: 기본 개념과 역사",
                "source_pdf_filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf",
                "chapter_content_summary": "SQL(Structured Query Language)의 정의와 관계형 데이터베이스를 조작하는 주된 언어로서의 역할을 설명합니다. SQL이 '무엇을 할지'를 명시하는 고수준 언어이며, DBMS가 '어떻게 할지'를 결정하는 쿼리 최적화 과정을 다룹니다. 또한, SQL의 두 가지 주요 측면인 데이터 정의 언어(DDL)와 데이터 조작 언어(DML)를 소개하고, 무결성, 뷰 정의, 트랜잭션 제어, 내장 SQL 및 동적 SQL, 권한 부여와 같은 SQL의 다양한 구성 요소를 살펴봅니다. 마지막으로, IBM SEQUEL에서 시작하여 Oracle V2를 거쳐 ANSI 및 ISO 표준으로 발전한 SQL의 간략한 역사를 소개하고, 기본적인 SQL 쿼리 구조(SELECT, FROM, WHERE)를 설명합니다.",
                "chapter_full_text": "ECE30030/ITP30010 Database SystemsStructured Query LanguageReading: Chapter 3\nCharmgil Hongcharmgil@handong.eduSpring, 2025Handong Global University\n1\nAgenda•Structured query language (SQL)•SQL data manipulation language (DML)•SELECT, FROM, WHERE•NULL values•Set operations•String operations, ordering•Aggregate functions, aggregation•SQL data definition language (DDL)   --   NEXT CLASS\nECE30030/ITP30010 Database Systems2\nStructured Query Language (SQL)•SQL: Structured Query Language•The principal language used to describe and manipulate relational databases•Very high-level•Say “what to do” rather than “how to do it”•SQL is not specifying data-manipulation details•DBMSs figure out the “best” way to execute queries•Called “query optimization”•Two aspects to SQL•Data definition: for declaring database schemas (DDL)•Data manipulation: for querying (asking questions about) databases and for modifying the database (DML)\nECE30030/ITP30010 Database Systems3\nSQL Parts•DML – provides the ability to query information from the database and to insert tuples into, delete tuples from, and modify tuples in the database•Integrity – the DDL includes commands for specifying integrity constraints•View definition – the DDL includes commands for defining views•Transaction control – includes commands for specifying the beginning and ending of transactions•Embedded SQL and dynamic SQL – define how SQL statements can be embedded within general-purpose programming language•Authorization – includes commands for specifying access rights to relations and viewsECE30030/ITP30010 Database Systems4\nA Brief History•IBM SEQUEL (Structured English Query Language) was developed as a part of the System R project (Chamberlin and Boyce, early 1970s)•Later on, SEQUEL was renamed SQL (structured query language)•System R à System/38 (1979), SQL/DS (1981), DB2 (1983)•Relational Software, Inc released the first commercial implementation of SQL, Oracle V2 for VAX computers•Relational Software, Inc is now Oracle Corporation•ANSI and ISO standardized SQL:•SQL-86,  SQL-89,  SQL-92,  SQL:1999,  …,  SQL:2011,  SQL:2016 (current)•SQL-92 is supported by the most of database systems\nECE30030/ITP30010 Database Systems5\nBasic Query Structure•A typical SQL query has the form:   SELECT A1, A2, ..., An FROM r1, r2, ..., rm WHERE P•Ai represents an attribute•Ri represents a relation•P is a predicate\n•The result of an SQL query is a relation\nECE30030/ITP30010 Database Systems6"
              },
              {
                "chapter_title": "SQL 데이터 조작 언어(DML) 기초: SELECT, FROM, WHERE 절",
                "source_pdf_filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf",
                "chapter_content_summary": "이 장에서는 SQL 데이터 조작 언어(DML)의 핵심 구성 요소인 SELECT, FROM, WHERE 절을 상세히 다룹니다. 'instructor' 및 'teaches'와 같은 예시 관계(테이블)를 사용하여 실제 쿼리 작성 방법을 시연합니다. SELECT 절을 통해 원하는 속성을 선택하고, 중복을 포함하거나 제거하는 방법(ALL, DISTINCT), 모든 속성을 선택하는 '*' 사용법, 리터럴 및 산술 표현식 활용, 그리고 AS 키워드를 사용한 속성 이름 변경 방법을 학습합니다. WHERE 절에서는 논리 연산자(AND, OR, NOT) 및 비교 연산자(<, <=, >, >=, =, <>, BETWEEN)를 사용하여 조건을 지정하고, 튜플 비교를 수행하는 방법을 설명합니다. 마지막으로 FROM 절을 통해 쿼리에 포함될 관계를 지정하고, 카르테시안 곱을 이해하며, WHERE 절과 결합하여 JOIN 연산을 구현하는 방법을 구체적인 예시와 함께 제시합니다. 또한, AS 키워드를 이용한 관계 및 속성 이름 변경(별칭 지정)을 다룹니다.",
                "chapter_full_text": "ECE30030/ITP30010 Database Systems7\nSQL Data Manipulation Language•The SQL data-manipulation language (DML) allows querying (ask questions about) and modifying the databases\nECE30030/ITP30010 Database Systems8\nRunning Examples•Relations (tables): instructor, teaches\nECE30030/ITP30010 Database Systems9\nInstructor relationteaches relation\nBasic Query Structure•A typical SQL query has the form:   SELECT A1, A2, ..., An FROM r1, r2, ..., rm WHERE P•Ai represents an attribute•Ri represents a relation•P is a predicate\n•The result of an SQL query is a relation\nECE30030/ITP30010 Database Systems10\nThe SELECT Clause•The SELECT clause lists the attributes desired in the result of a query•Corresponds to the projection operation of the relational algebra\n•Example: Find the names of all instructors•SQL: SELECT name FROM instructor;\nECE30030/ITP30010 Database Systems11\nNote•Note: SQL names are case insensitive•E.g., Name ≡ NAME ≡ name•SQL commands (SELECT, FROM, WHERE, …) are written in upper case (just a convention)•MySQL has an option flag, lower_case_table_names•Link: https://dev.mysql.com/doc/refman/8.0/en/identifier-case-sensitivity.html \nECE30030/ITP30010 Database Systems12\nThe SELECT Clause•SQL allows duplicates in relations as well as in query results•The keyword ALL specifies that duplicates should not be removed SELECT ALL dept_name FROM instructor\nECE30030/ITP30010 Database Systems13\nThe SELECT Clause•SQL allows duplicates in relations as well as in query results•The keyword ALL specifies that duplicates should not be removed SELECT ALL dept_name FROM instructor•To force the elimination of duplicates, insert the keyword DISTINCT after SELECT•Find the department names of all instructor, removing duplicates: SELECT DISTINCT dept_name FROM instructor;\nECE30030/ITP30010 Database Systems14\nThe SELECT Clause•An asterisk in the select clause denotes “all attributes” SELECT * FROM instructor;•An attribute can be a literal with no FROM clause SELECT ‘437’;•Result is a table with one column and a single row with value “437”•Can give the column a name using AS: SELECT ‘437’ AS FOO\nECE30030/ITP30010 Database Systems15\nThe SELECT Clause•An attribute can be a literal with FROM clause SELECT 'A' FROM instructor•Result is a table with one column and N rows (number of tuples in the instructor table), each row with value “A”\nECE30030/ITP30010 Database Systems16\nThe SELECT Clause•The SELECT clause can contain arithmetic expressions involving the operation, +, –, *, and /, and operating on constants or attributes of tuples•The query:     SELECT ID, name, salary/12      FROM instructorwould return a relation that is the same as the instructor relation,except that the value of the attribute salary is divided by 12\n17\nThe SELECT Clause•The SELECT clause can contain arithmetic expressions involving the operation, +, –, *, and /, and operating on constants or attributes of tuples•Can rename “salary/12” using the AS clause:  SELECT ID, name, salary/12 AS monthly_salary   FROM instructor\n18\nThe WHERE Clause•The WHERE clause specifies conditions that the result must satisfy•Corresponds to the selection predicate of the relational algebra•E.g., To find all instructors in Comp. Sci. dept: SELECT name FROM instructor  WHERE dept_name = 'Comp. Sci.';\nECE30030/ITP30010 Database Systems19\nThe WHERE Clause•SQL allows the use of the logical connectives AND, OR, and NOT•The operands of the logical connectives can be expressions involving the comparison operators <, <=, >, >=, =, and <>•<> means not equal (there is no != in SQL)•Comparisons can be applied to results of arithmetic expressions•E.g., To find all instructors in Comp. Sci. with salary > 70,000: SELECT name FROM instructor WHERE dept_name = 'Comp. Sci.' AND salary > 70000;\nECE30030/ITP30010 Database Systems20\nThe WHERE Clause•SQL includes a BETWEEN comparison operator•Example: Find the names of all instructors with salary between $90,000 and $100,000 (that is, ³ $90,000 and £ $100,000)•SELECT nameFROM instructorWHERE salary BETWEEN 90000 AND 100000\nECE30030/ITP30010 Database Systems21\nThe WHERE Clause•Tuple comparison: makes comparisons per tuple•SELECT name, course_idFROM instructor, teachesWHERE (instructor.ID, dept_name) = (teaches.ID, 'Biology');\nECE30030/ITP30010 Database Systems22\nThe FROM Clause•The FROM clause lists the relations involved in the query•Corresponds to the Cartesian-product operation of the relational algebra•Find the Cartesian-product instructor × teaches SELECT * FROM instructor, teaches;•Generates every possible instructor-teaches pairs, with all attributes from both relations•For common attributes (e.g., ID), the attributes in the resulting table are renamed using the relation name (e.g., instructor.ID)\nECE30030/ITP30010 Database Systems23\nThe FROM Clause•Find the Cartesian-product instructor X teaches SELECT * FROM instructor, teaches;\n24\ninstructor.IDnamedept_namesalaryteaches.IDcourse_idsec_idsemesteryear10101SrinivasanComp. Sci.6500076766BIO-101 1Summer201712121WuFinance9000076766BIO-101 1Summer201715151MozartMusic4000076766BIO-101 1Summer201722222EinsteinPhysics9500076766BIO-101 1Summer201732343El SaidHistory6000076766BIO-101 1Summer2017… … … … … … … … …10101SrinivasanComp. Sci.6500010101CS-101 1Fall 201712121WuFinance9000010101CS-101 1Fall 201715151MozartMusic4000010101CS-101 1Fall 201722222EinsteinPhysics9500010101CS-101 1Fall 201732343El SaidHistory6000010101CS-101 1Fall 2017… … … … … … … … …… … … … … … … … …10101SrinivasanComp. Sci.6500083821CS-190 2Spring201712121WuFinance9000083821CS-190 2Spring201715151MozartMusic4000083821CS-190 2Spring2017… … … … … … … … …10101SrinivasanComp. Sci.6500010101CS-315 1Spring201812121WuFinance9000010101CS-315 1Spring201815151MozartMusic4000010101CS-315 1Spring2018… … … … … … … … …… … … … … … … … …\nImplementing JOIN•Cartesian-product is not very useful directly; but useful combined with WHERE-clause condition (selection operation in relational algebra)•Cartesian-product + selection = join•E.g., Find the names of all instructors who have taught some course and the course_id SELECT name, course_id FROM instructor , teaches WHERE instructor.ID = teaches.ID\nECE30030/ITP30010 Database Systems25\nImplementing JOIN•Cartesian-product is not very useful directly; but useful combined with WHERE-clause condition (selection operation in relational algebra)•Cartesian-product + selection = join•Find the names of all instructors in the Music department who have taught some course and the course_id SELECT name, course_id FROM instructor , teaches WHERE instructor.ID = teaches.ID  AND instructor. dept_name = 'Music'\nECE30030/ITP30010 Database Systems26\nThe Rename Operation•The SQL allows renaming relations and attributes using the AS clause:   old-name AS new-name•Find the names of all instructors who have a higher salary than some instructor in ‘Comp. Sci.’•SELECT DISTINCT T.nameFROM instructor AS T, instructor AS SWHERE T.salary > S.salary AND S.dept_name = 'Comp. Sci.'\nECE30030/ITP30010 Database Systems27\nThe Rename Operation•The SQL allows renaming relations and attributes using the AS clause:   old-name AS new-name•Find the names of all instructors who have a higher salary than some instructor in ‘Comp. Sci.’•SELECT DISTINCT T.nameFROM instructor AS T, instructor AS SWHERE T.salary > S.salary AND S.dept_name = 'Comp. Sci.'•Keyword AS is optional and may be omitted  instructor AS T  ≡  instructor T\nECE30030/ITP30010 Database Systems28"
              },
              {
                "chapter_title": "SQL DML 고급 기능: NULL 값, 집합 연산, 문자열 처리 및 정렬",
                "source_pdf_filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf",
                "chapter_content_summary": "이 장에서는 SQL DML의 고급 기능을 탐구합니다. 먼저, 알려지지 않거나 존재하지 않는 값을 나타내는 NULL 값의 특성을 이해하고, 산술 연산에서의 NULL 동작 및 IS NULL / IS NOT NULL 술어를 사용하여 NULL 값을 확인하는 방법을 배웁니다. 다음으로, 여러 쿼리 결과를 결합하는 집합 연산인 UNION, INTERSECT, EXCEPT를 살펴봅니다. 각 연산이 기본적으로 중복을 제거하며, ALL 키워드를 사용하여 중복을 유지하는 방법을 설명합니다. 특히 MySQL에서 INTERSECT와 EXCEPT가 직접 지원되지 않을 때 JOIN 또는 NOT IN을 사용하여 에뮬레이션하는 기법을 소개합니다. 이어서, 문자열 패턴 매칭을 위한 LIKE 연산자와 '%' (모든 부분 문자열), '_' (단일 문자) 특수 문자의 사용법을 다룹니다. 백슬래시를 이용한 이스케이프 문자 처리, 패턴 매칭의 대소문자 구분, 그리고 연결, 대소문자 변환, 길이 확인, 부분 문자열 추출 등 다양한 SQL 문자열 함수를 소개합니다. 마지막으로, ORDER BY 절을 사용하여 쿼리 결과를 특정 속성을 기준으로 오름차순(ASC) 또는 내림차순(DESC)으로 정렬하는 방법을 학습하며, 여러 속성을 기준으로 정렬하는 예시도 제시합니다.",
                "chapter_full_text": "ECE30030/ITP30010 Database Systems29\nNULL Values•It is possible for tuples to have a NULL value for some of their attributes•NULL signifies an unknown value or that a value does not exist•The result of any arithmetic expression involving NULL is NULL•E.g.,  5 + NULL returns NULL\nECE30030/ITP30010 Database Systems30\nIS NULL / IS NOT NULL•The predicate IS NULL can be used to check for NULL values•E.g., Find all instructors whose salary is null SELECT name FROM instructor WHERE salary IS NULL•The predicate IS NOT NULL succeeds if the value on which it is applied is not null\nECE30030/ITP30010 Database Systems31\nECE30030/ITP30010 Database Systems32\nSet Operations•Set operations UNION, INTERSECT, and EXCEPT•Each of the above operations automatically eliminates duplicates•To retain all duplicates, use ALL:•UNION ALL•INTERSECT ALL•EXCEPT ALL\n•C.f., SELECT retains all duplicates by default\nECE30030/ITP30010 Database Systems33\nSet Operations: UNION•Find courses that ran in Fall 2017 or in Spring 2018•(SELECT course_id  FROM teaches WHERE semester = 'Fall' AND year = 2017)UNION(SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018)\nECE30030/ITP30010 Database Systems34\nSet Operations: INTERSECT•Find courses that ran in Fall 2017 and in Spring 2018•(SELECT course_id  FROM teaches WHERE semester = 'Fall' AND year = 2017)INTERSECT(SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018)•C.f., MySQL does NOT support INTERSECT•One can emulate INTERSECT using JOIN (we’ll study JOIN later)•SELECT LT.course_idFROM (SELECT course_id FROM teaches WHERE semester = 'Fall' AND year = 2017) AS LTJOIN (SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018) AS RTON LT.course_id=RT.course_id;\nECE30030/ITP30010 Database Systems35\nSet Operations: EXCEPT•Find courses that ran in Fall 2017 but not in Spring 2018•(SELECT course_id  FROM teaches WHERE semester = 'Fall' AND year = 2017)EXCEPT(SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018)•C.f., MySQL does NOT support EXCEPT•One can emulate EXCEPT using NOT IN•SELECT course_id FROM teaches WHERE semester = 'Fall' AND year = 2017AND course_id NOT IN(SELECT course_id  FROM teaches  WHERE semester = 'Spring' AND year = 2018);\nECE30030/ITP30010 Database Systems36\nECE30030/ITP30010 Database Systems37\nString Operations•SQL includes a string-matching operator for comparisons on character strings•The operator LIKE uses patterns that are described using two special characters:•percent (%) – The % character matches any substring•underscore (_) – The _ character matches any character•Find the names of all instructors whose name includes the substring “ri” SELECT name FROM instructor WHERE name LIKE ‘%ri%'\nECE30030/ITP30010 Database Systems38\nString Operations•Escape character: Use backslash (\\) as the escape character•E.g., Match the string “100%” LIKE '100 \\%’ ESCAPE  ‘\\’\nECE30030/ITP30010 Database Systems39\nString Operations•Patterns are case sensitive•Pattern matching examples:•'Intro%' matches any string beginning with “Intro”•'%Comp%' matches any string containing “Comp” as a substring•'_ _ _' matches any string of exactly three characters•'_ _ _ %' matches any string of at least three characters•SQL supports a variety of string operations such as•concatenation (using “||”)•converting from upper to lower case (and vice versa)•finding string length, extracting substrings, etc.\nECE30030/ITP30010 Database Systems40\nOrdering the Display of Tuples•List in alphabetic order the names of all instructors•SELECT DISTINCT nameFROM instructorORDER BY name\nECE30030/ITP30010 Database Systems41\nOrdering the Display of Tuples•Can sort on multiple attributes•E.g., SELECT dept_name, name     FROM instructor      ORDER BY dept_name, name\nECE30030/ITP30010 Database Systems42\nOrdering the Display of Tuples•We may specify DESC for descending order or ASC for ascending order, for each attribute; ascending order is the default•E.g., ORDER BY name DESC\nECE30030/ITP30010 Database Systems43"
              },
              {
                "chapter_title": "SQL DML 집계 함수 및 데이터 수정 (INSERT, UPDATE, DELETE)",
                "source_pdf_filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf",
                "chapter_content_summary": "이 장에서는 SQL 데이터 조작 언어(DML)의 고급 기능인 집계 함수와 데이터를 수정하는 명령어를 다룹니다. AVG, MIN, MAX, SUM, COUNT와 같은 집계 함수를 사용하여 컬럼 값의 멀티셋에 대한 통계 값을 계산하는 방법을 학습합니다. 특히 GROUP BY 절을 이용한 데이터 그룹화와 HAVING 절을 이용한 그룹별 필터링을 심층적으로 다루며, WHERE 절과의 차이점을 명확히 설명합니다. 또한, DML의 핵심 명령인 INSERT, UPDATE, DELETE에 대해 자세히 알아봅니다. INSERT 명령을 통해 테이블에 새로운 튜플을 추가하는 다양한 방법(모든 컬럼, 선택된 컬럼, NULL 값 처리, SELECT 쿼리 결과 삽입)과 외래 키 제약 조건의 중요성을 강조합니다. UPDATE 명령으로는 기존 데이터를 수정하는 기본 구문, 조건부 업데이트, CASE 문을 사용한 복잡한 조건 처리, 스칼라 서브쿼리 활용법을 배웁니다. 마지막으로 DELETE 명령을 통해 테이블에서 특정 행 또는 모든 행을 삭제하는 방법과 TRUNCATE 명령의 차이점, 그리고 삭제 시 서브쿼리 사용 시의 고려사항을 설명합니다.",
                "chapter_full_text": "ECE30030/ITP30010 Database Systems44\nAggregate Functions•These functions operate on the multiset of values of a column of a relation, and return a value•AVG:  average value•MIN:  minimum value•MAX:  maximum value•SUM:  sum of values•COUNT:  number of values\nECE30030/ITP30010 Database Systems45\nAggregate Functions Examples•Find the average salary of instructors in the Computer Science department•SELECT AVG(salary)FROM instructorWHERE dept_name= 'Comp. Sci.';•Find the total number of instructors who teach a course in the Spring 2018 semester•SELECT COUNT(DISTINCT ID)FROM teachesWHERE semester = 'Spring’ AND year = 2018;•Find the number of tuples in the teaches relation•SELECT COUNT (*)FROM teaches;\nECE30030/ITP30010 Database Systems46\nAggregate Functions: Group By•Find the average salary of instructors in each department•SELECT dept_name, AVG(salary) AS avg_salaryFROM instructorGROUP BY dept_name;\nECE30030/ITP30010 Database Systems47\nAggregation•Attributes in SELECT clause outside of aggregate functions must appear in GROUP BY list•/* erroneous query */SELECT dept_name, ID, AVG(salary)FROM instructorGROUP BY dept_name;\nECE30030/ITP30010 Database Systems48\nAggregate Functions – Having Clause•Find the names and average salaries of all departments whose average salary is greater than 65000•SELECT dept_name, AVG(salary) AS avg_salaryFROM instructorGROUP BY dept_nameHAVING AVG(salary) > 65000;\nECE30030/ITP30010 Database Systems49\nAggregate Functions – Having Clause•Note: predicates in the HAVING clause are applied after the formation of groups whereas predicates in the WHERE clause are applied before forming groups\nECE30030/ITP30010 Database Systems50\nSELECT dept_name, AVG(salary) AS avg_salaryFROM instructorGROUP BY dept_nameHAVING AVG(salary) > 65000;\nSELECT dept_name, AVG(salary) AS avg_salaryFROM instructorWHERE salary > 65000GROUP BY dept_name;\nSQL Commands\nSQLDMLSELECTINSERTUPDATEDELETE\nDDLCREATEALTERDROP\nECE30030/ITP30010 Database Systems51\nINSERT•Basic syntax•Insert data into every column:•INSERT INTO tablenameVALUES (col1_value, col2_value, …)•Must list values in the same order as in the table schema•If some data values are unknown, must type NULL •For character sequences, use quotation marks•Single quotation marks are preferred (but double quotation marks are allowed)•Value in quotations is case-sensitive•Insert data into selected columns•INSERT INTO tablename (col1_name, col3_name, col4_name, …)VALUES (col1_value, col3_value, col4_value, …)\nECE30030/ITP30010 Database Systems52\nINSERT•Add a new tuple to course•INSERT INTO courseVALUES ('CS-437', 'Database Systems', 'Comp. Sci.', 4);•or equivalently•INSERT INTO course (course_id, title, dept_name, credits)VALUES ('CS-437', 'Database Systems', 'Comp. Sci.', 4);•Add a new tuple to student  with tot_creds set to null•INSERT INTO studentVALUES ('3003', 'Green', 'Finance', null);\nECE30030/ITP30010 Database Systems53\nINSERT•A foreign key specifies that an attribute from one relation has to map to a tuple in another relation•Value in one relation must appear in another relation\nECE30030/ITP30010 Database Systems54\nRelation: instructor\nRelation: department\nINSERT•A foreign key specifies that an attribute from one relation has to map to a tuple in another relation•Value in one relation must appear in another relation•Make sure all foreign keys that new row references have already been added to database•One cannot insert a foreign key value unless the corresponding value exists in the referenced relation\nECE30030/ITP30010 Database Systems55\nINSERT•Inserting results of other SELECT query•Make each student in the Music department who has earned more than 144 credit hours an instructor in the Music department with a salary of  $18,000•INSERT INTO instructor  SELECT ID, name, dept_name, 18000  FROM student   WHERE dept_name = 'Music’ AND total_cred > 144;•The SELECT FROM WHERE statement is evaluated fully before any of its results are inserted into the relation•Otherwise queries like  INSERT INTO table1 SELECT * FROM table1would cause problem\nECE30030/ITP30010 Database Systems56\nUPDATE•Basic syntax•Updating a table•UPDATE tablenameSET col1_name = new_col1_value, col2_name = new_col2_value, …;•Updating a table with conditions•UPDATE tablenameSET col1_name = new_col1_value, col2_name = new_col2_value, …WHERE predicate;\nECE30030/ITP30010 Database Systems57\nUPDATE•Give a 5% salary raise to all instructors•UPDATE instructorSET salary = salary * 1.05•Give a 5% salary raise to those instructors who earn less than 70000•UPDATE instructorSET salary = salary * 1.05WHERE salary < 70000;•Give a 5% salary raise to instructors whose salary is less than average•UPDATE instructorSET salary = salary * 1.05WHERE salary <  (SELECT AVG(salary) FROM instructor);\nECE30030/ITP30010 Database Systems58\nUPDATE•Increase salaries of instructors whose salary is over $100,000 by 3%, and all others by a 5%•Write two UPDATE statements:  UPDATE instructor  SET salary = salary * 1.03  WHERE salary > 100000;  UPDATE instructor  SET salary = salary * 1.05  WHERE salary <= 100000;•The order is important•Can be done better using the case statement (next slide)\nECE30030/ITP30010 Database Systems59\nCASE Statement for Conditional Update•The following query is equivalent to the previous UPDATE queries•UPDATE instructorSET salary = CASE                           WHEN salary <= 100000 THEN salary * 1.05                           ELSE salary * 1.03                       END\nECE30030/ITP30010 Database Systems60\nUPDATE with Scalar Subqueries•Recompute and update tot_creds value for all students•UPDATE student SSET tot_cred = (SELECT SUM(credits)                             FROM takes, course                             WHERE takes.course_id = course.course_id  AND                                            S.ID= takes.ID  AND                                            takes.grade <> 'F' AND                                            takes.grade IS NOT NULL);\nECE30030/ITP30010 Database Systems61\nDELETE•Basic syntax•To remove specific rows•DELETE FROM tablenameWHERE predicate;•To remove all rows•DELETE FROM tablename;•This is equivalent to TRUNCATE:TRUNCATE (TABLE) tablename;•One cannot truncate a table with foreign key constraints•Must disable the constraints first (we will cover ALTER when we study SQL DDL):ALTER TABLE tablenameDISABLE CONSTRAINT constraint_name;\nECE30030/ITP30010 Database Systems62\nDELETE•Delete all instructors•DELETE FROM instructor;•Delete all instructors from the Finance department•DELETE FROM instructorWHERE dept_name= 'Finance';•Delete all tuples in the instructor relation for those instructors associated with a department located in the Watson building•DELETE FROM instructorWHERE dept name IN (SELECT dept name        FROM department        WHERE building = 'Watson');\nECE30030/ITP30010 Database Systems63\nDELETE•Delete all instructors whose salary is less than the average salary of instructors•Example:  DELETE FROM instructor                WHERE salary < (SELECT AVG (salary)                  FROM instructor);•Issue:  as we delete tuples from instructor, the average salary changes•Solution used in SQL:1.First, compute AVG(salary) and find all tuples to delete2.Next, delete all tuples found above (without recomputing AVG or retesting the tuples)\nECE30030/ITP30010 Database Systems64"
              }
            ],
            "generated_content": [],
            "final_result": ""
          }
        },
        {
          "node": "generate_chapter_content",
          "status": "completed",
          "state_snapshot": {
            "run_id": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d",
            "pdf_file_paths": [
              "temp_pdf_uploads/cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_1a4c2f45-b482-4e82-826e-fa8945eb99c7_DB03 - mysql.pdf",
              "temp_pdf_uploads/cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf"
            ],
            "all_pdf_texts": [
              {
                "filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_1a4c2f45-b482-4e82-826e-fa8945eb99c7_DB03 - mysql.pdf",
                "text": "ECE30030/ITP30010 Database SystemsHandshaking with an R-DBMSCharmgil Hongcharmgil@handong.eduSpring, 2025Handong Global University\n1\n\nAgenda•Introduction to MySQL•SQL preview\nECE30030/ITP30010 Database Systems2\nMySQL•MySQL is an SQL-based relational database management system (DBMS)•Free and open-source R-DBMS (under GPL)•Owned by Oracle•Commercial version of MySQL is also provided (including technical support)•“My” came from the name of co-founder Michael Widenius’ daughter•C.f., MariaDB•Compatible with standard SQL•Frequently used for commercial web services\nECE30030/ITP30010 Database Systems3\n* Image src: https://en.wikipedia.org/wiki/MySQL\nMySQL•Companies using MySQL (a study by Enlyft)•“We have data on 199,498 (out of 1,409,176) companies that use MySQL”•Often used by companies with 10-50 employees and 1M-10M dollars in revenue•C.f., Oracle 12 is most often used by companies with 50-200 employees and >1000M dollars in revenue\nECE30030/ITP30010 Database Systems4* Source: https://enlyft.com/tech/products/mysql \n\nMySQL•Companies using MySQL (full list: https://www.mysql.com/customers/)\nECE30030/ITP30010 Database Systems5\n* Source: https://stackshare.io/mysql \nMySQL•Why MySQL?•Popular•Active discussions all over the Internet•Versatile: runs on Linux, Windows, Mac OS X, Solaris, FreeBSD, …•Supports wide range of programming languages (C/C++, Java, Python, .Net, …)•Cost starts from zero•High performance (fast and reliable)\nECE30030/ITP30010 Database Systems6* Image src: https://db-engines.com/en/ranking\n\nDBMS Trend Popularity\n•Score definition: https://db-engines.com/en/ranking_definition\nECE30030/ITP30010 Database Systems7* Image src: https://db-engines.com/en/ranking_trend \n\nMySQL•Why MySQL?•Popular•Active discussions all over the Internet•Versatile: runs on Linux, Windows, Mac OS X, Solaris, FreeBSD, …•Supports wide range of programming languages (C/C++, Java, Python, .Net, …)•Cost starts from zero•High performance (fast and reliable)\nECE30030/ITP30010 Database Systems8* Image src: https://dev.mysql.com/downloads/\n\nMySQL\nECE30030/ITP30010 Database Systems9\n•Massive•Convenient•Multi-user•Safe•Efficient•Reliable\nCan handle terabytes of dataSupports high-level query languageSupports concurrent data accessSupports transactionsCan handle thousands of queries/second99.99% up-time in many real-world products\nMySQL Versions•MySQL 5.x vs 8.x\nECE30030/ITP30010 Database Systems10\nVersion 5.x-Most popular version of MySQL-More stable and conventionalVersion 8.x-Current version-Provides up-to-date DB functionalities (better storage engine, faster, more secure)\n* Source: https://www.eversql.com/mysql-8-adoption-usage-rate/#:~:text=MySQL%205.7%20is%20still%20the,17%25%20are%20using%20MySQL%208. \nMySQL Versions•MySQL 5.x vs 8.x\nECE30030/ITP30010 Database Systems11\nVersion 5.x-Most popular version of MySQL-More stable and conventionalVersion 8.x-Current version-Provides up-to-date DB functionalities (better storage engine, faster, more secure)\n* Source: https://severalnines.com/database-blog/mysql-performance-benchmarking-mysql-57-vs-mysql-80 \n\nMySQL Versions•MySQL 5.x vs 8.x\nECE30030/ITP30010 Database Systems12\nVersion 5.x-Most popular version of MySQL-More stable and conventionalVersion 8.x-Current version-Provides up-to-date DB functionalities (better storage engine, faster, more secure)\n* Source: https://severalnines.com/database-blog/mysql-performance-benchmarking-mysql-57-vs-mysql-80 \n\nWhere to Get MySQL?•https://dev.mysql.com/downloads/•Look for the “Community” versions – the branch that is available for free•”Enterprise” versions are the commercial ones•We have prepared a Docker image for the course•Consists of Ubuntu Server, MySQL, example databases for course activities\nECE30030/ITP30010 Database Systems13* Image src: https://www.docker.com \n\nWhere to Get MySQL?\nECE30030/ITP30010 Database Systems14\n* Image source: https://baumannalexj.medium.com/connect-your-db-tool-to-a-dockerized-mysql-server-container-bc18853524ed   https://www.jetbrains.com/datagrip/features/look_and_feel.html\n\nAgenda•Introduction to MySQL•SQL preview\nECE30030/ITP30010 Database Systems15\nStructured Query Language (SQL)•SQL: Structured Query Language•The principal language used to describe and manipulate relational databases•Very high-level•Say “what to do” rather than “how to do it”•SQL is not specifying data-manipulation details•DBMSs figure out the “best” way to execute queries•Called “query optimization”•Two aspects to SQL•Data definition: for declaring database schemas (DDL)•Data manipulation: for querying (asking questions about) databases and for modifying the database (DML)\nECE30030/ITP30010 Database Systems16\nSQL Parts•DML – provides the ability to query information from the database and to insert tuples into, delete tuples from, and modify tuples in the database•Integrity – the DDL includes commands for specifying integrity constraints•Vide definition – the DDL includes commands for defining views•Transaction control – includes commands for specifying the beginning and ending of transactions•Embedded SQL and dynamic SQL – define how SQL statements can be embedded within general-purpose programming language•Authorization – includes commands for specifying access rights to relations and viewsECE30030/ITP30010 Database Systems17\nA Brief History•IBM SEQUEL (Structured English Query Language) was developed as a part of the System R project (Chamberlin and Boyce, early 1970s)•Later on, SEQUEL was renamed SQL (structured query language)•System R à System/38 (1979), SQL/DS (1981), DB2 (1983)•Relational Software, Inc released the first commercial implementation of SQL, Oracle V2 for VAX computers•Relational Software, Inc is now Oracle Corporation•ANSI and ISO standardized SQL:•SQL-86,  SQL-89,  SQL-92,  SQL:1999,  …,  SQL:2011,  SQL:2016 (current)•SQL-92 is supported by the most of database systems\nECE30030/ITP30010 Database Systems18\nBasic Query Structure•A typical SQL query has the form:   SELECT A1, A2, ..., An FROM r1, r2, ..., rm WHERE P•Ai represents an attribute•Ri represents a relation•P is a predicate\n•The result of an SQL query is a relation\nECE30030/ITP30010 Database Systems19\nEOF•Coming next:•Structured Query Language\nECE30030/ITP30010 Database Systems20"
              },
              {
                "filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf",
                "text": "ECE30030/ITP30010 Database SystemsStructured Query LanguageReading: Chapter 3\nCharmgil Hongcharmgil@handong.eduSpring, 2025Handong Global University\n1\n\nAgenda•Structured query language (SQL)•SQL data manipulation language (DML)•SELECT, FROM, WHERE•NULL values•Set operations•String operations, ordering•Aggregate functions, aggregation•SQL data definition language (DDL)   --   NEXT CLASS\nECE30030/ITP30010 Database Systems2\nStructured Query Language (SQL)•SQL: Structured Query Language•The principal language used to describe and manipulate relational databases•Very high-level•Say “what to do” rather than “how to do it”•SQL is not specifying data-manipulation details•DBMSs figure out the “best” way to execute queries•Called “query optimization”•Two aspects to SQL•Data definition: for declaring database schemas (DDL)•Data manipulation: for querying (asking questions about) databases and for modifying the database (DML)\nECE30030/ITP30010 Database Systems3\nSQL Parts•DML – provides the ability to query information from the database and to insert tuples into, delete tuples from, and modify tuples in the database•Integrity – the DDL includes commands for specifying integrity constraints•View definition – the DDL includes commands for defining views•Transaction control – includes commands for specifying the beginning and ending of transactions•Embedded SQL and dynamic SQL – define how SQL statements can be embedded within general-purpose programming language•Authorization – includes commands for specifying access rights to relations and viewsECE30030/ITP30010 Database Systems4\nA Brief History•IBM SEQUEL (Structured English Query Language) was developed as a part of the System R project (Chamberlin and Boyce, early 1970s)•Later on, SEQUEL was renamed SQL (structured query language)•System R à System/38 (1979), SQL/DS (1981), DB2 (1983)•Relational Software, Inc released the first commercial implementation of SQL, Oracle V2 for VAX computers•Relational Software, Inc is now Oracle Corporation•ANSI and ISO standardized SQL:•SQL-86,  SQL-89,  SQL-92,  SQL:1999,  …,  SQL:2011,  SQL:2016 (current)•SQL-92 is supported by the most of database systems\nECE30030/ITP30010 Database Systems5\nBasic Query Structure•A typical SQL query has the form:   SELECT A1, A2, ..., An FROM r1, r2, ..., rm WHERE P•Ai represents an attribute•Ri represents a relation•P is a predicate\n•The result of an SQL query is a relation\nECE30030/ITP30010 Database Systems6\nAgenda•Structured query language (SQL)•SQL data manipulation language (DML)•SELECT, FROM, WHERE•NULL values•Set operations•String operations, ordering•Aggregate functions, aggregation•SQL data definition language (DDL)\nECE30030/ITP30010 Database Systems7\nSQL Data Manipulation Language•The SQL data-manipulation language (DML) allows querying (ask questions about) and modifying the databases\nECE30030/ITP30010 Database Systems8\nRunning Examples•Relations (tables): instructor, teaches\nECE30030/ITP30010 Database Systems9\nInstructor relationteaches relation\nBasic Query Structure•A typical SQL query has the form:   SELECT A1, A2, ..., An FROM r1, r2, ..., rm WHERE P•Ai represents an attribute•Ri represents a relation•P is a predicate\n•The result of an SQL query is a relation\nECE30030/ITP30010 Database Systems10\nThe SELECT Clause•The SELECT clause lists the attributes desired in the result of a query•Corresponds to the projection operation of the relational algebra\n•Example: Find the names of all instructors•SQL: SELECT name FROM instructor;\nECE30030/ITP30010 Database Systems11\n\nNote•Note: SQL names are case insensitive•E.g., Name ≡ NAME ≡ name•SQL commands (SELECT, FROM, WHERE, …) are written in upper case (just a convention)•MySQL has an option flag, lower_case_table_names•Link: https://dev.mysql.com/doc/refman/8.0/en/identifier-case-sensitivity.html \nECE30030/ITP30010 Database Systems12\nThe SELECT Clause•SQL allows duplicates in relations as well as in query results•The keyword ALL specifies that duplicates should not be removed SELECT ALL dept_name FROM instructor\nECE30030/ITP30010 Database Systems13\n\nThe SELECT Clause•SQL allows duplicates in relations as well as in query results•The keyword ALL specifies that duplicates should not be removed SELECT ALL dept_name FROM instructor•To force the elimination of duplicates, insert the keyword DISTINCT after SELECT•Find the department names of all instructor, removing duplicates: SELECT DISTINCT dept_name FROM instructor;\nECE30030/ITP30010 Database Systems14\n\nThe SELECT Clause•An asterisk in the select clause denotes “all attributes” SELECT * FROM instructor;•An attribute can be a literal with no FROM clause SELECT ‘437’;•Result is a table with one column and a single row with value “437”•Can give the column a name using AS: SELECT ‘437’ AS FOO\nECE30030/ITP30010 Database Systems15\n\nThe SELECT Clause•An attribute can be a literal with FROM clause SELECT 'A' FROM instructor•Result is a table with one column and N rows (number of tuples in the instructor table), each row with value “A”\nECE30030/ITP30010 Database Systems16\n\nThe SELECT Clause•The SELECT clause can contain arithmetic expressions involving the operation, +, –, *, and /, and operating on constants or attributes of tuples•The query:     SELECT ID, name, salary/12      FROM instructorwould return a relation that is the same as the instructor relation,except that the value of the attribute salary is divided by 12\n17\n\nThe SELECT Clause•The SELECT clause can contain arithmetic expressions involving the operation, +, –, *, and /, and operating on constants or attributes of tuples•Can rename “salary/12” using the AS clause:  SELECT ID, name, salary/12 AS monthly_salary   FROM instructor\n18\n\nThe WHERE Clause•The WHERE clause specifies conditions that the result must satisfy•Corresponds to the selection predicate of the relational algebra•E.g., To find all instructors in Comp. Sci. dept: SELECT name FROM instructor  WHERE dept_name = 'Comp. Sci.';\nECE30030/ITP30010 Database Systems19\n\nThe WHERE Clause•SQL allows the use of the logical connectives AND, OR, and NOT•The operands of the logical connectives can be expressions involving the comparison operators <, <=, >, >=, =, and <>•<> means not equal (there is no != in SQL)•Comparisons can be applied to results of arithmetic expressions•E.g., To find all instructors in Comp. Sci. with salary > 70,000: SELECT name FROM instructor WHERE dept_name = 'Comp. Sci.' AND salary > 70000;\nECE30030/ITP30010 Database Systems20\n\nThe WHERE Clause•SQL includes a BETWEEN comparison operator•Example: Find the names of all instructors with salary between $90,000 and $100,000 (that is, ³ $90,000 and £ $100,000)•SELECT nameFROM instructorWHERE salary BETWEEN 90000 AND 100000\nECE30030/ITP30010 Database Systems21\n\nThe WHERE Clause•Tuple comparison: makes comparisons per tuple•SELECT name, course_idFROM instructor, teachesWHERE (instructor.ID, dept_name) = (teaches.ID, 'Biology');\nECE30030/ITP30010 Database Systems22\n\nThe FROM Clause•The FROM clause lists the relations involved in the query•Corresponds to the Cartesian-product operation of the relational algebra•Find the Cartesian-product instructor × teaches SELECT * FROM instructor, teaches;•Generates every possible instructor-teaches pairs, with all attributes from both relations•For common attributes (e.g., ID), the attributes in the resulting table are renamed using the relation name (e.g., instructor.ID)\nECE30030/ITP30010 Database Systems23\nThe FROM Clause•Find the Cartesian-product instructor X teaches SELECT * FROM instructor, teaches;\n24\ninstructor.IDnamedept_namesalaryteaches.IDcourse_idsec_idsemesteryear10101SrinivasanComp. Sci.6500076766BIO-101 1Summer201712121WuFinance9000076766BIO-101 1Summer201715151MozartMusic4000076766BIO-101 1Summer201722222EinsteinPhysics9500076766BIO-101 1Summer201732343El SaidHistory6000076766BIO-101 1Summer2017… … … … … … … … …10101SrinivasanComp. Sci.6500010101CS-101 1Fall 201712121WuFinance9000010101CS-101 1Fall 201715151MozartMusic4000010101CS-101 1Fall 201722222EinsteinPhysics9500010101CS-101 1Fall 201732343El SaidHistory6000010101CS-101 1Fall 2017… … … … … … … … …… … … … … … … … …10101SrinivasanComp. Sci.6500083821CS-190 2Spring201712121WuFinance9000083821CS-190 2Spring201715151MozartMusic4000083821CS-190 2Spring2017… … … … … … … … …10101SrinivasanComp. Sci.6500010101CS-315 1Spring201812121WuFinance9000010101CS-315 1Spring201815151MozartMusic4000010101CS-315 1Spring2018… … … … … … … … …… … … … … … … … …\nImplementing JOIN•Cartesian-product is not very useful directly; but useful combined with WHERE-clause condition (selection operation in relational algebra)•Cartesian-product + selection = join•E.g., Find the names of all instructors who have taught some course and the course_id SELECT name, course_id FROM instructor , teaches WHERE instructor.ID = teaches.ID\nECE30030/ITP30010 Database Systems25\n\nImplementing JOIN•Cartesian-product is not very useful directly; but useful combined with WHERE-clause condition (selection operation in relational algebra)•Cartesian-product + selection = join•Find the names of all instructors in the Music department who have taught some course and the course_id SELECT name, course_id FROM instructor , teaches WHERE instructor.ID = teaches.ID  AND instructor. dept_name = 'Music'\nECE30030/ITP30010 Database Systems26\n\nThe Rename Operation•The SQL allows renaming relations and attributes using the AS clause:   old-name AS new-name•Find the names of all instructors who have a higher salary than some instructor in ‘Comp. Sci.’•SELECT DISTINCT T.nameFROM instructor AS T, instructor AS SWHERE T.salary > S.salary AND S.dept_name = 'Comp. Sci.'\nECE30030/ITP30010 Database Systems27\n\nThe Rename Operation•The SQL allows renaming relations and attributes using the AS clause:   old-name AS new-name•Find the names of all instructors who have a higher salary than some instructor in ‘Comp. Sci.’•SELECT DISTINCT T.nameFROM instructor AS T, instructor AS SWHERE T.salary > S.salary AND S.dept_name = 'Comp. Sci.'•Keyword AS is optional and may be omitted  instructor AS T  ≡  instructor T\nECE30030/ITP30010 Database Systems28\nAgenda•Structured query language (SQL)•SQL data manipulation language (DML)•SELECT, FROM, WHERE•NULL values•Set operations•String operations, ordering•Aggregate functions, aggregation•SQL data definition language (DDL)\nECE30030/ITP30010 Database Systems29\nNULL Values•It is possible for tuples to have a NULL value for some of their attributes•NULL signifies an unknown value or that a value does not exist•The result of any arithmetic expression involving NULL is NULL•E.g.,  5 + NULL returns NULL\nECE30030/ITP30010 Database Systems30\nIS NULL / IS NOT NULL•The predicate IS NULL can be used to check for NULL values•E.g., Find all instructors whose salary is null SELECT name FROM instructor WHERE salary IS NULL•The predicate IS NOT NULL succeeds if the value on which it is applied is not null\nECE30030/ITP30010 Database Systems31\nAgenda•Structured query language (SQL)•SQL data manipulation language (DML)•SELECT, FROM, WHERE•NULL values•Set operations•String operations, ordering•Aggregate functions, aggregation•SQL data definition language (DDL)\nECE30030/ITP30010 Database Systems32\nSet Operations•Set operations UNION, INTERSECT, and EXCEPT•Each of the above operations automatically eliminates duplicates•To retain all duplicates, use ALL:•UNION ALL•INTERSECT ALL•EXCEPT ALL\n•C.f., SELECT retains all duplicates by default\nECE30030/ITP30010 Database Systems33\nSet Operations: UNION•Find courses that ran in Fall 2017 or in Spring 2018•(SELECT course_id  FROM teaches WHERE semester = 'Fall' AND year = 2017)UNION(SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018)\nECE30030/ITP30010 Database Systems34\n\nSet Operations: INTERSECT•Find courses that ran in Fall 2017 and in Spring 2018•(SELECT course_id  FROM teaches WHERE semester = 'Fall' AND year = 2017)INTERSECT(SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018)•C.f., MySQL does NOT support INTERSECT•One can emulate INTERSECT using JOIN (we’ll study JOIN later)•SELECT LT.course_idFROM (SELECT course_id FROM teaches WHERE semester = 'Fall' AND year = 2017) AS LTJOIN (SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018) AS RTON LT.course_id=RT.course_id;\nECE30030/ITP30010 Database Systems35\n\nSet Operations: EXCEPT•Find courses that ran in Fall 2017 but not in Spring 2018•(SELECT course_id  FROM teaches WHERE semester = 'Fall' AND year = 2017)EXCEPT(SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018)•C.f., MySQL does NOT support EXCEPT•One can emulate EXCEPT using NOT IN•SELECT course_id FROM teaches WHERE semester = 'Fall' AND year = 2017AND course_id NOT IN(SELECT course_id  FROM teaches  WHERE semester = 'Spring' AND year = 2018);\nECE30030/ITP30010 Database Systems36\n\nAgenda•Structured query language (SQL)•SQL data manipulation language (DML)•SELECT, FROM, WHERE•NULL values•Set operations•String operations, ordering•Aggregate functions, aggregation•SQL data definition language (DDL)\nECE30030/ITP30010 Database Systems37\nString Operations•SQL includes a string-matching operator for comparisons on character strings•The operator LIKE uses patterns that are described using two special characters:•percent (%) – The % character matches any substring•underscore (_) – The _ character matches any character•Find the names of all instructors whose name includes the substring “ri” SELECT name FROM instructor WHERE name LIKE ‘%ri%'\nECE30030/ITP30010 Database Systems38\n\nString Operations•Escape character: Use backslash (\\) as the escape character•E.g., Match the string “100%” LIKE '100 \\%’ ESCAPE  ‘\\’\nECE30030/ITP30010 Database Systems39\nString Operations•Patterns are case sensitive•Pattern matching examples:•'Intro%' matches any string beginning with “Intro”•'%Comp%' matches any string containing “Comp” as a substring•'_ _ _' matches any string of exactly three characters•'_ _ _ %' matches any string of at least three characters•SQL supports a variety of string operations such as•concatenation (using “||”)•converting from upper to lower case (and vice versa)•finding string length, extracting substrings, etc.\nECE30030/ITP30010 Database Systems40\nOrdering the Display of Tuples•List in alphabetic order the names of all instructors•SELECT DISTINCT nameFROM instructorORDER BY name\nECE30030/ITP30010 Database Systems41\n\nOrdering the Display of Tuples•Can sort on multiple attributes•E.g., SELECT dept_name, name     FROM instructor      ORDER BY dept_name, name\nECE30030/ITP30010 Database Systems42\n\nOrdering the Display of Tuples•We may specify DESC for descending order or ASC for ascending order, for each attribute; ascending order is the default•E.g., ORDER BY name DESC\nECE30030/ITP30010 Database Systems43\n\nAgenda•Structured query language (SQL)•SQL data manipulation language (DML)•SELECT, FROM, WHERE•NULL values•Set operations•String operations, ordering•Aggregate functions, aggregation•SQL data definition language (DDL)\nECE30030/ITP30010 Database Systems44\nAggregate Functions•These functions operate on the multiset of values of a column of a relation, and return a value•AVG:  average value•MIN:  minimum value•MAX:  maximum value•SUM:  sum of values•COUNT:  number of values\nECE30030/ITP30010 Database Systems45\nAggregate Functions Examples•Find the average salary of instructors in the Computer Science department•SELECT AVG(salary)FROM instructorWHERE dept_name= 'Comp. Sci.';•Find the total number of instructors who teach a course in the Spring 2018 semester•SELECT COUNT(DISTINCT ID)FROM teachesWHERE semester = 'Spring’ AND year = 2018;•Find the number of tuples in the teaches relation•SELECT COUNT (*)FROM teaches;\nECE30030/ITP30010 Database Systems46\n\nAggregate Functions: Group By•Find the average salary of instructors in each department•SELECT dept_name, AVG(salary) AS avg_salaryFROM instructorGROUP BY dept_name;\nECE30030/ITP30010 Database Systems47\n\nAggregation•Attributes in SELECT clause outside of aggregate functions must appear in GROUP BY list•/* erroneous query */SELECT dept_name, ID, AVG(salary)FROM instructorGROUP BY dept_name;\nECE30030/ITP30010 Database Systems48\n\nAggregate Functions – Having Clause•Find the names and average salaries of all departments whose average salary is greater than 65000•SELECT dept_name, AVG(salary) AS avg_salaryFROM instructorGROUP BY dept_nameHAVING AVG(salary) > 65000;\nECE30030/ITP30010 Database Systems49\n\nAggregate Functions – Having Clause•Note: predicates in the HAVING clause are applied after the formation of groups whereas predicates in the WHERE clause are applied before forming groups\nECE30030/ITP30010 Database Systems50\nSELECT dept_name, AVG(salary) AS avg_salaryFROM instructorGROUP BY dept_nameHAVING AVG(salary) > 65000;\nSELECT dept_name, AVG(salary) AS avg_salaryFROM instructorWHERE salary > 65000GROUP BY dept_name;\n\nSQL Commands\nSQLDMLSELECTINSERTUPDATEDELETE\nDDLCREATEALTERDROP\nECE30030/ITP30010 Database Systems51\nINSERT•Basic syntax•Insert data into every column:•INSERT INTO tablenameVALUES (col1_value, col2_value, …)•Must list values in the same order as in the table schema•If some data values are unknown, must type NULL •For character sequences, use quotation marks•Single quotation marks are preferred (but double quotation marks are allowed)•Value in quotations is case-sensitive•Insert data into selected columns•INSERT INTO tablename (col1_name, col3_name, col4_name, …)VALUES (col1_value, col3_value, col4_value, …)\nECE30030/ITP30010 Database Systems52\nINSERT•Add a new tuple to course•INSERT INTO courseVALUES ('CS-437', 'Database Systems', 'Comp. Sci.', 4);•or equivalently•INSERT INTO course (course_id, title, dept_name, credits)VALUES ('CS-437', 'Database Systems', 'Comp. Sci.', 4);•Add a new tuple to student  with tot_creds set to null•INSERT INTO studentVALUES ('3003', 'Green', 'Finance', null);\nECE30030/ITP30010 Database Systems53\nINSERT•A foreign key specifies that an attribute from one relation has to map to a tuple in another relation•Value in one relation must appear in another relation\nECE30030/ITP30010 Database Systems54\nRelation: instructor\nRelation: department\nINSERT•A foreign key specifies that an attribute from one relation has to map to a tuple in another relation•Value in one relation must appear in another relation•Make sure all foreign keys that new row references have already been added to database•One cannot insert a foreign key value unless the corresponding value exists in the referenced relation\nECE30030/ITP30010 Database Systems55\nINSERT•Inserting results of other SELECT query•Make each student in the Music department who has earned more than 144 credit hours an instructor in the Music department with a salary of  $18,000•INSERT INTO instructor  SELECT ID, name, dept_name, 18000  FROM student   WHERE dept_name = 'Music’ AND total_cred > 144;•The SELECT FROM WHERE statement is evaluated fully before any of its results are inserted into the relation•Otherwise queries like  INSERT INTO table1 SELECT * FROM table1would cause problem\nECE30030/ITP30010 Database Systems56\nUPDATE•Basic syntax•Updating a table•UPDATE tablenameSET col1_name = new_col1_value, col2_name = new_col2_value, …;•Updating a table with conditions•UPDATE tablenameSET col1_name = new_col1_value, col2_name = new_col2_value, …WHERE predicate;\nECE30030/ITP30010 Database Systems57\nUPDATE•Give a 5% salary raise to all instructors•UPDATE instructorSET salary = salary * 1.05•Give a 5% salary raise to those instructors who earn less than 70000•UPDATE instructorSET salary = salary * 1.05WHERE salary < 70000;•Give a 5% salary raise to instructors whose salary is less than average•UPDATE instructorSET salary = salary * 1.05WHERE salary <  (SELECT AVG(salary) FROM instructor);\nECE30030/ITP30010 Database Systems58\nUPDATE•Increase salaries of instructors whose salary is over $100,000 by 3%, and all others by a 5%•Write two UPDATE statements:  UPDATE instructor  SET salary = salary * 1.03  WHERE salary > 100000;  UPDATE instructor  SET salary = salary * 1.05  WHERE salary <= 100000;•The order is important•Can be done better using the case statement (next slide)\nECE30030/ITP30010 Database Systems59\nCASE Statement for Conditional Update•The following query is equivalent to the previous UPDATE queries•UPDATE instructorSET salary = CASE                           WHEN salary <= 100000 THEN salary * 1.05                           ELSE salary * 1.03                       END\nECE30030/ITP30010 Database Systems60\nUPDATE with Scalar Subqueries•Recompute and update tot_creds value for all students•UPDATE student SSET tot_cred = (SELECT SUM(credits)                             FROM takes, course                             WHERE takes.course_id = course.course_id  AND                                            S.ID= takes.ID  AND                                            takes.grade <> 'F' AND                                            takes.grade IS NOT NULL);\nECE30030/ITP30010 Database Systems61\nDELETE•Basic syntax•To remove specific rows•DELETE FROM tablenameWHERE predicate;•To remove all rows•DELETE FROM tablename;•This is equivalent to TRUNCATE:TRUNCATE (TABLE) tablename;•One cannot truncate a table with foreign key constraints•Must disable the constraints first (we will cover ALTER when we study SQL DDL):ALTER TABLE tablenameDISABLE CONSTRAINT constraint_name;\nECE30030/ITP30010 Database Systems62\nDELETE•Delete all instructors•DELETE FROM instructor;•Delete all instructors from the Finance department•DELETE FROM instructorWHERE dept_name= 'Finance';•Delete all tuples in the instructor relation for those instructors associated with a department located in the Watson building•DELETE FROM instructorWHERE dept name IN (SELECT dept name        FROM department        WHERE building = 'Watson');\nECE30030/ITP30010 Database Systems63\nDELETE•Delete all instructors whose salary is less than the average salary of instructors•Example:  DELETE FROM instructor                WHERE salary < (SELECT AVG (salary)                  FROM instructor);•Issue:  as we delete tuples from instructor, the average salary changes•Solution used in SQL:1.First, compute AVG(salary) and find all tuples to delete2.Next, delete all tuples found above (without recomputing AVG or retesting the tuples)\nECE30030/ITP30010 Database Systems64\nEOF•Coming next:•More on Structured Query Language\nECE30030/ITP30010 Database Systems65"
              }
            ],
            "notebook_title": "관계형 데이터베이스 시스템: MySQL 소개 및 SQL 심층 활용",
            "holistic_chapters": [
              {
                "chapter_title": "관계형 데이터베이스 시스템(R-DBMS) 개요 및 MySQL 소개",
                "source_pdf_filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_1a4c2f45-b482-4e82-826e-fa8945eb99c7_DB03 - mysql.pdf",
                "chapter_content_summary": "이 장에서는 관계형 데이터베이스 관리 시스템(R-DBMS)의 기본 개념을 소개하고, 대표적인 오픈소스 R-DBMS인 MySQL에 대해 심층적으로 다룹니다. MySQL의 정의, Oracle 소유권, 표준 SQL 호환성, 상업적 웹 서비스에서의 활용 사례, 기업 사용 통계, 그리고 MySQL의 인기 요인(다양한 운영체제 및 프로그래밍 언어 지원, 비용 효율성, 고성능)을 설명합니다. 또한, R-DBMS 시장에서의 MySQL의 트렌드와 인기도를 살펴보고, MySQL 5.x와 8.x 버전의 주요 차이점 및 MySQL 커뮤니티 버전을 다운로드하고 Docker 이미지를 활용하는 방법을 안내합니다. MySQL이 대규모 데이터 처리, 다중 사용자 지원, 효율성, 안정성, 보안성 측면에서 갖는 강점들을 강조합니다.",
                "chapter_full_text": "ECE30030/ITP30010 Database SystemsHandshaking with an R-DBMSCharmgil Hongcharmgil@handong.eduSpring, 2025Handong Global University\n1\nAgenda•Introduction to MySQL•SQL preview\nECE30030/ITP30010 Database Systems2\nMySQL•MySQL is an SQL-based relational database management system (DBMS)•Free and open-source R-DBMS (under GPL)•Owned by Oracle•Commercial version of MySQL is also provided (including technical support)•“My” came from the name of co-founder Michael Widenius’ daughter•C.f., MariaDB•Compatible with standard SQL•Frequently used for commercial web services\nECE30030/ITP30010 Database Systems3\n* Image src: https://en.wikipedia.org/wiki/MySQL\nMySQL•Companies using MySQL (a study by Enlyft)•“We have data on 199,498 (out of 1,409,176) companies that use MySQL”•Often used by companies with 10-50 employees and 1M-10M dollars in revenue•C.f., Oracle 12 is most often used by companies with 50-200 employees and >1000M dollars in revenue\nECE30030/ITP30010 Database Systems4* Source: https://enlyft.com/tech/products/mysql \nMySQL•Companies using MySQL (full list: https://www.mysql.com/customers/)\nECE30030/ITP30010 Database Systems5\n* Source: https://stackshare.io/mysql \nMySQL•Why MySQL?•Popular•Active discussions all over the Internet•Versatile: runs on Linux, Windows, Mac OS X, Solaris, FreeBSD, …•Supports wide range of programming languages (C/C++, Java, Python, .Net, …)•Cost starts from zero•High performance (fast and reliable)\nECE30030/ITP30010 Database Systems6* Image src: https://db-engines.com/en/ranking\nDBMS Trend Popularity\n•Score definition: https://db-engines.com/en/ranking_definition\nECE30030/ITP30010 Database Systems7* Image src: https://db-engines.com/en/ranking_trend \nMySQL•Why MySQL?•Popular•Active discussions all over the Internet•Versatile: runs on Linux, Windows, Mac OS X, Solaris, FreeBSD, …•Supports wide range of programming languages (C/C++, Java, Python, .Net, …)•Cost starts from zero•High performance (fast and reliable)\nECE30030/ITP30010 Database Systems8* Image src: https://dev.mysql.com/downloads/\nMySQL\nECE30030/ITP30010 Database Systems9\n•Massive•Convenient•Multi-user•Safe•Efficient•Reliable\nCan handle terabytes of dataSupports high-level query languageSupports concurrent data accessSupports transactionsCan handle thousands of queries/second99.99% up-time in many real-world products\nMySQL Versions•MySQL 5.x vs 8.x\nECE30030/ITP30010 Database Systems10\nVersion 5.x-Most popular version of MySQL-More stable and conventionalVersion 8.x-Current version-Provides up-to-date DB functionalities (better storage engine, faster, more secure)\n* Source: https://www.eversql.com/mysql-8-adoption-usage-rate/#:~:text=MySQL%205.7%20is%20still%20the,17%25%20are%20using%20MySQL%208. \nMySQL Versions•MySQL 5.x vs 8.x\nECE30030/ITP30010 Database Systems11\nVersion 5.x-Most popular version of MySQL-More stable and conventionalVersion 8.x-Current version-Provides up-to-date DB functionalities (better storage engine, faster, more secure)\n* Source: https://severalnines.com/database-blog/mysql-performance-benchmarking-mysql-57-vs-mysql-80 \nMySQL Versions•MySQL 5.x vs 8.x\nECE30030/ITP30010 Database Systems12\nVersion 5.x-Most popular version of MySQL-More stable and conventionalVersion 8.x-Current version-Provides up-to-date DB functionalities (better storage engine, faster, more secure)\n* Source: https://severalnines.com/database-blog/mysql-performance-benchmarking-mysql-57-vs-mysql-80 \nWhere to Get MySQL?•https://dev.mysql.com/downloads/•Look for the “Community” versions – the branch that is available for free•”Enterprise” versions are the commercial ones•We have prepared a Docker image for the course•Consists of Ubuntu Server, MySQL, example databases for course activities\nECE30030/ITP30010 Database Systems13* Image src: https://www.docker.com \nWhere to Get MySQL?\nECE30030/ITP30010 Database Systems14\n* Image source: https://baumannalexj.medium.com/connect-your-db-tool-to-a-dockerized-mysql-server-container-bc18853524ed   https://www.jetbrains.com/datagrip/features/look_and_feel.html"
              },
              {
                "chapter_title": "SQL(구조적 질의어)의 이해: 기본 개념과 역사",
                "source_pdf_filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf",
                "chapter_content_summary": "SQL(Structured Query Language)의 정의와 관계형 데이터베이스를 조작하는 주된 언어로서의 역할을 설명합니다. SQL이 '무엇을 할지'를 명시하는 고수준 언어이며, DBMS가 '어떻게 할지'를 결정하는 쿼리 최적화 과정을 다룹니다. 또한, SQL의 두 가지 주요 측면인 데이터 정의 언어(DDL)와 데이터 조작 언어(DML)를 소개하고, 무결성, 뷰 정의, 트랜잭션 제어, 내장 SQL 및 동적 SQL, 권한 부여와 같은 SQL의 다양한 구성 요소를 살펴봅니다. 마지막으로, IBM SEQUEL에서 시작하여 Oracle V2를 거쳐 ANSI 및 ISO 표준으로 발전한 SQL의 간략한 역사를 소개하고, 기본적인 SQL 쿼리 구조(SELECT, FROM, WHERE)를 설명합니다.",
                "chapter_full_text": "ECE30030/ITP30010 Database SystemsStructured Query LanguageReading: Chapter 3\nCharmgil Hongcharmgil@handong.eduSpring, 2025Handong Global University\n1\nAgenda•Structured query language (SQL)•SQL data manipulation language (DML)•SELECT, FROM, WHERE•NULL values•Set operations•String operations, ordering•Aggregate functions, aggregation•SQL data definition language (DDL)   --   NEXT CLASS\nECE30030/ITP30010 Database Systems2\nStructured Query Language (SQL)•SQL: Structured Query Language•The principal language used to describe and manipulate relational databases•Very high-level•Say “what to do” rather than “how to do it”•SQL is not specifying data-manipulation details•DBMSs figure out the “best” way to execute queries•Called “query optimization”•Two aspects to SQL•Data definition: for declaring database schemas (DDL)•Data manipulation: for querying (asking questions about) databases and for modifying the database (DML)\nECE30030/ITP30010 Database Systems3\nSQL Parts•DML – provides the ability to query information from the database and to insert tuples into, delete tuples from, and modify tuples in the database•Integrity – the DDL includes commands for specifying integrity constraints•View definition – the DDL includes commands for defining views•Transaction control – includes commands for specifying the beginning and ending of transactions•Embedded SQL and dynamic SQL – define how SQL statements can be embedded within general-purpose programming language•Authorization – includes commands for specifying access rights to relations and viewsECE30030/ITP30010 Database Systems4\nA Brief History•IBM SEQUEL (Structured English Query Language) was developed as a part of the System R project (Chamberlin and Boyce, early 1970s)•Later on, SEQUEL was renamed SQL (structured query language)•System R à System/38 (1979), SQL/DS (1981), DB2 (1983)•Relational Software, Inc released the first commercial implementation of SQL, Oracle V2 for VAX computers•Relational Software, Inc is now Oracle Corporation•ANSI and ISO standardized SQL:•SQL-86,  SQL-89,  SQL-92,  SQL:1999,  …,  SQL:2011,  SQL:2016 (current)•SQL-92 is supported by the most of database systems\nECE30030/ITP30010 Database Systems5\nBasic Query Structure•A typical SQL query has the form:   SELECT A1, A2, ..., An FROM r1, r2, ..., rm WHERE P•Ai represents an attribute•Ri represents a relation•P is a predicate\n•The result of an SQL query is a relation\nECE30030/ITP30010 Database Systems6"
              },
              {
                "chapter_title": "SQL 데이터 조작 언어(DML) 기초: SELECT, FROM, WHERE 절",
                "source_pdf_filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf",
                "chapter_content_summary": "이 장에서는 SQL 데이터 조작 언어(DML)의 핵심 구성 요소인 SELECT, FROM, WHERE 절을 상세히 다룹니다. 'instructor' 및 'teaches'와 같은 예시 관계(테이블)를 사용하여 실제 쿼리 작성 방법을 시연합니다. SELECT 절을 통해 원하는 속성을 선택하고, 중복을 포함하거나 제거하는 방법(ALL, DISTINCT), 모든 속성을 선택하는 '*' 사용법, 리터럴 및 산술 표현식 활용, 그리고 AS 키워드를 사용한 속성 이름 변경 방법을 학습합니다. WHERE 절에서는 논리 연산자(AND, OR, NOT) 및 비교 연산자(<, <=, >, >=, =, <>, BETWEEN)를 사용하여 조건을 지정하고, 튜플 비교를 수행하는 방법을 설명합니다. 마지막으로 FROM 절을 통해 쿼리에 포함될 관계를 지정하고, 카르테시안 곱을 이해하며, WHERE 절과 결합하여 JOIN 연산을 구현하는 방법을 구체적인 예시와 함께 제시합니다. 또한, AS 키워드를 이용한 관계 및 속성 이름 변경(별칭 지정)을 다룹니다.",
                "chapter_full_text": "ECE30030/ITP30010 Database Systems7\nSQL Data Manipulation Language•The SQL data-manipulation language (DML) allows querying (ask questions about) and modifying the databases\nECE30030/ITP30010 Database Systems8\nRunning Examples•Relations (tables): instructor, teaches\nECE30030/ITP30010 Database Systems9\nInstructor relationteaches relation\nBasic Query Structure•A typical SQL query has the form:   SELECT A1, A2, ..., An FROM r1, r2, ..., rm WHERE P•Ai represents an attribute•Ri represents a relation•P is a predicate\n•The result of an SQL query is a relation\nECE30030/ITP30010 Database Systems10\nThe SELECT Clause•The SELECT clause lists the attributes desired in the result of a query•Corresponds to the projection operation of the relational algebra\n•Example: Find the names of all instructors•SQL: SELECT name FROM instructor;\nECE30030/ITP30010 Database Systems11\nNote•Note: SQL names are case insensitive•E.g., Name ≡ NAME ≡ name•SQL commands (SELECT, FROM, WHERE, …) are written in upper case (just a convention)•MySQL has an option flag, lower_case_table_names•Link: https://dev.mysql.com/doc/refman/8.0/en/identifier-case-sensitivity.html \nECE30030/ITP30010 Database Systems12\nThe SELECT Clause•SQL allows duplicates in relations as well as in query results•The keyword ALL specifies that duplicates should not be removed SELECT ALL dept_name FROM instructor\nECE30030/ITP30010 Database Systems13\nThe SELECT Clause•SQL allows duplicates in relations as well as in query results•The keyword ALL specifies that duplicates should not be removed SELECT ALL dept_name FROM instructor•To force the elimination of duplicates, insert the keyword DISTINCT after SELECT•Find the department names of all instructor, removing duplicates: SELECT DISTINCT dept_name FROM instructor;\nECE30030/ITP30010 Database Systems14\nThe SELECT Clause•An asterisk in the select clause denotes “all attributes” SELECT * FROM instructor;•An attribute can be a literal with no FROM clause SELECT ‘437’;•Result is a table with one column and a single row with value “437”•Can give the column a name using AS: SELECT ‘437’ AS FOO\nECE30030/ITP30010 Database Systems15\nThe SELECT Clause•An attribute can be a literal with FROM clause SELECT 'A' FROM instructor•Result is a table with one column and N rows (number of tuples in the instructor table), each row with value “A”\nECE30030/ITP30010 Database Systems16\nThe SELECT Clause•The SELECT clause can contain arithmetic expressions involving the operation, +, –, *, and /, and operating on constants or attributes of tuples•The query:     SELECT ID, name, salary/12      FROM instructorwould return a relation that is the same as the instructor relation,except that the value of the attribute salary is divided by 12\n17\nThe SELECT Clause•The SELECT clause can contain arithmetic expressions involving the operation, +, –, *, and /, and operating on constants or attributes of tuples•Can rename “salary/12” using the AS clause:  SELECT ID, name, salary/12 AS monthly_salary   FROM instructor\n18\nThe WHERE Clause•The WHERE clause specifies conditions that the result must satisfy•Corresponds to the selection predicate of the relational algebra•E.g., To find all instructors in Comp. Sci. dept: SELECT name FROM instructor  WHERE dept_name = 'Comp. Sci.';\nECE30030/ITP30010 Database Systems19\nThe WHERE Clause•SQL allows the use of the logical connectives AND, OR, and NOT•The operands of the logical connectives can be expressions involving the comparison operators <, <=, >, >=, =, and <>•<> means not equal (there is no != in SQL)•Comparisons can be applied to results of arithmetic expressions•E.g., To find all instructors in Comp. Sci. with salary > 70,000: SELECT name FROM instructor WHERE dept_name = 'Comp. Sci.' AND salary > 70000;\nECE30030/ITP30010 Database Systems20\nThe WHERE Clause•SQL includes a BETWEEN comparison operator•Example: Find the names of all instructors with salary between $90,000 and $100,000 (that is, ³ $90,000 and £ $100,000)•SELECT nameFROM instructorWHERE salary BETWEEN 90000 AND 100000\nECE30030/ITP30010 Database Systems21\nThe WHERE Clause•Tuple comparison: makes comparisons per tuple•SELECT name, course_idFROM instructor, teachesWHERE (instructor.ID, dept_name) = (teaches.ID, 'Biology');\nECE30030/ITP30010 Database Systems22\nThe FROM Clause•The FROM clause lists the relations involved in the query•Corresponds to the Cartesian-product operation of the relational algebra•Find the Cartesian-product instructor × teaches SELECT * FROM instructor, teaches;•Generates every possible instructor-teaches pairs, with all attributes from both relations•For common attributes (e.g., ID), the attributes in the resulting table are renamed using the relation name (e.g., instructor.ID)\nECE30030/ITP30010 Database Systems23\nThe FROM Clause•Find the Cartesian-product instructor X teaches SELECT * FROM instructor, teaches;\n24\ninstructor.IDnamedept_namesalaryteaches.IDcourse_idsec_idsemesteryear10101SrinivasanComp. Sci.6500076766BIO-101 1Summer201712121WuFinance9000076766BIO-101 1Summer201715151MozartMusic4000076766BIO-101 1Summer201722222EinsteinPhysics9500076766BIO-101 1Summer201732343El SaidHistory6000076766BIO-101 1Summer2017… … … … … … … … …10101SrinivasanComp. Sci.6500010101CS-101 1Fall 201712121WuFinance9000010101CS-101 1Fall 201715151MozartMusic4000010101CS-101 1Fall 201722222EinsteinPhysics9500010101CS-101 1Fall 201732343El SaidHistory6000010101CS-101 1Fall 2017… … … … … … … … …… … … … … … … … …10101SrinivasanComp. Sci.6500083821CS-190 2Spring201712121WuFinance9000083821CS-190 2Spring201715151MozartMusic4000083821CS-190 2Spring2017… … … … … … … … …10101SrinivasanComp. Sci.6500010101CS-315 1Spring201812121WuFinance9000010101CS-315 1Spring201815151MozartMusic4000010101CS-315 1Spring2018… … … … … … … … …… … … … … … … … …\nImplementing JOIN•Cartesian-product is not very useful directly; but useful combined with WHERE-clause condition (selection operation in relational algebra)•Cartesian-product + selection = join•E.g., Find the names of all instructors who have taught some course and the course_id SELECT name, course_id FROM instructor , teaches WHERE instructor.ID = teaches.ID\nECE30030/ITP30010 Database Systems25\nImplementing JOIN•Cartesian-product is not very useful directly; but useful combined with WHERE-clause condition (selection operation in relational algebra)•Cartesian-product + selection = join•Find the names of all instructors in the Music department who have taught some course and the course_id SELECT name, course_id FROM instructor , teaches WHERE instructor.ID = teaches.ID  AND instructor. dept_name = 'Music'\nECE30030/ITP30010 Database Systems26\nThe Rename Operation•The SQL allows renaming relations and attributes using the AS clause:   old-name AS new-name•Find the names of all instructors who have a higher salary than some instructor in ‘Comp. Sci.’•SELECT DISTINCT T.nameFROM instructor AS T, instructor AS SWHERE T.salary > S.salary AND S.dept_name = 'Comp. Sci.'\nECE30030/ITP30010 Database Systems27\nThe Rename Operation•The SQL allows renaming relations and attributes using the AS clause:   old-name AS new-name•Find the names of all instructors who have a higher salary than some instructor in ‘Comp. Sci.’•SELECT DISTINCT T.nameFROM instructor AS T, instructor AS SWHERE T.salary > S.salary AND S.dept_name = 'Comp. Sci.'•Keyword AS is optional and may be omitted  instructor AS T  ≡  instructor T\nECE30030/ITP30010 Database Systems28"
              },
              {
                "chapter_title": "SQL DML 고급 기능: NULL 값, 집합 연산, 문자열 처리 및 정렬",
                "source_pdf_filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf",
                "chapter_content_summary": "이 장에서는 SQL DML의 고급 기능을 탐구합니다. 먼저, 알려지지 않거나 존재하지 않는 값을 나타내는 NULL 값의 특성을 이해하고, 산술 연산에서의 NULL 동작 및 IS NULL / IS NOT NULL 술어를 사용하여 NULL 값을 확인하는 방법을 배웁니다. 다음으로, 여러 쿼리 결과를 결합하는 집합 연산인 UNION, INTERSECT, EXCEPT를 살펴봅니다. 각 연산이 기본적으로 중복을 제거하며, ALL 키워드를 사용하여 중복을 유지하는 방법을 설명합니다. 특히 MySQL에서 INTERSECT와 EXCEPT가 직접 지원되지 않을 때 JOIN 또는 NOT IN을 사용하여 에뮬레이션하는 기법을 소개합니다. 이어서, 문자열 패턴 매칭을 위한 LIKE 연산자와 '%' (모든 부분 문자열), '_' (단일 문자) 특수 문자의 사용법을 다룹니다. 백슬래시를 이용한 이스케이프 문자 처리, 패턴 매칭의 대소문자 구분, 그리고 연결, 대소문자 변환, 길이 확인, 부분 문자열 추출 등 다양한 SQL 문자열 함수를 소개합니다. 마지막으로, ORDER BY 절을 사용하여 쿼리 결과를 특정 속성을 기준으로 오름차순(ASC) 또는 내림차순(DESC)으로 정렬하는 방법을 학습하며, 여러 속성을 기준으로 정렬하는 예시도 제시합니다.",
                "chapter_full_text": "ECE30030/ITP30010 Database Systems29\nNULL Values•It is possible for tuples to have a NULL value for some of their attributes•NULL signifies an unknown value or that a value does not exist•The result of any arithmetic expression involving NULL is NULL•E.g.,  5 + NULL returns NULL\nECE30030/ITP30010 Database Systems30\nIS NULL / IS NOT NULL•The predicate IS NULL can be used to check for NULL values•E.g., Find all instructors whose salary is null SELECT name FROM instructor WHERE salary IS NULL•The predicate IS NOT NULL succeeds if the value on which it is applied is not null\nECE30030/ITP30010 Database Systems31\nECE30030/ITP30010 Database Systems32\nSet Operations•Set operations UNION, INTERSECT, and EXCEPT•Each of the above operations automatically eliminates duplicates•To retain all duplicates, use ALL:•UNION ALL•INTERSECT ALL•EXCEPT ALL\n•C.f., SELECT retains all duplicates by default\nECE30030/ITP30010 Database Systems33\nSet Operations: UNION•Find courses that ran in Fall 2017 or in Spring 2018•(SELECT course_id  FROM teaches WHERE semester = 'Fall' AND year = 2017)UNION(SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018)\nECE30030/ITP30010 Database Systems34\nSet Operations: INTERSECT•Find courses that ran in Fall 2017 and in Spring 2018•(SELECT course_id  FROM teaches WHERE semester = 'Fall' AND year = 2017)INTERSECT(SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018)•C.f., MySQL does NOT support INTERSECT•One can emulate INTERSECT using JOIN (we’ll study JOIN later)•SELECT LT.course_idFROM (SELECT course_id FROM teaches WHERE semester = 'Fall' AND year = 2017) AS LTJOIN (SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018) AS RTON LT.course_id=RT.course_id;\nECE30030/ITP30010 Database Systems35\nSet Operations: EXCEPT•Find courses that ran in Fall 2017 but not in Spring 2018•(SELECT course_id  FROM teaches WHERE semester = 'Fall' AND year = 2017)EXCEPT(SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018)•C.f., MySQL does NOT support EXCEPT•One can emulate EXCEPT using NOT IN•SELECT course_id FROM teaches WHERE semester = 'Fall' AND year = 2017AND course_id NOT IN(SELECT course_id  FROM teaches  WHERE semester = 'Spring' AND year = 2018);\nECE30030/ITP30010 Database Systems36\nECE30030/ITP30010 Database Systems37\nString Operations•SQL includes a string-matching operator for comparisons on character strings•The operator LIKE uses patterns that are described using two special characters:•percent (%) – The % character matches any substring•underscore (_) – The _ character matches any character•Find the names of all instructors whose name includes the substring “ri” SELECT name FROM instructor WHERE name LIKE ‘%ri%'\nECE30030/ITP30010 Database Systems38\nString Operations•Escape character: Use backslash (\\) as the escape character•E.g., Match the string “100%” LIKE '100 \\%’ ESCAPE  ‘\\’\nECE30030/ITP30010 Database Systems39\nString Operations•Patterns are case sensitive•Pattern matching examples:•'Intro%' matches any string beginning with “Intro”•'%Comp%' matches any string containing “Comp” as a substring•'_ _ _' matches any string of exactly three characters•'_ _ _ %' matches any string of at least three characters•SQL supports a variety of string operations such as•concatenation (using “||”)•converting from upper to lower case (and vice versa)•finding string length, extracting substrings, etc.\nECE30030/ITP30010 Database Systems40\nOrdering the Display of Tuples•List in alphabetic order the names of all instructors•SELECT DISTINCT nameFROM instructorORDER BY name\nECE30030/ITP30010 Database Systems41\nOrdering the Display of Tuples•Can sort on multiple attributes•E.g., SELECT dept_name, name     FROM instructor      ORDER BY dept_name, name\nECE30030/ITP30010 Database Systems42\nOrdering the Display of Tuples•We may specify DESC for descending order or ASC for ascending order, for each attribute; ascending order is the default•E.g., ORDER BY name DESC\nECE30030/ITP30010 Database Systems43"
              },
              {
                "chapter_title": "SQL DML 집계 함수 및 데이터 수정 (INSERT, UPDATE, DELETE)",
                "source_pdf_filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf",
                "chapter_content_summary": "이 장에서는 SQL 데이터 조작 언어(DML)의 고급 기능인 집계 함수와 데이터를 수정하는 명령어를 다룹니다. AVG, MIN, MAX, SUM, COUNT와 같은 집계 함수를 사용하여 컬럼 값의 멀티셋에 대한 통계 값을 계산하는 방법을 학습합니다. 특히 GROUP BY 절을 이용한 데이터 그룹화와 HAVING 절을 이용한 그룹별 필터링을 심층적으로 다루며, WHERE 절과의 차이점을 명확히 설명합니다. 또한, DML의 핵심 명령인 INSERT, UPDATE, DELETE에 대해 자세히 알아봅니다. INSERT 명령을 통해 테이블에 새로운 튜플을 추가하는 다양한 방법(모든 컬럼, 선택된 컬럼, NULL 값 처리, SELECT 쿼리 결과 삽입)과 외래 키 제약 조건의 중요성을 강조합니다. UPDATE 명령으로는 기존 데이터를 수정하는 기본 구문, 조건부 업데이트, CASE 문을 사용한 복잡한 조건 처리, 스칼라 서브쿼리 활용법을 배웁니다. 마지막으로 DELETE 명령을 통해 테이블에서 특정 행 또는 모든 행을 삭제하는 방법과 TRUNCATE 명령의 차이점, 그리고 삭제 시 서브쿼리 사용 시의 고려사항을 설명합니다.",
                "chapter_full_text": "ECE30030/ITP30010 Database Systems44\nAggregate Functions•These functions operate on the multiset of values of a column of a relation, and return a value•AVG:  average value•MIN:  minimum value•MAX:  maximum value•SUM:  sum of values•COUNT:  number of values\nECE30030/ITP30010 Database Systems45\nAggregate Functions Examples•Find the average salary of instructors in the Computer Science department•SELECT AVG(salary)FROM instructorWHERE dept_name= 'Comp. Sci.';•Find the total number of instructors who teach a course in the Spring 2018 semester•SELECT COUNT(DISTINCT ID)FROM teachesWHERE semester = 'Spring’ AND year = 2018;•Find the number of tuples in the teaches relation•SELECT COUNT (*)FROM teaches;\nECE30030/ITP30010 Database Systems46\nAggregate Functions: Group By•Find the average salary of instructors in each department•SELECT dept_name, AVG(salary) AS avg_salaryFROM instructorGROUP BY dept_name;\nECE30030/ITP30010 Database Systems47\nAggregation•Attributes in SELECT clause outside of aggregate functions must appear in GROUP BY list•/* erroneous query */SELECT dept_name, ID, AVG(salary)FROM instructorGROUP BY dept_name;\nECE30030/ITP30010 Database Systems48\nAggregate Functions – Having Clause•Find the names and average salaries of all departments whose average salary is greater than 65000•SELECT dept_name, AVG(salary) AS avg_salaryFROM instructorGROUP BY dept_nameHAVING AVG(salary) > 65000;\nECE30030/ITP30010 Database Systems49\nAggregate Functions – Having Clause•Note: predicates in the HAVING clause are applied after the formation of groups whereas predicates in the WHERE clause are applied before forming groups\nECE30030/ITP30010 Database Systems50\nSELECT dept_name, AVG(salary) AS avg_salaryFROM instructorGROUP BY dept_nameHAVING AVG(salary) > 65000;\nSELECT dept_name, AVG(salary) AS avg_salaryFROM instructorWHERE salary > 65000GROUP BY dept_name;\nSQL Commands\nSQLDMLSELECTINSERTUPDATEDELETE\nDDLCREATEALTERDROP\nECE30030/ITP30010 Database Systems51\nINSERT•Basic syntax•Insert data into every column:•INSERT INTO tablenameVALUES (col1_value, col2_value, …)•Must list values in the same order as in the table schema•If some data values are unknown, must type NULL •For character sequences, use quotation marks•Single quotation marks are preferred (but double quotation marks are allowed)•Value in quotations is case-sensitive•Insert data into selected columns•INSERT INTO tablename (col1_name, col3_name, col4_name, …)VALUES (col1_value, col3_value, col4_value, …)\nECE30030/ITP30010 Database Systems52\nINSERT•Add a new tuple to course•INSERT INTO courseVALUES ('CS-437', 'Database Systems', 'Comp. Sci.', 4);•or equivalently•INSERT INTO course (course_id, title, dept_name, credits)VALUES ('CS-437', 'Database Systems', 'Comp. Sci.', 4);•Add a new tuple to student  with tot_creds set to null•INSERT INTO studentVALUES ('3003', 'Green', 'Finance', null);\nECE30030/ITP30010 Database Systems53\nINSERT•A foreign key specifies that an attribute from one relation has to map to a tuple in another relation•Value in one relation must appear in another relation\nECE30030/ITP30010 Database Systems54\nRelation: instructor\nRelation: department\nINSERT•A foreign key specifies that an attribute from one relation has to map to a tuple in another relation•Value in one relation must appear in another relation•Make sure all foreign keys that new row references have already been added to database•One cannot insert a foreign key value unless the corresponding value exists in the referenced relation\nECE30030/ITP30010 Database Systems55\nINSERT•Inserting results of other SELECT query•Make each student in the Music department who has earned more than 144 credit hours an instructor in the Music department with a salary of  $18,000•INSERT INTO instructor  SELECT ID, name, dept_name, 18000  FROM student   WHERE dept_name = 'Music’ AND total_cred > 144;•The SELECT FROM WHERE statement is evaluated fully before any of its results are inserted into the relation•Otherwise queries like  INSERT INTO table1 SELECT * FROM table1would cause problem\nECE30030/ITP30010 Database Systems56\nUPDATE•Basic syntax•Updating a table•UPDATE tablenameSET col1_name = new_col1_value, col2_name = new_col2_value, …;•Updating a table with conditions•UPDATE tablenameSET col1_name = new_col1_value, col2_name = new_col2_value, …WHERE predicate;\nECE30030/ITP30010 Database Systems57\nUPDATE•Give a 5% salary raise to all instructors•UPDATE instructorSET salary = salary * 1.05•Give a 5% salary raise to those instructors who earn less than 70000•UPDATE instructorSET salary = salary * 1.05WHERE salary < 70000;•Give a 5% salary raise to instructors whose salary is less than average•UPDATE instructorSET salary = salary * 1.05WHERE salary <  (SELECT AVG(salary) FROM instructor);\nECE30030/ITP30010 Database Systems58\nUPDATE•Increase salaries of instructors whose salary is over $100,000 by 3%, and all others by a 5%•Write two UPDATE statements:  UPDATE instructor  SET salary = salary * 1.03  WHERE salary > 100000;  UPDATE instructor  SET salary = salary * 1.05  WHERE salary <= 100000;•The order is important•Can be done better using the case statement (next slide)\nECE30030/ITP30010 Database Systems59\nCASE Statement for Conditional Update•The following query is equivalent to the previous UPDATE queries•UPDATE instructorSET salary = CASE                           WHEN salary <= 100000 THEN salary * 1.05                           ELSE salary * 1.03                       END\nECE30030/ITP30010 Database Systems60\nUPDATE with Scalar Subqueries•Recompute and update tot_creds value for all students•UPDATE student SSET tot_cred = (SELECT SUM(credits)                             FROM takes, course                             WHERE takes.course_id = course.course_id  AND                                            S.ID= takes.ID  AND                                            takes.grade <> 'F' AND                                            takes.grade IS NOT NULL);\nECE30030/ITP30010 Database Systems61\nDELETE•Basic syntax•To remove specific rows•DELETE FROM tablenameWHERE predicate;•To remove all rows•DELETE FROM tablename;•This is equivalent to TRUNCATE:TRUNCATE (TABLE) tablename;•One cannot truncate a table with foreign key constraints•Must disable the constraints first (we will cover ALTER when we study SQL DDL):ALTER TABLE tablenameDISABLE CONSTRAINT constraint_name;\nECE30030/ITP30010 Database Systems62\nDELETE•Delete all instructors•DELETE FROM instructor;•Delete all instructors from the Finance department•DELETE FROM instructorWHERE dept_name= 'Finance';•Delete all tuples in the instructor relation for those instructors associated with a department located in the Watson building•DELETE FROM instructorWHERE dept name IN (SELECT dept name        FROM department        WHERE building = 'Watson');\nECE30030/ITP30010 Database Systems63\nDELETE•Delete all instructors whose salary is less than the average salary of instructors•Example:  DELETE FROM instructor                WHERE salary < (SELECT AVG (salary)                  FROM instructor);•Issue:  as we delete tuples from instructor, the average salary changes•Solution used in SQL:1.First, compute AVG(salary) and find all tuples to delete2.Next, delete all tuples found above (without recomputing AVG or retesting the tuples)\nECE30030/ITP30010 Database Systems64"
              }
            ],
            "generated_content": [
              {
                "title": "관계형 데이터베이스 시스템(R-DBMS) 개요 및 MySQL 소개",
                "metadata": "Source: cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_1a4c2f45-b482-4e82-826e-fa8945eb99c7_DB03 - mysql.pdf, Text length: 2496 chars",
                "documentContent": [
                  {
                    "type": "heading",
                    "content": "목차",
                    "level": 1
                  },
                  {
                    "type": "paragraph",
                    "content": "MySQL 소개",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "SQL 미리보기",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "MySQL",
                    "level": 1
                  },
                  {
                    "type": "paragraph",
                    "content": "MySQL은 SQL 기반의 관계형 데이터베이스 관리 시스템(DBMS)입니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "GPL 라이선스 하의 무료 오픈소스 R-DBMS입니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "오라클이 소유하고 있습니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "상업용 MySQL 버전도 제공됩니다(기술 지원 포함).",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "“My”는 공동 창립자 Michael Widenius의 딸 이름에서 유래했습니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "참고: MariaDB",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "표준 SQL과 호환됩니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "상업용 웹 서비스에 자주 사용됩니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "MySQL 사용 기업",
                    "level": 1
                  },
                  {
                    "type": "paragraph",
                    "content": "Enlyft의 연구에 따르면, MySQL을 사용하는 1,409,176개 회사 중 199,498개 회사에 대한 데이터를 보유하고 있습니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "주로 직원 수 10-50명, 매출 100만-1000만 달러 규모의 회사에서 사용됩니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "참고: Oracle 12는 직원 수 50-200명, 매출 10억 달러 이상 규모의 회사에서 가장 많이 사용됩니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "MySQL을 사용하는 회사 전체 목록은 https://www.mysql.com/customers/ 에서 확인할 수 있습니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "MySQL을 사용하는 이유",
                    "level": 1
                  },
                  {
                    "type": "paragraph",
                    "content": "인기 많음",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "인터넷 전반에 걸쳐 활발한 토론이 이루어집니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "다재다능함: Linux, Windows, Mac OS X, Solaris, FreeBSD 등 다양한 운영체제에서 실행됩니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "다양한 프로그래밍 언어(C/C++, Java, Python, .Net 등)를 지원합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "비용이 0부터 시작합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "고성능 (빠르고 신뢰할 수 있음)",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "DBMS 인기 추세",
                    "level": 1
                  },
                  {
                    "type": "paragraph",
                    "content": "점수 정의: https://db-engines.com/en/ranking_definition",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "MySQL의 주요 특징",
                    "level": 1
                  },
                  {
                    "type": "paragraph",
                    "content": "방대함: 테라바이트 단위의 데이터를 처리할 수 있습니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "편리함: 고수준 질의어를 지원합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "다중 사용자: 동시 데이터 접근을 지원합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "안전함: 트랜잭션을 지원합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "효율적임: 초당 수천 건의 질의를 처리할 수 있습니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "신뢰성: 많은 실제 제품에서 99.99%의 가동 시간을 자랑합니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "MySQL 버전",
                    "level": 1
                  },
                  {
                    "type": "paragraph",
                    "content": "MySQL 5.x 대 8.x",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "버전 5.x: MySQL의 가장 인기 있는 버전이며, 더 안정적이고 보편적입니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "버전 8.x: 현재 버전으로, 최신 DB 기능(더 나은 스토리지 엔진, 더 빠른 속도, 더 강력한 보안)을 제공합니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "MySQL 얻는 방법",
                    "level": 1
                  },
                  {
                    "type": "paragraph",
                    "content": "https://dev.mysql.com/downloads/",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "무료로 사용 가능한 \"커뮤니티\" 버전을 찾아보세요.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "”엔터프라이즈” 버전은 상업용입니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "이 강의를 위해 Docker 이미지가 준비되어 있습니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "Ubuntu 서버, MySQL, 그리고 강의 활동을 위한 예제 데이터베이스로 구성되어 있습니다.",
                    "level": null
                  }
                ],
                "aiNotes": {
                  "summary": "본 문서는 관계형 데이터베이스 관리 시스템(R-DBMS)의 개요와 MySQL에 대해 소개합니다. MySQL이 SQL 기반의 무료 오픈소스 R-DBMS이며, 오라클이 소유하고 있음을 설명합니다. 또한 MySQL의 광범위한 사용 현황, 다양한 운영체제 및 프로그래밍 언어 지원, 고성능, 안정성 등의 장점을 강조합니다. MySQL 5.x와 8.x 버전의 주요 차이점을 비교하고, MySQL을 다운로드하고 활용할 수 있는 방법을 안내합니다.",
                  "keyConcepts": [
                    {
                      "term": "관계형 데이터베이스 관리 시스템 (R-DBMS)",
                      "definition": "SQL 기반으로 데이터를 관계형 모델에 따라 저장, 관리, 검색하는 시스템입니다."
                    },
                    {
                      "term": "MySQL",
                      "definition": "오라클이 소유한 SQL 기반의 오픈소스 R-DBMS로, 상업용 웹 서비스에 널리 사용되며 높은 성능과 안정성을 제공합니다."
                    },
                    {
                      "term": "오픈소스 소프트웨어",
                      "definition": "소스 코드가 공개되어 누구나 자유롭게 사용, 수정, 배포할 수 있는 소프트웨어입니다."
                    },
                    {
                      "term": "SQL (Structured Query Language)",
                      "definition": "관계형 데이터베이스와 상호작용하고 데이터를 정의, 조작, 제어하기 위한 표준 언어입니다."
                    },
                    {
                      "term": "MySQL 버전 5.x vs 8.x",
                      "definition": "5.x는 가장 대중적이고 안정적인 버전이며, 8.x는 현재 버전으로 최신 기능, 향상된 스토리지 엔진, 속도 및 보안을 제공합니다."
                    }
                  ],
                  "importantTerms": [
                    {
                      "term": "DBMS",
                      "definition": "데이터베이스 관리 시스템(Database Management System)의 약자로, 데이터베이스를 효율적으로 관리하는 소프트웨어입니다."
                    },
                    {
                      "term": "GPL",
                      "definition": "General Public License의 약자로, 자유 소프트웨어 라이선스의 일종이며, 소프트웨어의 복사, 배포, 수정 권한을 부여합니다."
                    },
                    {
                      "term": "MariaDB",
                      "definition": "MySQL의 한 포크(fork)로, MySQL과 높은 호환성을 가지며 오픈소스 커뮤니티에 의해 개발되고 있습니다."
                    },
                    {
                      "term": "트랜잭션",
                      "definition": "데이터베이스의 논리적인 작업 단위로, 데이터의 무결성을 보장하기 위해 전부 실행되거나 전혀 실행되지 않아야 하는 일련의 연산입니다."
                    },
                    {
                      "term": "스토리지 엔진",
                      "definition": "데이터베이스 시스템 내에서 데이터를 디스크에 저장하고 검색하는 방식을 담당하는 구성 요소입니다."
                    },
                    {
                      "term": "Docker",
                      "definition": "애플리케이션을 컨테이너라는 격리된 환경에서 개발, 배포, 실행할 수 있게 해주는 플랫폼입니다."
                    }
                  ],
                  "outline": [
                    {
                      "text": "목차",
                      "id": "목차",
                      "children": null
                    },
                    {
                      "text": "MySQL",
                      "id": "mysql",
                      "children": [
                        {
                          "text": "MySQL 정의 및 특징",
                          "id": "mysql-정의-및-특징",
                          "children": null
                        },
                        {
                          "text": "MySQL 사용 기업",
                          "id": "mysql-사용-기업",
                          "children": null
                        },
                        {
                          "text": "MySQL을 사용하는 이유",
                          "id": "mysql을-사용하는-이유",
                          "children": null
                        },
                        {
                          "text": "MySQL의 주요 특징",
                          "id": "mysql의-주요-특징",
                          "children": null
                        }
                      ]
                    },
                    {
                      "text": "DBMS 인기 추세",
                      "id": "dbms-인기-추세",
                      "children": null
                    },
                    {
                      "text": "MySQL 버전",
                      "id": "mysql-버전",
                      "children": null
                    },
                    {
                      "text": "MySQL 얻는 방법",
                      "id": "mysql-얻는-방법",
                      "children": null
                    }
                  ]
                },
                "quiz": [
                  {
                    "question": "MySQL의 주요 특징이 아닌 것은 무엇인가요?",
                    "options": [
                      "오라클이 소유한 상용 소프트웨어이다.",
                      "SQL 기반의 관계형 데이터베이스 관리 시스템이다.",
                      "GPL 라이선스 하에 무료 오픈소스 버전이 제공된다.",
                      "다양한 운영체제와 프로그래밍 언어를 지원한다."
                    ],
                    "answerIndex": 0,
                    "explanation": "MySQL은 오라클이 소유하고 있지만, GPL 라이선스 하에 무료 오픈소스 버전이 제공되며 상용 버전도 별도로 존재합니다. 따라서 '오라클이 소유한 상용 소프트웨어이다'는 MySQL의 모든 특징을 포괄하지 않습니다."
                  },
                  {
                    "question": "MySQL 5.x 버전과 8.x 버전의 주요 차이점은 무엇인가요?",
                    "options": [
                      "5.x는 최신 기능에 중점을 둔 반면 8.x는 안정성에 중점을 둡니다.",
                      "5.x는 현재 버전이고 8.x는 이전 버전입니다.",
                      "5.x는 더 안정적이고 대중적이며, 8.x는 최신 기능과 향상된 성능을 제공합니다.",
                      "5.x는 유료 버전이고 8.x는 무료 버전입니다."
                    ],
                    "answerIndex": 2,
                    "explanation": "MySQL 5.x는 가장 대중적이고 안정적인 버전으로 남아있지만, 8.x는 최신 버전으로서 더 나은 스토리지 엔진, 속도 및 보안 등 최신 기능을 제공합니다."
                  },
                  {
                    "question": "다음 중 MySQL을 얻을 수 있는 방법으로 본문에 언급되지 않은 것은 무엇인가요?",
                    "options": [
                      "dev.mysql.com/downloads/에서 커뮤니티 버전 다운로드",
                      "MySQL 엔터프라이즈 버전 구매",
                      "Docker 이미지를 통해 구축",
                      "CD-ROM으로 설치"
                    ],
                    "answerIndex": 3,
                    "explanation": "본문에서는 공식 다운로드 페이지에서 커뮤니티 버전 다운로드, 엔터프라이즈 버전 구매, 그리고 Docker 이미지 활용 방법이 언급되었으나, CD-ROM을 통한 설치는 언급되지 않았습니다."
                  }
                ]
              },
              {
                "title": "SQL(구조적 질의어)의 이해: 기본 개념과 역사",
                "metadata": "Source: cd0e465a-9cfa-47bf-93fa-9eb3748fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf, Text length: 1968 chars",
                "documentContent": [
                  {
                    "type": "heading",
                    "content": "서론",
                    "level": 1
                  },
                  {
                    "type": "paragraph",
                    "content": "이 문서는 관계형 데이터베이스를 다루는 핵심 언어인 SQL(구조적 질의어)의 기본 개념과 역사, 그리고 주요 구성 요소에 대해 설명합니다. SQL은 데이터베이스에 '무엇을 할지'를 지시하는 높은 수준의 언어로, '어떻게 할지'에 대한 세부 사항은 DBMS(데이터베이스 관리 시스템)의 질의 최적화 기능에 맡깁니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "구조적 질의어 (SQL) 개요",
                    "level": 1
                  },
                  {
                    "type": "heading",
                    "content": "SQL의 정의 및 특징",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "SQL은 관계형 데이터베이스를 기술하고 조작하는 데 사용되는 주요 언어입니다. SQL은 매우 높은 수준의 언어로, 사용자에게 데이터 조작의 세부 사항을 명시하는 대신 '무엇을 할지'를 지시하도록 합니다. DBMS는 질의 최적화(query optimization)를 통해 질의를 실행하는 '최적의' 방법을 찾아냅니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "SQL의 주요 구성 요소",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "SQL은 크게 두 가지 주요 측면으로 나뉩니다:",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "데이터 정의: 데이터베이스 스키마를 선언하는 데 사용되는 DDL(Data Definition Language).",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "데이터 조작: 데이터베이스에 질의하고(질문을 던지고) 데이터베이스를 수정하는 데 사용되는 DML(Data Manipulation Language).",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "SQL의 다양한 기능",
                    "level": 1
                  },
                  {
                    "type": "heading",
                    "content": "데이터 조작 언어 (DML)",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "DML은 데이터베이스에서 정보를 질의하고, 튜플을 삽입, 삭제, 수정하는 기능을 제공합니다. `SELECT`, `FROM`, `WHERE`와 같은 구문이 DML의 핵심을 이룹니다. 또한, NULL 값 처리, 집합 연산, 문자열 연산, 정렬, 그리고 집계 함수와 같은 고급 기능도 포함됩니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "기타 SQL 기능",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "SQL은 DML 외에도 다양한 기능을 포함합니다:",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "무결성: DDL은 무결성 제약 조건을 명시하기 위한 명령어를 포함합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "뷰 정의: DDL은 뷰를 정의하기 위한 명령어를 포함합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "트랜잭션 제어: 트랜잭션의 시작과 끝을 명시하기 위한 명령어를 포함합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "임베디드 SQL 및 동적 SQL: SQL 문을 범용 프로그래밍 언어 내에 포함하는 방법을 정의합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "권한 부여: 관계 및 뷰에 대한 접근 권한을 명시하기 위한 명령어를 포함합니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "SQL의 간략한 역사",
                    "level": 1
                  },
                  {
                    "type": "heading",
                    "content": "초기 개발: IBM SEQUEL과 System R",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "SQL의 전신인 IBM SEQUEL(Structured English Query Language)은 1970년대 초 Chamberlin과 Boyce에 의해 System R 프로젝트의 일환으로 개발되었습니다. 이후 SEQUEL은 SQL(Structured Query Language)로 이름이 변경되었습니다. System R은 System/38(1979), SQL/DS(1981), DB2(1983)로 발전했습니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "상업적 구현 및 표준화",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "Relational Software, Inc.(현재 Oracle Corporation)는 VAX 컴퓨터용 Oracle V2를 출시하며 최초의 상업적 SQL 구현을 선보였습니다. ANSI와 ISO는 SQL을 표준화했으며, SQL-86을 시작으로 SQL-89, SQL-92, SQL:1999 등을 거쳐 현재는 SQL:2016에 이르렀습니다. 특히 SQL-92는 대부분의 데이터베이스 시스템에서 지원됩니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "기본 질의 구조",
                    "level": 1
                  },
                  {
                    "type": "heading",
                    "content": "SELECT-FROM-WHERE 구문",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "전형적인 SQL 질의는 다음과 같은 형태를 가집니다:",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "SELECT A1, A2, ..., An\nFROM r1, r2, ..., rm\nWHERE P",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "여기서 Ai는 속성(attribute)을 나타내고, Ri는 관계(relation)를 나타내며, P는 술어(predicate)입니다. SQL 질의의 결과는 항상 관계(테이블)입니다.",
                    "level": null
                  }
                ],
                "aiNotes": {
                  "summary": "이 문서는 관계형 데이터베이스의 핵심 언어인 SQL(구조적 질의어)에 대해 설명합니다. SQL의 정의와 특징, 데이터 정의 언어(DDL)와 데이터 조작 언어(DML)로의 구분, 그리고 무결성 제약 조건, 뷰 정의, 트랜잭션 제어 등 다양한 기능을 다룹니다. 또한, IBM의 SEQUEL 개발부터 Oracle의 상업적 구현, 그리고 ANSI 및 ISO 표준화에 이르는 SQL의 간략한 역사와 함께, `SELECT-FROM-WHERE`로 대표되는 SQL의 기본 질의 구조를 소개합니다.",
                  "keyConcepts": [
                    {
                      "term": "SQL (구조적 질의어)",
                      "definition": {
                        "easy": null,
                        "medium": "관계형 데이터베이스를 기술하고 조작하는 데 사용되는 주요 언어로, '무엇을 할지'를 지시하는 높은 수준의 언어입니다.",
                        "hard": null
                      }
                    },
                    {
                      "term": "DML (데이터 조작 언어)",
                      "definition": {
                        "easy": null,
                        "medium": "데이터베이스에서 정보를 질의하고, 튜플을 삽입, 삭제, 수정하는 기능을 제공하는 SQL의 한 부분입니다.",
                        "hard": null
                      }
                    },
                    {
                      "term": "DDL (데이터 정의 언어)",
                      "definition": {
                        "easy": null,
                        "medium": "데이터베이스 스키마를 선언하고 무결성 제약 조건 및 뷰 정의와 같은 데이터베이스 구조 관련 기능을 담당하는 SQL의 한 부분입니다.",
                        "hard": null
                      }
                    },
                    {
                      "term": "질의 최적화",
                      "definition": {
                        "easy": null,
                        "medium": "DBMS가 SQL 질의를 효율적으로 실행하기 위해 '최적의' 실행 계획을 찾는 과정입니다.",
                        "hard": null
                      }
                    }
                  ],
                  "importantTerms": [
                    {
                      "term": "SQL",
                      "definition": "Structured Query Language의 약자로, 관계형 데이터베이스를 관리하는 표준 언어입니다."
                    },
                    {
                      "term": "DML",
                      "definition": "Data Manipulation Language의 약자로, 데이터 검색, 삽입, 수정, 삭제 등 데이터 조작에 사용되는 SQL 명령어 집합입니다."
                    },
                    {
                      "term": "DDL",
                      "definition": "Data Definition Language의 약자로, 데이터베이스 스키마 정의, 테이블 생성 및 수정, 뷰 생성 등 데이터 구조 정의에 사용되는 SQL 명령어 집합입니다."
                    },
                    {
                      "term": "SEQUEL",
                      "definition": "Structured English Query Language의 약자로, SQL의 초기 명칭이자 IBM System R 프로젝트에서 개발되었습니다."
                    },
                    {
                      "term": "System R",
                      "definition": "IBM에서 1970년대 초에 개발한 관계형 데이터베이스 시스템 연구 프로젝트로, SQL의 기원이 되었습니다."
                    },
                    {
                      "term": "질의 최적화 (Query Optimization)",
                      "definition": "DBMS가 SQL 질의를 가장 효율적으로 실행하기 위한 방법을 결정하는 과정입니다."
                    },
                    {
                      "term": "SELECT-FROM-WHERE",
                      "definition": "SQL에서 데이터를 질의하는 가장 기본적인 구문 형태입니다."
                    }
                  ],
                  "outline": [
                    {
                      "text": "서론",
                      "id": "서론",
                      "children": null
                    },
                    {
                      "text": "구조적 질의어 (SQL) 개요",
                      "id": "구조적-질의어-sql-개요",
                      "children": [
                        {
                          "text": "SQL의 정의 및 특징",
                          "id": "sql의-정의-및-특징",
                          "children": null
                        },
                        {
                          "text": "SQL의 주요 구성 요소",
                          "id": "sql의-주요-구성-요소",
                          "children": null
                        }
                      ]
                    },
                    {
                      "text": "SQL의 다양한 기능",
                      "id": "sql의-다양한-기능",
                      "children": [
                        {
                          "text": "데이터 조작 언어 (DML)",
                          "id": "데이터-조작-언어-dml",
                          "children": null
                        },
                        {
                          "text": "기타 SQL 기능",
                          "id": "기타-sql-기능",
                          "children": null
                        }
                      ]
                    },
                    {
                      "text": "SQL의 간략한 역사",
                      "id": "sql의-간략한-역사",
                      "children": [
                        {
                          "text": "초기 개발: IBM SEQUEL과 System R",
                          "id": "초기-개발-ibm-sequel과-system-r",
                          "children": null
                        },
                        {
                          "text": "상업적 구현 및 표준화",
                          "id": "상업적-구현-및-표준화",
                          "children": null
                        }
                      ]
                    },
                    {
                      "text": "기본 질의 구조",
                      "id": "기본-질의-구조",
                      "children": [
                        {
                          "text": "SELECT-FROM-WHERE 구문",
                          "id": "select-from-where-구문",
                          "children": null
                        }
                      ]
                    }
                  ]
                },
                "quiz": [
                  {
                    "question": "SQL의 주요 특징 중 하나는 무엇입니까?",
                    "options": [
                      "데이터 조작의 세부 사항을 명시합니다.",
                      "데이터베이스에 '무엇을 할지'보다 '어떻게 할지'를 지시합니다.",
                      "DBMS가 질의 실행 방법을 최적화하도록 합니다.",
                      "비관계형 데이터베이스를 조작하는 데 주로 사용됩니다."
                    ],
                    "answerIndex": 2,
                    "explanation": "SQL은 '무엇을 할지'를 명시하며, '어떻게 할지'에 대한 세부 사항은 DBMS의 질의 최적화 기능에 맡깁니다."
                  },
                  {
                    "question": "최초의 상업적 SQL 구현을 출시한 회사는 어디입니까?",
                    "options": [
                      "IBM",
                      "Microsoft",
                      "Relational Software, Inc. (현재 Oracle Corporation)",
                      "ANSI"
                    ],
                    "answerIndex": 2,
                    "explanation": "Relational Software, Inc. (현재 Oracle Corporation)가 VAX 컴퓨터용 Oracle V2를 통해 최초의 상업적 SQL 구현을 출시했습니다."
                  },
                  {
                    "question": "SQL의 구성 요소 중 데이터베이스 스키마를 선언하고 무결성 제약 조건 및 뷰를 정의하는 역할을 하는 것은 무엇입니까?",
                    "options": [
                      "DML (Data Manipulation Language)",
                      "DDL (Data Definition Language)",
                      "Transaction Control (트랜잭션 제어)",
                      "Authorization (권한 부여)"
                    ],
                    "answerIndex": 1,
                    "explanation": "DDL(데이터 정의 언어)은 데이터베이스 스키마를 선언하고 무결성 제약 조건 및 뷰를 정의하는 데 사용됩니다."
                  }
                ]
              },
              {
                "title": "SQL 데이터 조작 언어(DML) 기초: SELECT, FROM, WHERE 절",
                "metadata": "Source: cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf, Text length: 4209 chars",
                "documentContent": [
                  {
                    "type": "heading",
                    "content": "SQL 데이터 조작 언어(DML)",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "SQL 데이터 조작 언어(DML)는 데이터베이스를 질의(질문)하고 수정할 수 있도록 합니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "실행 예시",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "관계(테이블): instructor, teaches",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "Instructor 관계 및 Teaches 관계",
                    "level": 2
                  },
                  {
                    "type": "heading",
                    "content": "기본 질의 구조",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "일반적인 SQL 질의는 다음과 같은 형태를 가집니다: SELECT A1, A2, ..., An FROM r1, r2, ..., rm WHERE P",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "Ai는 속성을 나타냅니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "Ri는 관계를 나타냅니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "P는 술어(predicate)입니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "SQL 질의의 결과는 관계(relation)입니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "SELECT 절",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "SELECT 절은 질의 결과에 필요한 속성들을 나열합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "관계 대수의 프로젝션(projection) 연산에 해당합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "예시: 모든 강사의 이름을 찾기",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "SQL: SELECT name FROM instructor;",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "참고",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "참고: SQL 이름은 대소문자를 구분하지 않습니다. 예: Name ≡ NAME ≡ name",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "SQL 명령(SELECT, FROM, WHERE 등)은 대문자로 작성하는 것이 일반적인 관례입니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "MySQL에는 lower_case_table_names라는 옵션 플래그가 있습니다. 링크: https://dev.mysql.com/doc/refman/8.0/en/identifier-case-sensitivity.html",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "SELECT 절: 중복 처리",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "SQL은 관계뿐만 아니라 질의 결과에서도 중복을 허용합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "ALL 키워드는 중복을 제거하지 않도록 지정합니다. SELECT ALL dept_name FROM instructor",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "중복 제거를 강제하려면 SELECT 뒤에 DISTINCT 키워드를 삽입합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "모든 강사의 부서 이름을 중복 없이 찾기: SELECT DISTINCT dept_name FROM instructor;",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "SELECT 절: 모든 속성 및 리터럴 사용",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "SELECT 절의 별표(*)는 “모든 속성”을 의미합니다. SELECT * FROM instructor;",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "속성은 FROM 절 없이 리터럴(상수)이 될 수 있습니다. SELECT ‘437’;",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "결과는 하나의 열과 “437” 값을 가진 단일 행으로 구성된 테이블입니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "AS를 사용하여 열에 이름을 부여할 수 있습니다: SELECT ‘437’ AS FOO",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "속성은 FROM 절을 포함하는 리터럴이 될 수 있습니다. SELECT 'A' FROM instructor",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "결과는 하나의 열과 N개의 행(instructor 테이블의 튜플 수)으로 구성된 테이블이며, 각 행은 “A” 값을 가집니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "SELECT 절: 산술 표현식",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "SELECT 절은 +, –, *, / 연산을 포함하는 산술 표현식을 포함할 수 있으며, 상수 또는 튜플의 속성에 대해 작동합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "질의: SELECT ID, name, salary/12 FROM instructor는 instructor 관계와 동일한 관계를 반환하지만, salary 속성 값이 12로 나뉘어 표시됩니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "AS 절을 사용하여 “salary/12”의 이름을 변경할 수 있습니다: SELECT ID, name, salary/12 AS monthly_salary FROM instructor",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "WHERE 절",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "WHERE 절은 결과가 만족해야 하는 조건을 지정합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "관계 대수의 선택(selection) 술어에 해당합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "예시: ‘Comp. Sci.’ 부서의 모든 강사를 찾으려면: SELECT name FROM instructor WHERE dept_name = 'Comp. Sci.';",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "WHERE 절: 논리 연산자와 비교 연산자",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "SQL은 AND, OR, NOT 논리 연결자를 사용할 수 있도록 합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "논리 연결자의 피연산자는 <, <=, >, >=, =, <>와 같은 비교 연산자를 포함하는 표현식일 수 있습니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "<>는 같지 않음을 의미합니다 (SQL에는 !=가 없습니다).",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "비교는 산술 표현식의 결과에도 적용될 수 있습니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "예시: ‘Comp. Sci.’ 부서에 속하며 급여가 70,000보다 많은 모든 강사를 찾으려면: SELECT name FROM instructor WHERE dept_name = 'Comp. Sci.' AND salary > 70000;",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "WHERE 절: BETWEEN 연산자",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "SQL에는 BETWEEN 비교 연산자가 포함되어 있습니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "예시: 급여가 $90,000에서 $100,000 사이(즉, $90,000 이상 $100,000 이하)인 모든 강사의 이름을 찾으려면:",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "SELECT name FROM instructor WHERE salary BETWEEN 90000 AND 100000",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "WHERE 절: 튜플 비교",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "튜플 비교: 튜플별로 비교를 수행합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "SELECT name, course_id FROM instructor, teaches WHERE (instructor.ID, dept_name) = (teaches.ID, 'Biology');",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "FROM 절",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "FROM 절은 질의에 관련된 관계(테이블)들을 나열합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "관계 대수의 카티션 곱(Cartesian-product) 연산에 해당합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "예시: instructor × teaches의 카티션 곱을 찾으려면: SELECT * FROM instructor, teaches;",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "두 관계의 모든 속성을 포함하여 가능한 모든 instructor-teaches 쌍을 생성합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "공통 속성(예: ID)의 경우, 결과 테이블의 속성 이름은 관계 이름(예: instructor.ID)을 사용하여 변경됩니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "FROM 절: 카티션 곱 예시",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "instructor X teaches의 카티션 곱을 찾으려면: SELECT * FROM instructor, teaches;",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "결과 테이블은 instructor와 teaches 관계의 모든 속성을 포함하며, 각 instructor 튜플과 각 teaches 튜플의 모든 가능한 조합을 생성합니다. 예를 들어, instructor.ID, name, dept_name, salary와 teaches.ID, course_id, sec_id, semester, year와 같은 속성들이 조합되어 나타납니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "조인 구현",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "카티션 곱은 직접적으로는 유용하지 않지만, WHERE 절 조건(관계 대수의 선택 연산)과 결합하면 유용합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "카티션 곱 + 선택 = 조인(join)",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "예시: 어떤 과목을 가르친 모든 강사의 이름과 course_id를 찾으려면: SELECT name, course_id FROM instructor , teaches WHERE instructor.ID = teaches.ID",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "음악과에 속하며 어떤 과목을 가르친 모든 강사의 이름과 course_id를 찾으려면: SELECT name, course_id FROM instructor , teaches WHERE instructor.ID = teaches.ID AND instructor. dept_name = 'Music'",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "이름 변경(Rename) 연산",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "SQL은 AS 절을 사용하여 관계와 속성의 이름을 변경할 수 있도록 합니다: old-name AS new-name",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "예시: 'Comp. Sci.' 부서의 어떤 강사보다 급여가 높은 모든 강사의 이름을 찾으려면:",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "SELECT DISTINCT T.name FROM instructor AS T, instructor AS S WHERE T.salary > S.salary AND S.dept_name = 'Comp. Sci.'",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "AS 키워드는 선택 사항이며 생략될 수 있습니다. instructor AS T ≡ instructor T",
                    "level": null
                  }
                ],
                "aiNotes": {
                  "summary": "본 문서는 SQL 데이터 조작 언어(DML)의 핵심 구성 요소인 SELECT, FROM, WHERE 절의 기초를 다룹니다. 각 절의 기본적인 기능과 함께 중복 처리(ALL, DISTINCT), 산술 표현식, 조건 필터링(AND, OR, NOT, BETWEEN), 테이블 간의 조인(JOIN) 구현, 그리고 테이블 및 속성 이름 변경(AS)과 같은 다양한 활용 방법을 예시와 함께 설명합니다. 또한 SQL 이름의 대소문자 구분 규칙에 대한 내용도 포함되어 있습니다.",
                  "keyConcepts": [
                    {
                      "term": "SQL DML",
                      "definition": "데이터베이스에서 데이터를 질의하고 수정하는 데 사용되는 언어입니다."
                    },
                    {
                      "term": "SELECT 절",
                      "definition": "질의 결과에 포함할 속성(컬럼)을 지정하는 부분으로, 관계 대수의 프로젝션(Projection) 연산에 해당합니다."
                    },
                    {
                      "term": "FROM 절",
                      "definition": "데이터를 검색할 관계(테이블)를 지정하는 부분으로, 관계 대수의 카티션 곱(Cartesian Product) 연산에 해당합니다."
                    },
                    {
                      "term": "WHERE 절",
                      "definition": "질의 결과가 만족해야 할 조건을 지정하는 부분으로, 관계 대수의 선택(Selection) 연산에 해당합니다."
                    },
                    {
                      "term": "조인 (JOIN)",
                      "definition": "FROM 절의 카티션 곱과 WHERE 절의 선택 조건을 결합하여 두 개 이상의 테이블에서 관련 튜플을 연결하여 새로운 테이블을 생성하는 연산입니다."
                    }
                  ],
                  "importantTerms": [
                    {
                      "term": "DML (Data Manipulation Language)",
                      "definition": "데이터베이스에서 데이터를 검색, 삽입, 삭제, 수정하는 데 사용되는 언어."
                    },
                    {
                      "term": "SELECT",
                      "definition": "SQL 쿼리의 결과를 정의하는 절로, 어떤 컬럼을 반환할지 지정."
                    },
                    {
                      "term": "FROM",
                      "definition": "SQL 쿼리에서 데이터를 검색할 테이블을 지정하는 절."
                    },
                    {
                      "term": "WHERE",
                      "definition": "SQL 쿼리에서 특정 조건을 만족하는 행만 선택하도록 필터링하는 절."
                    },
                    {
                      "term": "DISTINCT",
                      "definition": "SELECT 절에서 중복된 결과를 제거할 때 사용하는 키워드."
                    },
                    {
                      "term": "AS",
                      "definition": "SQL에서 테이블이나 컬럼의 이름을 변경(별칭 지정)할 때 사용하는 키워드."
                    },
                    {
                      "term": "카티션 곱 (Cartesian Product)",
                      "definition": "두 테이블의 모든 가능한 행 조합을 생성하는 연산."
                    }
                  ],
                  "outline": [
                    {
                      "text": "SQL 데이터 조작 언어(DML) 개요",
                      "id": "sql-데이터-조작-언어-dml-개요",
                      "children": null
                    },
                    {
                      "text": "기본 질의 구조",
                      "id": "기본-질의-구조",
                      "children": null
                    },
                    {
                      "text": "SELECT 절의 활용",
                      "id": "select-절의-활용",
                      "children": [
                        {
                          "text": "속성 선택 및 프로젝션",
                          "id": "속성-선택-및-프로젝션",
                          "children": null
                        },
                        {
                          "text": "대소문자 구분 및 SQL 명령 규칙",
                          "id": "대소문자-구분-및-sql-명령-규칙",
                          "children": null
                        },
                        {
                          "text": "중복 처리 (ALL, DISTINCT)",
                          "id": "중복-처리-all-distinct",
                          "children": null
                        },
                        {
                          "text": "모든 속성 선택 (*) 및 리터럴 사용",
                          "id": "모든-속성-선택-및-리터럴-사용",
                          "children": null
                        },
                        {
                          "text": "산술 표현식 및 결과 이름 변경 (AS)",
                          "id": "산술-표현식-및-결과-이름-변경-as",
                          "children": null
                        }
                      ]
                    },
                    {
                      "text": "WHERE 절의 활용",
                      "id": "where-절의-활용",
                      "children": [
                        {
                          "text": "조건 지정 및 선택 연산",
                          "id": "조건-지정-및-선택-연산",
                          "children": null
                        },
                        {
                          "text": "논리 연산자 (AND, OR, NOT) 및 비교 연산자",
                          "id": "논리-연산자-and-or-not-및-비교-연산자",
                          "children": null
                        },
                        {
                          "text": "BETWEEN 연산자",
                          "id": "between-연산자",
                          "children": null
                        },
                        {
                          "text": "튜플 비교",
                          "id": "튜플-비교",
                          "children": null
                        }
                      ]
                    },
                    {
                      "text": "FROM 절의 활용",
                      "id": "from-절의-활용",
                      "children": [
                        {
                          "text": "관계 지정 및 카티션 곱",
                          "id": "관계-지정-및-카티션-곱",
                          "children": null
                        },
                        {
                          "text": "조인 구현 (Cartesian-product + selection)",
                          "id": "조인-구현-cartesian-product-selection",
                          "children": null
                        }
                      ]
                    },
                    {
                      "text": "이름 변경 (AS) 연산",
                      "id": "이름-변경-as-연산",
                      "children": null
                    }
                  ]
                },
                "quiz": [
                  {
                    "question": "중복된 값을 제거하고 강사들의 부서 이름을 검색하는 올바른 SQL 쿼리는 무엇입니까?",
                    "options": [
                      "SELECT ALL dept_name FROM instructor;",
                      "SELECT dept_name FROM instructor;",
                      "SELECT DISTINCT dept_name FROM instructor;",
                      "SELECT UNIQUE dept_name FROM instructor;"
                    ],
                    "answerIndex": 2,
                    "explanation": "`DISTINCT` 키워드는 SELECT 절에서 중복된 결과를 제거하는 데 사용됩니다."
                  },
                  {
                    "question": "'Comp. Sci.' 부서에 속하며 급여가 70,000보다 많은 모든 강사의 이름을 찾는 SQL 쿼리로 가장 적절한 것은 무엇입니까?",
                    "options": [
                      "SELECT name FROM instructor WHERE dept_name = 'Comp. Sci.' OR salary > 70000;",
                      "SELECT name FROM instructor WHERE dept_name = 'Comp. Sci.' AND salary > 70000;",
                      "SELECT name FROM instructor WHERE dept_name <> 'Comp. Sci.' AND salary <= 70000;",
                      "SELECT name FROM instructor WHERE dept_name = 'Comp. Sci.' BETWEEN salary 70000;"
                    ],
                    "answerIndex": 1,
                    "explanation": "`AND` 논리 연산자는 두 조건을 모두 만족하는 경우를 찾을 때 사용됩니다."
                  },
                  {
                    "question": "다음 SQL 쿼리 `SELECT DISTINCT T.name FROM instructor AS T, instructor AS S WHERE T.salary > S.salary AND S.dept_name = 'Comp. Sci.'`에 대한 설명으로 옳은 것은 무엇입니까?",
                    "options": [
                      "이 쿼리는 'Comp. Sci.' 부서 강사들 중 가장 높은 급여를 받는 강사의 이름을 찾습니다.",
                      "이 쿼리는 'Comp. Sci.' 부서의 특정 강사보다 급여가 높은 다른 강사들의 이름을 찾습니다.",
                      "이 쿼리는 'Comp. Sci.' 부서의 모든 강사 이름을 나열합니다.",
                      "이 쿼리는 두 개의 다른 테이블에서 강사 정보를 조인합니다."
                    ],
                    "answerIndex": 1,
                    "explanation": "`FROM instructor AS T, instructor AS S`는 instructor 테이블을 두 개의 별칭(T와 S)으로 사용하여 자체 조인(self-join)을 수행하며, `WHERE T.salary > S.salary AND S.dept_name = 'Comp. Sci.'` 조건은 'Comp. Sci.' 부서의 어떤 강사(S)보다 급여가 높은 강사(T)를 찾습니다."
                  }
                ]
              },
              {
                "title": "SQL DML 고급 기능: NULL 값, 집합 연산, 문자열 처리 및 정렬",
                "metadata": "Source: cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf, Text length: 3206 chars",
                "documentContent": [
                  {
                    "type": "heading",
                    "content": "NULL 값",
                    "level": 1
                  },
                  {
                    "type": "paragraph",
                    "content": "튜플에 일부 속성에 대해 NULL 값이 있을 수 있습니다. NULL은 알 수 없거나 값이 존재하지 않음을 의미합니다. NULL이 포함된 모든 산술 표현식의 결과는 NULL입니다. 예를 들어, '5 + NULL'은 NULL을 반환합니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "IS NULL / IS NOT NULL",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "술어 `IS NULL`은 NULL 값을 확인하는 데 사용됩니다. 예를 들어, `SELECT name FROM instructor WHERE salary IS NULL`은 급여가 NULL인 모든 강사의 이름을 찾습니다. `IS NOT NULL` 술어는 적용된 값이 NULL이 아닐 때 성공합니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "집합 연산",
                    "level": 1
                  },
                  {
                    "type": "paragraph",
                    "content": "`UNION`, `INTERSECT`, `EXCEPT`와 같은 집합 연산이 있습니다. 이 연산들은 각각 자동으로 중복을 제거합니다. 모든 중복을 유지하려면 `ALL` 키워드를 사용합니다(예: `UNION ALL`, `INTERSECT ALL`, `EXCEPT ALL`). 참고로 `SELECT` 문은 기본적으로 모든 중복을 유지합니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "UNION",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "`UNION`은 두 쿼리의 결과를 결합합니다. 예를 들어, 2017년 가을 또는 2018년 봄에 개설된 강좌를 찾을 수 있습니다. (`SELECT course_id FROM teaches WHERE semester = 'Fall' AND year = 2017) UNION (SELECT course_id FROM teaches WHERE semester = 'Spring' AND year = 2018`).",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "INTERSECT",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "`INTERSECT`는 두 쿼리 결과의 공통 부분을 찾습니다. 예를 들어, 2017년 가을과 2018년 봄 모두에 개설된 강좌를 찾을 수 있습니다. MySQL은 `INTERSECT`를 직접 지원하지 않으므로, `JOIN`을 사용하여 에뮬레이션할 수 있습니다. (`SELECT LT.course_id FROM (SELECT course_id FROM teaches WHERE semester = 'Fall' AND year = 2017) AS LT JOIN (SELECT course_id FROM teaches WHERE semester = 'Spring' AND year = 2018) AS RT ON LT.course_id=RT.course_id;`)",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "EXCEPT",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "`EXCEPT`는 첫 번째 쿼리 결과에서 두 번째 쿼리 결과를 제외한 부분을 찾습니다. 예를 들어, 2017년 가을에 개설되었지만 2018년 봄에는 개설되지 않은 강좌를 찾을 수 있습니다. MySQL은 `EXCEPT`를 직접 지원하지 않으므로, `NOT IN`을 사용하여 에뮬레이션할 수 있습니다. (`SELECT course_id FROM teaches WHERE semester = 'Fall' AND year = 2017 AND course_id NOT IN(SELECT course_id FROM teaches WHERE semester = 'Spring' AND year = 2018);`)",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "문자열 연산",
                    "level": 1
                  },
                  {
                    "type": "paragraph",
                    "content": "SQL은 문자열 비교를 위한 문자열 일치 연산자를 포함합니다. `LIKE` 연산자는 두 가지 특수 문자를 사용하여 패턴을 설명합니다. 퍼센트(`%`) 문자는 모든 부분 문자열과 일치하고, 밑줄(`_`) 문자는 모든 단일 문자와 일치합니다. 예를 들어, `SELECT name FROM instructor WHERE name LIKE ‘%ri%'`는 이름에 \"ri\" 부분 문자열이 포함된 모든 강사의 이름을 찾습니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "이스케이프 문자(예: 백슬래시 `\\`)를 사용하여 특수 문자를 리터럴로 일치시킬 수 있습니다. 예를 들어, \"100%\" 문자열과 일치시키려면 `LIKE '100 \\%' ESCAPE '\\'`를 사용합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "패턴은 대소문자를 구분합니다. 패턴 일치 예시: 'Intro%'는 \"Intro\"로 시작하는 모든 문자열과 일치하고, '%Comp%'는 \"Comp\"를 포함하는 모든 문자열과 일치하며, '_ _ _'는 정확히 세 문자로 된 모든 문자열과 일치하고, '_ _ _ %'는 최소 세 문자로 된 모든 문자열과 일치합니다. SQL은 연결(`||`), 대소문자 변환, 문자열 길이 찾기, 부분 문자열 추출 등 다양한 문자열 연산을 지원합니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "튜플 표시 정렬",
                    "level": 1
                  },
                  {
                    "type": "paragraph",
                    "content": "`ORDER BY` 절을 사용하여 튜플의 표시 순서를 정렬할 수 있습니다. 예를 들어, 모든 강사의 이름을 알파벳 순서로 나열하려면 `SELECT DISTINCT name FROM instructor ORDER BY name`을 사용합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "여러 속성을 기준으로 정렬할 수 있습니다. 예를 들어, `SELECT dept_name, name FROM instructor ORDER BY dept_name, name`과 같이 부서 이름과 이름 순으로 정렬할 수 있습니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "각 속성에 대해 내림차순(`DESC`) 또는 오름차순(`ASC`)을 지정할 수 있으며, 오름차순이 기본값입니다. 예를 들어, `ORDER BY name DESC`는 이름을 내림차순으로 정렬합니다.",
                    "level": null
                  }
                ],
                "aiNotes": {
                  "summary": "이 문서는 SQL DML의 고급 기능을 다룹니다. NULL 값의 개념과 `IS NULL`, `IS NOT NULL`을 이용한 처리 방법을 설명합니다. 또한 `UNION`, `INTERSECT`, `EXCEPT`와 같은 집합 연산의 사용법과 `ALL` 키워드를 통한 중복 유지 방법, 그리고 MySQL에서의 에뮬레이션 방안을 제시합니다. 마지막으로 `LIKE` 연산자를 활용한 문자열 패턴 매칭과 `ORDER BY` 절을 이용한 결과 정렬 방법에 대해 자세히 설명합니다.",
                  "keyConcepts": [
                    {
                      "term": "NULL 값 처리",
                      "definition": "데이터베이스에서 알 수 없거나 존재하지 않는 값을 나타내는 NULL을 다루는 방법과 관련된 SQL 기능."
                    },
                    {
                      "term": "SQL 집합 연산",
                      "definition": "여러 쿼리 결과를 `UNION`, `INTERSECT`, `EXCEPT`를 사용하여 결합하거나 비교하는 기능."
                    },
                    {
                      "term": "문자열 패턴 매칭",
                      "definition": "`LIKE` 연산자와 `%`, `_` 특수 문자를 사용하여 문자열 내의 특정 패턴을 검색하는 방법."
                    },
                    {
                      "term": "결과 집합 정렬",
                      "definition": "`ORDER BY` 절을 사용하여 쿼리 결과 튜플의 표시 순서를 오름차순(`ASC`) 또는 내림차순(`DESC`)으로 지정하는 방법."
                    }
                  ],
                  "importantTerms": [
                    {
                      "term": "NULL",
                      "definition": "알 수 없거나 존재하지 않는 값."
                    },
                    {
                      "term": "IS NULL / IS NOT NULL",
                      "definition": "NULL 값을 확인하는 데 사용되는 술어."
                    },
                    {
                      "term": "UNION",
                      "definition": "두 쿼리 결과를 합치는 집합 연산자이며, 기본적으로 중복을 제거한다."
                    },
                    {
                      "term": "LIKE",
                      "definition": "문자열 패턴 매칭에 사용되는 연산자."
                    },
                    {
                      "term": "%",
                      "definition": "`LIKE` 연산자에서 임의의 부분 문자열과 일치하는 특수 문자."
                    },
                    {
                      "term": "_",
                      "definition": "`LIKE` 연산자에서 임의의 단일 문자와 일치하는 특수 문자."
                    },
                    {
                      "term": "ORDER BY",
                      "definition": "쿼리 결과의 정렬 순서를 지정하는 절."
                    }
                  ],
                  "outline": [
                    {
                      "text": "NULL 값",
                      "id": "null-값",
                      "children": [
                        {
                          "text": "NULL 값의 정의 및 특징",
                          "id": "null-값의-정의-및-특징",
                          "children": null
                        },
                        {
                          "text": "IS NULL / IS NOT NULL 술어",
                          "id": "is-null-is-not-null-술어",
                          "children": null
                        }
                      ]
                    },
                    {
                      "text": "집합 연산",
                      "id": "집합-연산",
                      "children": [
                        {
                          "text": "집합 연산의 종류 (UNION, INTERSECT, EXCEPT)",
                          "id": "집합-연산의-종류",
                          "children": null
                        },
                        {
                          "text": "중복 제거 및 ALL 키워드",
                          "id": "중복-제거-및-all-키워드",
                          "children": null
                        },
                        {
                          "text": "UNION 예시",
                          "id": "union-예시",
                          "children": null
                        },
                        {
                          "text": "INTERSECT 예시 및 MySQL 에뮬레이션",
                          "id": "intersect-예시-및-mysql-에뮬레이션",
                          "children": null
                        },
                        {
                          "text": "EXCEPT 예시 및 MySQL 에뮬레이션",
                          "id": "except-예시-및-mysql-에뮬레이션",
                          "children": null
                        }
                      ]
                    },
                    {
                      "text": "문자열 연산",
                      "id": "문자열-연산",
                      "children": [
                        {
                          "text": "LIKE 연산자 및 패턴 매칭 특수 문자 (%, _)",
                          "id": "like-연산자-및-패턴-매칭-특수-문자",
                          "children": null
                        },
                        {
                          "text": "이스케이프 문자",
                          "id": "이스케이프-문자",
                          "children": null
                        },
                        {
                          "text": "패턴 매칭 예시 및 특징 (대소문자 구분)",
                          "id": "패턴-매칭-예시-및-특징",
                          "children": null
                        },
                        {
                          "text": "기타 문자열 함수",
                          "id": "기타-문자열-함수",
                          "children": null
                        }
                      ]
                    },
                    {
                      "text": "튜플 표시 정렬",
                      "id": "튜플-표시-정렬",
                      "children": [
                        {
                          "text": "ORDER BY 절 기본 사용법",
                          "id": "order-by-절-기본-사용법",
                          "children": null
                        },
                        {
                          "text": "여러 속성으로 정렬",
                          "id": "여러-속성으로-정렬",
                          "children": null
                        },
                        {
                          "text": "오름차순 (ASC) 및 내림차순 (DESC) 지정",
                          "id": "오름차순-및-내림차순-지정",
                          "children": null
                        }
                      ]
                    }
                  ]
                },
                "quiz": [
                  {
                    "question": "SQL에서 NULL 값이 포함된 산술 연산의 결과는 무엇입니까?",
                    "options": [
                      "0",
                      "1",
                      "NULL",
                      "오류"
                    ],
                    "answerIndex": 2,
                    "explanation": "NULL이 포함된 산술 표현식의 결과는 항상 NULL입니다."
                  },
                  {
                    "question": "다음 중 두 쿼리 결과의 중복을 포함하여 합치는 SQL 집합 연산자는 무엇입니까?",
                    "options": [
                      "UNION",
                      "INTERSECT ALL",
                      "UNION ALL",
                      "EXCEPT"
                    ],
                    "answerIndex": 2,
                    "explanation": "`UNION`은 중복을 제거하지만, `UNION ALL`은 모든 중복을 유지하면서 두 쿼리 결과를 합칩니다."
                  },
                  {
                    "question": "`LIKE` 연산자에서 임의의 단일 문자와 일치하는 특수 문자는 무엇입니까?",
                    "options": [
                      "%",
                      "_",
                      "\\",
                      "?"
                    ],
                    "answerIndex": 1,
                    "explanation": "`%`는 임의의 부분 문자열과 일치하고, `_`는 임의의 단일 문자와 일치합니다."
                  }
                ]
              },
              {
                "title": "SQL DML: 집계 함수 및 데이터 수정 (INSERT, UPDATE, DELETE)",
                "metadata": "Source: cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf, Text length: 5040 chars",
                "documentContent": [
                  {
                    "type": "heading",
                    "content": "집계 함수 (Aggregate Functions)",
                    "level": 1
                  },
                  {
                    "type": "paragraph",
                    "content": "집계 함수는 릴레이션의 특정 컬럼 값들의 멀티셋에 대해 작동하며 단일 값을 반환합니다. 주요 집계 함수는 다음과 같습니다:",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **AVG**: 평균값",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **MIN**: 최솟값",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **MAX**: 최댓값",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **SUM**: 합계",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **COUNT**: 값의 개수",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "집계 함수 예시",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "집계 함수는 다양한 질의에 사용될 수 있습니다. 예를 들어, 컴퓨터 공학과 강사들의 평균 급여를 찾거나, 2018년 봄 학기에 강의를 가르친 강사의 총 수를 세거나, `teaches` 릴레이션의 튜플 수를 세는 데 활용됩니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **컴퓨터 공학과 강사들의 평균 급여 찾기:**",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "SELECT AVG(salary)\nFROM instructor\nWHERE dept_name= 'Comp. Sci.';",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **2018년 봄 학기에 강의를 가르친 강사의 총 수 찾기:**",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "SELECT COUNT(DISTINCT ID)\nFROM teaches\nWHERE semester = 'Spring’ AND year = 2018;",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **`teaches` 릴레이션의 튜플 수 찾기:**",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "SELECT COUNT (*)\nFROM teaches;",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "GROUP BY 절",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "`GROUP BY` 절은 특정 컬럼의 값을 기준으로 행들을 그룹으로 묶고, 각 그룹에 대해 집계 함수를 적용할 때 사용됩니다. 예를 들어, 각 부서의 강사 평균 급여를 찾을 수 있습니다.",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "SELECT dept_name, AVG(salary) AS avg_salary\nFROM instructor\nGROUP BY dept_name;",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "GROUP BY 규칙",
                    "level": 3
                  },
                  {
                    "type": "paragraph",
                    "content": "`SELECT` 절에 집계 함수 외에 사용된 모든 속성은 반드시 `GROUP BY` 목록에 포함되어야 합니다. 그렇지 않으면 오류가 발생합니다.",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "/* 오류가 발생하는 질의 */\nSELECT dept_name, ID, AVG(salary)\nFROM instructor\nGROUP BY dept_name;",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "HAVING 절",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "`HAVING` 절은 `GROUP BY` 절에 의해 생성된 그룹에 조건을 적용하여 결과를 필터링하는 데 사용됩니다. 예를 들어, 평균 급여가 65000을 초과하는 모든 부서의 이름과 평균 급여를 찾을 수 있습니다.",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "SELECT dept_name, AVG(salary) AS avg_salary\nFROM instructor\nGROUP BY dept_name\nHAVING AVG(salary) > 65000;",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "HAVING과 WHERE의 차이",
                    "level": 3
                  },
                  {
                    "type": "paragraph",
                    "content": "`HAVING` 절의 조건은 그룹이 형성된 **후**에 적용되는 반면, `WHERE` 절의 조건은 그룹을 형성하기 **전**에 적용됩니다. 이는 데이터 필터링 시점의 중요한 차이입니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "SQL DML 명령어",
                    "level": 1
                  },
                  {
                    "type": "paragraph",
                    "content": "SQL 데이터 조작 언어(DML)는 데이터베이스 내의 데이터를 검색, 삽입, 수정, 삭제하는 데 사용됩니다. 주요 DML 명령어는 `SELECT`, `INSERT`, `UPDATE`, `DELETE`입니다. 데이터 정의 언어(DDL)는 `CREATE`, `ALTER`, `DROP`과 같이 데이터베이스 스키마를 정의하고 관리하는 데 사용됩니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "INSERT (데이터 삽입)",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "`INSERT` 문은 테이블에 새로운 행(튜플)을 추가하는 데 사용됩니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "기본 문법",
                    "level": 3
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **모든 컬럼에 데이터 삽입:**",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "INSERT INTO tablename\nVALUES (col1_value, col2_value, …)",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "    *   값은 테이블 스키마와 동일한 순서로 나열되어야 합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "    *   알 수 없는 데이터 값은 `NULL`로 지정해야 합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "    *   문자열은 따옴표를 사용하며, 작은따옴표(')가 권장됩니다. 따옴표 안의 값은 대소문자를 구분합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **선택한 컬럼에 데이터 삽입:**",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "INSERT INTO tablename (col1_name, col3_name, col4_name, …)\nVALUES (col1_value, col3_value, col4_value, …)",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "INSERT 예시",
                    "level": 3
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **`course` 테이블에 새로운 튜플 추가:**",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "INSERT INTO course\nVALUES ('CS-437', 'Database Systems', 'Comp. Sci.', 4);",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "    또는 동일하게:",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "INSERT INTO course (course_id, title, dept_name, credits)\nVALUES ('CS-437', 'Database Systems', 'Comp. Sci.', 4);",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **`student` 테이블에 `tot_creds`가 NULL인 새로운 튜플 추가:**",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "INSERT INTO student\nVALUES ('3003', 'Green', 'Finance', null);",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "외래 키 제약 조건과 INSERT",
                    "level": 3
                  },
                  {
                    "type": "paragraph",
                    "content": "외래 키는 한 릴레이션의 속성이 다른 릴레이션의 튜플에 매핑되어야 함을 지정합니다. 즉, 한 릴레이션의 값이 다른 릴레이션에 존재해야 합니다. 새로운 행을 삽입할 때는 해당 행이 참조하는 모든 외래 키가 데이터베이스에 이미 추가되어 있는지 확인해야 합니다. 참조된 릴레이션에 해당 값이 존재하지 않으면 외래 키 값을 삽입할 수 없습니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "다른 SELECT 쿼리 결과 삽입",
                    "level": 3
                  },
                  {
                    "type": "paragraph",
                    "content": "`SELECT` 쿼리의 결과를 다른 테이블에 삽입할 수 있습니다. 이때 `SELECT FROM WHERE` 문은 그 결과가 릴레이션에 삽입되기 전에 완전히 평가됩니다. 이는 `INSERT INTO table1 SELECT * FROM table1`과 같은 질의에서 발생할 수 있는 문제를 방지합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **음악학과 학생 중 144학점 이상을 이수한 학생들을 $18,000 급여의 음악학과 강사로 추가:**",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "INSERT INTO instructor\n  SELECT ID, name, dept_name, 18000\n  FROM student\n  WHERE dept_name = 'Music’ AND total_cred > 144;",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "UPDATE (데이터 수정)",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "`UPDATE` 문은 테이블의 기존 데이터를 수정하는 데 사용됩니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "기본 문법",
                    "level": 3
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **테이블 업데이트 (조건 없음):** 모든 행의 지정된 컬럼을 수정합니다.",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "UPDATE tablename\nSET col1_name = new_col1_value, col2_name = new_col2_value, …;",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **조건 있는 테이블 업데이트:** `WHERE` 절의 조건과 일치하는 행만 수정합니다.",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "UPDATE tablename\nSET col1_name = new_col1_value, col2_name = new_col2_value, …\nWHERE predicate;",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "UPDATE 예시",
                    "level": 3
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **모든 강사의 급여를 5% 인상:**",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "UPDATE instructor\nSET salary = salary * 1.05",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **급여가 70000 미만인 강사의 급여를 5% 인상:**",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "UPDATE instructor\nSET salary = salary * 1.05\nWHERE salary < 70000;",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **급여가 평균 급여 미만인 강사의 급여를 5% 인상:**",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "UPDATE instructor\nSET salary = salary * 1.05\nWHERE salary <  (SELECT AVG(salary) FROM instructor);",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "CASE 문을 이용한 조건부 UPDATE",
                    "level": 3
                  },
                  {
                    "type": "paragraph",
                    "content": "여러 조건에 따라 다른 값을 적용해야 할 경우 `CASE` 문을 사용할 수 있습니다. 이는 여러 `UPDATE` 문을 사용하는 것보다 효율적이며, 실행 순서에 따른 문제를 방지할 수 있습니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **급여가 $100,000 초과인 강사는 3% 인상, 그 외는 5% 인상:**",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "UPDATE instructor\nSET salary = CASE\n                           WHEN salary <= 100000 THEN salary * 1.05\n                           ELSE salary * 1.03\n                       END",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "스칼라 서브쿼리를 이용한 UPDATE",
                    "level": 3
                  },
                  {
                    "type": "paragraph",
                    "content": "스칼라 서브쿼리(단일 값을 반환하는 서브쿼리)를 사용하여 컬럼 값을 업데이트할 수 있습니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **모든 학생의 `tot_creds` 값을 재계산하여 업데이트:**",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "UPDATE student S\nSET tot_cred = (SELECT SUM(credits)\n                             FROM takes, course\n                             WHERE takes.course_id = course.course_id  AND\n                                            S.ID= takes.ID  AND\n                                            takes.grade <> 'F' AND\n                                            takes.grade IS NOT NULL);",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "DELETE (데이터 삭제)",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "`DELETE` 문은 테이블에서 행을 제거하는 데 사용됩니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "기본 문법",
                    "level": 3
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **특정 행 제거:** `WHERE` 절의 조건과 일치하는 행을 제거합니다.",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "DELETE FROM tablename\nWHERE predicate;",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **모든 행 제거:** 테이블의 모든 행을 제거합니다.",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "DELETE FROM tablename;",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "TRUNCATE와의 비교",
                    "level": 3
                  },
                  {
                    "type": "paragraph",
                    "content": "`DELETE FROM tablename;`는 `TRUNCATE (TABLE) tablename;`와 기능적으로 유사하게 테이블의 모든 행을 제거합니다. 그러나 `TRUNCATE`는 외래 키 제약 조건이 있는 테이블에서는 사용할 수 없습니다. 외래 키 제약 조건이 있는 테이블을 `TRUNCATE`하려면 먼저 제약 조건을 비활성화해야 합니다.",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "ALTER TABLE tablename\nDISABLE CONSTRAINT constraint_name;",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "DELETE 예시",
                    "level": 3
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **모든 강사 삭제:**",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "DELETE FROM instructor;",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **재무학과 강사 모두 삭제:**",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "DELETE FROM instructor\nWHERE dept_name= 'Finance';",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **Watson 건물에 위치한 부서에 소속된 강사 모두 삭제:**",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "DELETE FROM instructor\nWHERE dept_name IN (SELECT dept_name\n        FROM department\n        WHERE building = 'Watson');",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "서브쿼리를 이용한 DELETE 시 주의사항",
                    "level": 3
                  },
                  {
                    "type": "paragraph",
                    "content": "서브쿼리를 사용하여 `DELETE` 작업을 수행할 때, 삭제되는 튜플이 서브쿼리의 결과에 영향을 미칠 수 있습니다. 예를 들어, 강사 평균 급여보다 낮은 급여를 가진 강사를 삭제하는 경우, 강사가 삭제됨에 따라 평균 급여가 변경될 수 있습니다.",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "DELETE FROM instructor\nWHERE salary < (SELECT AVG (salary) FROM instructor);",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "SQL에서는 이러한 문제를 해결하기 위해 다음과 같은 방식을 사용합니다. 먼저 `AVG(salary)`를 계산하고 삭제할 모든 튜플을 찾은 다음, 평균을 재계산하거나 튜플을 재확인하지 않고 찾아진 모든 튜플을 삭제합니다.",
                    "level": null
                  }
                ],
                "aiNotes": {
                  "summary": "이 문서는 SQL의 데이터 조작 언어(DML) 중 집계 함수와 데이터 수정 명령어(INSERT, UPDATE, DELETE)에 대해 설명합니다. 집계 함수의 종류(AVG, MIN, MAX, SUM, COUNT)와 사용 예시를 제시하며, GROUP BY 및 HAVING 절의 사용법과 WHERE 절과의 차이점을 강조합니다. 또한, INSERT 명령어를 이용한 데이터 삽입 방법, 외래 키 제약 조건과의 관계, 그리고 SELECT 쿼리 결과 삽입에 대해 다룹니다. UPDATE 명령어의 기본 문법, 다양한 조건부 업데이트 예시, 그리고 CASE 문 및 스칼라 서브쿼리 활용법을 설명합니다. 마지막으로 DELETE 명령어의 기본 문법, TRUNCATE와의 차이점, 외래 키 제약 조건, 그리고 서브쿼리를 사용한 삭제 시의 처리 방식에 대해 상세히 기술합니다.",
                  "keyConcepts": [
                    {
                      "term": "집계 함수 (Aggregate Functions)",
                      "definition": "릴레이션의 컬럼 값들의 멀티셋에 대해 작동하여 단일 값을 반환하는 함수 (예: AVG, MIN, MAX, SUM, COUNT)."
                    },
                    {
                      "term": "GROUP BY",
                      "definition": "SQL에서 특정 컬럼의 값을 기준으로 행들을 그룹으로 묶어 각 그룹에 대해 집계 함수를 적용할 수 있게 하는 절."
                    },
                    {
                      "term": "HAVING 절",
                      "definition": "GROUP BY 절에 의해 생성된 그룹에 조건을 적용하여 결과를 필터링하는 데 사용되는 절. WHERE 절과 달리 그룹화 후에 적용된다."
                    },
                    {
                      "term": "INSERT",
                      "definition": "SQL에서 테이블에 새로운 행(튜플)을 추가하는 데 사용되는 DML 명령어."
                    },
                    {
                      "term": "UPDATE",
                      "definition": "SQL에서 테이블의 기존 데이터를 수정하는 데 사용되는 DML 명령어."
                    },
                    {
                      "term": "DELETE",
                      "definition": "SQL에서 테이블의 행을 제거하는 데 사용되는 DML 명령어."
                    }
                  ],
                  "importantTerms": [
                    {
                      "term": "멀티셋 (Multiset)",
                      "definition": "중복된 값을 허용하는 집합."
                    },
                    {
                      "term": "튜플 (Tuple)",
                      "definition": "릴레이션(테이블)의 한 행을 의미한다."
                    },
                    {
                      "term": "외래 키 (Foreign Key)",
                      "definition": "한 릴레이션의 속성이 다른 릴레이션의 기본 키를 참조하여 두 릴레이션 간의 관계를 설정하는 제약 조건."
                    },
                    {
                      "term": "스칼라 서브쿼리 (Scalar Subquery)",
                      "definition": "단일 행, 단일 컬럼의 값을 반환하는 서브쿼리."
                    },
                    {
                      "term": "TRUNCATE",
                      "definition": "테이블의 모든 행을 빠르게 제거하는 DDL 명령어. DELETE와 달리 외래 키 제약 조건이 있는 테이블에는 직접 적용할 수 없다."
                    }
                  ],
                  "outline": [
                    {
                      "text": "집계 함수 (Aggregate Functions)",
                      "id": "집계-함수-aggregate-functions",
                      "children": [
                        {
                          "text": "집계 함수 예시",
                          "id": "집계-함수-예시",
                          "children": null
                        },
                        {
                          "text": "GROUP BY 절",
                          "id": "group-by-절",
                          "children": [
                            {
                              "text": "GROUP BY 규칙",
                              "id": "group-by-규칙",
                              "children": null
                            }
                          ]
                        },
                        {
                          "text": "HAVING 절",
                          "id": "having-절",
                          "children": [
                            {
                              "text": "HAVING과 WHERE의 차이",
                              "id": "having과-where의-차이",
                              "children": null
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "text": "SQL DML 명령어",
                      "id": "sql-dml-명령어",
                      "children": [
                        {
                          "text": "INSERT (데이터 삽입)",
                          "id": "insert-데이터-삽입",
                          "children": [
                            {
                              "text": "기본 문법",
                              "id": "기본-문법",
                              "children": null
                            },
                            {
                              "text": "INSERT 예시",
                              "id": "insert-예시",
                              "children": null
                            },
                            {
                              "text": "외래 키 제약 조건과 INSERT",
                              "id": "외래-키-제약-조건과-insert",
                              "children": null
                            },
                            {
                              "text": "다른 SELECT 쿼리 결과 삽입",
                              "id": "다른-select-쿼리-결과-삽입",
                              "children": null
                            }
                          ]
                        },
                        {
                          "text": "UPDATE (데이터 수정)",
                          "id": "update-데이터-수정",
                          "children": [
                            {
                              "text": "기본 문법",
                              "id": "기본-문법-1",
                              "children": null
                            },
                            {
                              "text": "UPDATE 예시",
                              "id": "update-예시",
                              "children": null
                            },
                            {
                              "text": "CASE 문을 이용한 조건부 UPDATE",
                              "id": "case-문을-이용한-조건부-update",
                              "children": null
                            },
                            {
                              "text": "스칼라 서브쿼리를 이용한 UPDATE",
                              "id": "스칼라-서브쿼리를-이용한-update",
                              "children": null
                            }
                          ]
                        },
                        {
                          "text": "DELETE (데이터 삭제)",
                          "id": "delete-데이터-삭제",
                          "children": [
                            {
                              "text": "기본 문법",
                              "id": "기본-문법-2",
                              "children": null
                            },
                            {
                              "text": "TRUNCATE와의 비교",
                              "id": "truncate와의-비교",
                              "children": null
                            },
                            {
                              "text": "DELETE 예시",
                              "id": "delete-예시",
                              "children": null
                            },
                            {
                              "text": "서브쿼리를 이용한 DELETE 시 주의사항",
                              "id": "서브쿼리를-이용한-delete-시-주의사항",
                              "children": null
                            }
                          ]
                        }
                      ]
                    }
                  ]
                },
                "quiz": [
                  {
                    "question": "다음 중 SQL의 `HAVING` 절에 대한 설명으로 올바른 것은 무엇입니까?",
                    "options": [
                      "그룹을 형성하기 전에 개별 행에 조건을 적용합니다.",
                      "집계 함수가 적용된 그룹에 조건을 적용합니다.",
                      "테이블에서 데이터를 삭제할 때 사용됩니다.",
                      "새로운 행을 테이블에 삽입할 때 사용됩니다."
                    ],
                    "answerIndex": 1,
                    "explanation": "`HAVING` 절은 `GROUP BY` 절에 의해 생성된 그룹에 조건을 적용하여 필터링하는 데 사용됩니다. `WHERE` 절과 달리 그룹화가 완료된 후에 적용됩니다."
                  },
                  {
                    "question": "SQL `INSERT` 문을 사용하여 새 행을 삽입할 때, 외래 키(Foreign Key) 제약 조건과 관련하여 반드시 지켜야 할 사항은 무엇입니까?",
                    "options": [
                      "외래 키 값은 항상 NULL로 설정되어야 합니다.",
                      "새로운 행의 외래 키 값이 참조하는 릴레이션에 이미 존재해야 합니다.",
                      "외래 키 값은 삽입 후 자동으로 생성됩니다.",
                      "외래 키 제약 조건은 `INSERT` 작업에 영향을 미치지 않습니다."
                    ],
                    "answerIndex": 1,
                    "explanation": "외래 키는 다른 릴레이션의 기본 키를 참조하므로, 새로운 행을 삽입할 때 해당 외래 키 값이 참조하는 릴레이션에 이미 존재해야 참조 무결성이 유지됩니다."
                  },
                  {
                    "question": "다음 SQL `UPDATE` 문 중, 급여가 $100,000 이하인 강사의 급여는 5% 인상하고, $100,000 초과인 강사의 급여는 3% 인상하는 올바른 방법은 무엇입니까?",
                    "options": [
                      "UPDATE instructor SET salary = salary * 1.05 WHERE salary <= 100000; UPDATE instructor SET salary = salary * 1.03 WHERE salary > 100000;",
                      "UPDATE instructor SET salary = CASE WHEN salary <= 100000 THEN salary * 1.05 ELSE salary * 1.03 END;",
                      "UPDATE instructor SET salary = salary * 1.03 OR salary * 1.05;",
                      "UPDATE instructor WHERE salary <= 100000 SET salary = salary * 1.05; ELSE SET salary = salary * 1.03;"
                    ],
                    "answerIndex": 1,
                    "explanation": "`CASE` 문은 여러 조건에 따라 다른 값을 적용할 때 사용되는 효율적인 방법입니다. 제시된 `CASE` 문은 주어진 조건에 따라 급여 인상률을 정확하게 적용합니다. 두 개의 `UPDATE` 문을 사용하는 첫 번째 옵션도 가능하지만, 순서에 따라 결과가 달라질 수 있고 `CASE` 문이 더 간결하고 안전한 방법입니다."
                  }
                ]
              }
            ],
            "final_result": ""
          }
        },
        {
          "node": "start_processing",
          "status": "completed",
          "state_snapshot": {
            "run_id": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d",
            "pdf_file_paths": [
              "temp_pdf_uploads/cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_1a4c2f45-b482-4e82-826e-fa8945eb99c7_DB03 - mysql.pdf",
              "temp_pdf_uploads/cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf"
            ],
            "notebook_title": "",
            "holistic_chapters": [],
            "generated_content": [],
            "final_result": ""
          }
        },
        {
          "node": "start_processing",
          "status": "completed",
          "state_snapshot": {
            "run_id": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d",
            "pdf_file_paths": [
              "temp_pdf_uploads/cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_1a4c2f45-b482-4e82-826e-fa8945eb99c7_DB03 - mysql.pdf",
              "temp_pdf_uploads/cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf"
            ],
            "notebook_title": "",
            "holistic_chapters": [],
            "generated_content": [],
            "final_result": ""
          }
        },
        {
          "node": "analyze_overall_structure",
          "status": "completed",
          "state_snapshot": {
            "run_id": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d",
            "pdf_file_paths": [
              "temp_pdf_uploads/cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_1a4c2f45-b482-4e82-826e-fa8945eb99c7_DB03 - mysql.pdf",
              "temp_pdf_uploads/cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf"
            ],
            "notebook_title": "관계형 데이터베이스 시스템: MySQL 소개 및 SQL 심층 활용",
            "holistic_chapters": [
              {
                "chapter_title": "관계형 데이터베이스 시스템(R-DBMS) 개요 및 MySQL 소개",
                "source_pdf_filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_1a4c2f45-b482-4e82-826e-fa8945eb99c7_DB03 - mysql.pdf",
                "chapter_content_summary": "이 장에서는 관계형 데이터베이스 관리 시스템(R-DBMS)의 기본 개념을 소개하고, 대표적인 오픈소스 R-DBMS인 MySQL에 대해 심층적으로 다룹니다. MySQL의 정의, Oracle 소유권, 표준 SQL 호환성, 상업적 웹 서비스에서의 활용 사례, 기업 사용 통계, 그리고 MySQL의 인기 요인(다양한 운영체제 및 프로그래밍 언어 지원, 비용 효율성, 고성능)을 설명합니다. 또한, R-DBMS 시장에서의 MySQL의 트렌드와 인기도를 살펴보고, MySQL 5.x와 8.x 버전의 주요 차이점 및 MySQL 커뮤니티 버전을 다운로드하고 Docker 이미지를 활용하는 방법을 안내합니다. MySQL이 대규모 데이터 처리, 다중 사용자 지원, 효율성, 안정성, 보안성 측면에서 갖는 강점들을 강조합니다.",
                "chapter_full_text": "ECE30030/ITP30010 Database SystemsHandshaking with an R-DBMSCharmgil Hongcharmgil@handong.eduSpring, 2025Handong Global University\n1\nAgenda•Introduction to MySQL•SQL preview\nECE30030/ITP30010 Database Systems2\nMySQL•MySQL is an SQL-based relational database management system (DBMS)•Free and open-source R-DBMS (under GPL)•Owned by Oracle•Commercial version of MySQL is also provided (including technical support)•“My” came from the name of co-founder Michael Widenius’ daughter•C.f., MariaDB•Compatible with standard SQL•Frequently used for commercial web services\nECE30030/ITP30010 Database Systems3\n* Image src: https://en.wikipedia.org/wiki/MySQL\nMySQL•Companies using MySQL (a study by Enlyft)•“We have data on 199,498 (out of 1,409,176) companies that use MySQL”•Often used by companies with 10-50 employees and 1M-10M dollars in revenue•C.f., Oracle 12 is most often used by companies with 50-200 employees and >1000M dollars in revenue\nECE30030/ITP30010 Database Systems4* Source: https://enlyft.com/tech/products/mysql \nMySQL•Companies using MySQL (full list: https://www.mysql.com/customers/)\nECE30030/ITP30010 Database Systems5\n* Source: https://stackshare.io/mysql \nMySQL•Why MySQL?•Popular•Active discussions all over the Internet•Versatile: runs on Linux, Windows, Mac OS X, Solaris, FreeBSD, …•Supports wide range of programming languages (C/C++, Java, Python, .Net, …)•Cost starts from zero•High performance (fast and reliable)\nECE30030/ITP30010 Database Systems6* Image src: https://db-engines.com/en/ranking\nDBMS Trend Popularity\n•Score definition: https://db-engines.com/en/ranking_definition\nECE30030/ITP30010 Database Systems7* Image src: https://db-engines.com/en/ranking_trend \nMySQL•Why MySQL?•Popular•Active discussions all over the Internet•Versatile: runs on Linux, Windows, Mac OS X, Solaris, FreeBSD, …•Supports wide range of programming languages (C/C++, Java, Python, .Net, …)•Cost starts from zero•High performance (fast and reliable)\nECE30030/ITP30010 Database Systems8* Image src: https://dev.mysql.com/downloads/\nMySQL\nECE30030/ITP30010 Database Systems9\n•Massive•Convenient•Multi-user•Safe•Efficient•Reliable\nCan handle terabytes of dataSupports high-level query languageSupports concurrent data accessSupports transactionsCan handle thousands of queries/second99.99% up-time in many real-world products\nMySQL Versions•MySQL 5.x vs 8.x\nECE30030/ITP30010 Database Systems10\nVersion 5.x-Most popular version of MySQL-More stable and conventionalVersion 8.x-Current version-Provides up-to-date DB functionalities (better storage engine, faster, more secure)\n* Source: https://www.eversql.com/mysql-8-adoption-usage-rate/#:~:text=MySQL%205.7%20is%20still%20the,17%25%20are%20using%20MySQL%208. \nMySQL Versions•MySQL 5.x vs 8.x\nECE30030/ITP30010 Database Systems11\nVersion 5.x-Most popular version of MySQL-More stable and conventionalVersion 8.x-Current version-Provides up-to-date DB functionalities (better storage engine, faster, more secure)\n* Source: https://severalnines.com/database-blog/mysql-performance-benchmarking-mysql-57-vs-mysql-80 \nMySQL Versions•MySQL 5.x vs 8.x\nECE30030/ITP30010 Database Systems12\nVersion 5.x-Most popular version of MySQL-More stable and conventionalVersion 8.x-Current version-Provides up-to-date DB functionalities (better storage engine, faster, more secure)\n* Source: https://severalnines.com/database-blog/mysql-performance-benchmarking-mysql-57-vs-mysql-80 \nWhere to Get MySQL?•https://dev.mysql.com/downloads/•Look for the “Community” versions – the branch that is available for free•”Enterprise” versions are the commercial ones•We have prepared a Docker image for the course•Consists of Ubuntu Server, MySQL, example databases for course activities\nECE30030/ITP30010 Database Systems13* Image src: https://www.docker.com \nWhere to Get MySQL?\nECE30030/ITP30010 Database Systems14\n* Image source: https://baumannalexj.medium.com/connect-your-db-tool-to-a-dockerized-mysql-server-container-bc18853524ed   https://www.jetbrains.com/datagrip/features/look_and_feel.html"
              },
              {
                "chapter_title": "SQL(구조적 질의어)의 이해: 기본 개념과 역사",
                "source_pdf_filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf",
                "chapter_content_summary": "SQL(Structured Query Language)의 정의와 관계형 데이터베이스를 조작하는 주된 언어로서의 역할을 설명합니다. SQL이 '무엇을 할지'를 명시하는 고수준 언어이며, DBMS가 '어떻게 할지'를 결정하는 쿼리 최적화 과정을 다룹니다. 또한, SQL의 두 가지 주요 측면인 데이터 정의 언어(DDL)와 데이터 조작 언어(DML)를 소개하고, 무결성, 뷰 정의, 트랜잭션 제어, 내장 SQL 및 동적 SQL, 권한 부여와 같은 SQL의 다양한 구성 요소를 살펴봅니다. 마지막으로, IBM SEQUEL에서 시작하여 Oracle V2를 거쳐 ANSI 및 ISO 표준으로 발전한 SQL의 간략한 역사를 소개하고, 기본적인 SQL 쿼리 구조(SELECT, FROM, WHERE)를 설명합니다.",
                "chapter_full_text": "ECE30030/ITP30010 Database SystemsStructured Query LanguageReading: Chapter 3\nCharmgil Hongcharmgil@handong.eduSpring, 2025Handong Global University\n1\nAgenda•Structured query language (SQL)•SQL data manipulation language (DML)•SELECT, FROM, WHERE•NULL values•Set operations•String operations, ordering•Aggregate functions, aggregation•SQL data definition language (DDL)   --   NEXT CLASS\nECE30030/ITP30010 Database Systems2\nStructured Query Language (SQL)•SQL: Structured Query Language•The principal language used to describe and manipulate relational databases•Very high-level•Say “what to do” rather than “how to do it”•SQL is not specifying data-manipulation details•DBMSs figure out the “best” way to execute queries•Called “query optimization”•Two aspects to SQL•Data definition: for declaring database schemas (DDL)•Data manipulation: for querying (asking questions about) databases and for modifying the database (DML)\nECE30030/ITP30010 Database Systems3\nSQL Parts•DML – provides the ability to query information from the database and to insert tuples into, delete tuples from, and modify tuples in the database•Integrity – the DDL includes commands for specifying integrity constraints•View definition – the DDL includes commands for defining views•Transaction control – includes commands for specifying the beginning and ending of transactions•Embedded SQL and dynamic SQL – define how SQL statements can be embedded within general-purpose programming language•Authorization – includes commands for specifying access rights to relations and viewsECE30030/ITP30010 Database Systems4\nA Brief History•IBM SEQUEL (Structured English Query Language) was developed as a part of the System R project (Chamberlin and Boyce, early 1970s)•Later on, SEQUEL was renamed SQL (structured query language)•System R à System/38 (1979), SQL/DS (1981), DB2 (1983)•Relational Software, Inc released the first commercial implementation of SQL, Oracle V2 for VAX computers•Relational Software, Inc is now Oracle Corporation•ANSI and ISO standardized SQL:•SQL-86,  SQL-89,  SQL-92,  SQL:1999,  …,  SQL:2011,  SQL:2016 (current)•SQL-92 is supported by the most of database systems\nECE30030/ITP30010 Database Systems5\nBasic Query Structure•A typical SQL query has the form:   SELECT A1, A2, ..., An FROM r1, r2, ..., rm WHERE P•Ai represents an attribute•Ri represents a relation•P is a predicate\n•The result of an SQL query is a relation\nECE30030/ITP30010 Database Systems6"
              },
              {
                "chapter_title": "SQL 데이터 조작 언어(DML) 기초: SELECT, FROM, WHERE 절",
                "source_pdf_filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf",
                "chapter_content_summary": "이 장에서는 SQL 데이터 조작 언어(DML)의 핵심 구성 요소인 SELECT, FROM, WHERE 절을 상세히 다룹니다. 'instructor' 및 'teaches'와 같은 예시 관계(테이블)를 사용하여 실제 쿼리 작성 방법을 시연합니다. SELECT 절을 통해 원하는 속성을 선택하고, 중복을 포함하거나 제거하는 방법(ALL, DISTINCT), 모든 속성을 선택하는 '*' 사용법, 리터럴 및 산술 표현식 활용, 그리고 AS 키워드를 사용한 속성 이름 변경 방법을 학습합니다. WHERE 절에서는 논리 연산자(AND, OR, NOT) 및 비교 연산자(<, <=, >, >=, =, <>, BETWEEN)를 사용하여 조건을 지정하고, 튜플 비교를 수행하는 방법을 설명합니다. 마지막으로 FROM 절을 통해 쿼리에 포함될 관계를 지정하고, 카르테시안 곱을 이해하며, WHERE 절과 결합하여 JOIN 연산을 구현하는 방법을 구체적인 예시와 함께 제시합니다. 또한, AS 키워드를 이용한 관계 및 속성 이름 변경(별칭 지정)을 다룹니다.",
                "chapter_full_text": "ECE30030/ITP30010 Database Systems7\nSQL Data Manipulation Language•The SQL data-manipulation language (DML) allows querying (ask questions about) and modifying the databases\nECE30030/ITP30010 Database Systems8\nRunning Examples•Relations (tables): instructor, teaches\nECE30030/ITP30010 Database Systems9\nInstructor relationteaches relation\nBasic Query Structure•A typical SQL query has the form:   SELECT A1, A2, ..., An FROM r1, r2, ..., rm WHERE P•Ai represents an attribute•Ri represents a relation•P is a predicate\n•The result of an SQL query is a relation\nECE30030/ITP30010 Database Systems10\nThe SELECT Clause•The SELECT clause lists the attributes desired in the result of a query•Corresponds to the projection operation of the relational algebra\n•Example: Find the names of all instructors•SQL: SELECT name FROM instructor;\nECE30030/ITP30010 Database Systems11\nNote•Note: SQL names are case insensitive•E.g., Name ≡ NAME ≡ name•SQL commands (SELECT, FROM, WHERE, …) are written in upper case (just a convention)•MySQL has an option flag, lower_case_table_names•Link: https://dev.mysql.com/doc/refman/8.0/en/identifier-case-sensitivity.html \nECE30030/ITP30010 Database Systems12\nThe SELECT Clause•SQL allows duplicates in relations as well as in query results•The keyword ALL specifies that duplicates should not be removed SELECT ALL dept_name FROM instructor\nECE30030/ITP30010 Database Systems13\nThe SELECT Clause•SQL allows duplicates in relations as well as in query results•The keyword ALL specifies that duplicates should not be removed SELECT ALL dept_name FROM instructor•To force the elimination of duplicates, insert the keyword DISTINCT after SELECT•Find the department names of all instructor, removing duplicates: SELECT DISTINCT dept_name FROM instructor;\nECE30030/ITP30010 Database Systems14\nThe SELECT Clause•An asterisk in the select clause denotes “all attributes” SELECT * FROM instructor;•An attribute can be a literal with no FROM clause SELECT ‘437’;•Result is a table with one column and a single row with value “437”•Can give the column a name using AS: SELECT ‘437’ AS FOO\nECE30030/ITP30010 Database Systems15\nThe SELECT Clause•An attribute can be a literal with FROM clause SELECT 'A' FROM instructor•Result is a table with one column and N rows (number of tuples in the instructor table), each row with value “A”\nECE30030/ITP30010 Database Systems16\nThe SELECT Clause•The SELECT clause can contain arithmetic expressions involving the operation, +, –, *, and /, and operating on constants or attributes of tuples•The query:     SELECT ID, name, salary/12      FROM instructorwould return a relation that is the same as the instructor relation,except that the value of the attribute salary is divided by 12\n17\nThe SELECT Clause•The SELECT clause can contain arithmetic expressions involving the operation, +, –, *, and /, and operating on constants or attributes of tuples•Can rename “salary/12” using the AS clause:  SELECT ID, name, salary/12 AS monthly_salary   FROM instructor\n18\nThe WHERE Clause•The WHERE clause specifies conditions that the result must satisfy•Corresponds to the selection predicate of the relational algebra•E.g., To find all instructors in Comp. Sci. dept: SELECT name FROM instructor  WHERE dept_name = 'Comp. Sci.';\nECE30030/ITP30010 Database Systems19\nThe WHERE Clause•SQL allows the use of the logical connectives AND, OR, and NOT•The operands of the logical connectives can be expressions involving the comparison operators <, <=, >, >=, =, and <>•<> means not equal (there is no != in SQL)•Comparisons can be applied to results of arithmetic expressions•E.g., To find all instructors in Comp. Sci. with salary > 70,000: SELECT name FROM instructor WHERE dept_name = 'Comp. Sci.' AND salary > 70000;\nECE30030/ITP30010 Database Systems20\nThe WHERE Clause•SQL includes a BETWEEN comparison operator•Example: Find the names of all instructors with salary between $90,000 and $100,000 (that is, ³ $90,000 and £ $100,000)•SELECT nameFROM instructorWHERE salary BETWEEN 90000 AND 100000\nECE30030/ITP30010 Database Systems21\nThe WHERE Clause•Tuple comparison: makes comparisons per tuple•SELECT name, course_idFROM instructor, teachesWHERE (instructor.ID, dept_name) = (teaches.ID, 'Biology');\nECE30030/ITP30010 Database Systems22\nThe FROM Clause•The FROM clause lists the relations involved in the query•Corresponds to the Cartesian-product operation of the relational algebra•Find the Cartesian-product instructor × teaches SELECT * FROM instructor, teaches;•Generates every possible instructor-teaches pairs, with all attributes from both relations•For common attributes (e.g., ID), the attributes in the resulting table are renamed using the relation name (e.g., instructor.ID)\nECE30030/ITP30010 Database Systems23\nThe FROM Clause•Find the Cartesian-product instructor X teaches SELECT * FROM instructor, teaches;\n24\ninstructor.IDnamedept_namesalaryteaches.IDcourse_idsec_idsemesteryear10101SrinivasanComp. Sci.6500076766BIO-101 1Summer201712121WuFinance9000076766BIO-101 1Summer201715151MozartMusic4000076766BIO-101 1Summer201722222EinsteinPhysics9500076766BIO-101 1Summer201732343El SaidHistory6000076766BIO-101 1Summer2017… … … … … … … … …10101SrinivasanComp. Sci.6500010101CS-101 1Fall 201712121WuFinance9000010101CS-101 1Fall 201715151MozartMusic4000010101CS-101 1Fall 201722222EinsteinPhysics9500010101CS-101 1Fall 201732343El SaidHistory6000010101CS-101 1Fall 2017… … … … … … … … …… … … … … … … … …10101SrinivasanComp. Sci.6500083821CS-190 2Spring201712121WuFinance9000083821CS-190 2Spring201715151MozartMusic4000083821CS-190 2Spring2017… … … … … … … … …10101SrinivasanComp. Sci.6500010101CS-315 1Spring201812121WuFinance9000010101CS-315 1Spring201815151MozartMusic4000010101CS-315 1Spring2018… … … … … … … … …… … … … … … … … …\nImplementing JOIN•Cartesian-product is not very useful directly; but useful combined with WHERE-clause condition (selection operation in relational algebra)•Cartesian-product + selection = join•E.g., Find the names of all instructors who have taught some course and the course_id SELECT name, course_id FROM instructor , teaches WHERE instructor.ID = teaches.ID\nECE30030/ITP30010 Database Systems25\nImplementing JOIN•Cartesian-product is not very useful directly; but useful combined with WHERE-clause condition (selection operation in relational algebra)•Cartesian-product + selection = join•Find the names of all instructors in the Music department who have taught some course and the course_id SELECT name, course_id FROM instructor , teaches WHERE instructor.ID = teaches.ID  AND instructor. dept_name = 'Music'\nECE30030/ITP30010 Database Systems26\nThe Rename Operation•The SQL allows renaming relations and attributes using the AS clause:   old-name AS new-name•Find the names of all instructors who have a higher salary than some instructor in ‘Comp. Sci.’•SELECT DISTINCT T.nameFROM instructor AS T, instructor AS SWHERE T.salary > S.salary AND S.dept_name = 'Comp. Sci.'\nECE30030/ITP30010 Database Systems27\nThe Rename Operation•The SQL allows renaming relations and attributes using the AS clause:   old-name AS new-name•Find the names of all instructors who have a higher salary than some instructor in ‘Comp. Sci.’•SELECT DISTINCT T.nameFROM instructor AS T, instructor AS SWHERE T.salary > S.salary AND S.dept_name = 'Comp. Sci.'•Keyword AS is optional and may be omitted  instructor AS T  ≡  instructor T\nECE30030/ITP30010 Database Systems28"
              },
              {
                "chapter_title": "SQL DML 고급 기능: NULL 값, 집합 연산, 문자열 처리 및 정렬",
                "source_pdf_filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf",
                "chapter_content_summary": "이 장에서는 SQL DML의 고급 기능을 탐구합니다. 먼저, 알려지지 않거나 존재하지 않는 값을 나타내는 NULL 값의 특성을 이해하고, 산술 연산에서의 NULL 동작 및 IS NULL / IS NOT NULL 술어를 사용하여 NULL 값을 확인하는 방법을 배웁니다. 다음으로, 여러 쿼리 결과를 결합하는 집합 연산인 UNION, INTERSECT, EXCEPT를 살펴봅니다. 각 연산이 기본적으로 중복을 제거하며, ALL 키워드를 사용하여 중복을 유지하는 방법을 설명합니다. 특히 MySQL에서 INTERSECT와 EXCEPT가 직접 지원되지 않을 때 JOIN 또는 NOT IN을 사용하여 에뮬레이션하는 기법을 소개합니다. 이어서, 문자열 패턴 매칭을 위한 LIKE 연산자와 '%' (모든 부분 문자열), '_' (단일 문자) 특수 문자의 사용법을 다룹니다. 백슬래시를 이용한 이스케이프 문자 처리, 패턴 매칭의 대소문자 구분, 그리고 연결, 대소문자 변환, 길이 확인, 부분 문자열 추출 등 다양한 SQL 문자열 함수를 소개합니다. 마지막으로, ORDER BY 절을 사용하여 쿼리 결과를 특정 속성을 기준으로 오름차순(ASC) 또는 내림차순(DESC)으로 정렬하는 방법을 학습하며, 여러 속성을 기준으로 정렬하는 예시도 제시합니다.",
                "chapter_full_text": "ECE30030/ITP30010 Database Systems29\nNULL Values•It is possible for tuples to have a NULL value for some of their attributes•NULL signifies an unknown value or that a value does not exist•The result of any arithmetic expression involving NULL is NULL•E.g.,  5 + NULL returns NULL\nECE30030/ITP30010 Database Systems30\nIS NULL / IS NOT NULL•The predicate IS NULL can be used to check for NULL values•E.g., Find all instructors whose salary is null SELECT name FROM instructor WHERE salary IS NULL•The predicate IS NOT NULL succeeds if the value on which it is applied is not null\nECE30030/ITP30010 Database Systems31\nECE30030/ITP30010 Database Systems32\nSet Operations•Set operations UNION, INTERSECT, and EXCEPT•Each of the above operations automatically eliminates duplicates•To retain all duplicates, use ALL:•UNION ALL•INTERSECT ALL•EXCEPT ALL\n•C.f., SELECT retains all duplicates by default\nECE30030/ITP30010 Database Systems33\nSet Operations: UNION•Find courses that ran in Fall 2017 or in Spring 2018•(SELECT course_id  FROM teaches WHERE semester = 'Fall' AND year = 2017)UNION(SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018)\nECE30030/ITP30010 Database Systems34\nSet Operations: INTERSECT•Find courses that ran in Fall 2017 and in Spring 2018•(SELECT course_id  FROM teaches WHERE semester = 'Fall' AND year = 2017)INTERSECT(SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018)•C.f., MySQL does NOT support INTERSECT•One can emulate INTERSECT using JOIN (we’ll study JOIN later)•SELECT LT.course_idFROM (SELECT course_id FROM teaches WHERE semester = 'Fall' AND year = 2017) AS LTJOIN (SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018) AS RTON LT.course_id=RT.course_id;\nECE30030/ITP30010 Database Systems35\nSet Operations: EXCEPT•Find courses that ran in Fall 2017 but not in Spring 2018•(SELECT course_id  FROM teaches WHERE semester = 'Fall' AND year = 2017)EXCEPT(SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018)•C.f., MySQL does NOT support EXCEPT•One can emulate EXCEPT using NOT IN•SELECT course_id FROM teaches WHERE semester = 'Fall' AND year = 2017AND course_id NOT IN(SELECT course_id  FROM teaches  WHERE semester = 'Spring' AND year = 2018);\nECE30030/ITP30010 Database Systems36\nECE30030/ITP30010 Database Systems37\nString Operations•SQL includes a string-matching operator for comparisons on character strings•The operator LIKE uses patterns that are described using two special characters:•percent (%) – The % character matches any substring•underscore (_) – The _ character matches any character•Find the names of all instructors whose name includes the substring “ri” SELECT name FROM instructor WHERE name LIKE ‘%ri%'\nECE30030/ITP30010 Database Systems38\nString Operations•Escape character: Use backslash (\\) as the escape character•E.g., Match the string “100%” LIKE '100 \\%’ ESCAPE  ‘\\’\nECE30030/ITP30010 Database Systems39\nString Operations•Patterns are case sensitive•Pattern matching examples:•'Intro%' matches any string beginning with “Intro”•'%Comp%' matches any string containing “Comp” as a substring•'_ _ _' matches any string of exactly three characters•'_ _ _ %' matches any string of at least three characters•SQL supports a variety of string operations such as•concatenation (using “||”)•converting from upper to lower case (and vice versa)•finding string length, extracting substrings, etc.\nECE30030/ITP30010 Database Systems40\nOrdering the Display of Tuples•List in alphabetic order the names of all instructors•SELECT DISTINCT nameFROM instructorORDER BY name\nECE30030/ITP30010 Database Systems41\nOrdering the Display of Tuples•Can sort on multiple attributes•E.g., SELECT dept_name, name     FROM instructor      ORDER BY dept_name, name\nECE30030/ITP30010 Database Systems42\nOrdering the Display of Tuples•We may specify DESC for descending order or ASC for ascending order, for each attribute; ascending order is the default•E.g., ORDER BY name DESC\nECE30030/ITP30010 Database Systems43"
              },
              {
                "chapter_title": "SQL DML 집계 함수 및 데이터 수정 (INSERT, UPDATE, DELETE)",
                "source_pdf_filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf",
                "chapter_content_summary": "이 장에서는 SQL 데이터 조작 언어(DML)의 고급 기능인 집계 함수와 데이터를 수정하는 명령어를 다룹니다. AVG, MIN, MAX, SUM, COUNT와 같은 집계 함수를 사용하여 컬럼 값의 멀티셋에 대한 통계 값을 계산하는 방법을 학습합니다. 특히 GROUP BY 절을 이용한 데이터 그룹화와 HAVING 절을 이용한 그룹별 필터링을 심층적으로 다루며, WHERE 절과의 차이점을 명확히 설명합니다. 또한, DML의 핵심 명령인 INSERT, UPDATE, DELETE에 대해 자세히 알아봅니다. INSERT 명령을 통해 테이블에 새로운 튜플을 추가하는 다양한 방법(모든 컬럼, 선택된 컬럼, NULL 값 처리, SELECT 쿼리 결과 삽입)과 외래 키 제약 조건의 중요성을 강조합니다. UPDATE 명령으로는 기존 데이터를 수정하는 기본 구문, 조건부 업데이트, CASE 문을 사용한 복잡한 조건 처리, 스칼라 서브쿼리 활용법을 배웁니다. 마지막으로 DELETE 명령을 통해 테이블에서 특정 행 또는 모든 행을 삭제하는 방법과 TRUNCATE 명령의 차이점, 그리고 삭제 시 서브쿼리 사용 시의 고려사항을 설명합니다.",
                "chapter_full_text": "ECE30030/ITP30010 Database Systems44\nAggregate Functions•These functions operate on the multiset of values of a column of a relation, and return a value•AVG:  average value•MIN:  minimum value•MAX:  maximum value•SUM:  sum of values•COUNT:  number of values\nECE30030/ITP30010 Database Systems45\nAggregate Functions Examples•Find the average salary of instructors in the Computer Science department•SELECT AVG(salary)FROM instructorWHERE dept_name= 'Comp. Sci.';•Find the total number of instructors who teach a course in the Spring 2018 semester•SELECT COUNT(DISTINCT ID)FROM teachesWHERE semester = 'Spring’ AND year = 2018;•Find the number of tuples in the teaches relation•SELECT COUNT (*)FROM teaches;\nECE30030/ITP30010 Database Systems46\nAggregate Functions: Group By•Find the average salary of instructors in each department•SELECT dept_name, AVG(salary) AS avg_salaryFROM instructorGROUP BY dept_name;\nECE30030/ITP30010 Database Systems47\nAggregation•Attributes in SELECT clause outside of aggregate functions must appear in GROUP BY list•/* erroneous query */SELECT dept_name, ID, AVG(salary)FROM instructorGROUP BY dept_name;\nECE30030/ITP30010 Database Systems48\nAggregate Functions – Having Clause•Find the names and average salaries of all departments whose average salary is greater than 65000•SELECT dept_name, AVG(salary) AS avg_salaryFROM instructorGROUP BY dept_nameHAVING AVG(salary) > 65000;\nECE30030/ITP30010 Database Systems49\nAggregate Functions – Having Clause•Note: predicates in the HAVING clause are applied after the formation of groups whereas predicates in the WHERE clause are applied before forming groups\nECE30030/ITP30010 Database Systems50\nSELECT dept_name, AVG(salary) AS avg_salaryFROM instructorGROUP BY dept_nameHAVING AVG(salary) > 65000;\nSELECT dept_name, AVG(salary) AS avg_salaryFROM instructorWHERE salary > 65000GROUP BY dept_name;\nSQL Commands\nSQLDMLSELECTINSERTUPDATEDELETE\nDDLCREATEALTERDROP\nECE30030/ITP30010 Database Systems51\nINSERT•Basic syntax•Insert data into every column:•INSERT INTO tablenameVALUES (col1_value, col2_value, …)•Must list values in the same order as in the table schema•If some data values are unknown, must type NULL •For character sequences, use quotation marks•Single quotation marks are preferred (but double quotation marks are allowed)•Value in quotations is case-sensitive•Insert data into selected columns•INSERT INTO tablename (col1_name, col3_name, col4_name, …)VALUES (col1_value, col3_value, col4_value, …)\nECE30030/ITP30010 Database Systems52\nINSERT•Add a new tuple to course•INSERT INTO courseVALUES ('CS-437', 'Database Systems', 'Comp. Sci.', 4);•or equivalently•INSERT INTO course (course_id, title, dept_name, credits)VALUES ('CS-437', 'Database Systems', 'Comp. Sci.', 4);•Add a new tuple to student  with tot_creds set to null•INSERT INTO studentVALUES ('3003', 'Green', 'Finance', null);\nECE30030/ITP30010 Database Systems53\nINSERT•A foreign key specifies that an attribute from one relation has to map to a tuple in another relation•Value in one relation must appear in another relation\nECE30030/ITP30010 Database Systems54\nRelation: instructor\nRelation: department\nINSERT•A foreign key specifies that an attribute from one relation has to map to a tuple in another relation•Value in one relation must appear in another relation•Make sure all foreign keys that new row references have already been added to database•One cannot insert a foreign key value unless the corresponding value exists in the referenced relation\nECE30030/ITP30010 Database Systems55\nINSERT•Inserting results of other SELECT query•Make each student in the Music department who has earned more than 144 credit hours an instructor in the Music department with a salary of  $18,000•INSERT INTO instructor  SELECT ID, name, dept_name, 18000  FROM student   WHERE dept_name = 'Music’ AND total_cred > 144;•The SELECT FROM WHERE statement is evaluated fully before any of its results are inserted into the relation•Otherwise queries like  INSERT INTO table1 SELECT * FROM table1would cause problem\nECE30030/ITP30010 Database Systems56\nUPDATE•Basic syntax•Updating a table•UPDATE tablenameSET col1_name = new_col1_value, col2_name = new_col2_value, …;•Updating a table with conditions•UPDATE tablenameSET col1_name = new_col1_value, col2_name = new_col2_value, …WHERE predicate;\nECE30030/ITP30010 Database Systems57\nUPDATE•Give a 5% salary raise to all instructors•UPDATE instructorSET salary = salary * 1.05•Give a 5% salary raise to those instructors who earn less than 70000•UPDATE instructorSET salary = salary * 1.05WHERE salary < 70000;•Give a 5% salary raise to instructors whose salary is less than average•UPDATE instructorSET salary = salary * 1.05WHERE salary <  (SELECT AVG(salary) FROM instructor);\nECE30030/ITP30010 Database Systems58\nUPDATE•Increase salaries of instructors whose salary is over $100,000 by 3%, and all others by a 5%•Write two UPDATE statements:  UPDATE instructor  SET salary = salary * 1.03  WHERE salary > 100000;  UPDATE instructor  SET salary = salary * 1.05  WHERE salary <= 100000;•The order is important•Can be done better using the case statement (next slide)\nECE30030/ITP30010 Database Systems59\nCASE Statement for Conditional Update•The following query is equivalent to the previous UPDATE queries•UPDATE instructorSET salary = CASE                           WHEN salary <= 100000 THEN salary * 1.05                           ELSE salary * 1.03                       END\nECE30030/ITP30010 Database Systems60\nUPDATE with Scalar Subqueries•Recompute and update tot_creds value for all students•UPDATE student SSET tot_cred = (SELECT SUM(credits)                             FROM takes, course                             WHERE takes.course_id = course.course_id  AND                                            S.ID= takes.ID  AND                                            takes.grade <> 'F' AND                                            takes.grade IS NOT NULL);\nECE30030/ITP30010 Database Systems61\nDELETE•Basic syntax•To remove specific rows•DELETE FROM tablenameWHERE predicate;•To remove all rows•DELETE FROM tablename;•This is equivalent to TRUNCATE:TRUNCATE (TABLE) tablename;•One cannot truncate a table with foreign key constraints•Must disable the constraints first (we will cover ALTER when we study SQL DDL):ALTER TABLE tablenameDISABLE CONSTRAINT constraint_name;\nECE30030/ITP30010 Database Systems62\nDELETE•Delete all instructors•DELETE FROM instructor;•Delete all instructors from the Finance department•DELETE FROM instructorWHERE dept_name= 'Finance';•Delete all tuples in the instructor relation for those instructors associated with a department located in the Watson building•DELETE FROM instructorWHERE dept name IN (SELECT dept name        FROM department        WHERE building = 'Watson');\nECE30030/ITP30010 Database Systems63\nDELETE•Delete all instructors whose salary is less than the average salary of instructors•Example:  DELETE FROM instructor                WHERE salary < (SELECT AVG (salary)                  FROM instructor);•Issue:  as we delete tuples from instructor, the average salary changes•Solution used in SQL:1.First, compute AVG(salary) and find all tuples to delete2.Next, delete all tuples found above (without recomputing AVG or retesting the tuples)\nECE30030/ITP30010 Database Systems64"
              }
            ],
            "generated_content": [],
            "final_result": ""
          }
        },
        {
          "node": "start_processing",
          "status": "completed",
          "state_snapshot": {
            "run_id": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d",
            "pdf_file_paths": [
              "temp_pdf_uploads/cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_1a4c2f45-b482-4e82-826e-fa8945eb99c7_DB03 - mysql.pdf",
              "temp_pdf_uploads/cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf"
            ],
            "notebook_title": "",
            "holistic_chapters": [],
            "generated_content": [],
            "final_result": ""
          }
        },
        {
          "node": "start_processing",
          "status": "completed",
          "state_snapshot": {
            "run_id": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d",
            "pdf_file_paths": [
              "temp_pdf_uploads/cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_1a4c2f45-b482-4e82-826e-fa8945eb99c7_DB03 - mysql.pdf",
              "temp_pdf_uploads/cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf"
            ],
            "notebook_title": "",
            "holistic_chapters": [],
            "generated_content": [],
            "final_result": ""
          }
        },
        {
          "node": "analyze_overall_structure",
          "status": "completed",
          "state_snapshot": {
            "run_id": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d",
            "pdf_file_paths": [
              "temp_pdf_uploads/cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_1a4c2f45-b482-4e82-826e-fa8945eb99c7_DB03 - mysql.pdf",
              "temp_pdf_uploads/cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf"
            ],
            "notebook_title": "관계형 데이터베이스 시스템: MySQL 소개 및 SQL 심층 활용",
            "holistic_chapters": [
              {
                "chapter_title": "관계형 데이터베이스 시스템(R-DBMS) 개요 및 MySQL 소개",
                "source_pdf_filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_1a4c2f45-b482-4e82-826e-fa8945eb99c7_DB03 - mysql.pdf",
                "chapter_content_summary": "이 장에서는 관계형 데이터베이스 관리 시스템(R-DBMS)의 기본 개념을 소개하고, 대표적인 오픈소스 R-DBMS인 MySQL에 대해 심층적으로 다룹니다. MySQL의 정의, Oracle 소유권, 표준 SQL 호환성, 상업적 웹 서비스에서의 활용 사례, 기업 사용 통계, 그리고 MySQL의 인기 요인(다양한 운영체제 및 프로그래밍 언어 지원, 비용 효율성, 고성능)을 설명합니다. 또한, R-DBMS 시장에서의 MySQL의 트렌드와 인기도를 살펴보고, MySQL 5.x와 8.x 버전의 주요 차이점 및 MySQL 커뮤니티 버전을 다운로드하고 Docker 이미지를 활용하는 방법을 안내합니다. MySQL이 대규모 데이터 처리, 다중 사용자 지원, 효율성, 안정성, 보안성 측면에서 갖는 강점들을 강조합니다.",
                "chapter_full_text": "ECE30030/ITP30010 Database SystemsHandshaking with an R-DBMSCharmgil Hongcharmgil@handong.eduSpring, 2025Handong Global University\n1\nAgenda•Introduction to MySQL•SQL preview\nECE30030/ITP30010 Database Systems2\nMySQL•MySQL is an SQL-based relational database management system (DBMS)•Free and open-source R-DBMS (under GPL)•Owned by Oracle•Commercial version of MySQL is also provided (including technical support)•“My” came from the name of co-founder Michael Widenius’ daughter•C.f., MariaDB•Compatible with standard SQL•Frequently used for commercial web services\nECE30030/ITP30010 Database Systems3\n* Image src: https://en.wikipedia.org/wiki/MySQL\nMySQL•Companies using MySQL (a study by Enlyft)•“We have data on 199,498 (out of 1,409,176) companies that use MySQL”•Often used by companies with 10-50 employees and 1M-10M dollars in revenue•C.f., Oracle 12 is most often used by companies with 50-200 employees and >1000M dollars in revenue\nECE30030/ITP30010 Database Systems4* Source: https://enlyft.com/tech/products/mysql \nMySQL•Companies using MySQL (full list: https://www.mysql.com/customers/)\nECE30030/ITP30010 Database Systems5\n* Source: https://stackshare.io/mysql \nMySQL•Why MySQL?•Popular•Active discussions all over the Internet•Versatile: runs on Linux, Windows, Mac OS X, Solaris, FreeBSD, …•Supports wide range of programming languages (C/C++, Java, Python, .Net, …)•Cost starts from zero•High performance (fast and reliable)\nECE30030/ITP30010 Database Systems6* Image src: https://db-engines.com/en/ranking\nDBMS Trend Popularity\n•Score definition: https://db-engines.com/en/ranking_definition\nECE30030/ITP30010 Database Systems7* Image src: https://db-engines.com/en/ranking_trend \nMySQL•Why MySQL?•Popular•Active discussions all over the Internet•Versatile: runs on Linux, Windows, Mac OS X, Solaris, FreeBSD, …•Supports wide range of programming languages (C/C++, Java, Python, .Net, …)•Cost starts from zero•High performance (fast and reliable)\nECE30030/ITP30010 Database Systems8* Image src: https://dev.mysql.com/downloads/\nMySQL\nECE30030/ITP30010 Database Systems9\n•Massive•Convenient•Multi-user•Safe•Efficient•Reliable\nCan handle terabytes of dataSupports high-level query languageSupports concurrent data accessSupports transactionsCan handle thousands of queries/second99.99% up-time in many real-world products\nMySQL Versions•MySQL 5.x vs 8.x\nECE30030/ITP30010 Database Systems10\nVersion 5.x-Most popular version of MySQL-More stable and conventionalVersion 8.x-Current version-Provides up-to-date DB functionalities (better storage engine, faster, more secure)\n* Source: https://www.eversql.com/mysql-8-adoption-usage-rate/#:~:text=MySQL%205.7%20is%20still%20the,17%25%20are%20using%20MySQL%208. \nMySQL Versions•MySQL 5.x vs 8.x\nECE30030/ITP30010 Database Systems11\nVersion 5.x-Most popular version of MySQL-More stable and conventionalVersion 8.x-Current version-Provides up-to-date DB functionalities (better storage engine, faster, more secure)\n* Source: https://severalnines.com/database-blog/mysql-performance-benchmarking-mysql-57-vs-mysql-80 \nMySQL Versions•MySQL 5.x vs 8.x\nECE30030/ITP30010 Database Systems12\nVersion 5.x-Most popular version of MySQL-More stable and conventionalVersion 8.x-Current version-Provides up-to-date DB functionalities (better storage engine, faster, more secure)\n* Source: https://severalnines.com/database-blog/mysql-performance-benchmarking-mysql-57-vs-mysql-80 \nWhere to Get MySQL?•https://dev.mysql.com/downloads/•Look for the “Community” versions – the branch that is available for free•”Enterprise” versions are the commercial ones•We have prepared a Docker image for the course•Consists of Ubuntu Server, MySQL, example databases for course activities\nECE30030/ITP30010 Database Systems13* Image src: https://www.docker.com \nWhere to Get MySQL?\nECE30030/ITP30010 Database Systems14\n* Image source: https://baumannalexj.medium.com/connect-your-db-tool-to-a-dockerized-mysql-server-container-bc18853524ed   https://www.jetbrains.com/datagrip/features/look_and_feel.html"
              },
              {
                "chapter_title": "SQL(구조적 질의어)의 이해: 기본 개념과 역사",
                "source_pdf_filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf",
                "chapter_content_summary": "SQL(Structured Query Language)의 정의와 관계형 데이터베이스를 조작하는 주된 언어로서의 역할을 설명합니다. SQL이 '무엇을 할지'를 명시하는 고수준 언어이며, DBMS가 '어떻게 할지'를 결정하는 쿼리 최적화 과정을 다룹니다. 또한, SQL의 두 가지 주요 측면인 데이터 정의 언어(DDL)와 데이터 조작 언어(DML)를 소개하고, 무결성, 뷰 정의, 트랜잭션 제어, 내장 SQL 및 동적 SQL, 권한 부여와 같은 SQL의 다양한 구성 요소를 살펴봅니다. 마지막으로, IBM SEQUEL에서 시작하여 Oracle V2를 거쳐 ANSI 및 ISO 표준으로 발전한 SQL의 간략한 역사를 소개하고, 기본적인 SQL 쿼리 구조(SELECT, FROM, WHERE)를 설명합니다.",
                "chapter_full_text": "ECE30030/ITP30010 Database SystemsStructured Query LanguageReading: Chapter 3\nCharmgil Hongcharmgil@handong.eduSpring, 2025Handong Global University\n1\nAgenda•Structured query language (SQL)•SQL data manipulation language (DML)•SELECT, FROM, WHERE•NULL values•Set operations•String operations, ordering•Aggregate functions, aggregation•SQL data definition language (DDL)   --   NEXT CLASS\nECE30030/ITP30010 Database Systems2\nStructured Query Language (SQL)•SQL: Structured Query Language•The principal language used to describe and manipulate relational databases•Very high-level•Say “what to do” rather than “how to do it”•SQL is not specifying data-manipulation details•DBMSs figure out the “best” way to execute queries•Called “query optimization”•Two aspects to SQL•Data definition: for declaring database schemas (DDL)•Data manipulation: for querying (asking questions about) databases and for modifying the database (DML)\nECE30030/ITP30010 Database Systems3\nSQL Parts•DML – provides the ability to query information from the database and to insert tuples into, delete tuples from, and modify tuples in the database•Integrity – the DDL includes commands for specifying integrity constraints•View definition – the DDL includes commands for defining views•Transaction control – includes commands for specifying the beginning and ending of transactions•Embedded SQL and dynamic SQL – define how SQL statements can be embedded within general-purpose programming language•Authorization – includes commands for specifying access rights to relations and viewsECE30030/ITP30010 Database Systems4\nA Brief History•IBM SEQUEL (Structured English Query Language) was developed as a part of the System R project (Chamberlin and Boyce, early 1970s)•Later on, SEQUEL was renamed SQL (structured query language)•System R à System/38 (1979), SQL/DS (1981), DB2 (1983)•Relational Software, Inc released the first commercial implementation of SQL, Oracle V2 for VAX computers•Relational Software, Inc is now Oracle Corporation•ANSI and ISO standardized SQL:•SQL-86,  SQL-89,  SQL-92,  SQL:1999,  …,  SQL:2011,  SQL:2016 (current)•SQL-92 is supported by the most of database systems\nECE30030/ITP30010 Database Systems5\nBasic Query Structure•A typical SQL query has the form:   SELECT A1, A2, ..., An FROM r1, r2, ..., rm WHERE P•Ai represents an attribute•Ri represents a relation•P is a predicate\n•The result of an SQL query is a relation\nECE30030/ITP30010 Database Systems6"
              },
              {
                "chapter_title": "SQL 데이터 조작 언어(DML) 기초: SELECT, FROM, WHERE 절",
                "source_pdf_filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf",
                "chapter_content_summary": "이 장에서는 SQL 데이터 조작 언어(DML)의 핵심 구성 요소인 SELECT, FROM, WHERE 절을 상세히 다룹니다. 'instructor' 및 'teaches'와 같은 예시 관계(테이블)를 사용하여 실제 쿼리 작성 방법을 시연합니다. SELECT 절을 통해 원하는 속성을 선택하고, 중복을 포함하거나 제거하는 방법(ALL, DISTINCT), 모든 속성을 선택하는 '*' 사용법, 리터럴 및 산술 표현식 활용, 그리고 AS 키워드를 사용한 속성 이름 변경 방법을 학습합니다. WHERE 절에서는 논리 연산자(AND, OR, NOT) 및 비교 연산자(<, <=, >, >=, =, <>, BETWEEN)를 사용하여 조건을 지정하고, 튜플 비교를 수행하는 방법을 설명합니다. 마지막으로 FROM 절을 통해 쿼리에 포함될 관계를 지정하고, 카르테시안 곱을 이해하며, WHERE 절과 결합하여 JOIN 연산을 구현하는 방법을 구체적인 예시와 함께 제시합니다. 또한, AS 키워드를 이용한 관계 및 속성 이름 변경(별칭 지정)을 다룹니다.",
                "chapter_full_text": "ECE30030/ITP30010 Database Systems7\nSQL Data Manipulation Language•The SQL data-manipulation language (DML) allows querying (ask questions about) and modifying the databases\nECE30030/ITP30010 Database Systems8\nRunning Examples•Relations (tables): instructor, teaches\nECE30030/ITP30010 Database Systems9\nInstructor relationteaches relation\nBasic Query Structure•A typical SQL query has the form:   SELECT A1, A2, ..., An FROM r1, r2, ..., rm WHERE P•Ai represents an attribute•Ri represents a relation•P is a predicate\n•The result of an SQL query is a relation\nECE30030/ITP30010 Database Systems10\nThe SELECT Clause•The SELECT clause lists the attributes desired in the result of a query•Corresponds to the projection operation of the relational algebra\n•Example: Find the names of all instructors•SQL: SELECT name FROM instructor;\nECE30030/ITP30010 Database Systems11\nNote•Note: SQL names are case insensitive•E.g., Name ≡ NAME ≡ name•SQL commands (SELECT, FROM, WHERE, …) are written in upper case (just a convention)•MySQL has an option flag, lower_case_table_names•Link: https://dev.mysql.com/doc/refman/8.0/en/identifier-case-sensitivity.html \nECE30030/ITP30010 Database Systems12\nThe SELECT Clause•SQL allows duplicates in relations as well as in query results•The keyword ALL specifies that duplicates should not be removed SELECT ALL dept_name FROM instructor\nECE30030/ITP30010 Database Systems13\nThe SELECT Clause•SQL allows duplicates in relations as well as in query results•The keyword ALL specifies that duplicates should not be removed SELECT ALL dept_name FROM instructor•To force the elimination of duplicates, insert the keyword DISTINCT after SELECT•Find the department names of all instructor, removing duplicates: SELECT DISTINCT dept_name FROM instructor;\nECE30030/ITP30010 Database Systems14\nThe SELECT Clause•An asterisk in the select clause denotes “all attributes” SELECT * FROM instructor;•An attribute can be a literal with no FROM clause SELECT ‘437’;•Result is a table with one column and a single row with value “437”•Can give the column a name using AS: SELECT ‘437’ AS FOO\nECE30030/ITP30010 Database Systems15\nThe SELECT Clause•An attribute can be a literal with FROM clause SELECT 'A' FROM instructor•Result is a table with one column and N rows (number of tuples in the instructor table), each row with value “A”\nECE30030/ITP30010 Database Systems16\nThe SELECT Clause•The SELECT clause can contain arithmetic expressions involving the operation, +, –, *, and /, and operating on constants or attributes of tuples•The query:     SELECT ID, name, salary/12      FROM instructorwould return a relation that is the same as the instructor relation,except that the value of the attribute salary is divided by 12\n17\nThe SELECT Clause•The SELECT clause can contain arithmetic expressions involving the operation, +, –, *, and /, and operating on constants or attributes of tuples•Can rename “salary/12” using the AS clause:  SELECT ID, name, salary/12 AS monthly_salary   FROM instructor\n18\nThe WHERE Clause•The WHERE clause specifies conditions that the result must satisfy•Corresponds to the selection predicate of the relational algebra•E.g., To find all instructors in Comp. Sci. dept: SELECT name FROM instructor  WHERE dept_name = 'Comp. Sci.';\nECE30030/ITP30010 Database Systems19\nThe WHERE Clause•SQL allows the use of the logical connectives AND, OR, and NOT•The operands of the logical connectives can be expressions involving the comparison operators <, <=, >, >=, =, and <>•<> means not equal (there is no != in SQL)•Comparisons can be applied to results of arithmetic expressions•E.g., To find all instructors in Comp. Sci. with salary > 70,000: SELECT name FROM instructor WHERE dept_name = 'Comp. Sci.' AND salary > 70000;\nECE30030/ITP30010 Database Systems20\nThe WHERE Clause•SQL includes a BETWEEN comparison operator•Example: Find the names of all instructors with salary between $90,000 and $100,000 (that is, ³ $90,000 and £ $100,000)•SELECT nameFROM instructorWHERE salary BETWEEN 90000 AND 100000\nECE30030/ITP30010 Database Systems21\nThe WHERE Clause•Tuple comparison: makes comparisons per tuple•SELECT name, course_idFROM instructor, teachesWHERE (instructor.ID, dept_name) = (teaches.ID, 'Biology');\nECE30030/ITP30010 Database Systems22\nThe FROM Clause•The FROM clause lists the relations involved in the query•Corresponds to the Cartesian-product operation of the relational algebra•Find the Cartesian-product instructor × teaches SELECT * FROM instructor, teaches;•Generates every possible instructor-teaches pairs, with all attributes from both relations•For common attributes (e.g., ID), the attributes in the resulting table are renamed using the relation name (e.g., instructor.ID)\nECE30030/ITP30010 Database Systems23\nThe FROM Clause•Find the Cartesian-product instructor X teaches SELECT * FROM instructor, teaches;\n24\ninstructor.IDnamedept_namesalaryteaches.IDcourse_idsec_idsemesteryear10101SrinivasanComp. Sci.6500076766BIO-101 1Summer201712121WuFinance9000076766BIO-101 1Summer201715151MozartMusic4000076766BIO-101 1Summer201722222EinsteinPhysics9500076766BIO-101 1Summer201732343El SaidHistory6000076766BIO-101 1Summer2017… … … … … … … … …10101SrinivasanComp. Sci.6500010101CS-101 1Fall 201712121WuFinance9000010101CS-101 1Fall 201715151MozartMusic4000010101CS-101 1Fall 201722222EinsteinPhysics9500010101CS-101 1Fall 201732343El SaidHistory6000010101CS-101 1Fall 2017… … … … … … … … …… … … … … … … … …10101SrinivasanComp. Sci.6500083821CS-190 2Spring201712121WuFinance9000083821CS-190 2Spring201715151MozartMusic4000083821CS-190 2Spring2017… … … … … … … … …10101SrinivasanComp. Sci.6500010101CS-315 1Spring201812121WuFinance9000010101CS-315 1Spring201815151MozartMusic4000010101CS-315 1Spring2018… … … … … … … … …… … … … … … … … …\nImplementing JOIN•Cartesian-product is not very useful directly; but useful combined with WHERE-clause condition (selection operation in relational algebra)•Cartesian-product + selection = join•E.g., Find the names of all instructors who have taught some course and the course_id SELECT name, course_id FROM instructor , teaches WHERE instructor.ID = teaches.ID\nECE30030/ITP30010 Database Systems25\nImplementing JOIN•Cartesian-product is not very useful directly; but useful combined with WHERE-clause condition (selection operation in relational algebra)•Cartesian-product + selection = join•Find the names of all instructors in the Music department who have taught some course and the course_id SELECT name, course_id FROM instructor , teaches WHERE instructor.ID = teaches.ID  AND instructor. dept_name = 'Music'\nECE30030/ITP30010 Database Systems26\nThe Rename Operation•The SQL allows renaming relations and attributes using the AS clause:   old-name AS new-name•Find the names of all instructors who have a higher salary than some instructor in ‘Comp. Sci.’•SELECT DISTINCT T.nameFROM instructor AS T, instructor AS SWHERE T.salary > S.salary AND S.dept_name = 'Comp. Sci.'\nECE30030/ITP30010 Database Systems27\nThe Rename Operation•The SQL allows renaming relations and attributes using the AS clause:   old-name AS new-name•Find the names of all instructors who have a higher salary than some instructor in ‘Comp. Sci.’•SELECT DISTINCT T.nameFROM instructor AS T, instructor AS SWHERE T.salary > S.salary AND S.dept_name = 'Comp. Sci.'•Keyword AS is optional and may be omitted  instructor AS T  ≡  instructor T\nECE30030/ITP30010 Database Systems28"
              },
              {
                "chapter_title": "SQL DML 고급 기능: NULL 값, 집합 연산, 문자열 처리 및 정렬",
                "source_pdf_filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf",
                "chapter_content_summary": "이 장에서는 SQL DML의 고급 기능을 탐구합니다. 먼저, 알려지지 않거나 존재하지 않는 값을 나타내는 NULL 값의 특성을 이해하고, 산술 연산에서의 NULL 동작 및 IS NULL / IS NOT NULL 술어를 사용하여 NULL 값을 확인하는 방법을 배웁니다. 다음으로, 여러 쿼리 결과를 결합하는 집합 연산인 UNION, INTERSECT, EXCEPT를 살펴봅니다. 각 연산이 기본적으로 중복을 제거하며, ALL 키워드를 사용하여 중복을 유지하는 방법을 설명합니다. 특히 MySQL에서 INTERSECT와 EXCEPT가 직접 지원되지 않을 때 JOIN 또는 NOT IN을 사용하여 에뮬레이션하는 기법을 소개합니다. 이어서, 문자열 패턴 매칭을 위한 LIKE 연산자와 '%' (모든 부분 문자열), '_' (단일 문자) 특수 문자의 사용법을 다룹니다. 백슬래시를 이용한 이스케이프 문자 처리, 패턴 매칭의 대소문자 구분, 그리고 연결, 대소문자 변환, 길이 확인, 부분 문자열 추출 등 다양한 SQL 문자열 함수를 소개합니다. 마지막으로, ORDER BY 절을 사용하여 쿼리 결과를 특정 속성을 기준으로 오름차순(ASC) 또는 내림차순(DESC)으로 정렬하는 방법을 학습하며, 여러 속성을 기준으로 정렬하는 예시도 제시합니다.",
                "chapter_full_text": "ECE30030/ITP30010 Database Systems29\nNULL Values•It is possible for tuples to have a NULL value for some of their attributes•NULL signifies an unknown value or that a value does not exist•The result of any arithmetic expression involving NULL is NULL•E.g.,  5 + NULL returns NULL\nECE30030/ITP30010 Database Systems30\nIS NULL / IS NOT NULL•The predicate IS NULL can be used to check for NULL values•E.g., Find all instructors whose salary is null SELECT name FROM instructor WHERE salary IS NULL•The predicate IS NOT NULL succeeds if the value on which it is applied is not null\nECE30030/ITP30010 Database Systems31\nECE30030/ITP30010 Database Systems32\nSet Operations•Set operations UNION, INTERSECT, and EXCEPT•Each of the above operations automatically eliminates duplicates•To retain all duplicates, use ALL:•UNION ALL•INTERSECT ALL•EXCEPT ALL\n•C.f., SELECT retains all duplicates by default\nECE30030/ITP30010 Database Systems33\nSet Operations: UNION•Find courses that ran in Fall 2017 or in Spring 2018•(SELECT course_id  FROM teaches WHERE semester = 'Fall' AND year = 2017)UNION(SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018)\nECE30030/ITP30010 Database Systems34\nSet Operations: INTERSECT•Find courses that ran in Fall 2017 and in Spring 2018•(SELECT course_id  FROM teaches WHERE semester = 'Fall' AND year = 2017)INTERSECT(SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018)•C.f., MySQL does NOT support INTERSECT•One can emulate INTERSECT using JOIN (we’ll study JOIN later)•SELECT LT.course_idFROM (SELECT course_id FROM teaches WHERE semester = 'Fall' AND year = 2017) AS LTJOIN (SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018) AS RTON LT.course_id=RT.course_id;\nECE30030/ITP30010 Database Systems35\nSet Operations: EXCEPT•Find courses that ran in Fall 2017 but not in Spring 2018•(SELECT course_id  FROM teaches WHERE semester = 'Fall' AND year = 2017)EXCEPT(SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018)•C.f., MySQL does NOT support EXCEPT•One can emulate EXCEPT using NOT IN•SELECT course_id FROM teaches WHERE semester = 'Fall' AND year = 2017AND course_id NOT IN(SELECT course_id  FROM teaches  WHERE semester = 'Spring' AND year = 2018);\nECE30030/ITP30010 Database Systems36\nECE30030/ITP30010 Database Systems37\nString Operations•SQL includes a string-matching operator for comparisons on character strings•The operator LIKE uses patterns that are described using two special characters:•percent (%) – The % character matches any substring•underscore (_) – The _ character matches any character•Find the names of all instructors whose name includes the substring “ri” SELECT name FROM instructor WHERE name LIKE ‘%ri%'\nECE30030/ITP30010 Database Systems38\nString Operations•Escape character: Use backslash (\\) as the escape character•E.g., Match the string “100%” LIKE '100 \\%’ ESCAPE  ‘\\’\nECE30030/ITP30010 Database Systems39\nString Operations•Patterns are case sensitive•Pattern matching examples:•'Intro%' matches any string beginning with “Intro”•'%Comp%' matches any string containing “Comp” as a substring•'_ _ _' matches any string of exactly three characters•'_ _ _ %' matches any string of at least three characters•SQL supports a variety of string operations such as•concatenation (using “||”)•converting from upper to lower case (and vice versa)•finding string length, extracting substrings, etc.\nECE30030/ITP30010 Database Systems40\nOrdering the Display of Tuples•List in alphabetic order the names of all instructors•SELECT DISTINCT nameFROM instructorORDER BY name\nECE30030/ITP30010 Database Systems41\nOrdering the Display of Tuples•Can sort on multiple attributes•E.g., SELECT dept_name, name     FROM instructor      ORDER BY dept_name, name\nECE30030/ITP30010 Database Systems42\nOrdering the Display of Tuples•We may specify DESC for descending order or ASC for ascending order, for each attribute; ascending order is the default•E.g., ORDER BY name DESC\nECE30030/ITP30010 Database Systems43"
              },
              {
                "chapter_title": "SQL DML 집계 함수 및 데이터 수정 (INSERT, UPDATE, DELETE)",
                "source_pdf_filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf",
                "chapter_content_summary": "이 장에서는 SQL 데이터 조작 언어(DML)의 고급 기능인 집계 함수와 데이터를 수정하는 명령어를 다룹니다. AVG, MIN, MAX, SUM, COUNT와 같은 집계 함수를 사용하여 컬럼 값의 멀티셋에 대한 통계 값을 계산하는 방법을 학습합니다. 특히 GROUP BY 절을 이용한 데이터 그룹화와 HAVING 절을 이용한 그룹별 필터링을 심층적으로 다루며, WHERE 절과의 차이점을 명확히 설명합니다. 또한, DML의 핵심 명령인 INSERT, UPDATE, DELETE에 대해 자세히 알아봅니다. INSERT 명령을 통해 테이블에 새로운 튜플을 추가하는 다양한 방법(모든 컬럼, 선택된 컬럼, NULL 값 처리, SELECT 쿼리 결과 삽입)과 외래 키 제약 조건의 중요성을 강조합니다. UPDATE 명령으로는 기존 데이터를 수정하는 기본 구문, 조건부 업데이트, CASE 문을 사용한 복잡한 조건 처리, 스칼라 서브쿼리 활용법을 배웁니다. 마지막으로 DELETE 명령을 통해 테이블에서 특정 행 또는 모든 행을 삭제하는 방법과 TRUNCATE 명령의 차이점, 그리고 삭제 시 서브쿼리 사용 시의 고려사항을 설명합니다.",
                "chapter_full_text": "ECE30030/ITP30010 Database Systems44\nAggregate Functions•These functions operate on the multiset of values of a column of a relation, and return a value•AVG:  average value•MIN:  minimum value•MAX:  maximum value•SUM:  sum of values•COUNT:  number of values\nECE30030/ITP30010 Database Systems45\nAggregate Functions Examples•Find the average salary of instructors in the Computer Science department•SELECT AVG(salary)FROM instructorWHERE dept_name= 'Comp. Sci.';•Find the total number of instructors who teach a course in the Spring 2018 semester•SELECT COUNT(DISTINCT ID)FROM teachesWHERE semester = 'Spring’ AND year = 2018;•Find the number of tuples in the teaches relation•SELECT COUNT (*)FROM teaches;\nECE30030/ITP30010 Database Systems46\nAggregate Functions: Group By•Find the average salary of instructors in each department•SELECT dept_name, AVG(salary) AS avg_salaryFROM instructorGROUP BY dept_name;\nECE30030/ITP30010 Database Systems47\nAggregation•Attributes in SELECT clause outside of aggregate functions must appear in GROUP BY list•/* erroneous query */SELECT dept_name, ID, AVG(salary)FROM instructorGROUP BY dept_name;\nECE30030/ITP30010 Database Systems48\nAggregate Functions – Having Clause•Find the names and average salaries of all departments whose average salary is greater than 65000•SELECT dept_name, AVG(salary) AS avg_salaryFROM instructorGROUP BY dept_nameHAVING AVG(salary) > 65000;\nECE30030/ITP30010 Database Systems49\nAggregate Functions – Having Clause•Note: predicates in the HAVING clause are applied after the formation of groups whereas predicates in the WHERE clause are applied before forming groups\nECE30030/ITP30010 Database Systems50\nSELECT dept_name, AVG(salary) AS avg_salaryFROM instructorGROUP BY dept_nameHAVING AVG(salary) > 65000;\nSELECT dept_name, AVG(salary) AS avg_salaryFROM instructorWHERE salary > 65000GROUP BY dept_name;\nSQL Commands\nSQLDMLSELECTINSERTUPDATEDELETE\nDDLCREATEALTERDROP\nECE30030/ITP30010 Database Systems51\nINSERT•Basic syntax•Insert data into every column:•INSERT INTO tablenameVALUES (col1_value, col2_value, …)•Must list values in the same order as in the table schema•If some data values are unknown, must type NULL •For character sequences, use quotation marks•Single quotation marks are preferred (but double quotation marks are allowed)•Value in quotations is case-sensitive•Insert data into selected columns•INSERT INTO tablename (col1_name, col3_name, col4_name, …)VALUES (col1_value, col3_value, col4_value, …)\nECE30030/ITP30010 Database Systems52\nINSERT•Add a new tuple to course•INSERT INTO courseVALUES ('CS-437', 'Database Systems', 'Comp. Sci.', 4);•or equivalently•INSERT INTO course (course_id, title, dept_name, credits)VALUES ('CS-437', 'Database Systems', 'Comp. Sci.', 4);•Add a new tuple to student  with tot_creds set to null•INSERT INTO studentVALUES ('3003', 'Green', 'Finance', null);\nECE30030/ITP30010 Database Systems53\nINSERT•A foreign key specifies that an attribute from one relation has to map to a tuple in another relation•Value in one relation must appear in another relation\nECE30030/ITP30010 Database Systems54\nRelation: instructor\nRelation: department\nINSERT•A foreign key specifies that an attribute from one relation has to map to a tuple in another relation•Value in one relation must appear in another relation•Make sure all foreign keys that new row references have already been added to database•One cannot insert a foreign key value unless the corresponding value exists in the referenced relation\nECE30030/ITP30010 Database Systems55\nINSERT•Inserting results of other SELECT query•Make each student in the Music department who has earned more than 144 credit hours an instructor in the Music department with a salary of  $18,000•INSERT INTO instructor  SELECT ID, name, dept_name, 18000  FROM student   WHERE dept_name = 'Music’ AND total_cred > 144;•The SELECT FROM WHERE statement is evaluated fully before any of its results are inserted into the relation•Otherwise queries like  INSERT INTO table1 SELECT * FROM table1would cause problem\nECE30030/ITP30010 Database Systems56\nUPDATE•Basic syntax•Updating a table•UPDATE tablenameSET col1_name = new_col1_value, col2_name = new_col2_value, …;•Updating a table with conditions•UPDATE tablenameSET col1_name = new_col1_value, col2_name = new_col2_value, …WHERE predicate;\nECE30030/ITP30010 Database Systems57\nUPDATE•Give a 5% salary raise to all instructors•UPDATE instructorSET salary = salary * 1.05•Give a 5% salary raise to those instructors who earn less than 70000•UPDATE instructorSET salary = salary * 1.05WHERE salary < 70000;•Give a 5% salary raise to instructors whose salary is less than average•UPDATE instructorSET salary = salary * 1.05WHERE salary <  (SELECT AVG(salary) FROM instructor);\nECE30030/ITP30010 Database Systems58\nUPDATE•Increase salaries of instructors whose salary is over $100,000 by 3%, and all others by a 5%•Write two UPDATE statements:  UPDATE instructor  SET salary = salary * 1.03  WHERE salary > 100000;  UPDATE instructor  SET salary = salary * 1.05  WHERE salary <= 100000;•The order is important•Can be done better using the case statement (next slide)\nECE30030/ITP30010 Database Systems59\nCASE Statement for Conditional Update•The following query is equivalent to the previous UPDATE queries•UPDATE instructorSET salary = CASE                           WHEN salary <= 100000 THEN salary * 1.05                           ELSE salary * 1.03                       END\nECE30030/ITP30010 Database Systems60\nUPDATE with Scalar Subqueries•Recompute and update tot_creds value for all students•UPDATE student SSET tot_cred = (SELECT SUM(credits)                             FROM takes, course                             WHERE takes.course_id = course.course_id  AND                                            S.ID= takes.ID  AND                                            takes.grade <> 'F' AND                                            takes.grade IS NOT NULL);\nECE30030/ITP30010 Database Systems61\nDELETE•Basic syntax•To remove specific rows•DELETE FROM tablenameWHERE predicate;•To remove all rows•DELETE FROM tablename;•This is equivalent to TRUNCATE:TRUNCATE (TABLE) tablename;•One cannot truncate a table with foreign key constraints•Must disable the constraints first (we will cover ALTER when we study SQL DDL):ALTER TABLE tablenameDISABLE CONSTRAINT constraint_name;\nECE30030/ITP30010 Database Systems62\nDELETE•Delete all instructors•DELETE FROM instructor;•Delete all instructors from the Finance department•DELETE FROM instructorWHERE dept_name= 'Finance';•Delete all tuples in the instructor relation for those instructors associated with a department located in the Watson building•DELETE FROM instructorWHERE dept name IN (SELECT dept name        FROM department        WHERE building = 'Watson');\nECE30030/ITP30010 Database Systems63\nDELETE•Delete all instructors whose salary is less than the average salary of instructors•Example:  DELETE FROM instructor                WHERE salary < (SELECT AVG (salary)                  FROM instructor);•Issue:  as we delete tuples from instructor, the average salary changes•Solution used in SQL:1.First, compute AVG(salary) and find all tuples to delete2.Next, delete all tuples found above (without recomputing AVG or retesting the tuples)\nECE30030/ITP30010 Database Systems64"
              }
            ],
            "generated_content": [],
            "final_result": ""
          }
        },
        {
          "node": "generate_chapter_content",
          "status": "completed",
          "state_snapshot": {
            "run_id": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d",
            "pdf_file_paths": [
              "temp_pdf_uploads/cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_1a4c2f45-b482-4e82-826e-fa8945eb99c7_DB03 - mysql.pdf",
              "temp_pdf_uploads/cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf"
            ],
            "all_pdf_texts": [
              {
                "filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_1a4c2f45-b482-4e82-826e-fa8945eb99c7_DB03 - mysql.pdf",
                "text": "ECE30030/ITP30010 Database SystemsHandshaking with an R-DBMSCharmgil Hongcharmgil@handong.eduSpring, 2025Handong Global University\n1\n\nAgenda•Introduction to MySQL•SQL preview\nECE30030/ITP30010 Database Systems2\nMySQL•MySQL is an SQL-based relational database management system (DBMS)•Free and open-source R-DBMS (under GPL)•Owned by Oracle•Commercial version of MySQL is also provided (including technical support)•“My” came from the name of co-founder Michael Widenius’ daughter•C.f., MariaDB•Compatible with standard SQL•Frequently used for commercial web services\nECE30030/ITP30010 Database Systems3\n* Image src: https://en.wikipedia.org/wiki/MySQL\nMySQL•Companies using MySQL (a study by Enlyft)•“We have data on 199,498 (out of 1,409,176) companies that use MySQL”•Often used by companies with 10-50 employees and 1M-10M dollars in revenue•C.f., Oracle 12 is most often used by companies with 50-200 employees and >1000M dollars in revenue\nECE30030/ITP30010 Database Systems4* Source: https://enlyft.com/tech/products/mysql \n\nMySQL•Companies using MySQL (full list: https://www.mysql.com/customers/)\nECE30030/ITP30010 Database Systems5\n* Source: https://stackshare.io/mysql \nMySQL•Why MySQL?•Popular•Active discussions all over the Internet•Versatile: runs on Linux, Windows, Mac OS X, Solaris, FreeBSD, …•Supports wide range of programming languages (C/C++, Java, Python, .Net, …)•Cost starts from zero•High performance (fast and reliable)\nECE30030/ITP30010 Database Systems6* Image src: https://db-engines.com/en/ranking\n\nDBMS Trend Popularity\n•Score definition: https://db-engines.com/en/ranking_definition\nECE30030/ITP30010 Database Systems7* Image src: https://db-engines.com/en/ranking_trend \n\nMySQL•Why MySQL?•Popular•Active discussions all over the Internet•Versatile: runs on Linux, Windows, Mac OS X, Solaris, FreeBSD, …•Supports wide range of programming languages (C/C++, Java, Python, .Net, …)•Cost starts from zero•High performance (fast and reliable)\nECE30030/ITP30010 Database Systems8* Image src: https://dev.mysql.com/downloads/\n\nMySQL\nECE30030/ITP30010 Database Systems9\n•Massive•Convenient•Multi-user•Safe•Efficient•Reliable\nCan handle terabytes of dataSupports high-level query languageSupports concurrent data accessSupports transactionsCan handle thousands of queries/second99.99% up-time in many real-world products\nMySQL Versions•MySQL 5.x vs 8.x\nECE30030/ITP30010 Database Systems10\nVersion 5.x-Most popular version of MySQL-More stable and conventionalVersion 8.x-Current version-Provides up-to-date DB functionalities (better storage engine, faster, more secure)\n* Source: https://www.eversql.com/mysql-8-adoption-usage-rate/#:~:text=MySQL%205.7%20is%20still%20the,17%25%20are%20using%20MySQL%208. \nMySQL Versions•MySQL 5.x vs 8.x\nECE30030/ITP30010 Database Systems11\nVersion 5.x-Most popular version of MySQL-More stable and conventionalVersion 8.x-Current version-Provides up-to-date DB functionalities (better storage engine, faster, more secure)\n* Source: https://severalnines.com/database-blog/mysql-performance-benchmarking-mysql-57-vs-mysql-80 \n\nMySQL Versions•MySQL 5.x vs 8.x\nECE30030/ITP30010 Database Systems12\nVersion 5.x-Most popular version of MySQL-More stable and conventionalVersion 8.x-Current version-Provides up-to-date DB functionalities (better storage engine, faster, more secure)\n* Source: https://severalnines.com/database-blog/mysql-performance-benchmarking-mysql-57-vs-mysql-80 \n\nWhere to Get MySQL?•https://dev.mysql.com/downloads/•Look for the “Community” versions – the branch that is available for free•”Enterprise” versions are the commercial ones•We have prepared a Docker image for the course•Consists of Ubuntu Server, MySQL, example databases for course activities\nECE30030/ITP30010 Database Systems13* Image src: https://www.docker.com \n\nWhere to Get MySQL?\nECE30030/ITP30010 Database Systems14\n* Image source: https://baumannalexj.medium.com/connect-your-db-tool-to-a-dockerized-mysql-server-container-bc18853524ed   https://www.jetbrains.com/datagrip/features/look_and_feel.html\n\nAgenda•Introduction to MySQL•SQL preview\nECE30030/ITP30010 Database Systems15\nStructured Query Language (SQL)•SQL: Structured Query Language•The principal language used to describe and manipulate relational databases•Very high-level•Say “what to do” rather than “how to do it”•SQL is not specifying data-manipulation details•DBMSs figure out the “best” way to execute queries•Called “query optimization”•Two aspects to SQL•Data definition: for declaring database schemas (DDL)•Data manipulation: for querying (asking questions about) databases and for modifying the database (DML)\nECE30030/ITP30010 Database Systems16\nSQL Parts•DML – provides the ability to query information from the database and to insert tuples into, delete tuples from, and modify tuples in the database•Integrity – the DDL includes commands for specifying integrity constraints•Vide definition – the DDL includes commands for defining views•Transaction control – includes commands for specifying the beginning and ending of transactions•Embedded SQL and dynamic SQL – define how SQL statements can be embedded within general-purpose programming language•Authorization – includes commands for specifying access rights to relations and viewsECE30030/ITP30010 Database Systems17\nA Brief History•IBM SEQUEL (Structured English Query Language) was developed as a part of the System R project (Chamberlin and Boyce, early 1970s)•Later on, SEQUEL was renamed SQL (structured query language)•System R à System/38 (1979), SQL/DS (1981), DB2 (1983)•Relational Software, Inc released the first commercial implementation of SQL, Oracle V2 for VAX computers•Relational Software, Inc is now Oracle Corporation•ANSI and ISO standardized SQL:•SQL-86,  SQL-89,  SQL-92,  SQL:1999,  …,  SQL:2011,  SQL:2016 (current)•SQL-92 is supported by the most of database systems\nECE30030/ITP30010 Database Systems18\nBasic Query Structure•A typical SQL query has the form:   SELECT A1, A2, ..., An FROM r1, r2, ..., rm WHERE P•Ai represents an attribute•Ri represents a relation•P is a predicate\n•The result of an SQL query is a relation\nECE30030/ITP30010 Database Systems19\nEOF•Coming next:•Structured Query Language\nECE30030/ITP30010 Database Systems20"
              },
              {
                "filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf",
                "text": "ECE30030/ITP30010 Database SystemsStructured Query LanguageReading: Chapter 3\nCharmgil Hongcharmgil@handong.eduSpring, 2025Handong Global University\n1\n\nAgenda•Structured query language (SQL)•SQL data manipulation language (DML)•SELECT, FROM, WHERE•NULL values•Set operations•String operations, ordering•Aggregate functions, aggregation•SQL data definition language (DDL)   --   NEXT CLASS\nECE30030/ITP30010 Database Systems2\nStructured Query Language (SQL)•SQL: Structured Query Language•The principal language used to describe and manipulate relational databases•Very high-level•Say “what to do” rather than “how to do it”•SQL is not specifying data-manipulation details•DBMSs figure out the “best” way to execute queries•Called “query optimization”•Two aspects to SQL•Data definition: for declaring database schemas (DDL)•Data manipulation: for querying (asking questions about) databases and for modifying the database (DML)\nECE30030/ITP30010 Database Systems3\nSQL Parts•DML – provides the ability to query information from the database and to insert tuples into, delete tuples from, and modify tuples in the database•Integrity – the DDL includes commands for specifying integrity constraints•View definition – the DDL includes commands for defining views•Transaction control – includes commands for specifying the beginning and ending of transactions•Embedded SQL and dynamic SQL – define how SQL statements can be embedded within general-purpose programming language•Authorization – includes commands for specifying access rights to relations and viewsECE30030/ITP30010 Database Systems4\nA Brief History•IBM SEQUEL (Structured English Query Language) was developed as a part of the System R project (Chamberlin and Boyce, early 1970s)•Later on, SEQUEL was renamed SQL (structured query language)•System R à System/38 (1979), SQL/DS (1981), DB2 (1983)•Relational Software, Inc released the first commercial implementation of SQL, Oracle V2 for VAX computers•Relational Software, Inc is now Oracle Corporation•ANSI and ISO standardized SQL:•SQL-86,  SQL-89,  SQL-92,  SQL:1999,  …,  SQL:2011,  SQL:2016 (current)•SQL-92 is supported by the most of database systems\nECE30030/ITP30010 Database Systems5\nBasic Query Structure•A typical SQL query has the form:   SELECT A1, A2, ..., An FROM r1, r2, ..., rm WHERE P•Ai represents an attribute•Ri represents a relation•P is a predicate\n•The result of an SQL query is a relation\nECE30030/ITP30010 Database Systems6\nAgenda•Structured query language (SQL)•SQL data manipulation language (DML)•SELECT, FROM, WHERE•NULL values•Set operations•String operations, ordering•Aggregate functions, aggregation•SQL data definition language (DDL)\nECE30030/ITP30010 Database Systems7\nSQL Data Manipulation Language•The SQL data-manipulation language (DML) allows querying (ask questions about) and modifying the databases\nECE30030/ITP30010 Database Systems8\nRunning Examples•Relations (tables): instructor, teaches\nECE30030/ITP30010 Database Systems9\nInstructor relationteaches relation\nBasic Query Structure•A typical SQL query has the form:   SELECT A1, A2, ..., An FROM r1, r2, ..., rm WHERE P•Ai represents an attribute•Ri represents a relation•P is a predicate\n•The result of an SQL query is a relation\nECE30030/ITP30010 Database Systems10\nThe SELECT Clause•The SELECT clause lists the attributes desired in the result of a query•Corresponds to the projection operation of the relational algebra\n•Example: Find the names of all instructors•SQL: SELECT name FROM instructor;\nECE30030/ITP30010 Database Systems11\n\nNote•Note: SQL names are case insensitive•E.g., Name ≡ NAME ≡ name•SQL commands (SELECT, FROM, WHERE, …) are written in upper case (just a convention)•MySQL has an option flag, lower_case_table_names•Link: https://dev.mysql.com/doc/refman/8.0/en/identifier-case-sensitivity.html \nECE30030/ITP30010 Database Systems12\nThe SELECT Clause•SQL allows duplicates in relations as well as in query results•The keyword ALL specifies that duplicates should not be removed SELECT ALL dept_name FROM instructor\nECE30030/ITP30010 Database Systems13\n\nThe SELECT Clause•SQL allows duplicates in relations as well as in query results•The keyword ALL specifies that duplicates should not be removed SELECT ALL dept_name FROM instructor•To force the elimination of duplicates, insert the keyword DISTINCT after SELECT•Find the department names of all instructor, removing duplicates: SELECT DISTINCT dept_name FROM instructor;\nECE30030/ITP30010 Database Systems14\n\nThe SELECT Clause•An asterisk in the select clause denotes “all attributes” SELECT * FROM instructor;•An attribute can be a literal with no FROM clause SELECT ‘437’;•Result is a table with one column and a single row with value “437”•Can give the column a name using AS: SELECT ‘437’ AS FOO\nECE30030/ITP30010 Database Systems15\n\nThe SELECT Clause•An attribute can be a literal with FROM clause SELECT 'A' FROM instructor•Result is a table with one column and N rows (number of tuples in the instructor table), each row with value “A”\nECE30030/ITP30010 Database Systems16\n\nThe SELECT Clause•The SELECT clause can contain arithmetic expressions involving the operation, +, –, *, and /, and operating on constants or attributes of tuples•The query:     SELECT ID, name, salary/12      FROM instructorwould return a relation that is the same as the instructor relation,except that the value of the attribute salary is divided by 12\n17\n\nThe SELECT Clause•The SELECT clause can contain arithmetic expressions involving the operation, +, –, *, and /, and operating on constants or attributes of tuples•Can rename “salary/12” using the AS clause:  SELECT ID, name, salary/12 AS monthly_salary   FROM instructor\n18\n\nThe WHERE Clause•The WHERE clause specifies conditions that the result must satisfy•Corresponds to the selection predicate of the relational algebra•E.g., To find all instructors in Comp. Sci. dept: SELECT name FROM instructor  WHERE dept_name = 'Comp. Sci.';\nECE30030/ITP30010 Database Systems19\n\nThe WHERE Clause•SQL allows the use of the logical connectives AND, OR, and NOT•The operands of the logical connectives can be expressions involving the comparison operators <, <=, >, >=, =, and <>•<> means not equal (there is no != in SQL)•Comparisons can be applied to results of arithmetic expressions•E.g., To find all instructors in Comp. Sci. with salary > 70,000: SELECT name FROM instructor WHERE dept_name = 'Comp. Sci.' AND salary > 70000;\nECE30030/ITP30010 Database Systems20\n\nThe WHERE Clause•SQL includes a BETWEEN comparison operator•Example: Find the names of all instructors with salary between $90,000 and $100,000 (that is, ³ $90,000 and £ $100,000)•SELECT nameFROM instructorWHERE salary BETWEEN 90000 AND 100000\nECE30030/ITP30010 Database Systems21\n\nThe WHERE Clause•Tuple comparison: makes comparisons per tuple•SELECT name, course_idFROM instructor, teachesWHERE (instructor.ID, dept_name) = (teaches.ID, 'Biology');\nECE30030/ITP30010 Database Systems22\n\nThe FROM Clause•The FROM clause lists the relations involved in the query•Corresponds to the Cartesian-product operation of the relational algebra•Find the Cartesian-product instructor × teaches SELECT * FROM instructor, teaches;•Generates every possible instructor-teaches pairs, with all attributes from both relations•For common attributes (e.g., ID), the attributes in the resulting table are renamed using the relation name (e.g., instructor.ID)\nECE30030/ITP30010 Database Systems23\nThe FROM Clause•Find the Cartesian-product instructor X teaches SELECT * FROM instructor, teaches;\n24\ninstructor.IDnamedept_namesalaryteaches.IDcourse_idsec_idsemesteryear10101SrinivasanComp. Sci.6500076766BIO-101 1Summer201712121WuFinance9000076766BIO-101 1Summer201715151MozartMusic4000076766BIO-101 1Summer201722222EinsteinPhysics9500076766BIO-101 1Summer201732343El SaidHistory6000076766BIO-101 1Summer2017… … … … … … … … …10101SrinivasanComp. Sci.6500010101CS-101 1Fall 201712121WuFinance9000010101CS-101 1Fall 201715151MozartMusic4000010101CS-101 1Fall 201722222EinsteinPhysics9500010101CS-101 1Fall 201732343El SaidHistory6000010101CS-101 1Fall 2017… … … … … … … … …… … … … … … … … …10101SrinivasanComp. Sci.6500083821CS-190 2Spring201712121WuFinance9000083821CS-190 2Spring201715151MozartMusic4000083821CS-190 2Spring2017… … … … … … … … …10101SrinivasanComp. Sci.6500010101CS-315 1Spring201812121WuFinance9000010101CS-315 1Spring201815151MozartMusic4000010101CS-315 1Spring2018… … … … … … … … …… … … … … … … … …\nImplementing JOIN•Cartesian-product is not very useful directly; but useful combined with WHERE-clause condition (selection operation in relational algebra)•Cartesian-product + selection = join•E.g., Find the names of all instructors who have taught some course and the course_id SELECT name, course_id FROM instructor , teaches WHERE instructor.ID = teaches.ID\nECE30030/ITP30010 Database Systems25\n\nImplementing JOIN•Cartesian-product is not very useful directly; but useful combined with WHERE-clause condition (selection operation in relational algebra)•Cartesian-product + selection = join•Find the names of all instructors in the Music department who have taught some course and the course_id SELECT name, course_id FROM instructor , teaches WHERE instructor.ID = teaches.ID  AND instructor. dept_name = 'Music'\nECE30030/ITP30010 Database Systems26\n\nThe Rename Operation•The SQL allows renaming relations and attributes using the AS clause:   old-name AS new-name•Find the names of all instructors who have a higher salary than some instructor in ‘Comp. Sci.’•SELECT DISTINCT T.nameFROM instructor AS T, instructor AS SWHERE T.salary > S.salary AND S.dept_name = 'Comp. Sci.'\nECE30030/ITP30010 Database Systems27\n\nThe Rename Operation•The SQL allows renaming relations and attributes using the AS clause:   old-name AS new-name•Find the names of all instructors who have a higher salary than some instructor in ‘Comp. Sci.’•SELECT DISTINCT T.nameFROM instructor AS T, instructor AS SWHERE T.salary > S.salary AND S.dept_name = 'Comp. Sci.'•Keyword AS is optional and may be omitted  instructor AS T  ≡  instructor T\nECE30030/ITP30010 Database Systems28\nAgenda•Structured query language (SQL)•SQL data manipulation language (DML)•SELECT, FROM, WHERE•NULL values•Set operations•String operations, ordering•Aggregate functions, aggregation•SQL data definition language (DDL)\nECE30030/ITP30010 Database Systems29\nNULL Values•It is possible for tuples to have a NULL value for some of their attributes•NULL signifies an unknown value or that a value does not exist•The result of any arithmetic expression involving NULL is NULL•E.g.,  5 + NULL returns NULL\nECE30030/ITP30010 Database Systems30\nIS NULL / IS NOT NULL•The predicate IS NULL can be used to check for NULL values•E.g., Find all instructors whose salary is null SELECT name FROM instructor WHERE salary IS NULL•The predicate IS NOT NULL succeeds if the value on which it is applied is not null\nECE30030/ITP30010 Database Systems31\nAgenda•Structured query language (SQL)•SQL data manipulation language (DML)•SELECT, FROM, WHERE•NULL values•Set operations•String operations, ordering•Aggregate functions, aggregation•SQL data definition language (DDL)\nECE30030/ITP30010 Database Systems32\nSet Operations•Set operations UNION, INTERSECT, and EXCEPT•Each of the above operations automatically eliminates duplicates•To retain all duplicates, use ALL:•UNION ALL•INTERSECT ALL•EXCEPT ALL\n•C.f., SELECT retains all duplicates by default\nECE30030/ITP30010 Database Systems33\nSet Operations: UNION•Find courses that ran in Fall 2017 or in Spring 2018•(SELECT course_id  FROM teaches WHERE semester = 'Fall' AND year = 2017)UNION(SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018)\nECE30030/ITP30010 Database Systems34\n\nSet Operations: INTERSECT•Find courses that ran in Fall 2017 and in Spring 2018•(SELECT course_id  FROM teaches WHERE semester = 'Fall' AND year = 2017)INTERSECT(SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018)•C.f., MySQL does NOT support INTERSECT•One can emulate INTERSECT using JOIN (we’ll study JOIN later)•SELECT LT.course_idFROM (SELECT course_id FROM teaches WHERE semester = 'Fall' AND year = 2017) AS LTJOIN (SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018) AS RTON LT.course_id=RT.course_id;\nECE30030/ITP30010 Database Systems35\n\nSet Operations: EXCEPT•Find courses that ran in Fall 2017 but not in Spring 2018•(SELECT course_id  FROM teaches WHERE semester = 'Fall' AND year = 2017)EXCEPT(SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018)•C.f., MySQL does NOT support EXCEPT•One can emulate EXCEPT using NOT IN•SELECT course_id FROM teaches WHERE semester = 'Fall' AND year = 2017AND course_id NOT IN(SELECT course_id  FROM teaches  WHERE semester = 'Spring' AND year = 2018);\nECE30030/ITP30010 Database Systems36\n\nAgenda•Structured query language (SQL)•SQL data manipulation language (DML)•SELECT, FROM, WHERE•NULL values•Set operations•String operations, ordering•Aggregate functions, aggregation•SQL data definition language (DDL)\nECE30030/ITP30010 Database Systems37\nString Operations•SQL includes a string-matching operator for comparisons on character strings•The operator LIKE uses patterns that are described using two special characters:•percent (%) – The % character matches any substring•underscore (_) – The _ character matches any character•Find the names of all instructors whose name includes the substring “ri” SELECT name FROM instructor WHERE name LIKE ‘%ri%'\nECE30030/ITP30010 Database Systems38\n\nString Operations•Escape character: Use backslash (\\) as the escape character•E.g., Match the string “100%” LIKE '100 \\%’ ESCAPE  ‘\\’\nECE30030/ITP30010 Database Systems39\nString Operations•Patterns are case sensitive•Pattern matching examples:•'Intro%' matches any string beginning with “Intro”•'%Comp%' matches any string containing “Comp” as a substring•'_ _ _' matches any string of exactly three characters•'_ _ _ %' matches any string of at least three characters•SQL supports a variety of string operations such as•concatenation (using “||”)•converting from upper to lower case (and vice versa)•finding string length, extracting substrings, etc.\nECE30030/ITP30010 Database Systems40\nOrdering the Display of Tuples•List in alphabetic order the names of all instructors•SELECT DISTINCT nameFROM instructorORDER BY name\nECE30030/ITP30010 Database Systems41\n\nOrdering the Display of Tuples•Can sort on multiple attributes•E.g., SELECT dept_name, name     FROM instructor      ORDER BY dept_name, name\nECE30030/ITP30010 Database Systems42\n\nOrdering the Display of Tuples•We may specify DESC for descending order or ASC for ascending order, for each attribute; ascending order is the default•E.g., ORDER BY name DESC\nECE30030/ITP30010 Database Systems43\n\nAgenda•Structured query language (SQL)•SQL data manipulation language (DML)•SELECT, FROM, WHERE•NULL values•Set operations•String operations, ordering•Aggregate functions, aggregation•SQL data definition language (DDL)\nECE30030/ITP30010 Database Systems44\nAggregate Functions•These functions operate on the multiset of values of a column of a relation, and return a value•AVG:  average value•MIN:  minimum value•MAX:  maximum value•SUM:  sum of values•COUNT:  number of values\nECE30030/ITP30010 Database Systems45\nAggregate Functions Examples•Find the average salary of instructors in the Computer Science department•SELECT AVG(salary)FROM instructorWHERE dept_name= 'Comp. Sci.';•Find the total number of instructors who teach a course in the Spring 2018 semester•SELECT COUNT(DISTINCT ID)FROM teachesWHERE semester = 'Spring’ AND year = 2018;•Find the number of tuples in the teaches relation•SELECT COUNT (*)FROM teaches;\nECE30030/ITP30010 Database Systems46\n\nAggregate Functions: Group By•Find the average salary of instructors in each department•SELECT dept_name, AVG(salary) AS avg_salaryFROM instructorGROUP BY dept_name;\nECE30030/ITP30010 Database Systems47\n\nAggregation•Attributes in SELECT clause outside of aggregate functions must appear in GROUP BY list•/* erroneous query */SELECT dept_name, ID, AVG(salary)FROM instructorGROUP BY dept_name;\nECE30030/ITP30010 Database Systems48\n\nAggregate Functions – Having Clause•Find the names and average salaries of all departments whose average salary is greater than 65000•SELECT dept_name, AVG(salary) AS avg_salaryFROM instructorGROUP BY dept_nameHAVING AVG(salary) > 65000;\nECE30030/ITP30010 Database Systems49\n\nAggregate Functions – Having Clause•Note: predicates in the HAVING clause are applied after the formation of groups whereas predicates in the WHERE clause are applied before forming groups\nECE30030/ITP30010 Database Systems50\nSELECT dept_name, AVG(salary) AS avg_salaryFROM instructorGROUP BY dept_nameHAVING AVG(salary) > 65000;\nSELECT dept_name, AVG(salary) AS avg_salaryFROM instructorWHERE salary > 65000GROUP BY dept_name;\n\nSQL Commands\nSQLDMLSELECTINSERTUPDATEDELETE\nDDLCREATEALTERDROP\nECE30030/ITP30010 Database Systems51\nINSERT•Basic syntax•Insert data into every column:•INSERT INTO tablenameVALUES (col1_value, col2_value, …)•Must list values in the same order as in the table schema•If some data values are unknown, must type NULL •For character sequences, use quotation marks•Single quotation marks are preferred (but double quotation marks are allowed)•Value in quotations is case-sensitive•Insert data into selected columns•INSERT INTO tablename (col1_name, col3_name, col4_name, …)VALUES (col1_value, col3_value, col4_value, …)\nECE30030/ITP30010 Database Systems52\nINSERT•Add a new tuple to course•INSERT INTO courseVALUES ('CS-437', 'Database Systems', 'Comp. Sci.', 4);•or equivalently•INSERT INTO course (course_id, title, dept_name, credits)VALUES ('CS-437', 'Database Systems', 'Comp. Sci.', 4);•Add a new tuple to student  with tot_creds set to null•INSERT INTO studentVALUES ('3003', 'Green', 'Finance', null);\nECE30030/ITP30010 Database Systems53\nINSERT•A foreign key specifies that an attribute from one relation has to map to a tuple in another relation•Value in one relation must appear in another relation\nECE30030/ITP30010 Database Systems54\nRelation: instructor\nRelation: department\nINSERT•A foreign key specifies that an attribute from one relation has to map to a tuple in another relation•Value in one relation must appear in another relation•Make sure all foreign keys that new row references have already been added to database•One cannot insert a foreign key value unless the corresponding value exists in the referenced relation\nECE30030/ITP30010 Database Systems55\nINSERT•Inserting results of other SELECT query•Make each student in the Music department who has earned more than 144 credit hours an instructor in the Music department with a salary of  $18,000•INSERT INTO instructor  SELECT ID, name, dept_name, 18000  FROM student   WHERE dept_name = 'Music’ AND total_cred > 144;•The SELECT FROM WHERE statement is evaluated fully before any of its results are inserted into the relation•Otherwise queries like  INSERT INTO table1 SELECT * FROM table1would cause problem\nECE30030/ITP30010 Database Systems56\nUPDATE•Basic syntax•Updating a table•UPDATE tablenameSET col1_name = new_col1_value, col2_name = new_col2_value, …;•Updating a table with conditions•UPDATE tablenameSET col1_name = new_col1_value, col2_name = new_col2_value, …WHERE predicate;\nECE30030/ITP30010 Database Systems57\nUPDATE•Give a 5% salary raise to all instructors•UPDATE instructorSET salary = salary * 1.05•Give a 5% salary raise to those instructors who earn less than 70000•UPDATE instructorSET salary = salary * 1.05WHERE salary < 70000;•Give a 5% salary raise to instructors whose salary is less than average•UPDATE instructorSET salary = salary * 1.05WHERE salary <  (SELECT AVG(salary) FROM instructor);\nECE30030/ITP30010 Database Systems58\nUPDATE•Increase salaries of instructors whose salary is over $100,000 by 3%, and all others by a 5%•Write two UPDATE statements:  UPDATE instructor  SET salary = salary * 1.03  WHERE salary > 100000;  UPDATE instructor  SET salary = salary * 1.05  WHERE salary <= 100000;•The order is important•Can be done better using the case statement (next slide)\nECE30030/ITP30010 Database Systems59\nCASE Statement for Conditional Update•The following query is equivalent to the previous UPDATE queries•UPDATE instructorSET salary = CASE                           WHEN salary <= 100000 THEN salary * 1.05                           ELSE salary * 1.03                       END\nECE30030/ITP30010 Database Systems60\nUPDATE with Scalar Subqueries•Recompute and update tot_creds value for all students•UPDATE student SSET tot_cred = (SELECT SUM(credits)                             FROM takes, course                             WHERE takes.course_id = course.course_id  AND                                            S.ID= takes.ID  AND                                            takes.grade <> 'F' AND                                            takes.grade IS NOT NULL);\nECE30030/ITP30010 Database Systems61\nDELETE•Basic syntax•To remove specific rows•DELETE FROM tablenameWHERE predicate;•To remove all rows•DELETE FROM tablename;•This is equivalent to TRUNCATE:TRUNCATE (TABLE) tablename;•One cannot truncate a table with foreign key constraints•Must disable the constraints first (we will cover ALTER when we study SQL DDL):ALTER TABLE tablenameDISABLE CONSTRAINT constraint_name;\nECE30030/ITP30010 Database Systems62\nDELETE•Delete all instructors•DELETE FROM instructor;•Delete all instructors from the Finance department•DELETE FROM instructorWHERE dept_name= 'Finance';•Delete all tuples in the instructor relation for those instructors associated with a department located in the Watson building•DELETE FROM instructorWHERE dept name IN (SELECT dept name        FROM department        WHERE building = 'Watson');\nECE30030/ITP30010 Database Systems63\nDELETE•Delete all instructors whose salary is less than the average salary of instructors•Example:  DELETE FROM instructor                WHERE salary < (SELECT AVG (salary)                  FROM instructor);•Issue:  as we delete tuples from instructor, the average salary changes•Solution used in SQL:1.First, compute AVG(salary) and find all tuples to delete2.Next, delete all tuples found above (without recomputing AVG or retesting the tuples)\nECE30030/ITP30010 Database Systems64\nEOF•Coming next:•More on Structured Query Language\nECE30030/ITP30010 Database Systems65"
              }
            ],
            "notebook_title": "관계형 데이터베이스 시스템: MySQL 소개 및 SQL 심층 활용",
            "holistic_chapters": [
              {
                "chapter_title": "관계형 데이터베이스 시스템(R-DBMS) 개요 및 MySQL 소개",
                "source_pdf_filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_1a4c2f45-b482-4e82-826e-fa8945eb99c7_DB03 - mysql.pdf",
                "chapter_content_summary": "이 장에서는 관계형 데이터베이스 관리 시스템(R-DBMS)의 기본 개념을 소개하고, 대표적인 오픈소스 R-DBMS인 MySQL에 대해 심층적으로 다룹니다. MySQL의 정의, Oracle 소유권, 표준 SQL 호환성, 상업적 웹 서비스에서의 활용 사례, 기업 사용 통계, 그리고 MySQL의 인기 요인(다양한 운영체제 및 프로그래밍 언어 지원, 비용 효율성, 고성능)을 설명합니다. 또한, R-DBMS 시장에서의 MySQL의 트렌드와 인기도를 살펴보고, MySQL 5.x와 8.x 버전의 주요 차이점 및 MySQL 커뮤니티 버전을 다운로드하고 Docker 이미지를 활용하는 방법을 안내합니다. MySQL이 대규모 데이터 처리, 다중 사용자 지원, 효율성, 안정성, 보안성 측면에서 갖는 강점들을 강조합니다.",
                "chapter_full_text": "ECE30030/ITP30010 Database SystemsHandshaking with an R-DBMSCharmgil Hongcharmgil@handong.eduSpring, 2025Handong Global University\n1\nAgenda•Introduction to MySQL•SQL preview\nECE30030/ITP30010 Database Systems2\nMySQL•MySQL is an SQL-based relational database management system (DBMS)•Free and open-source R-DBMS (under GPL)•Owned by Oracle•Commercial version of MySQL is also provided (including technical support)•“My” came from the name of co-founder Michael Widenius’ daughter•C.f., MariaDB•Compatible with standard SQL•Frequently used for commercial web services\nECE30030/ITP30010 Database Systems3\n* Image src: https://en.wikipedia.org/wiki/MySQL\nMySQL•Companies using MySQL (a study by Enlyft)•“We have data on 199,498 (out of 1,409,176) companies that use MySQL”•Often used by companies with 10-50 employees and 1M-10M dollars in revenue•C.f., Oracle 12 is most often used by companies with 50-200 employees and >1000M dollars in revenue\nECE30030/ITP30010 Database Systems4* Source: https://enlyft.com/tech/products/mysql \nMySQL•Companies using MySQL (full list: https://www.mysql.com/customers/)\nECE30030/ITP30010 Database Systems5\n* Source: https://stackshare.io/mysql \nMySQL•Why MySQL?•Popular•Active discussions all over the Internet•Versatile: runs on Linux, Windows, Mac OS X, Solaris, FreeBSD, …•Supports wide range of programming languages (C/C++, Java, Python, .Net, …)•Cost starts from zero•High performance (fast and reliable)\nECE30030/ITP30010 Database Systems6* Image src: https://db-engines.com/en/ranking\nDBMS Trend Popularity\n•Score definition: https://db-engines.com/en/ranking_definition\nECE30030/ITP30010 Database Systems7* Image src: https://db-engines.com/en/ranking_trend \nMySQL•Why MySQL?•Popular•Active discussions all over the Internet•Versatile: runs on Linux, Windows, Mac OS X, Solaris, FreeBSD, …•Supports wide range of programming languages (C/C++, Java, Python, .Net, …)•Cost starts from zero•High performance (fast and reliable)\nECE30030/ITP30010 Database Systems8* Image src: https://dev.mysql.com/downloads/\nMySQL\nECE30030/ITP30010 Database Systems9\n•Massive•Convenient•Multi-user•Safe•Efficient•Reliable\nCan handle terabytes of dataSupports high-level query languageSupports concurrent data accessSupports transactionsCan handle thousands of queries/second99.99% up-time in many real-world products\nMySQL Versions•MySQL 5.x vs 8.x\nECE30030/ITP30010 Database Systems10\nVersion 5.x-Most popular version of MySQL-More stable and conventionalVersion 8.x-Current version-Provides up-to-date DB functionalities (better storage engine, faster, more secure)\n* Source: https://www.eversql.com/mysql-8-adoption-usage-rate/#:~:text=MySQL%205.7%20is%20still%20the,17%25%20are%20using%20MySQL%208. \nMySQL Versions•MySQL 5.x vs 8.x\nECE30030/ITP30010 Database Systems11\nVersion 5.x-Most popular version of MySQL-More stable and conventionalVersion 8.x-Current version-Provides up-to-date DB functionalities (better storage engine, faster, more secure)\n* Source: https://severalnines.com/database-blog/mysql-performance-benchmarking-mysql-57-vs-mysql-80 \nMySQL Versions•MySQL 5.x vs 8.x\nECE30030/ITP30010 Database Systems12\nVersion 5.x-Most popular version of MySQL-More stable and conventionalVersion 8.x-Current version-Provides up-to-date DB functionalities (better storage engine, faster, more secure)\n* Source: https://severalnines.com/database-blog/mysql-performance-benchmarking-mysql-57-vs-mysql-80 \nWhere to Get MySQL?•https://dev.mysql.com/downloads/•Look for the “Community” versions – the branch that is available for free•”Enterprise” versions are the commercial ones•We have prepared a Docker image for the course•Consists of Ubuntu Server, MySQL, example databases for course activities\nECE30030/ITP30010 Database Systems13* Image src: https://www.docker.com \nWhere to Get MySQL?\nECE30030/ITP30010 Database Systems14\n* Image source: https://baumannalexj.medium.com/connect-your-db-tool-to-a-dockerized-mysql-server-container-bc18853524ed   https://www.jetbrains.com/datagrip/features/look_and_feel.html"
              },
              {
                "chapter_title": "SQL(구조적 질의어)의 이해: 기본 개념과 역사",
                "source_pdf_filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf",
                "chapter_content_summary": "SQL(Structured Query Language)의 정의와 관계형 데이터베이스를 조작하는 주된 언어로서의 역할을 설명합니다. SQL이 '무엇을 할지'를 명시하는 고수준 언어이며, DBMS가 '어떻게 할지'를 결정하는 쿼리 최적화 과정을 다룹니다. 또한, SQL의 두 가지 주요 측면인 데이터 정의 언어(DDL)와 데이터 조작 언어(DML)를 소개하고, 무결성, 뷰 정의, 트랜잭션 제어, 내장 SQL 및 동적 SQL, 권한 부여와 같은 SQL의 다양한 구성 요소를 살펴봅니다. 마지막으로, IBM SEQUEL에서 시작하여 Oracle V2를 거쳐 ANSI 및 ISO 표준으로 발전한 SQL의 간략한 역사를 소개하고, 기본적인 SQL 쿼리 구조(SELECT, FROM, WHERE)를 설명합니다.",
                "chapter_full_text": "ECE30030/ITP30010 Database SystemsStructured Query LanguageReading: Chapter 3\nCharmgil Hongcharmgil@handong.eduSpring, 2025Handong Global University\n1\nAgenda•Structured query language (SQL)•SQL data manipulation language (DML)•SELECT, FROM, WHERE•NULL values•Set operations•String operations, ordering•Aggregate functions, aggregation•SQL data definition language (DDL)   --   NEXT CLASS\nECE30030/ITP30010 Database Systems2\nStructured Query Language (SQL)•SQL: Structured Query Language•The principal language used to describe and manipulate relational databases•Very high-level•Say “what to do” rather than “how to do it”•SQL is not specifying data-manipulation details•DBMSs figure out the “best” way to execute queries•Called “query optimization”•Two aspects to SQL•Data definition: for declaring database schemas (DDL)•Data manipulation: for querying (asking questions about) databases and for modifying the database (DML)\nECE30030/ITP30010 Database Systems3\nSQL Parts•DML – provides the ability to query information from the database and to insert tuples into, delete tuples from, and modify tuples in the database•Integrity – the DDL includes commands for specifying integrity constraints•View definition – the DDL includes commands for defining views•Transaction control – includes commands for specifying the beginning and ending of transactions•Embedded SQL and dynamic SQL – define how SQL statements can be embedded within general-purpose programming language•Authorization – includes commands for specifying access rights to relations and viewsECE30030/ITP30010 Database Systems4\nA Brief History•IBM SEQUEL (Structured English Query Language) was developed as a part of the System R project (Chamberlin and Boyce, early 1970s)•Later on, SEQUEL was renamed SQL (structured query language)•System R à System/38 (1979), SQL/DS (1981), DB2 (1983)•Relational Software, Inc released the first commercial implementation of SQL, Oracle V2 for VAX computers•Relational Software, Inc is now Oracle Corporation•ANSI and ISO standardized SQL:•SQL-86,  SQL-89,  SQL-92,  SQL:1999,  …,  SQL:2011,  SQL:2016 (current)•SQL-92 is supported by the most of database systems\nECE30030/ITP30010 Database Systems5\nBasic Query Structure•A typical SQL query has the form:   SELECT A1, A2, ..., An FROM r1, r2, ..., rm WHERE P•Ai represents an attribute•Ri represents a relation•P is a predicate\n•The result of an SQL query is a relation\nECE30030/ITP30010 Database Systems6"
              },
              {
                "chapter_title": "SQL 데이터 조작 언어(DML) 기초: SELECT, FROM, WHERE 절",
                "source_pdf_filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf",
                "chapter_content_summary": "이 장에서는 SQL 데이터 조작 언어(DML)의 핵심 구성 요소인 SELECT, FROM, WHERE 절을 상세히 다룹니다. 'instructor' 및 'teaches'와 같은 예시 관계(테이블)를 사용하여 실제 쿼리 작성 방법을 시연합니다. SELECT 절을 통해 원하는 속성을 선택하고, 중복을 포함하거나 제거하는 방법(ALL, DISTINCT), 모든 속성을 선택하는 '*' 사용법, 리터럴 및 산술 표현식 활용, 그리고 AS 키워드를 사용한 속성 이름 변경 방법을 학습합니다. WHERE 절에서는 논리 연산자(AND, OR, NOT) 및 비교 연산자(<, <=, >, >=, =, <>, BETWEEN)를 사용하여 조건을 지정하고, 튜플 비교를 수행하는 방법을 설명합니다. 마지막으로 FROM 절을 통해 쿼리에 포함될 관계를 지정하고, 카르테시안 곱을 이해하며, WHERE 절과 결합하여 JOIN 연산을 구현하는 방법을 구체적인 예시와 함께 제시합니다. 또한, AS 키워드를 이용한 관계 및 속성 이름 변경(별칭 지정)을 다룹니다.",
                "chapter_full_text": "ECE30030/ITP30010 Database Systems7\nSQL Data Manipulation Language•The SQL data-manipulation language (DML) allows querying (ask questions about) and modifying the databases\nECE30030/ITP30010 Database Systems8\nRunning Examples•Relations (tables): instructor, teaches\nECE30030/ITP30010 Database Systems9\nInstructor relationteaches relation\nBasic Query Structure•A typical SQL query has the form:   SELECT A1, A2, ..., An FROM r1, r2, ..., rm WHERE P•Ai represents an attribute•Ri represents a relation•P is a predicate\n•The result of an SQL query is a relation\nECE30030/ITP30010 Database Systems10\nThe SELECT Clause•The SELECT clause lists the attributes desired in the result of a query•Corresponds to the projection operation of the relational algebra\n•Example: Find the names of all instructors•SQL: SELECT name FROM instructor;\nECE30030/ITP30010 Database Systems11\nNote•Note: SQL names are case insensitive•E.g., Name ≡ NAME ≡ name•SQL commands (SELECT, FROM, WHERE, …) are written in upper case (just a convention)•MySQL has an option flag, lower_case_table_names•Link: https://dev.mysql.com/doc/refman/8.0/en/identifier-case-sensitivity.html \nECE30030/ITP30010 Database Systems12\nThe SELECT Clause•SQL allows duplicates in relations as well as in query results•The keyword ALL specifies that duplicates should not be removed SELECT ALL dept_name FROM instructor\nECE30030/ITP30010 Database Systems13\nThe SELECT Clause•SQL allows duplicates in relations as well as in query results•The keyword ALL specifies that duplicates should not be removed SELECT ALL dept_name FROM instructor•To force the elimination of duplicates, insert the keyword DISTINCT after SELECT•Find the department names of all instructor, removing duplicates: SELECT DISTINCT dept_name FROM instructor;\nECE30030/ITP30010 Database Systems14\nThe SELECT Clause•An asterisk in the select clause denotes “all attributes” SELECT * FROM instructor;•An attribute can be a literal with no FROM clause SELECT ‘437’;•Result is a table with one column and a single row with value “437”•Can give the column a name using AS: SELECT ‘437’ AS FOO\nECE30030/ITP30010 Database Systems15\nThe SELECT Clause•An attribute can be a literal with FROM clause SELECT 'A' FROM instructor•Result is a table with one column and N rows (number of tuples in the instructor table), each row with value “A”\nECE30030/ITP30010 Database Systems16\nThe SELECT Clause•The SELECT clause can contain arithmetic expressions involving the operation, +, –, *, and /, and operating on constants or attributes of tuples•The query:     SELECT ID, name, salary/12      FROM instructorwould return a relation that is the same as the instructor relation,except that the value of the attribute salary is divided by 12\n17\nThe SELECT Clause•The SELECT clause can contain arithmetic expressions involving the operation, +, –, *, and /, and operating on constants or attributes of tuples•Can rename “salary/12” using the AS clause:  SELECT ID, name, salary/12 AS monthly_salary   FROM instructor\n18\nThe WHERE Clause•The WHERE clause specifies conditions that the result must satisfy•Corresponds to the selection predicate of the relational algebra•E.g., To find all instructors in Comp. Sci. dept: SELECT name FROM instructor  WHERE dept_name = 'Comp. Sci.';\nECE30030/ITP30010 Database Systems19\nThe WHERE Clause•SQL allows the use of the logical connectives AND, OR, and NOT•The operands of the logical connectives can be expressions involving the comparison operators <, <=, >, >=, =, and <>•<> means not equal (there is no != in SQL)•Comparisons can be applied to results of arithmetic expressions•E.g., To find all instructors in Comp. Sci. with salary > 70,000: SELECT name FROM instructor WHERE dept_name = 'Comp. Sci.' AND salary > 70000;\nECE30030/ITP30010 Database Systems20\nThe WHERE Clause•SQL includes a BETWEEN comparison operator•Example: Find the names of all instructors with salary between $90,000 and $100,000 (that is, ³ $90,000 and £ $100,000)•SELECT nameFROM instructorWHERE salary BETWEEN 90000 AND 100000\nECE30030/ITP30010 Database Systems21\nThe WHERE Clause•Tuple comparison: makes comparisons per tuple•SELECT name, course_idFROM instructor, teachesWHERE (instructor.ID, dept_name) = (teaches.ID, 'Biology');\nECE30030/ITP30010 Database Systems22\nThe FROM Clause•The FROM clause lists the relations involved in the query•Corresponds to the Cartesian-product operation of the relational algebra•Find the Cartesian-product instructor × teaches SELECT * FROM instructor, teaches;•Generates every possible instructor-teaches pairs, with all attributes from both relations•For common attributes (e.g., ID), the attributes in the resulting table are renamed using the relation name (e.g., instructor.ID)\nECE30030/ITP30010 Database Systems23\nThe FROM Clause•Find the Cartesian-product instructor X teaches SELECT * FROM instructor, teaches;\n24\ninstructor.IDnamedept_namesalaryteaches.IDcourse_idsec_idsemesteryear10101SrinivasanComp. Sci.6500076766BIO-101 1Summer201712121WuFinance9000076766BIO-101 1Summer201715151MozartMusic4000076766BIO-101 1Summer201722222EinsteinPhysics9500076766BIO-101 1Summer201732343El SaidHistory6000076766BIO-101 1Summer2017… … … … … … … … …10101SrinivasanComp. Sci.6500010101CS-101 1Fall 201712121WuFinance9000010101CS-101 1Fall 201715151MozartMusic4000010101CS-101 1Fall 201722222EinsteinPhysics9500010101CS-101 1Fall 201732343El SaidHistory6000010101CS-101 1Fall 2017… … … … … … … … …… … … … … … … … …10101SrinivasanComp. Sci.6500083821CS-190 2Spring201712121WuFinance9000083821CS-190 2Spring201715151MozartMusic4000083821CS-190 2Spring2017… … … … … … … … …10101SrinivasanComp. Sci.6500010101CS-315 1Spring201812121WuFinance9000010101CS-315 1Spring201815151MozartMusic4000010101CS-315 1Spring2018… … … … … … … … …… … … … … … … … …\nImplementing JOIN•Cartesian-product is not very useful directly; but useful combined with WHERE-clause condition (selection operation in relational algebra)•Cartesian-product + selection = join•E.g., Find the names of all instructors who have taught some course and the course_id SELECT name, course_id FROM instructor , teaches WHERE instructor.ID = teaches.ID\nECE30030/ITP30010 Database Systems25\nImplementing JOIN•Cartesian-product is not very useful directly; but useful combined with WHERE-clause condition (selection operation in relational algebra)•Cartesian-product + selection = join•Find the names of all instructors in the Music department who have taught some course and the course_id SELECT name, course_id FROM instructor , teaches WHERE instructor.ID = teaches.ID  AND instructor. dept_name = 'Music'\nECE30030/ITP30010 Database Systems26\nThe Rename Operation•The SQL allows renaming relations and attributes using the AS clause:   old-name AS new-name•Find the names of all instructors who have a higher salary than some instructor in ‘Comp. Sci.’•SELECT DISTINCT T.nameFROM instructor AS T, instructor AS SWHERE T.salary > S.salary AND S.dept_name = 'Comp. Sci.'\nECE30030/ITP30010 Database Systems27\nThe Rename Operation•The SQL allows renaming relations and attributes using the AS clause:   old-name AS new-name•Find the names of all instructors who have a higher salary than some instructor in ‘Comp. Sci.’•SELECT DISTINCT T.nameFROM instructor AS T, instructor AS SWHERE T.salary > S.salary AND S.dept_name = 'Comp. Sci.'•Keyword AS is optional and may be omitted  instructor AS T  ≡  instructor T\nECE30030/ITP30010 Database Systems28"
              },
              {
                "chapter_title": "SQL DML 고급 기능: NULL 값, 집합 연산, 문자열 처리 및 정렬",
                "source_pdf_filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf",
                "chapter_content_summary": "이 장에서는 SQL DML의 고급 기능을 탐구합니다. 먼저, 알려지지 않거나 존재하지 않는 값을 나타내는 NULL 값의 특성을 이해하고, 산술 연산에서의 NULL 동작 및 IS NULL / IS NOT NULL 술어를 사용하여 NULL 값을 확인하는 방법을 배웁니다. 다음으로, 여러 쿼리 결과를 결합하는 집합 연산인 UNION, INTERSECT, EXCEPT를 살펴봅니다. 각 연산이 기본적으로 중복을 제거하며, ALL 키워드를 사용하여 중복을 유지하는 방법을 설명합니다. 특히 MySQL에서 INTERSECT와 EXCEPT가 직접 지원되지 않을 때 JOIN 또는 NOT IN을 사용하여 에뮬레이션하는 기법을 소개합니다. 이어서, 문자열 패턴 매칭을 위한 LIKE 연산자와 '%' (모든 부분 문자열), '_' (단일 문자) 특수 문자의 사용법을 다룹니다. 백슬래시를 이용한 이스케이프 문자 처리, 패턴 매칭의 대소문자 구분, 그리고 연결, 대소문자 변환, 길이 확인, 부분 문자열 추출 등 다양한 SQL 문자열 함수를 소개합니다. 마지막으로, ORDER BY 절을 사용하여 쿼리 결과를 특정 속성을 기준으로 오름차순(ASC) 또는 내림차순(DESC)으로 정렬하는 방법을 학습하며, 여러 속성을 기준으로 정렬하는 예시도 제시합니다.",
                "chapter_full_text": "ECE30030/ITP30010 Database Systems29\nNULL Values•It is possible for tuples to have a NULL value for some of their attributes•NULL signifies an unknown value or that a value does not exist•The result of any arithmetic expression involving NULL is NULL•E.g.,  5 + NULL returns NULL\nECE30030/ITP30010 Database Systems30\nIS NULL / IS NOT NULL•The predicate IS NULL can be used to check for NULL values•E.g., Find all instructors whose salary is null SELECT name FROM instructor WHERE salary IS NULL•The predicate IS NOT NULL succeeds if the value on which it is applied is not null\nECE30030/ITP30010 Database Systems31\nECE30030/ITP30010 Database Systems32\nSet Operations•Set operations UNION, INTERSECT, and EXCEPT•Each of the above operations automatically eliminates duplicates•To retain all duplicates, use ALL:•UNION ALL•INTERSECT ALL•EXCEPT ALL\n•C.f., SELECT retains all duplicates by default\nECE30030/ITP30010 Database Systems33\nSet Operations: UNION•Find courses that ran in Fall 2017 or in Spring 2018•(SELECT course_id  FROM teaches WHERE semester = 'Fall' AND year = 2017)UNION(SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018)\nECE30030/ITP30010 Database Systems34\nSet Operations: INTERSECT•Find courses that ran in Fall 2017 and in Spring 2018•(SELECT course_id  FROM teaches WHERE semester = 'Fall' AND year = 2017)INTERSECT(SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018)•C.f., MySQL does NOT support INTERSECT•One can emulate INTERSECT using JOIN (we’ll study JOIN later)•SELECT LT.course_idFROM (SELECT course_id FROM teaches WHERE semester = 'Fall' AND year = 2017) AS LTJOIN (SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018) AS RTON LT.course_id=RT.course_id;\nECE30030/ITP30010 Database Systems35\nSet Operations: EXCEPT•Find courses that ran in Fall 2017 but not in Spring 2018•(SELECT course_id  FROM teaches WHERE semester = 'Fall' AND year = 2017)EXCEPT(SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018)•C.f., MySQL does NOT support EXCEPT•One can emulate EXCEPT using NOT IN•SELECT course_id FROM teaches WHERE semester = 'Fall' AND year = 2017AND course_id NOT IN(SELECT course_id  FROM teaches  WHERE semester = 'Spring' AND year = 2018);\nECE30030/ITP30010 Database Systems36\nECE30030/ITP30010 Database Systems37\nString Operations•SQL includes a string-matching operator for comparisons on character strings•The operator LIKE uses patterns that are described using two special characters:•percent (%) – The % character matches any substring•underscore (_) – The _ character matches any character•Find the names of all instructors whose name includes the substring “ri” SELECT name FROM instructor WHERE name LIKE ‘%ri%'\nECE30030/ITP30010 Database Systems38\nString Operations•Escape character: Use backslash (\\) as the escape character•E.g., Match the string “100%” LIKE '100 \\%’ ESCAPE  ‘\\’\nECE30030/ITP30010 Database Systems39\nString Operations•Patterns are case sensitive•Pattern matching examples:•'Intro%' matches any string beginning with “Intro”•'%Comp%' matches any string containing “Comp” as a substring•'_ _ _' matches any string of exactly three characters•'_ _ _ %' matches any string of at least three characters•SQL supports a variety of string operations such as•concatenation (using “||”)•converting from upper to lower case (and vice versa)•finding string length, extracting substrings, etc.\nECE30030/ITP30010 Database Systems40\nOrdering the Display of Tuples•List in alphabetic order the names of all instructors•SELECT DISTINCT nameFROM instructorORDER BY name\nECE30030/ITP30010 Database Systems41\nOrdering the Display of Tuples•Can sort on multiple attributes•E.g., SELECT dept_name, name     FROM instructor      ORDER BY dept_name, name\nECE30030/ITP30010 Database Systems42\nOrdering the Display of Tuples•We may specify DESC for descending order or ASC for ascending order, for each attribute; ascending order is the default•E.g., ORDER BY name DESC\nECE30030/ITP30010 Database Systems43"
              },
              {
                "chapter_title": "SQL DML 집계 함수 및 데이터 수정 (INSERT, UPDATE, DELETE)",
                "source_pdf_filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf",
                "chapter_content_summary": "이 장에서는 SQL 데이터 조작 언어(DML)의 고급 기능인 집계 함수와 데이터를 수정하는 명령어를 다룹니다. AVG, MIN, MAX, SUM, COUNT와 같은 집계 함수를 사용하여 컬럼 값의 멀티셋에 대한 통계 값을 계산하는 방법을 학습합니다. 특히 GROUP BY 절을 이용한 데이터 그룹화와 HAVING 절을 이용한 그룹별 필터링을 심층적으로 다루며, WHERE 절과의 차이점을 명확히 설명합니다. 또한, DML의 핵심 명령인 INSERT, UPDATE, DELETE에 대해 자세히 알아봅니다. INSERT 명령을 통해 테이블에 새로운 튜플을 추가하는 다양한 방법(모든 컬럼, 선택된 컬럼, NULL 값 처리, SELECT 쿼리 결과 삽입)과 외래 키 제약 조건의 중요성을 강조합니다. UPDATE 명령으로는 기존 데이터를 수정하는 기본 구문, 조건부 업데이트, CASE 문을 사용한 복잡한 조건 처리, 스칼라 서브쿼리 활용법을 배웁니다. 마지막으로 DELETE 명령을 통해 테이블에서 특정 행 또는 모든 행을 삭제하는 방법과 TRUNCATE 명령의 차이점, 그리고 삭제 시 서브쿼리 사용 시의 고려사항을 설명합니다.",
                "chapter_full_text": "ECE30030/ITP30010 Database Systems44\nAggregate Functions•These functions operate on the multiset of values of a column of a relation, and return a value•AVG:  average value•MIN:  minimum value•MAX:  maximum value•SUM:  sum of values•COUNT:  number of values\nECE30030/ITP30010 Database Systems45\nAggregate Functions Examples•Find the average salary of instructors in the Computer Science department•SELECT AVG(salary)FROM instructorWHERE dept_name= 'Comp. Sci.';•Find the total number of instructors who teach a course in the Spring 2018 semester•SELECT COUNT(DISTINCT ID)FROM teachesWHERE semester = 'Spring’ AND year = 2018;•Find the number of tuples in the teaches relation•SELECT COUNT (*)FROM teaches;\nECE30030/ITP30010 Database Systems46\nAggregate Functions: Group By•Find the average salary of instructors in each department•SELECT dept_name, AVG(salary) AS avg_salaryFROM instructorGROUP BY dept_name;\nECE30030/ITP30010 Database Systems47\nAggregation•Attributes in SELECT clause outside of aggregate functions must appear in GROUP BY list•/* erroneous query */SELECT dept_name, ID, AVG(salary)FROM instructorGROUP BY dept_name;\nECE30030/ITP30010 Database Systems48\nAggregate Functions – Having Clause•Find the names and average salaries of all departments whose average salary is greater than 65000•SELECT dept_name, AVG(salary) AS avg_salaryFROM instructorGROUP BY dept_nameHAVING AVG(salary) > 65000;\nECE30030/ITP30010 Database Systems49\nAggregate Functions – Having Clause•Note: predicates in the HAVING clause are applied after the formation of groups whereas predicates in the WHERE clause are applied before forming groups\nECE30030/ITP30010 Database Systems50\nSELECT dept_name, AVG(salary) AS avg_salaryFROM instructorGROUP BY dept_nameHAVING AVG(salary) > 65000;\nSELECT dept_name, AVG(salary) AS avg_salaryFROM instructorWHERE salary > 65000GROUP BY dept_name;\nSQL Commands\nSQLDMLSELECTINSERTUPDATEDELETE\nDDLCREATEALTERDROP\nECE30030/ITP30010 Database Systems51\nINSERT•Basic syntax•Insert data into every column:•INSERT INTO tablenameVALUES (col1_value, col2_value, …)•Must list values in the same order as in the table schema•If some data values are unknown, must type NULL •For character sequences, use quotation marks•Single quotation marks are preferred (but double quotation marks are allowed)•Value in quotations is case-sensitive•Insert data into selected columns•INSERT INTO tablename (col1_name, col3_name, col4_name, …)VALUES (col1_value, col3_value, col4_value, …)\nECE30030/ITP30010 Database Systems52\nINSERT•Add a new tuple to course•INSERT INTO courseVALUES ('CS-437', 'Database Systems', 'Comp. Sci.', 4);•or equivalently•INSERT INTO course (course_id, title, dept_name, credits)VALUES ('CS-437', 'Database Systems', 'Comp. Sci.', 4);•Add a new tuple to student  with tot_creds set to null•INSERT INTO studentVALUES ('3003', 'Green', 'Finance', null);\nECE30030/ITP30010 Database Systems53\nINSERT•A foreign key specifies that an attribute from one relation has to map to a tuple in another relation•Value in one relation must appear in another relation\nECE30030/ITP30010 Database Systems54\nRelation: instructor\nRelation: department\nINSERT•A foreign key specifies that an attribute from one relation has to map to a tuple in another relation•Value in one relation must appear in another relation•Make sure all foreign keys that new row references have already been added to database•One cannot insert a foreign key value unless the corresponding value exists in the referenced relation\nECE30030/ITP30010 Database Systems55\nINSERT•Inserting results of other SELECT query•Make each student in the Music department who has earned more than 144 credit hours an instructor in the Music department with a salary of  $18,000•INSERT INTO instructor  SELECT ID, name, dept_name, 18000  FROM student   WHERE dept_name = 'Music’ AND total_cred > 144;•The SELECT FROM WHERE statement is evaluated fully before any of its results are inserted into the relation•Otherwise queries like  INSERT INTO table1 SELECT * FROM table1would cause problem\nECE30030/ITP30010 Database Systems56\nUPDATE•Basic syntax•Updating a table•UPDATE tablenameSET col1_name = new_col1_value, col2_name = new_col2_value, …;•Updating a table with conditions•UPDATE tablenameSET col1_name = new_col1_value, col2_name = new_col2_value, …WHERE predicate;\nECE30030/ITP30010 Database Systems57\nUPDATE•Give a 5% salary raise to all instructors•UPDATE instructorSET salary = salary * 1.05•Give a 5% salary raise to those instructors who earn less than 70000•UPDATE instructorSET salary = salary * 1.05WHERE salary < 70000;•Give a 5% salary raise to instructors whose salary is less than average•UPDATE instructorSET salary = salary * 1.05WHERE salary <  (SELECT AVG(salary) FROM instructor);\nECE30030/ITP30010 Database Systems58\nUPDATE•Increase salaries of instructors whose salary is over $100,000 by 3%, and all others by a 5%•Write two UPDATE statements:  UPDATE instructor  SET salary = salary * 1.03  WHERE salary > 100000;  UPDATE instructor  SET salary = salary * 1.05  WHERE salary <= 100000;•The order is important•Can be done better using the case statement (next slide)\nECE30030/ITP30010 Database Systems59\nCASE Statement for Conditional Update•The following query is equivalent to the previous UPDATE queries•UPDATE instructorSET salary = CASE                           WHEN salary <= 100000 THEN salary * 1.05                           ELSE salary * 1.03                       END\nECE30030/ITP30010 Database Systems60\nUPDATE with Scalar Subqueries•Recompute and update tot_creds value for all students•UPDATE student SSET tot_cred = (SELECT SUM(credits)                             FROM takes, course                             WHERE takes.course_id = course.course_id  AND                                            S.ID= takes.ID  AND                                            takes.grade <> 'F' AND                                            takes.grade IS NOT NULL);\nECE30030/ITP30010 Database Systems61\nDELETE•Basic syntax•To remove specific rows•DELETE FROM tablenameWHERE predicate;•To remove all rows•DELETE FROM tablename;•This is equivalent to TRUNCATE:TRUNCATE (TABLE) tablename;•One cannot truncate a table with foreign key constraints•Must disable the constraints first (we will cover ALTER when we study SQL DDL):ALTER TABLE tablenameDISABLE CONSTRAINT constraint_name;\nECE30030/ITP30010 Database Systems62\nDELETE•Delete all instructors•DELETE FROM instructor;•Delete all instructors from the Finance department•DELETE FROM instructorWHERE dept_name= 'Finance';•Delete all tuples in the instructor relation for those instructors associated with a department located in the Watson building•DELETE FROM instructorWHERE dept name IN (SELECT dept name        FROM department        WHERE building = 'Watson');\nECE30030/ITP30010 Database Systems63\nDELETE•Delete all instructors whose salary is less than the average salary of instructors•Example:  DELETE FROM instructor                WHERE salary < (SELECT AVG (salary)                  FROM instructor);•Issue:  as we delete tuples from instructor, the average salary changes•Solution used in SQL:1.First, compute AVG(salary) and find all tuples to delete2.Next, delete all tuples found above (without recomputing AVG or retesting the tuples)\nECE30030/ITP30010 Database Systems64"
              }
            ],
            "generated_content": [
              {
                "title": "관계형 데이터베이스 시스템(R-DBMS) 개요 및 MySQL 소개",
                "metadata": "Source: cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_1a4c2f45-b482-4e82-826e-fa8945eb99c7_DB03 - mysql.pdf, Text length: 2496 chars",
                "documentContent": [
                  {
                    "type": "heading",
                    "content": "목차",
                    "level": 1
                  },
                  {
                    "type": "paragraph",
                    "content": "MySQL 소개",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "SQL 미리보기",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "MySQL",
                    "level": 1
                  },
                  {
                    "type": "paragraph",
                    "content": "MySQL은 SQL 기반의 관계형 데이터베이스 관리 시스템(DBMS)입니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "GPL 라이선스 하의 무료 오픈소스 R-DBMS입니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "오라클이 소유하고 있습니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "상업용 MySQL 버전도 제공됩니다(기술 지원 포함).",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "“My”는 공동 창립자 Michael Widenius의 딸 이름에서 유래했습니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "참고: MariaDB",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "표준 SQL과 호환됩니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "상업용 웹 서비스에 자주 사용됩니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "MySQL 사용 기업",
                    "level": 1
                  },
                  {
                    "type": "paragraph",
                    "content": "Enlyft의 연구에 따르면, MySQL을 사용하는 1,409,176개 회사 중 199,498개 회사에 대한 데이터를 보유하고 있습니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "주로 직원 수 10-50명, 매출 100만-1000만 달러 규모의 회사에서 사용됩니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "참고: Oracle 12는 직원 수 50-200명, 매출 10억 달러 이상 규모의 회사에서 가장 많이 사용됩니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "MySQL을 사용하는 회사 전체 목록은 https://www.mysql.com/customers/ 에서 확인할 수 있습니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "MySQL을 사용하는 이유",
                    "level": 1
                  },
                  {
                    "type": "paragraph",
                    "content": "인기 많음",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "인터넷 전반에 걸쳐 활발한 토론이 이루어집니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "다재다능함: Linux, Windows, Mac OS X, Solaris, FreeBSD 등 다양한 운영체제에서 실행됩니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "다양한 프로그래밍 언어(C/C++, Java, Python, .Net 등)를 지원합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "비용이 0부터 시작합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "고성능 (빠르고 신뢰할 수 있음)",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "DBMS 인기 추세",
                    "level": 1
                  },
                  {
                    "type": "paragraph",
                    "content": "점수 정의: https://db-engines.com/en/ranking_definition",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "MySQL의 주요 특징",
                    "level": 1
                  },
                  {
                    "type": "paragraph",
                    "content": "방대함: 테라바이트 단위의 데이터를 처리할 수 있습니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "편리함: 고수준 질의어를 지원합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "다중 사용자: 동시 데이터 접근을 지원합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "안전함: 트랜잭션을 지원합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "효율적임: 초당 수천 건의 질의를 처리할 수 있습니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "신뢰성: 많은 실제 제품에서 99.99%의 가동 시간을 자랑합니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "MySQL 버전",
                    "level": 1
                  },
                  {
                    "type": "paragraph",
                    "content": "MySQL 5.x 대 8.x",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "버전 5.x: MySQL의 가장 인기 있는 버전이며, 더 안정적이고 보편적입니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "버전 8.x: 현재 버전으로, 최신 DB 기능(더 나은 스토리지 엔진, 더 빠른 속도, 더 강력한 보안)을 제공합니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "MySQL 얻는 방법",
                    "level": 1
                  },
                  {
                    "type": "paragraph",
                    "content": "https://dev.mysql.com/downloads/",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "무료로 사용 가능한 \"커뮤니티\" 버전을 찾아보세요.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "”엔터프라이즈” 버전은 상업용입니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "이 강의를 위해 Docker 이미지가 준비되어 있습니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "Ubuntu 서버, MySQL, 그리고 강의 활동을 위한 예제 데이터베이스로 구성되어 있습니다.",
                    "level": null
                  }
                ],
                "aiNotes": {
                  "summary": "본 문서는 관계형 데이터베이스 관리 시스템(R-DBMS)의 개요와 MySQL에 대해 소개합니다. MySQL이 SQL 기반의 무료 오픈소스 R-DBMS이며, 오라클이 소유하고 있음을 설명합니다. 또한 MySQL의 광범위한 사용 현황, 다양한 운영체제 및 프로그래밍 언어 지원, 고성능, 안정성 등의 장점을 강조합니다. MySQL 5.x와 8.x 버전의 주요 차이점을 비교하고, MySQL을 다운로드하고 활용할 수 있는 방법을 안내합니다.",
                  "keyConcepts": [
                    {
                      "term": "관계형 데이터베이스 관리 시스템 (R-DBMS)",
                      "definition": "SQL 기반으로 데이터를 관계형 모델에 따라 저장, 관리, 검색하는 시스템입니다."
                    },
                    {
                      "term": "MySQL",
                      "definition": "오라클이 소유한 SQL 기반의 오픈소스 R-DBMS로, 상업용 웹 서비스에 널리 사용되며 높은 성능과 안정성을 제공합니다."
                    },
                    {
                      "term": "오픈소스 소프트웨어",
                      "definition": "소스 코드가 공개되어 누구나 자유롭게 사용, 수정, 배포할 수 있는 소프트웨어입니다."
                    },
                    {
                      "term": "SQL (Structured Query Language)",
                      "definition": "관계형 데이터베이스와 상호작용하고 데이터를 정의, 조작, 제어하기 위한 표준 언어입니다."
                    },
                    {
                      "term": "MySQL 버전 5.x vs 8.x",
                      "definition": "5.x는 가장 대중적이고 안정적인 버전이며, 8.x는 현재 버전으로 최신 기능, 향상된 스토리지 엔진, 속도 및 보안을 제공합니다."
                    }
                  ],
                  "importantTerms": [
                    {
                      "term": "DBMS",
                      "definition": "데이터베이스 관리 시스템(Database Management System)의 약자로, 데이터베이스를 효율적으로 관리하는 소프트웨어입니다."
                    },
                    {
                      "term": "GPL",
                      "definition": "General Public License의 약자로, 자유 소프트웨어 라이선스의 일종이며, 소프트웨어의 복사, 배포, 수정 권한을 부여합니다."
                    },
                    {
                      "term": "MariaDB",
                      "definition": "MySQL의 한 포크(fork)로, MySQL과 높은 호환성을 가지며 오픈소스 커뮤니티에 의해 개발되고 있습니다."
                    },
                    {
                      "term": "트랜잭션",
                      "definition": "데이터베이스의 논리적인 작업 단위로, 데이터의 무결성을 보장하기 위해 전부 실행되거나 전혀 실행되지 않아야 하는 일련의 연산입니다."
                    },
                    {
                      "term": "스토리지 엔진",
                      "definition": "데이터베이스 시스템 내에서 데이터를 디스크에 저장하고 검색하는 방식을 담당하는 구성 요소입니다."
                    },
                    {
                      "term": "Docker",
                      "definition": "애플리케이션을 컨테이너라는 격리된 환경에서 개발, 배포, 실행할 수 있게 해주는 플랫폼입니다."
                    }
                  ],
                  "outline": [
                    {
                      "text": "목차",
                      "id": "목차",
                      "children": null
                    },
                    {
                      "text": "MySQL",
                      "id": "mysql",
                      "children": [
                        {
                          "text": "MySQL 정의 및 특징",
                          "id": "mysql-정의-및-특징",
                          "children": null
                        },
                        {
                          "text": "MySQL 사용 기업",
                          "id": "mysql-사용-기업",
                          "children": null
                        },
                        {
                          "text": "MySQL을 사용하는 이유",
                          "id": "mysql을-사용하는-이유",
                          "children": null
                        },
                        {
                          "text": "MySQL의 주요 특징",
                          "id": "mysql의-주요-특징",
                          "children": null
                        }
                      ]
                    },
                    {
                      "text": "DBMS 인기 추세",
                      "id": "dbms-인기-추세",
                      "children": null
                    },
                    {
                      "text": "MySQL 버전",
                      "id": "mysql-버전",
                      "children": null
                    },
                    {
                      "text": "MySQL 얻는 방법",
                      "id": "mysql-얻는-방법",
                      "children": null
                    }
                  ]
                },
                "quiz": [
                  {
                    "question": "MySQL의 주요 특징이 아닌 것은 무엇인가요?",
                    "options": [
                      "오라클이 소유한 상용 소프트웨어이다.",
                      "SQL 기반의 관계형 데이터베이스 관리 시스템이다.",
                      "GPL 라이선스 하에 무료 오픈소스 버전이 제공된다.",
                      "다양한 운영체제와 프로그래밍 언어를 지원한다."
                    ],
                    "answerIndex": 0,
                    "explanation": "MySQL은 오라클이 소유하고 있지만, GPL 라이선스 하에 무료 오픈소스 버전이 제공되며 상용 버전도 별도로 존재합니다. 따라서 '오라클이 소유한 상용 소프트웨어이다'는 MySQL의 모든 특징을 포괄하지 않습니다."
                  },
                  {
                    "question": "MySQL 5.x 버전과 8.x 버전의 주요 차이점은 무엇인가요?",
                    "options": [
                      "5.x는 최신 기능에 중점을 둔 반면 8.x는 안정성에 중점을 둡니다.",
                      "5.x는 현재 버전이고 8.x는 이전 버전입니다.",
                      "5.x는 더 안정적이고 대중적이며, 8.x는 최신 기능과 향상된 성능을 제공합니다.",
                      "5.x는 유료 버전이고 8.x는 무료 버전입니다."
                    ],
                    "answerIndex": 2,
                    "explanation": "MySQL 5.x는 가장 대중적이고 안정적인 버전으로 남아있지만, 8.x는 최신 버전으로서 더 나은 스토리지 엔진, 속도 및 보안 등 최신 기능을 제공합니다."
                  },
                  {
                    "question": "다음 중 MySQL을 얻을 수 있는 방법으로 본문에 언급되지 않은 것은 무엇인가요?",
                    "options": [
                      "dev.mysql.com/downloads/에서 커뮤니티 버전 다운로드",
                      "MySQL 엔터프라이즈 버전 구매",
                      "Docker 이미지를 통해 구축",
                      "CD-ROM으로 설치"
                    ],
                    "answerIndex": 3,
                    "explanation": "본문에서는 공식 다운로드 페이지에서 커뮤니티 버전 다운로드, 엔터프라이즈 버전 구매, 그리고 Docker 이미지 활용 방법이 언급되었으나, CD-ROM을 통한 설치는 언급되지 않았습니다."
                  }
                ]
              },
              {
                "title": "SQL(구조적 질의어)의 이해: 기본 개념과 역사",
                "metadata": "Source: cd0e465a-9cfa-47bf-93fa-9eb3748fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf, Text length: 1968 chars",
                "documentContent": [
                  {
                    "type": "heading",
                    "content": "서론",
                    "level": 1
                  },
                  {
                    "type": "paragraph",
                    "content": "이 문서는 관계형 데이터베이스를 다루는 핵심 언어인 SQL(구조적 질의어)의 기본 개념과 역사, 그리고 주요 구성 요소에 대해 설명합니다. SQL은 데이터베이스에 '무엇을 할지'를 지시하는 높은 수준의 언어로, '어떻게 할지'에 대한 세부 사항은 DBMS(데이터베이스 관리 시스템)의 질의 최적화 기능에 맡깁니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "구조적 질의어 (SQL) 개요",
                    "level": 1
                  },
                  {
                    "type": "heading",
                    "content": "SQL의 정의 및 특징",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "SQL은 관계형 데이터베이스를 기술하고 조작하는 데 사용되는 주요 언어입니다. SQL은 매우 높은 수준의 언어로, 사용자에게 데이터 조작의 세부 사항을 명시하는 대신 '무엇을 할지'를 지시하도록 합니다. DBMS는 질의 최적화(query optimization)를 통해 질의를 실행하는 '최적의' 방법을 찾아냅니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "SQL의 주요 구성 요소",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "SQL은 크게 두 가지 주요 측면으로 나뉩니다:",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "데이터 정의: 데이터베이스 스키마를 선언하는 데 사용되는 DDL(Data Definition Language).",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "데이터 조작: 데이터베이스에 질의하고(질문을 던지고) 데이터베이스를 수정하는 데 사용되는 DML(Data Manipulation Language).",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "SQL의 다양한 기능",
                    "level": 1
                  },
                  {
                    "type": "heading",
                    "content": "데이터 조작 언어 (DML)",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "DML은 데이터베이스에서 정보를 질의하고, 튜플을 삽입, 삭제, 수정하는 기능을 제공합니다. `SELECT`, `FROM`, `WHERE`와 같은 구문이 DML의 핵심을 이룹니다. 또한, NULL 값 처리, 집합 연산, 문자열 연산, 정렬, 그리고 집계 함수와 같은 고급 기능도 포함됩니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "기타 SQL 기능",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "SQL은 DML 외에도 다양한 기능을 포함합니다:",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "무결성: DDL은 무결성 제약 조건을 명시하기 위한 명령어를 포함합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "뷰 정의: DDL은 뷰를 정의하기 위한 명령어를 포함합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "트랜잭션 제어: 트랜잭션의 시작과 끝을 명시하기 위한 명령어를 포함합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "임베디드 SQL 및 동적 SQL: SQL 문을 범용 프로그래밍 언어 내에 포함하는 방법을 정의합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "권한 부여: 관계 및 뷰에 대한 접근 권한을 명시하기 위한 명령어를 포함합니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "SQL의 간략한 역사",
                    "level": 1
                  },
                  {
                    "type": "heading",
                    "content": "초기 개발: IBM SEQUEL과 System R",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "SQL의 전신인 IBM SEQUEL(Structured English Query Language)은 1970년대 초 Chamberlin과 Boyce에 의해 System R 프로젝트의 일환으로 개발되었습니다. 이후 SEQUEL은 SQL(Structured Query Language)로 이름이 변경되었습니다. System R은 System/38(1979), SQL/DS(1981), DB2(1983)로 발전했습니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "상업적 구현 및 표준화",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "Relational Software, Inc.(현재 Oracle Corporation)는 VAX 컴퓨터용 Oracle V2를 출시하며 최초의 상업적 SQL 구현을 선보였습니다. ANSI와 ISO는 SQL을 표준화했으며, SQL-86을 시작으로 SQL-89, SQL-92, SQL:1999 등을 거쳐 현재는 SQL:2016에 이르렀습니다. 특히 SQL-92는 대부분의 데이터베이스 시스템에서 지원됩니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "기본 질의 구조",
                    "level": 1
                  },
                  {
                    "type": "heading",
                    "content": "SELECT-FROM-WHERE 구문",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "전형적인 SQL 질의는 다음과 같은 형태를 가집니다:",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "SELECT A1, A2, ..., An\nFROM r1, r2, ..., rm\nWHERE P",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "여기서 Ai는 속성(attribute)을 나타내고, Ri는 관계(relation)를 나타내며, P는 술어(predicate)입니다. SQL 질의의 결과는 항상 관계(테이블)입니다.",
                    "level": null
                  }
                ],
                "aiNotes": {
                  "summary": "이 문서는 관계형 데이터베이스의 핵심 언어인 SQL(구조적 질의어)에 대해 설명합니다. SQL의 정의와 특징, 데이터 정의 언어(DDL)와 데이터 조작 언어(DML)로의 구분, 그리고 무결성 제약 조건, 뷰 정의, 트랜잭션 제어 등 다양한 기능을 다룹니다. 또한, IBM의 SEQUEL 개발부터 Oracle의 상업적 구현, 그리고 ANSI 및 ISO 표준화에 이르는 SQL의 간략한 역사와 함께, `SELECT-FROM-WHERE`로 대표되는 SQL의 기본 질의 구조를 소개합니다.",
                  "keyConcepts": [
                    {
                      "term": "SQL (구조적 질의어)",
                      "definition": {
                        "easy": null,
                        "medium": "관계형 데이터베이스를 기술하고 조작하는 데 사용되는 주요 언어로, '무엇을 할지'를 지시하는 높은 수준의 언어입니다.",
                        "hard": null
                      }
                    },
                    {
                      "term": "DML (데이터 조작 언어)",
                      "definition": {
                        "easy": null,
                        "medium": "데이터베이스에서 정보를 질의하고, 튜플을 삽입, 삭제, 수정하는 기능을 제공하는 SQL의 한 부분입니다.",
                        "hard": null
                      }
                    },
                    {
                      "term": "DDL (데이터 정의 언어)",
                      "definition": {
                        "easy": null,
                        "medium": "데이터베이스 스키마를 선언하고 무결성 제약 조건 및 뷰 정의와 같은 데이터베이스 구조 관련 기능을 담당하는 SQL의 한 부분입니다.",
                        "hard": null
                      }
                    },
                    {
                      "term": "질의 최적화",
                      "definition": {
                        "easy": null,
                        "medium": "DBMS가 SQL 질의를 효율적으로 실행하기 위해 '최적의' 실행 계획을 찾는 과정입니다.",
                        "hard": null
                      }
                    }
                  ],
                  "importantTerms": [
                    {
                      "term": "SQL",
                      "definition": "Structured Query Language의 약자로, 관계형 데이터베이스를 관리하는 표준 언어입니다."
                    },
                    {
                      "term": "DML",
                      "definition": "Data Manipulation Language의 약자로, 데이터 검색, 삽입, 수정, 삭제 등 데이터 조작에 사용되는 SQL 명령어 집합입니다."
                    },
                    {
                      "term": "DDL",
                      "definition": "Data Definition Language의 약자로, 데이터베이스 스키마 정의, 테이블 생성 및 수정, 뷰 생성 등 데이터 구조 정의에 사용되는 SQL 명령어 집합입니다."
                    },
                    {
                      "term": "SEQUEL",
                      "definition": "Structured English Query Language의 약자로, SQL의 초기 명칭이자 IBM System R 프로젝트에서 개발되었습니다."
                    },
                    {
                      "term": "System R",
                      "definition": "IBM에서 1970년대 초에 개발한 관계형 데이터베이스 시스템 연구 프로젝트로, SQL의 기원이 되었습니다."
                    },
                    {
                      "term": "질의 최적화 (Query Optimization)",
                      "definition": "DBMS가 SQL 질의를 가장 효율적으로 실행하기 위한 방법을 결정하는 과정입니다."
                    },
                    {
                      "term": "SELECT-FROM-WHERE",
                      "definition": "SQL에서 데이터를 질의하는 가장 기본적인 구문 형태입니다."
                    }
                  ],
                  "outline": [
                    {
                      "text": "서론",
                      "id": "서론",
                      "children": null
                    },
                    {
                      "text": "구조적 질의어 (SQL) 개요",
                      "id": "구조적-질의어-sql-개요",
                      "children": [
                        {
                          "text": "SQL의 정의 및 특징",
                          "id": "sql의-정의-및-특징",
                          "children": null
                        },
                        {
                          "text": "SQL의 주요 구성 요소",
                          "id": "sql의-주요-구성-요소",
                          "children": null
                        }
                      ]
                    },
                    {
                      "text": "SQL의 다양한 기능",
                      "id": "sql의-다양한-기능",
                      "children": [
                        {
                          "text": "데이터 조작 언어 (DML)",
                          "id": "데이터-조작-언어-dml",
                          "children": null
                        },
                        {
                          "text": "기타 SQL 기능",
                          "id": "기타-sql-기능",
                          "children": null
                        }
                      ]
                    },
                    {
                      "text": "SQL의 간략한 역사",
                      "id": "sql의-간략한-역사",
                      "children": [
                        {
                          "text": "초기 개발: IBM SEQUEL과 System R",
                          "id": "초기-개발-ibm-sequel과-system-r",
                          "children": null
                        },
                        {
                          "text": "상업적 구현 및 표준화",
                          "id": "상업적-구현-및-표준화",
                          "children": null
                        }
                      ]
                    },
                    {
                      "text": "기본 질의 구조",
                      "id": "기본-질의-구조",
                      "children": [
                        {
                          "text": "SELECT-FROM-WHERE 구문",
                          "id": "select-from-where-구문",
                          "children": null
                        }
                      ]
                    }
                  ]
                },
                "quiz": [
                  {
                    "question": "SQL의 주요 특징 중 하나는 무엇입니까?",
                    "options": [
                      "데이터 조작의 세부 사항을 명시합니다.",
                      "데이터베이스에 '무엇을 할지'보다 '어떻게 할지'를 지시합니다.",
                      "DBMS가 질의 실행 방법을 최적화하도록 합니다.",
                      "비관계형 데이터베이스를 조작하는 데 주로 사용됩니다."
                    ],
                    "answerIndex": 2,
                    "explanation": "SQL은 '무엇을 할지'를 명시하며, '어떻게 할지'에 대한 세부 사항은 DBMS의 질의 최적화 기능에 맡깁니다."
                  },
                  {
                    "question": "최초의 상업적 SQL 구현을 출시한 회사는 어디입니까?",
                    "options": [
                      "IBM",
                      "Microsoft",
                      "Relational Software, Inc. (현재 Oracle Corporation)",
                      "ANSI"
                    ],
                    "answerIndex": 2,
                    "explanation": "Relational Software, Inc. (현재 Oracle Corporation)가 VAX 컴퓨터용 Oracle V2를 통해 최초의 상업적 SQL 구현을 출시했습니다."
                  },
                  {
                    "question": "SQL의 구성 요소 중 데이터베이스 스키마를 선언하고 무결성 제약 조건 및 뷰를 정의하는 역할을 하는 것은 무엇입니까?",
                    "options": [
                      "DML (Data Manipulation Language)",
                      "DDL (Data Definition Language)",
                      "Transaction Control (트랜잭션 제어)",
                      "Authorization (권한 부여)"
                    ],
                    "answerIndex": 1,
                    "explanation": "DDL(데이터 정의 언어)은 데이터베이스 스키마를 선언하고 무결성 제약 조건 및 뷰를 정의하는 데 사용됩니다."
                  }
                ]
              },
              {
                "title": "SQL 데이터 조작 언어(DML) 기초: SELECT, FROM, WHERE 절",
                "metadata": "Source: cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf, Text length: 4209 chars",
                "documentContent": [
                  {
                    "type": "heading",
                    "content": "SQL 데이터 조작 언어(DML)",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "SQL 데이터 조작 언어(DML)는 데이터베이스를 질의(질문)하고 수정할 수 있도록 합니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "실행 예시",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "관계(테이블): instructor, teaches",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "Instructor 관계 및 Teaches 관계",
                    "level": 2
                  },
                  {
                    "type": "heading",
                    "content": "기본 질의 구조",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "일반적인 SQL 질의는 다음과 같은 형태를 가집니다: SELECT A1, A2, ..., An FROM r1, r2, ..., rm WHERE P",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "Ai는 속성을 나타냅니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "Ri는 관계를 나타냅니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "P는 술어(predicate)입니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "SQL 질의의 결과는 관계(relation)입니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "SELECT 절",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "SELECT 절은 질의 결과에 필요한 속성들을 나열합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "관계 대수의 프로젝션(projection) 연산에 해당합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "예시: 모든 강사의 이름을 찾기",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "SQL: SELECT name FROM instructor;",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "참고",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "참고: SQL 이름은 대소문자를 구분하지 않습니다. 예: Name ≡ NAME ≡ name",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "SQL 명령(SELECT, FROM, WHERE 등)은 대문자로 작성하는 것이 일반적인 관례입니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "MySQL에는 lower_case_table_names라는 옵션 플래그가 있습니다. 링크: https://dev.mysql.com/doc/refman/8.0/en/identifier-case-sensitivity.html",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "SELECT 절: 중복 처리",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "SQL은 관계뿐만 아니라 질의 결과에서도 중복을 허용합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "ALL 키워드는 중복을 제거하지 않도록 지정합니다. SELECT ALL dept_name FROM instructor",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "중복 제거를 강제하려면 SELECT 뒤에 DISTINCT 키워드를 삽입합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "모든 강사의 부서 이름을 중복 없이 찾기: SELECT DISTINCT dept_name FROM instructor;",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "SELECT 절: 모든 속성 및 리터럴 사용",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "SELECT 절의 별표(*)는 “모든 속성”을 의미합니다. SELECT * FROM instructor;",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "속성은 FROM 절 없이 리터럴(상수)이 될 수 있습니다. SELECT ‘437’;",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "결과는 하나의 열과 “437” 값을 가진 단일 행으로 구성된 테이블입니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "AS를 사용하여 열에 이름을 부여할 수 있습니다: SELECT ‘437’ AS FOO",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "속성은 FROM 절을 포함하는 리터럴이 될 수 있습니다. SELECT 'A' FROM instructor",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "결과는 하나의 열과 N개의 행(instructor 테이블의 튜플 수)으로 구성된 테이블이며, 각 행은 “A” 값을 가집니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "SELECT 절: 산술 표현식",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "SELECT 절은 +, –, *, / 연산을 포함하는 산술 표현식을 포함할 수 있으며, 상수 또는 튜플의 속성에 대해 작동합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "질의: SELECT ID, name, salary/12 FROM instructor는 instructor 관계와 동일한 관계를 반환하지만, salary 속성 값이 12로 나뉘어 표시됩니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "AS 절을 사용하여 “salary/12”의 이름을 변경할 수 있습니다: SELECT ID, name, salary/12 AS monthly_salary FROM instructor",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "WHERE 절",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "WHERE 절은 결과가 만족해야 하는 조건을 지정합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "관계 대수의 선택(selection) 술어에 해당합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "예시: ‘Comp. Sci.’ 부서의 모든 강사를 찾으려면: SELECT name FROM instructor WHERE dept_name = 'Comp. Sci.';",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "WHERE 절: 논리 연산자와 비교 연산자",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "SQL은 AND, OR, NOT 논리 연결자를 사용할 수 있도록 합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "논리 연결자의 피연산자는 <, <=, >, >=, =, <>와 같은 비교 연산자를 포함하는 표현식일 수 있습니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "<>는 같지 않음을 의미합니다 (SQL에는 !=가 없습니다).",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "비교는 산술 표현식의 결과에도 적용될 수 있습니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "예시: ‘Comp. Sci.’ 부서에 속하며 급여가 70,000보다 많은 모든 강사를 찾으려면: SELECT name FROM instructor WHERE dept_name = 'Comp. Sci.' AND salary > 70000;",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "WHERE 절: BETWEEN 연산자",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "SQL에는 BETWEEN 비교 연산자가 포함되어 있습니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "예시: 급여가 $90,000에서 $100,000 사이(즉, $90,000 이상 $100,000 이하)인 모든 강사의 이름을 찾으려면:",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "SELECT name FROM instructor WHERE salary BETWEEN 90000 AND 100000",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "WHERE 절: 튜플 비교",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "튜플 비교: 튜플별로 비교를 수행합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "SELECT name, course_id FROM instructor, teaches WHERE (instructor.ID, dept_name) = (teaches.ID, 'Biology');",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "FROM 절",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "FROM 절은 질의에 관련된 관계(테이블)들을 나열합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "관계 대수의 카티션 곱(Cartesian-product) 연산에 해당합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "예시: instructor × teaches의 카티션 곱을 찾으려면: SELECT * FROM instructor, teaches;",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "두 관계의 모든 속성을 포함하여 가능한 모든 instructor-teaches 쌍을 생성합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "공통 속성(예: ID)의 경우, 결과 테이블의 속성 이름은 관계 이름(예: instructor.ID)을 사용하여 변경됩니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "FROM 절: 카티션 곱 예시",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "instructor X teaches의 카티션 곱을 찾으려면: SELECT * FROM instructor, teaches;",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "결과 테이블은 instructor와 teaches 관계의 모든 속성을 포함하며, 각 instructor 튜플과 각 teaches 튜플의 모든 가능한 조합을 생성합니다. 예를 들어, instructor.ID, name, dept_name, salary와 teaches.ID, course_id, sec_id, semester, year와 같은 속성들이 조합되어 나타납니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "조인 구현",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "카티션 곱은 직접적으로는 유용하지 않지만, WHERE 절 조건(관계 대수의 선택 연산)과 결합하면 유용합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "카티션 곱 + 선택 = 조인(join)",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "예시: 어떤 과목을 가르친 모든 강사의 이름과 course_id를 찾으려면: SELECT name, course_id FROM instructor , teaches WHERE instructor.ID = teaches.ID",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "음악과에 속하며 어떤 과목을 가르친 모든 강사의 이름과 course_id를 찾으려면: SELECT name, course_id FROM instructor , teaches WHERE instructor.ID = teaches.ID AND instructor. dept_name = 'Music'",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "이름 변경(Rename) 연산",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "SQL은 AS 절을 사용하여 관계와 속성의 이름을 변경할 수 있도록 합니다: old-name AS new-name",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "예시: 'Comp. Sci.' 부서의 어떤 강사보다 급여가 높은 모든 강사의 이름을 찾으려면:",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "SELECT DISTINCT T.name FROM instructor AS T, instructor AS S WHERE T.salary > S.salary AND S.dept_name = 'Comp. Sci.'",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "AS 키워드는 선택 사항이며 생략될 수 있습니다. instructor AS T ≡ instructor T",
                    "level": null
                  }
                ],
                "aiNotes": {
                  "summary": "본 문서는 SQL 데이터 조작 언어(DML)의 핵심 구성 요소인 SELECT, FROM, WHERE 절의 기초를 다룹니다. 각 절의 기본적인 기능과 함께 중복 처리(ALL, DISTINCT), 산술 표현식, 조건 필터링(AND, OR, NOT, BETWEEN), 테이블 간의 조인(JOIN) 구현, 그리고 테이블 및 속성 이름 변경(AS)과 같은 다양한 활용 방법을 예시와 함께 설명합니다. 또한 SQL 이름의 대소문자 구분 규칙에 대한 내용도 포함되어 있습니다.",
                  "keyConcepts": [
                    {
                      "term": "SQL DML",
                      "definition": "데이터베이스에서 데이터를 질의하고 수정하는 데 사용되는 언어입니다."
                    },
                    {
                      "term": "SELECT 절",
                      "definition": "질의 결과에 포함할 속성(컬럼)을 지정하는 부분으로, 관계 대수의 프로젝션(Projection) 연산에 해당합니다."
                    },
                    {
                      "term": "FROM 절",
                      "definition": "데이터를 검색할 관계(테이블)를 지정하는 부분으로, 관계 대수의 카티션 곱(Cartesian Product) 연산에 해당합니다."
                    },
                    {
                      "term": "WHERE 절",
                      "definition": "질의 결과가 만족해야 할 조건을 지정하는 부분으로, 관계 대수의 선택(Selection) 연산에 해당합니다."
                    },
                    {
                      "term": "조인 (JOIN)",
                      "definition": "FROM 절의 카티션 곱과 WHERE 절의 선택 조건을 결합하여 두 개 이상의 테이블에서 관련 튜플을 연결하여 새로운 테이블을 생성하는 연산입니다."
                    }
                  ],
                  "importantTerms": [
                    {
                      "term": "DML (Data Manipulation Language)",
                      "definition": "데이터베이스에서 데이터를 검색, 삽입, 삭제, 수정하는 데 사용되는 언어."
                    },
                    {
                      "term": "SELECT",
                      "definition": "SQL 쿼리의 결과를 정의하는 절로, 어떤 컬럼을 반환할지 지정."
                    },
                    {
                      "term": "FROM",
                      "definition": "SQL 쿼리에서 데이터를 검색할 테이블을 지정하는 절."
                    },
                    {
                      "term": "WHERE",
                      "definition": "SQL 쿼리에서 특정 조건을 만족하는 행만 선택하도록 필터링하는 절."
                    },
                    {
                      "term": "DISTINCT",
                      "definition": "SELECT 절에서 중복된 결과를 제거할 때 사용하는 키워드."
                    },
                    {
                      "term": "AS",
                      "definition": "SQL에서 테이블이나 컬럼의 이름을 변경(별칭 지정)할 때 사용하는 키워드."
                    },
                    {
                      "term": "카티션 곱 (Cartesian Product)",
                      "definition": "두 테이블의 모든 가능한 행 조합을 생성하는 연산."
                    }
                  ],
                  "outline": [
                    {
                      "text": "SQL 데이터 조작 언어(DML) 개요",
                      "id": "sql-데이터-조작-언어-dml-개요",
                      "children": null
                    },
                    {
                      "text": "기본 질의 구조",
                      "id": "기본-질의-구조",
                      "children": null
                    },
                    {
                      "text": "SELECT 절의 활용",
                      "id": "select-절의-활용",
                      "children": [
                        {
                          "text": "속성 선택 및 프로젝션",
                          "id": "속성-선택-및-프로젝션",
                          "children": null
                        },
                        {
                          "text": "대소문자 구분 및 SQL 명령 규칙",
                          "id": "대소문자-구분-및-sql-명령-규칙",
                          "children": null
                        },
                        {
                          "text": "중복 처리 (ALL, DISTINCT)",
                          "id": "중복-처리-all-distinct",
                          "children": null
                        },
                        {
                          "text": "모든 속성 선택 (*) 및 리터럴 사용",
                          "id": "모든-속성-선택-및-리터럴-사용",
                          "children": null
                        },
                        {
                          "text": "산술 표현식 및 결과 이름 변경 (AS)",
                          "id": "산술-표현식-및-결과-이름-변경-as",
                          "children": null
                        }
                      ]
                    },
                    {
                      "text": "WHERE 절의 활용",
                      "id": "where-절의-활용",
                      "children": [
                        {
                          "text": "조건 지정 및 선택 연산",
                          "id": "조건-지정-및-선택-연산",
                          "children": null
                        },
                        {
                          "text": "논리 연산자 (AND, OR, NOT) 및 비교 연산자",
                          "id": "논리-연산자-and-or-not-및-비교-연산자",
                          "children": null
                        },
                        {
                          "text": "BETWEEN 연산자",
                          "id": "between-연산자",
                          "children": null
                        },
                        {
                          "text": "튜플 비교",
                          "id": "튜플-비교",
                          "children": null
                        }
                      ]
                    },
                    {
                      "text": "FROM 절의 활용",
                      "id": "from-절의-활용",
                      "children": [
                        {
                          "text": "관계 지정 및 카티션 곱",
                          "id": "관계-지정-및-카티션-곱",
                          "children": null
                        },
                        {
                          "text": "조인 구현 (Cartesian-product + selection)",
                          "id": "조인-구현-cartesian-product-selection",
                          "children": null
                        }
                      ]
                    },
                    {
                      "text": "이름 변경 (AS) 연산",
                      "id": "이름-변경-as-연산",
                      "children": null
                    }
                  ]
                },
                "quiz": [
                  {
                    "question": "중복된 값을 제거하고 강사들의 부서 이름을 검색하는 올바른 SQL 쿼리는 무엇입니까?",
                    "options": [
                      "SELECT ALL dept_name FROM instructor;",
                      "SELECT dept_name FROM instructor;",
                      "SELECT DISTINCT dept_name FROM instructor;",
                      "SELECT UNIQUE dept_name FROM instructor;"
                    ],
                    "answerIndex": 2,
                    "explanation": "`DISTINCT` 키워드는 SELECT 절에서 중복된 결과를 제거하는 데 사용됩니다."
                  },
                  {
                    "question": "'Comp. Sci.' 부서에 속하며 급여가 70,000보다 많은 모든 강사의 이름을 찾는 SQL 쿼리로 가장 적절한 것은 무엇입니까?",
                    "options": [
                      "SELECT name FROM instructor WHERE dept_name = 'Comp. Sci.' OR salary > 70000;",
                      "SELECT name FROM instructor WHERE dept_name = 'Comp. Sci.' AND salary > 70000;",
                      "SELECT name FROM instructor WHERE dept_name <> 'Comp. Sci.' AND salary <= 70000;",
                      "SELECT name FROM instructor WHERE dept_name = 'Comp. Sci.' BETWEEN salary 70000;"
                    ],
                    "answerIndex": 1,
                    "explanation": "`AND` 논리 연산자는 두 조건을 모두 만족하는 경우를 찾을 때 사용됩니다."
                  },
                  {
                    "question": "다음 SQL 쿼리 `SELECT DISTINCT T.name FROM instructor AS T, instructor AS S WHERE T.salary > S.salary AND S.dept_name = 'Comp. Sci.'`에 대한 설명으로 옳은 것은 무엇입니까?",
                    "options": [
                      "이 쿼리는 'Comp. Sci.' 부서 강사들 중 가장 높은 급여를 받는 강사의 이름을 찾습니다.",
                      "이 쿼리는 'Comp. Sci.' 부서의 특정 강사보다 급여가 높은 다른 강사들의 이름을 찾습니다.",
                      "이 쿼리는 'Comp. Sci.' 부서의 모든 강사 이름을 나열합니다.",
                      "이 쿼리는 두 개의 다른 테이블에서 강사 정보를 조인합니다."
                    ],
                    "answerIndex": 1,
                    "explanation": "`FROM instructor AS T, instructor AS S`는 instructor 테이블을 두 개의 별칭(T와 S)으로 사용하여 자체 조인(self-join)을 수행하며, `WHERE T.salary > S.salary AND S.dept_name = 'Comp. Sci.'` 조건은 'Comp. Sci.' 부서의 어떤 강사(S)보다 급여가 높은 강사(T)를 찾습니다."
                  }
                ]
              },
              {
                "title": "SQL DML 고급 기능: NULL 값, 집합 연산, 문자열 처리 및 정렬",
                "metadata": "Source: cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf, Text length: 3206 chars",
                "documentContent": [
                  {
                    "type": "heading",
                    "content": "NULL 값",
                    "level": 1
                  },
                  {
                    "type": "paragraph",
                    "content": "튜플에 일부 속성에 대해 NULL 값이 있을 수 있습니다. NULL은 알 수 없거나 값이 존재하지 않음을 의미합니다. NULL이 포함된 모든 산술 표현식의 결과는 NULL입니다. 예를 들어, '5 + NULL'은 NULL을 반환합니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "IS NULL / IS NOT NULL",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "술어 `IS NULL`은 NULL 값을 확인하는 데 사용됩니다. 예를 들어, `SELECT name FROM instructor WHERE salary IS NULL`은 급여가 NULL인 모든 강사의 이름을 찾습니다. `IS NOT NULL` 술어는 적용된 값이 NULL이 아닐 때 성공합니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "집합 연산",
                    "level": 1
                  },
                  {
                    "type": "paragraph",
                    "content": "`UNION`, `INTERSECT`, `EXCEPT`와 같은 집합 연산이 있습니다. 이 연산들은 각각 자동으로 중복을 제거합니다. 모든 중복을 유지하려면 `ALL` 키워드를 사용합니다(예: `UNION ALL`, `INTERSECT ALL`, `EXCEPT ALL`). 참고로 `SELECT` 문은 기본적으로 모든 중복을 유지합니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "UNION",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "`UNION`은 두 쿼리의 결과를 결합합니다. 예를 들어, 2017년 가을 또는 2018년 봄에 개설된 강좌를 찾을 수 있습니다. (`SELECT course_id FROM teaches WHERE semester = 'Fall' AND year = 2017) UNION (SELECT course_id FROM teaches WHERE semester = 'Spring' AND year = 2018`).",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "INTERSECT",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "`INTERSECT`는 두 쿼리 결과의 공통 부분을 찾습니다. 예를 들어, 2017년 가을과 2018년 봄 모두에 개설된 강좌를 찾을 수 있습니다. MySQL은 `INTERSECT`를 직접 지원하지 않으므로, `JOIN`을 사용하여 에뮬레이션할 수 있습니다. (`SELECT LT.course_id FROM (SELECT course_id FROM teaches WHERE semester = 'Fall' AND year = 2017) AS LT JOIN (SELECT course_id FROM teaches WHERE semester = 'Spring' AND year = 2018) AS RT ON LT.course_id=RT.course_id;`)",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "EXCEPT",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "`EXCEPT`는 첫 번째 쿼리 결과에서 두 번째 쿼리 결과를 제외한 부분을 찾습니다. 예를 들어, 2017년 가을에 개설되었지만 2018년 봄에는 개설되지 않은 강좌를 찾을 수 있습니다. MySQL은 `EXCEPT`를 직접 지원하지 않으므로, `NOT IN`을 사용하여 에뮬레이션할 수 있습니다. (`SELECT course_id FROM teaches WHERE semester = 'Fall' AND year = 2017 AND course_id NOT IN(SELECT course_id FROM teaches WHERE semester = 'Spring' AND year = 2018);`)",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "문자열 연산",
                    "level": 1
                  },
                  {
                    "type": "paragraph",
                    "content": "SQL은 문자열 비교를 위한 문자열 일치 연산자를 포함합니다. `LIKE` 연산자는 두 가지 특수 문자를 사용하여 패턴을 설명합니다. 퍼센트(`%`) 문자는 모든 부분 문자열과 일치하고, 밑줄(`_`) 문자는 모든 단일 문자와 일치합니다. 예를 들어, `SELECT name FROM instructor WHERE name LIKE ‘%ri%'`는 이름에 \"ri\" 부분 문자열이 포함된 모든 강사의 이름을 찾습니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "이스케이프 문자(예: 백슬래시 `\\`)를 사용하여 특수 문자를 리터럴로 일치시킬 수 있습니다. 예를 들어, \"100%\" 문자열과 일치시키려면 `LIKE '100 \\%' ESCAPE '\\'`를 사용합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "패턴은 대소문자를 구분합니다. 패턴 일치 예시: 'Intro%'는 \"Intro\"로 시작하는 모든 문자열과 일치하고, '%Comp%'는 \"Comp\"를 포함하는 모든 문자열과 일치하며, '_ _ _'는 정확히 세 문자로 된 모든 문자열과 일치하고, '_ _ _ %'는 최소 세 문자로 된 모든 문자열과 일치합니다. SQL은 연결(`||`), 대소문자 변환, 문자열 길이 찾기, 부분 문자열 추출 등 다양한 문자열 연산을 지원합니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "튜플 표시 정렬",
                    "level": 1
                  },
                  {
                    "type": "paragraph",
                    "content": "`ORDER BY` 절을 사용하여 튜플의 표시 순서를 정렬할 수 있습니다. 예를 들어, 모든 강사의 이름을 알파벳 순서로 나열하려면 `SELECT DISTINCT name FROM instructor ORDER BY name`을 사용합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "여러 속성을 기준으로 정렬할 수 있습니다. 예를 들어, `SELECT dept_name, name FROM instructor ORDER BY dept_name, name`과 같이 부서 이름과 이름 순으로 정렬할 수 있습니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "각 속성에 대해 내림차순(`DESC`) 또는 오름차순(`ASC`)을 지정할 수 있으며, 오름차순이 기본값입니다. 예를 들어, `ORDER BY name DESC`는 이름을 내림차순으로 정렬합니다.",
                    "level": null
                  }
                ],
                "aiNotes": {
                  "summary": "이 문서는 SQL DML의 고급 기능을 다룹니다. NULL 값의 개념과 `IS NULL`, `IS NOT NULL`을 이용한 처리 방법을 설명합니다. 또한 `UNION`, `INTERSECT`, `EXCEPT`와 같은 집합 연산의 사용법과 `ALL` 키워드를 통한 중복 유지 방법, 그리고 MySQL에서의 에뮬레이션 방안을 제시합니다. 마지막으로 `LIKE` 연산자를 활용한 문자열 패턴 매칭과 `ORDER BY` 절을 이용한 결과 정렬 방법에 대해 자세히 설명합니다.",
                  "keyConcepts": [
                    {
                      "term": "NULL 값 처리",
                      "definition": "데이터베이스에서 알 수 없거나 존재하지 않는 값을 나타내는 NULL을 다루는 방법과 관련된 SQL 기능."
                    },
                    {
                      "term": "SQL 집합 연산",
                      "definition": "여러 쿼리 결과를 `UNION`, `INTERSECT`, `EXCEPT`를 사용하여 결합하거나 비교하는 기능."
                    },
                    {
                      "term": "문자열 패턴 매칭",
                      "definition": "`LIKE` 연산자와 `%`, `_` 특수 문자를 사용하여 문자열 내의 특정 패턴을 검색하는 방법."
                    },
                    {
                      "term": "결과 집합 정렬",
                      "definition": "`ORDER BY` 절을 사용하여 쿼리 결과 튜플의 표시 순서를 오름차순(`ASC`) 또는 내림차순(`DESC`)으로 지정하는 방법."
                    }
                  ],
                  "importantTerms": [
                    {
                      "term": "NULL",
                      "definition": "알 수 없거나 존재하지 않는 값."
                    },
                    {
                      "term": "IS NULL / IS NOT NULL",
                      "definition": "NULL 값을 확인하는 데 사용되는 술어."
                    },
                    {
                      "term": "UNION",
                      "definition": "두 쿼리 결과를 합치는 집합 연산자이며, 기본적으로 중복을 제거한다."
                    },
                    {
                      "term": "LIKE",
                      "definition": "문자열 패턴 매칭에 사용되는 연산자."
                    },
                    {
                      "term": "%",
                      "definition": "`LIKE` 연산자에서 임의의 부분 문자열과 일치하는 특수 문자."
                    },
                    {
                      "term": "_",
                      "definition": "`LIKE` 연산자에서 임의의 단일 문자와 일치하는 특수 문자."
                    },
                    {
                      "term": "ORDER BY",
                      "definition": "쿼리 결과의 정렬 순서를 지정하는 절."
                    }
                  ],
                  "outline": [
                    {
                      "text": "NULL 값",
                      "id": "null-값",
                      "children": [
                        {
                          "text": "NULL 값의 정의 및 특징",
                          "id": "null-값의-정의-및-특징",
                          "children": null
                        },
                        {
                          "text": "IS NULL / IS NOT NULL 술어",
                          "id": "is-null-is-not-null-술어",
                          "children": null
                        }
                      ]
                    },
                    {
                      "text": "집합 연산",
                      "id": "집합-연산",
                      "children": [
                        {
                          "text": "집합 연산의 종류 (UNION, INTERSECT, EXCEPT)",
                          "id": "집합-연산의-종류",
                          "children": null
                        },
                        {
                          "text": "중복 제거 및 ALL 키워드",
                          "id": "중복-제거-및-all-키워드",
                          "children": null
                        },
                        {
                          "text": "UNION 예시",
                          "id": "union-예시",
                          "children": null
                        },
                        {
                          "text": "INTERSECT 예시 및 MySQL 에뮬레이션",
                          "id": "intersect-예시-및-mysql-에뮬레이션",
                          "children": null
                        },
                        {
                          "text": "EXCEPT 예시 및 MySQL 에뮬레이션",
                          "id": "except-예시-및-mysql-에뮬레이션",
                          "children": null
                        }
                      ]
                    },
                    {
                      "text": "문자열 연산",
                      "id": "문자열-연산",
                      "children": [
                        {
                          "text": "LIKE 연산자 및 패턴 매칭 특수 문자 (%, _)",
                          "id": "like-연산자-및-패턴-매칭-특수-문자",
                          "children": null
                        },
                        {
                          "text": "이스케이프 문자",
                          "id": "이스케이프-문자",
                          "children": null
                        },
                        {
                          "text": "패턴 매칭 예시 및 특징 (대소문자 구분)",
                          "id": "패턴-매칭-예시-및-특징",
                          "children": null
                        },
                        {
                          "text": "기타 문자열 함수",
                          "id": "기타-문자열-함수",
                          "children": null
                        }
                      ]
                    },
                    {
                      "text": "튜플 표시 정렬",
                      "id": "튜플-표시-정렬",
                      "children": [
                        {
                          "text": "ORDER BY 절 기본 사용법",
                          "id": "order-by-절-기본-사용법",
                          "children": null
                        },
                        {
                          "text": "여러 속성으로 정렬",
                          "id": "여러-속성으로-정렬",
                          "children": null
                        },
                        {
                          "text": "오름차순 (ASC) 및 내림차순 (DESC) 지정",
                          "id": "오름차순-및-내림차순-지정",
                          "children": null
                        }
                      ]
                    }
                  ]
                },
                "quiz": [
                  {
                    "question": "SQL에서 NULL 값이 포함된 산술 연산의 결과는 무엇입니까?",
                    "options": [
                      "0",
                      "1",
                      "NULL",
                      "오류"
                    ],
                    "answerIndex": 2,
                    "explanation": "NULL이 포함된 산술 표현식의 결과는 항상 NULL입니다."
                  },
                  {
                    "question": "다음 중 두 쿼리 결과의 중복을 포함하여 합치는 SQL 집합 연산자는 무엇입니까?",
                    "options": [
                      "UNION",
                      "INTERSECT ALL",
                      "UNION ALL",
                      "EXCEPT"
                    ],
                    "answerIndex": 2,
                    "explanation": "`UNION`은 중복을 제거하지만, `UNION ALL`은 모든 중복을 유지하면서 두 쿼리 결과를 합칩니다."
                  },
                  {
                    "question": "`LIKE` 연산자에서 임의의 단일 문자와 일치하는 특수 문자는 무엇입니까?",
                    "options": [
                      "%",
                      "_",
                      "\\",
                      "?"
                    ],
                    "answerIndex": 1,
                    "explanation": "`%`는 임의의 부분 문자열과 일치하고, `_`는 임의의 단일 문자와 일치합니다."
                  }
                ]
              },
              {
                "title": "SQL DML: 집계 함수 및 데이터 수정 (INSERT, UPDATE, DELETE)",
                "metadata": "Source: cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf, Text length: 5040 chars",
                "documentContent": [
                  {
                    "type": "heading",
                    "content": "집계 함수 (Aggregate Functions)",
                    "level": 1
                  },
                  {
                    "type": "paragraph",
                    "content": "집계 함수는 릴레이션의 특정 컬럼 값들의 멀티셋에 대해 작동하며 단일 값을 반환합니다. 주요 집계 함수는 다음과 같습니다:",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **AVG**: 평균값",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **MIN**: 최솟값",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **MAX**: 최댓값",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **SUM**: 합계",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **COUNT**: 값의 개수",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "집계 함수 예시",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "집계 함수는 다양한 질의에 사용될 수 있습니다. 예를 들어, 컴퓨터 공학과 강사들의 평균 급여를 찾거나, 2018년 봄 학기에 강의를 가르친 강사의 총 수를 세거나, `teaches` 릴레이션의 튜플 수를 세는 데 활용됩니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **컴퓨터 공학과 강사들의 평균 급여 찾기:**",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "SELECT AVG(salary)\nFROM instructor\nWHERE dept_name= 'Comp. Sci.';",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **2018년 봄 학기에 강의를 가르친 강사의 총 수 찾기:**",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "SELECT COUNT(DISTINCT ID)\nFROM teaches\nWHERE semester = 'Spring’ AND year = 2018;",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **`teaches` 릴레이션의 튜플 수 찾기:**",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "SELECT COUNT (*)\nFROM teaches;",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "GROUP BY 절",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "`GROUP BY` 절은 특정 컬럼의 값을 기준으로 행들을 그룹으로 묶고, 각 그룹에 대해 집계 함수를 적용할 때 사용됩니다. 예를 들어, 각 부서의 강사 평균 급여를 찾을 수 있습니다.",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "SELECT dept_name, AVG(salary) AS avg_salary\nFROM instructor\nGROUP BY dept_name;",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "GROUP BY 규칙",
                    "level": 3
                  },
                  {
                    "type": "paragraph",
                    "content": "`SELECT` 절에 집계 함수 외에 사용된 모든 속성은 반드시 `GROUP BY` 목록에 포함되어야 합니다. 그렇지 않으면 오류가 발생합니다.",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "/* 오류가 발생하는 질의 */\nSELECT dept_name, ID, AVG(salary)\nFROM instructor\nGROUP BY dept_name;",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "HAVING 절",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "`HAVING` 절은 `GROUP BY` 절에 의해 생성된 그룹에 조건을 적용하여 결과를 필터링하는 데 사용됩니다. 예를 들어, 평균 급여가 65000을 초과하는 모든 부서의 이름과 평균 급여를 찾을 수 있습니다.",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "SELECT dept_name, AVG(salary) AS avg_salary\nFROM instructor\nGROUP BY dept_name\nHAVING AVG(salary) > 65000;",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "HAVING과 WHERE의 차이",
                    "level": 3
                  },
                  {
                    "type": "paragraph",
                    "content": "`HAVING` 절의 조건은 그룹이 형성된 **후**에 적용되는 반면, `WHERE` 절의 조건은 그룹을 형성하기 **전**에 적용됩니다. 이는 데이터 필터링 시점의 중요한 차이입니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "SQL DML 명령어",
                    "level": 1
                  },
                  {
                    "type": "paragraph",
                    "content": "SQL 데이터 조작 언어(DML)는 데이터베이스 내의 데이터를 검색, 삽입, 수정, 삭제하는 데 사용됩니다. 주요 DML 명령어는 `SELECT`, `INSERT`, `UPDATE`, `DELETE`입니다. 데이터 정의 언어(DDL)는 `CREATE`, `ALTER`, `DROP`과 같이 데이터베이스 스키마를 정의하고 관리하는 데 사용됩니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "INSERT (데이터 삽입)",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "`INSERT` 문은 테이블에 새로운 행(튜플)을 추가하는 데 사용됩니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "기본 문법",
                    "level": 3
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **모든 컬럼에 데이터 삽입:**",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "INSERT INTO tablename\nVALUES (col1_value, col2_value, …)",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "    *   값은 테이블 스키마와 동일한 순서로 나열되어야 합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "    *   알 수 없는 데이터 값은 `NULL`로 지정해야 합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "    *   문자열은 따옴표를 사용하며, 작은따옴표(')가 권장됩니다. 따옴표 안의 값은 대소문자를 구분합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **선택한 컬럼에 데이터 삽입:**",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "INSERT INTO tablename (col1_name, col3_name, col4_name, …)\nVALUES (col1_value, col3_value, col4_value, …)",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "INSERT 예시",
                    "level": 3
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **`course` 테이블에 새로운 튜플 추가:**",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "INSERT INTO course\nVALUES ('CS-437', 'Database Systems', 'Comp. Sci.', 4);",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "    또는 동일하게:",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "INSERT INTO course (course_id, title, dept_name, credits)\nVALUES ('CS-437', 'Database Systems', 'Comp. Sci.', 4);",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **`student` 테이블에 `tot_creds`가 NULL인 새로운 튜플 추가:**",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "INSERT INTO student\nVALUES ('3003', 'Green', 'Finance', null);",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "외래 키 제약 조건과 INSERT",
                    "level": 3
                  },
                  {
                    "type": "paragraph",
                    "content": "외래 키는 한 릴레이션의 속성이 다른 릴레이션의 튜플에 매핑되어야 함을 지정합니다. 즉, 한 릴레이션의 값이 다른 릴레이션에 존재해야 합니다. 새로운 행을 삽입할 때는 해당 행이 참조하는 모든 외래 키가 데이터베이스에 이미 추가되어 있는지 확인해야 합니다. 참조된 릴레이션에 해당 값이 존재하지 않으면 외래 키 값을 삽입할 수 없습니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "다른 SELECT 쿼리 결과 삽입",
                    "level": 3
                  },
                  {
                    "type": "paragraph",
                    "content": "`SELECT` 쿼리의 결과를 다른 테이블에 삽입할 수 있습니다. 이때 `SELECT FROM WHERE` 문은 그 결과가 릴레이션에 삽입되기 전에 완전히 평가됩니다. 이는 `INSERT INTO table1 SELECT * FROM table1`과 같은 질의에서 발생할 수 있는 문제를 방지합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **음악학과 학생 중 144학점 이상을 이수한 학생들을 $18,000 급여의 음악학과 강사로 추가:**",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "INSERT INTO instructor\n  SELECT ID, name, dept_name, 18000\n  FROM student\n  WHERE dept_name = 'Music’ AND total_cred > 144;",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "UPDATE (데이터 수정)",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "`UPDATE` 문은 테이블의 기존 데이터를 수정하는 데 사용됩니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "기본 문법",
                    "level": 3
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **테이블 업데이트 (조건 없음):** 모든 행의 지정된 컬럼을 수정합니다.",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "UPDATE tablename\nSET col1_name = new_col1_value, col2_name = new_col2_value, …;",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **조건 있는 테이블 업데이트:** `WHERE` 절의 조건과 일치하는 행만 수정합니다.",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "UPDATE tablename\nSET col1_name = new_col1_value, col2_name = new_col2_value, …\nWHERE predicate;",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "UPDATE 예시",
                    "level": 3
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **모든 강사의 급여를 5% 인상:**",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "UPDATE instructor\nSET salary = salary * 1.05",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **급여가 70000 미만인 강사의 급여를 5% 인상:**",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "UPDATE instructor\nSET salary = salary * 1.05\nWHERE salary < 70000;",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **급여가 평균 급여 미만인 강사의 급여를 5% 인상:**",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "UPDATE instructor\nSET salary = salary * 1.05\nWHERE salary <  (SELECT AVG(salary) FROM instructor);",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "CASE 문을 이용한 조건부 UPDATE",
                    "level": 3
                  },
                  {
                    "type": "paragraph",
                    "content": "여러 조건에 따라 다른 값을 적용해야 할 경우 `CASE` 문을 사용할 수 있습니다. 이는 여러 `UPDATE` 문을 사용하는 것보다 효율적이며, 실행 순서에 따른 문제를 방지할 수 있습니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **급여가 $100,000 초과인 강사는 3% 인상, 그 외는 5% 인상:**",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "UPDATE instructor\nSET salary = CASE\n                           WHEN salary <= 100000 THEN salary * 1.05\n                           ELSE salary * 1.03\n                       END",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "스칼라 서브쿼리를 이용한 UPDATE",
                    "level": 3
                  },
                  {
                    "type": "paragraph",
                    "content": "스칼라 서브쿼리(단일 값을 반환하는 서브쿼리)를 사용하여 컬럼 값을 업데이트할 수 있습니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **모든 학생의 `tot_creds` 값을 재계산하여 업데이트:**",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "UPDATE student S\nSET tot_cred = (SELECT SUM(credits)\n                             FROM takes, course\n                             WHERE takes.course_id = course.course_id  AND\n                                            S.ID= takes.ID  AND\n                                            takes.grade <> 'F' AND\n                                            takes.grade IS NOT NULL);",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "DELETE (데이터 삭제)",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "`DELETE` 문은 테이블에서 행을 제거하는 데 사용됩니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "기본 문법",
                    "level": 3
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **특정 행 제거:** `WHERE` 절의 조건과 일치하는 행을 제거합니다.",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "DELETE FROM tablename\nWHERE predicate;",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **모든 행 제거:** 테이블의 모든 행을 제거합니다.",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "DELETE FROM tablename;",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "TRUNCATE와의 비교",
                    "level": 3
                  },
                  {
                    "type": "paragraph",
                    "content": "`DELETE FROM tablename;`는 `TRUNCATE (TABLE) tablename;`와 기능적으로 유사하게 테이블의 모든 행을 제거합니다. 그러나 `TRUNCATE`는 외래 키 제약 조건이 있는 테이블에서는 사용할 수 없습니다. 외래 키 제약 조건이 있는 테이블을 `TRUNCATE`하려면 먼저 제약 조건을 비활성화해야 합니다.",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "ALTER TABLE tablename\nDISABLE CONSTRAINT constraint_name;",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "DELETE 예시",
                    "level": 3
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **모든 강사 삭제:**",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "DELETE FROM instructor;",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **재무학과 강사 모두 삭제:**",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "DELETE FROM instructor\nWHERE dept_name= 'Finance';",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **Watson 건물에 위치한 부서에 소속된 강사 모두 삭제:**",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "DELETE FROM instructor\nWHERE dept_name IN (SELECT dept_name\n        FROM department\n        WHERE building = 'Watson');",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "서브쿼리를 이용한 DELETE 시 주의사항",
                    "level": 3
                  },
                  {
                    "type": "paragraph",
                    "content": "서브쿼리를 사용하여 `DELETE` 작업을 수행할 때, 삭제되는 튜플이 서브쿼리의 결과에 영향을 미칠 수 있습니다. 예를 들어, 강사 평균 급여보다 낮은 급여를 가진 강사를 삭제하는 경우, 강사가 삭제됨에 따라 평균 급여가 변경될 수 있습니다.",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "DELETE FROM instructor\nWHERE salary < (SELECT AVG (salary) FROM instructor);",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "SQL에서는 이러한 문제를 해결하기 위해 다음과 같은 방식을 사용합니다. 먼저 `AVG(salary)`를 계산하고 삭제할 모든 튜플을 찾은 다음, 평균을 재계산하거나 튜플을 재확인하지 않고 찾아진 모든 튜플을 삭제합니다.",
                    "level": null
                  }
                ],
                "aiNotes": {
                  "summary": "이 문서는 SQL의 데이터 조작 언어(DML) 중 집계 함수와 데이터 수정 명령어(INSERT, UPDATE, DELETE)에 대해 설명합니다. 집계 함수의 종류(AVG, MIN, MAX, SUM, COUNT)와 사용 예시를 제시하며, GROUP BY 및 HAVING 절의 사용법과 WHERE 절과의 차이점을 강조합니다. 또한, INSERT 명령어를 이용한 데이터 삽입 방법, 외래 키 제약 조건과의 관계, 그리고 SELECT 쿼리 결과 삽입에 대해 다룹니다. UPDATE 명령어의 기본 문법, 다양한 조건부 업데이트 예시, 그리고 CASE 문 및 스칼라 서브쿼리 활용법을 설명합니다. 마지막으로 DELETE 명령어의 기본 문법, TRUNCATE와의 차이점, 외래 키 제약 조건, 그리고 서브쿼리를 사용한 삭제 시의 처리 방식에 대해 상세히 기술합니다.",
                  "keyConcepts": [
                    {
                      "term": "집계 함수 (Aggregate Functions)",
                      "definition": "릴레이션의 컬럼 값들의 멀티셋에 대해 작동하여 단일 값을 반환하는 함수 (예: AVG, MIN, MAX, SUM, COUNT)."
                    },
                    {
                      "term": "GROUP BY",
                      "definition": "SQL에서 특정 컬럼의 값을 기준으로 행들을 그룹으로 묶어 각 그룹에 대해 집계 함수를 적용할 수 있게 하는 절."
                    },
                    {
                      "term": "HAVING 절",
                      "definition": "GROUP BY 절에 의해 생성된 그룹에 조건을 적용하여 결과를 필터링하는 데 사용되는 절. WHERE 절과 달리 그룹화 후에 적용된다."
                    },
                    {
                      "term": "INSERT",
                      "definition": "SQL에서 테이블에 새로운 행(튜플)을 추가하는 데 사용되는 DML 명령어."
                    },
                    {
                      "term": "UPDATE",
                      "definition": "SQL에서 테이블의 기존 데이터를 수정하는 데 사용되는 DML 명령어."
                    },
                    {
                      "term": "DELETE",
                      "definition": "SQL에서 테이블의 행을 제거하는 데 사용되는 DML 명령어."
                    }
                  ],
                  "importantTerms": [
                    {
                      "term": "멀티셋 (Multiset)",
                      "definition": "중복된 값을 허용하는 집합."
                    },
                    {
                      "term": "튜플 (Tuple)",
                      "definition": "릴레이션(테이블)의 한 행을 의미한다."
                    },
                    {
                      "term": "외래 키 (Foreign Key)",
                      "definition": "한 릴레이션의 속성이 다른 릴레이션의 기본 키를 참조하여 두 릴레이션 간의 관계를 설정하는 제약 조건."
                    },
                    {
                      "term": "스칼라 서브쿼리 (Scalar Subquery)",
                      "definition": "단일 행, 단일 컬럼의 값을 반환하는 서브쿼리."
                    },
                    {
                      "term": "TRUNCATE",
                      "definition": "테이블의 모든 행을 빠르게 제거하는 DDL 명령어. DELETE와 달리 외래 키 제약 조건이 있는 테이블에는 직접 적용할 수 없다."
                    }
                  ],
                  "outline": [
                    {
                      "text": "집계 함수 (Aggregate Functions)",
                      "id": "집계-함수-aggregate-functions",
                      "children": [
                        {
                          "text": "집계 함수 예시",
                          "id": "집계-함수-예시",
                          "children": null
                        },
                        {
                          "text": "GROUP BY 절",
                          "id": "group-by-절",
                          "children": [
                            {
                              "text": "GROUP BY 규칙",
                              "id": "group-by-규칙",
                              "children": null
                            }
                          ]
                        },
                        {
                          "text": "HAVING 절",
                          "id": "having-절",
                          "children": [
                            {
                              "text": "HAVING과 WHERE의 차이",
                              "id": "having과-where의-차이",
                              "children": null
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "text": "SQL DML 명령어",
                      "id": "sql-dml-명령어",
                      "children": [
                        {
                          "text": "INSERT (데이터 삽입)",
                          "id": "insert-데이터-삽입",
                          "children": [
                            {
                              "text": "기본 문법",
                              "id": "기본-문법",
                              "children": null
                            },
                            {
                              "text": "INSERT 예시",
                              "id": "insert-예시",
                              "children": null
                            },
                            {
                              "text": "외래 키 제약 조건과 INSERT",
                              "id": "외래-키-제약-조건과-insert",
                              "children": null
                            },
                            {
                              "text": "다른 SELECT 쿼리 결과 삽입",
                              "id": "다른-select-쿼리-결과-삽입",
                              "children": null
                            }
                          ]
                        },
                        {
                          "text": "UPDATE (데이터 수정)",
                          "id": "update-데이터-수정",
                          "children": [
                            {
                              "text": "기본 문법",
                              "id": "기본-문법-1",
                              "children": null
                            },
                            {
                              "text": "UPDATE 예시",
                              "id": "update-예시",
                              "children": null
                            },
                            {
                              "text": "CASE 문을 이용한 조건부 UPDATE",
                              "id": "case-문을-이용한-조건부-update",
                              "children": null
                            },
                            {
                              "text": "스칼라 서브쿼리를 이용한 UPDATE",
                              "id": "스칼라-서브쿼리를-이용한-update",
                              "children": null
                            }
                          ]
                        },
                        {
                          "text": "DELETE (데이터 삭제)",
                          "id": "delete-데이터-삭제",
                          "children": [
                            {
                              "text": "기본 문법",
                              "id": "기본-문법-2",
                              "children": null
                            },
                            {
                              "text": "TRUNCATE와의 비교",
                              "id": "truncate와의-비교",
                              "children": null
                            },
                            {
                              "text": "DELETE 예시",
                              "id": "delete-예시",
                              "children": null
                            },
                            {
                              "text": "서브쿼리를 이용한 DELETE 시 주의사항",
                              "id": "서브쿼리를-이용한-delete-시-주의사항",
                              "children": null
                            }
                          ]
                        }
                      ]
                    }
                  ]
                },
                "quiz": [
                  {
                    "question": "다음 중 SQL의 `HAVING` 절에 대한 설명으로 올바른 것은 무엇입니까?",
                    "options": [
                      "그룹을 형성하기 전에 개별 행에 조건을 적용합니다.",
                      "집계 함수가 적용된 그룹에 조건을 적용합니다.",
                      "테이블에서 데이터를 삭제할 때 사용됩니다.",
                      "새로운 행을 테이블에 삽입할 때 사용됩니다."
                    ],
                    "answerIndex": 1,
                    "explanation": "`HAVING` 절은 `GROUP BY` 절에 의해 생성된 그룹에 조건을 적용하여 필터링하는 데 사용됩니다. `WHERE` 절과 달리 그룹화가 완료된 후에 적용됩니다."
                  },
                  {
                    "question": "SQL `INSERT` 문을 사용하여 새 행을 삽입할 때, 외래 키(Foreign Key) 제약 조건과 관련하여 반드시 지켜야 할 사항은 무엇입니까?",
                    "options": [
                      "외래 키 값은 항상 NULL로 설정되어야 합니다.",
                      "새로운 행의 외래 키 값이 참조하는 릴레이션에 이미 존재해야 합니다.",
                      "외래 키 값은 삽입 후 자동으로 생성됩니다.",
                      "외래 키 제약 조건은 `INSERT` 작업에 영향을 미치지 않습니다."
                    ],
                    "answerIndex": 1,
                    "explanation": "외래 키는 다른 릴레이션의 기본 키를 참조하므로, 새로운 행을 삽입할 때 해당 외래 키 값이 참조하는 릴레이션에 이미 존재해야 참조 무결성이 유지됩니다."
                  },
                  {
                    "question": "다음 SQL `UPDATE` 문 중, 급여가 $100,000 이하인 강사의 급여는 5% 인상하고, $100,000 초과인 강사의 급여는 3% 인상하는 올바른 방법은 무엇입니까?",
                    "options": [
                      "UPDATE instructor SET salary = salary * 1.05 WHERE salary <= 100000; UPDATE instructor SET salary = salary * 1.03 WHERE salary > 100000;",
                      "UPDATE instructor SET salary = CASE WHEN salary <= 100000 THEN salary * 1.05 ELSE salary * 1.03 END;",
                      "UPDATE instructor SET salary = salary * 1.03 OR salary * 1.05;",
                      "UPDATE instructor WHERE salary <= 100000 SET salary = salary * 1.05; ELSE SET salary = salary * 1.03;"
                    ],
                    "answerIndex": 1,
                    "explanation": "`CASE` 문은 여러 조건에 따라 다른 값을 적용할 때 사용되는 효율적인 방법입니다. 제시된 `CASE` 문은 주어진 조건에 따라 급여 인상률을 정확하게 적용합니다. 두 개의 `UPDATE` 문을 사용하는 첫 번째 옵션도 가능하지만, 순서에 따라 결과가 달라질 수 있고 `CASE` 문이 더 간결하고 안전한 방법입니다."
                  }
                ]
              }
            ],
            "final_result": ""
          }
        },
        {
          "node": "finish_processing",
          "status": "completed",
          "state_snapshot": {
            "run_id": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d",
            "pdf_file_paths": [
              "temp_pdf_uploads/cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_1a4c2f45-b482-4e82-826e-fa8945eb99c7_DB03 - mysql.pdf",
              "temp_pdf_uploads/cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf"
            ],
            "all_pdf_texts": [
              {
                "filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_1a4c2f45-b482-4e82-826e-fa8945eb99c7_DB03 - mysql.pdf",
                "text": "ECE30030/ITP30010 Database SystemsHandshaking with an R-DBMSCharmgil Hongcharmgil@handong.eduSpring, 2025Handong Global University\n1\n\nAgenda•Introduction to MySQL•SQL preview\nECE30030/ITP30010 Database Systems2\nMySQL•MySQL is an SQL-based relational database management system (DBMS)•Free and open-source R-DBMS (under GPL)•Owned by Oracle•Commercial version of MySQL is also provided (including technical support)•“My” came from the name of co-founder Michael Widenius’ daughter•C.f., MariaDB•Compatible with standard SQL•Frequently used for commercial web services\nECE30030/ITP30010 Database Systems3\n* Image src: https://en.wikipedia.org/wiki/MySQL\nMySQL•Companies using MySQL (a study by Enlyft)•“We have data on 199,498 (out of 1,409,176) companies that use MySQL”•Often used by companies with 10-50 employees and 1M-10M dollars in revenue•C.f., Oracle 12 is most often used by companies with 50-200 employees and >1000M dollars in revenue\nECE30030/ITP30010 Database Systems4* Source: https://enlyft.com/tech/products/mysql \n\nMySQL•Companies using MySQL (full list: https://www.mysql.com/customers/)\nECE30030/ITP30010 Database Systems5\n* Source: https://stackshare.io/mysql \nMySQL•Why MySQL?•Popular•Active discussions all over the Internet•Versatile: runs on Linux, Windows, Mac OS X, Solaris, FreeBSD, …•Supports wide range of programming languages (C/C++, Java, Python, .Net, …)•Cost starts from zero•High performance (fast and reliable)\nECE30030/ITP30010 Database Systems6* Image src: https://db-engines.com/en/ranking\n\nDBMS Trend Popularity\n•Score definition: https://db-engines.com/en/ranking_definition\nECE30030/ITP30010 Database Systems7* Image src: https://db-engines.com/en/ranking_trend \n\nMySQL•Why MySQL?•Popular•Active discussions all over the Internet•Versatile: runs on Linux, Windows, Mac OS X, Solaris, FreeBSD, …•Supports wide range of programming languages (C/C++, Java, Python, .Net, …)•Cost starts from zero•High performance (fast and reliable)\nECE30030/ITP30010 Database Systems8* Image src: https://dev.mysql.com/downloads/\n\nMySQL\nECE30030/ITP30010 Database Systems9\n•Massive•Convenient•Multi-user•Safe•Efficient•Reliable\nCan handle terabytes of dataSupports high-level query languageSupports concurrent data accessSupports transactionsCan handle thousands of queries/second99.99% up-time in many real-world products\nMySQL Versions•MySQL 5.x vs 8.x\nECE30030/ITP30010 Database Systems10\nVersion 5.x-Most popular version of MySQL-More stable and conventionalVersion 8.x-Current version-Provides up-to-date DB functionalities (better storage engine, faster, more secure)\n* Source: https://www.eversql.com/mysql-8-adoption-usage-rate/#:~:text=MySQL%205.7%20is%20still%20the,17%25%20are%20using%20MySQL%208. \nMySQL Versions•MySQL 5.x vs 8.x\nECE30030/ITP30010 Database Systems11\nVersion 5.x-Most popular version of MySQL-More stable and conventionalVersion 8.x-Current version-Provides up-to-date DB functionalities (better storage engine, faster, more secure)\n* Source: https://severalnines.com/database-blog/mysql-performance-benchmarking-mysql-57-vs-mysql-80 \n\nMySQL Versions•MySQL 5.x vs 8.x\nECE30030/ITP30010 Database Systems12\nVersion 5.x-Most popular version of MySQL-More stable and conventionalVersion 8.x-Current version-Provides up-to-date DB functionalities (better storage engine, faster, more secure)\n* Source: https://severalnines.com/database-blog/mysql-performance-benchmarking-mysql-57-vs-mysql-80 \n\nWhere to Get MySQL?•https://dev.mysql.com/downloads/•Look for the “Community” versions – the branch that is available for free•”Enterprise” versions are the commercial ones•We have prepared a Docker image for the course•Consists of Ubuntu Server, MySQL, example databases for course activities\nECE30030/ITP30010 Database Systems13* Image src: https://www.docker.com \n\nWhere to Get MySQL?\nECE30030/ITP30010 Database Systems14\n* Image source: https://baumannalexj.medium.com/connect-your-db-tool-to-a-dockerized-mysql-server-container-bc18853524ed   https://www.jetbrains.com/datagrip/features/look_and_feel.html\n\nAgenda•Introduction to MySQL•SQL preview\nECE30030/ITP30010 Database Systems15\nStructured Query Language (SQL)•SQL: Structured Query Language•The principal language used to describe and manipulate relational databases•Very high-level•Say “what to do” rather than “how to do it”•SQL is not specifying data-manipulation details•DBMSs figure out the “best” way to execute queries•Called “query optimization”•Two aspects to SQL•Data definition: for declaring database schemas (DDL)•Data manipulation: for querying (asking questions about) databases and for modifying the database (DML)\nECE30030/ITP30010 Database Systems16\nSQL Parts•DML – provides the ability to query information from the database and to insert tuples into, delete tuples from, and modify tuples in the database•Integrity – the DDL includes commands for specifying integrity constraints•Vide definition – the DDL includes commands for defining views•Transaction control – includes commands for specifying the beginning and ending of transactions•Embedded SQL and dynamic SQL – define how SQL statements can be embedded within general-purpose programming language•Authorization – includes commands for specifying access rights to relations and viewsECE30030/ITP30010 Database Systems17\nA Brief History•IBM SEQUEL (Structured English Query Language) was developed as a part of the System R project (Chamberlin and Boyce, early 1970s)•Later on, SEQUEL was renamed SQL (structured query language)•System R à System/38 (1979), SQL/DS (1981), DB2 (1983)•Relational Software, Inc released the first commercial implementation of SQL, Oracle V2 for VAX computers•Relational Software, Inc is now Oracle Corporation•ANSI and ISO standardized SQL:•SQL-86,  SQL-89,  SQL-92,  SQL:1999,  …,  SQL:2011,  SQL:2016 (current)•SQL-92 is supported by the most of database systems\nECE30030/ITP30010 Database Systems18\nBasic Query Structure•A typical SQL query has the form:   SELECT A1, A2, ..., An FROM r1, r2, ..., rm WHERE P•Ai represents an attribute•Ri represents a relation•P is a predicate\n•The result of an SQL query is a relation\nECE30030/ITP30010 Database Systems19\nEOF•Coming next:•Structured Query Language\nECE30030/ITP30010 Database Systems20"
              },
              {
                "filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf",
                "text": "ECE30030/ITP30010 Database SystemsStructured Query LanguageReading: Chapter 3\nCharmgil Hongcharmgil@handong.eduSpring, 2025Handong Global University\n1\n\nAgenda•Structured query language (SQL)•SQL data manipulation language (DML)•SELECT, FROM, WHERE•NULL values•Set operations•String operations, ordering•Aggregate functions, aggregation•SQL data definition language (DDL)   --   NEXT CLASS\nECE30030/ITP30010 Database Systems2\nStructured Query Language (SQL)•SQL: Structured Query Language•The principal language used to describe and manipulate relational databases•Very high-level•Say “what to do” rather than “how to do it”•SQL is not specifying data-manipulation details•DBMSs figure out the “best” way to execute queries•Called “query optimization”•Two aspects to SQL•Data definition: for declaring database schemas (DDL)•Data manipulation: for querying (asking questions about) databases and for modifying the database (DML)\nECE30030/ITP30010 Database Systems3\nSQL Parts•DML – provides the ability to query information from the database and to insert tuples into, delete tuples from, and modify tuples in the database•Integrity – the DDL includes commands for specifying integrity constraints•View definition – the DDL includes commands for defining views•Transaction control – includes commands for specifying the beginning and ending of transactions•Embedded SQL and dynamic SQL – define how SQL statements can be embedded within general-purpose programming language•Authorization – includes commands for specifying access rights to relations and viewsECE30030/ITP30010 Database Systems4\nA Brief History•IBM SEQUEL (Structured English Query Language) was developed as a part of the System R project (Chamberlin and Boyce, early 1970s)•Later on, SEQUEL was renamed SQL (structured query language)•System R à System/38 (1979), SQL/DS (1981), DB2 (1983)•Relational Software, Inc released the first commercial implementation of SQL, Oracle V2 for VAX computers•Relational Software, Inc is now Oracle Corporation•ANSI and ISO standardized SQL:•SQL-86,  SQL-89,  SQL-92,  SQL:1999,  …,  SQL:2011,  SQL:2016 (current)•SQL-92 is supported by the most of database systems\nECE30030/ITP30010 Database Systems5\nBasic Query Structure•A typical SQL query has the form:   SELECT A1, A2, ..., An FROM r1, r2, ..., rm WHERE P•Ai represents an attribute•Ri represents a relation•P is a predicate\n•The result of an SQL query is a relation\nECE30030/ITP30010 Database Systems6\nAgenda•Structured query language (SQL)•SQL data manipulation language (DML)•SELECT, FROM, WHERE•NULL values•Set operations•String operations, ordering•Aggregate functions, aggregation•SQL data definition language (DDL)\nECE30030/ITP30010 Database Systems7\nSQL Data Manipulation Language•The SQL data-manipulation language (DML) allows querying (ask questions about) and modifying the databases\nECE30030/ITP30010 Database Systems8\nRunning Examples•Relations (tables): instructor, teaches\nECE30030/ITP30010 Database Systems9\nInstructor relationteaches relation\nBasic Query Structure•A typical SQL query has the form:   SELECT A1, A2, ..., An FROM r1, r2, ..., rm WHERE P•Ai represents an attribute•Ri represents a relation•P is a predicate\n•The result of an SQL query is a relation\nECE30030/ITP30010 Database Systems10\nThe SELECT Clause•The SELECT clause lists the attributes desired in the result of a query•Corresponds to the projection operation of the relational algebra\n•Example: Find the names of all instructors•SQL: SELECT name FROM instructor;\nECE30030/ITP30010 Database Systems11\n\nNote•Note: SQL names are case insensitive•E.g., Name ≡ NAME ≡ name•SQL commands (SELECT, FROM, WHERE, …) are written in upper case (just a convention)•MySQL has an option flag, lower_case_table_names•Link: https://dev.mysql.com/doc/refman/8.0/en/identifier-case-sensitivity.html \nECE30030/ITP30010 Database Systems12\nThe SELECT Clause•SQL allows duplicates in relations as well as in query results•The keyword ALL specifies that duplicates should not be removed SELECT ALL dept_name FROM instructor\nECE30030/ITP30010 Database Systems13\n\nThe SELECT Clause•SQL allows duplicates in relations as well as in query results•The keyword ALL specifies that duplicates should not be removed SELECT ALL dept_name FROM instructor•To force the elimination of duplicates, insert the keyword DISTINCT after SELECT•Find the department names of all instructor, removing duplicates: SELECT DISTINCT dept_name FROM instructor;\nECE30030/ITP30010 Database Systems14\n\nThe SELECT Clause•An asterisk in the select clause denotes “all attributes” SELECT * FROM instructor;•An attribute can be a literal with no FROM clause SELECT ‘437’;•Result is a table with one column and a single row with value “437”•Can give the column a name using AS: SELECT ‘437’ AS FOO\nECE30030/ITP30010 Database Systems15\n\nThe SELECT Clause•An attribute can be a literal with FROM clause SELECT 'A' FROM instructor•Result is a table with one column and N rows (number of tuples in the instructor table), each row with value “A”\nECE30030/ITP30010 Database Systems16\n\nThe SELECT Clause•The SELECT clause can contain arithmetic expressions involving the operation, +, –, *, and /, and operating on constants or attributes of tuples•The query:     SELECT ID, name, salary/12      FROM instructorwould return a relation that is the same as the instructor relation,except that the value of the attribute salary is divided by 12\n17\n\nThe SELECT Clause•The SELECT clause can contain arithmetic expressions involving the operation, +, –, *, and /, and operating on constants or attributes of tuples•Can rename “salary/12” using the AS clause:  SELECT ID, name, salary/12 AS monthly_salary   FROM instructor\n18\n\nThe WHERE Clause•The WHERE clause specifies conditions that the result must satisfy•Corresponds to the selection predicate of the relational algebra•E.g., To find all instructors in Comp. Sci. dept: SELECT name FROM instructor  WHERE dept_name = 'Comp. Sci.';\nECE30030/ITP30010 Database Systems19\n\nThe WHERE Clause•SQL allows the use of the logical connectives AND, OR, and NOT•The operands of the logical connectives can be expressions involving the comparison operators <, <=, >, >=, =, and <>•<> means not equal (there is no != in SQL)•Comparisons can be applied to results of arithmetic expressions•E.g., To find all instructors in Comp. Sci. with salary > 70,000: SELECT name FROM instructor WHERE dept_name = 'Comp. Sci.' AND salary > 70000;\nECE30030/ITP30010 Database Systems20\n\nThe WHERE Clause•SQL includes a BETWEEN comparison operator•Example: Find the names of all instructors with salary between $90,000 and $100,000 (that is, ³ $90,000 and £ $100,000)•SELECT nameFROM instructorWHERE salary BETWEEN 90000 AND 100000\nECE30030/ITP30010 Database Systems21\n\nThe WHERE Clause•Tuple comparison: makes comparisons per tuple•SELECT name, course_idFROM instructor, teachesWHERE (instructor.ID, dept_name) = (teaches.ID, 'Biology');\nECE30030/ITP30010 Database Systems22\n\nThe FROM Clause•The FROM clause lists the relations involved in the query•Corresponds to the Cartesian-product operation of the relational algebra•Find the Cartesian-product instructor × teaches SELECT * FROM instructor, teaches;•Generates every possible instructor-teaches pairs, with all attributes from both relations•For common attributes (e.g., ID), the attributes in the resulting table are renamed using the relation name (e.g., instructor.ID)\nECE30030/ITP30010 Database Systems23\nThe FROM Clause•Find the Cartesian-product instructor X teaches SELECT * FROM instructor, teaches;\n24\ninstructor.IDnamedept_namesalaryteaches.IDcourse_idsec_idsemesteryear10101SrinivasanComp. Sci.6500076766BIO-101 1Summer201712121WuFinance9000076766BIO-101 1Summer201715151MozartMusic4000076766BIO-101 1Summer201722222EinsteinPhysics9500076766BIO-101 1Summer201732343El SaidHistory6000076766BIO-101 1Summer2017… … … … … … … … …10101SrinivasanComp. Sci.6500010101CS-101 1Fall 201712121WuFinance9000010101CS-101 1Fall 201715151MozartMusic4000010101CS-101 1Fall 201722222EinsteinPhysics9500010101CS-101 1Fall 201732343El SaidHistory6000010101CS-101 1Fall 2017… … … … … … … … …… … … … … … … … …10101SrinivasanComp. Sci.6500083821CS-190 2Spring201712121WuFinance9000083821CS-190 2Spring201715151MozartMusic4000083821CS-190 2Spring2017… … … … … … … … …10101SrinivasanComp. Sci.6500010101CS-315 1Spring201812121WuFinance9000010101CS-315 1Spring201815151MozartMusic4000010101CS-315 1Spring2018… … … … … … … … …… … … … … … … … …\nImplementing JOIN•Cartesian-product is not very useful directly; but useful combined with WHERE-clause condition (selection operation in relational algebra)•Cartesian-product + selection = join•E.g., Find the names of all instructors who have taught some course and the course_id SELECT name, course_id FROM instructor , teaches WHERE instructor.ID = teaches.ID\nECE30030/ITP30010 Database Systems25\n\nImplementing JOIN•Cartesian-product is not very useful directly; but useful combined with WHERE-clause condition (selection operation in relational algebra)•Cartesian-product + selection = join•Find the names of all instructors in the Music department who have taught some course and the course_id SELECT name, course_id FROM instructor , teaches WHERE instructor.ID = teaches.ID  AND instructor. dept_name = 'Music'\nECE30030/ITP30010 Database Systems26\n\nThe Rename Operation•The SQL allows renaming relations and attributes using the AS clause:   old-name AS new-name•Find the names of all instructors who have a higher salary than some instructor in ‘Comp. Sci.’•SELECT DISTINCT T.nameFROM instructor AS T, instructor AS SWHERE T.salary > S.salary AND S.dept_name = 'Comp. Sci.'\nECE30030/ITP30010 Database Systems27\n\nThe Rename Operation•The SQL allows renaming relations and attributes using the AS clause:   old-name AS new-name•Find the names of all instructors who have a higher salary than some instructor in ‘Comp. Sci.’•SELECT DISTINCT T.nameFROM instructor AS T, instructor AS SWHERE T.salary > S.salary AND S.dept_name = 'Comp. Sci.'•Keyword AS is optional and may be omitted  instructor AS T  ≡  instructor T\nECE30030/ITP30010 Database Systems28\nAgenda•Structured query language (SQL)•SQL data manipulation language (DML)•SELECT, FROM, WHERE•NULL values•Set operations•String operations, ordering•Aggregate functions, aggregation•SQL data definition language (DDL)\nECE30030/ITP30010 Database Systems29\nNULL Values•It is possible for tuples to have a NULL value for some of their attributes•NULL signifies an unknown value or that a value does not exist•The result of any arithmetic expression involving NULL is NULL•E.g.,  5 + NULL returns NULL\nECE30030/ITP30010 Database Systems30\nIS NULL / IS NOT NULL•The predicate IS NULL can be used to check for NULL values•E.g., Find all instructors whose salary is null SELECT name FROM instructor WHERE salary IS NULL•The predicate IS NOT NULL succeeds if the value on which it is applied is not null\nECE30030/ITP30010 Database Systems31\nAgenda•Structured query language (SQL)•SQL data manipulation language (DML)•SELECT, FROM, WHERE•NULL values•Set operations•String operations, ordering•Aggregate functions, aggregation•SQL data definition language (DDL)\nECE30030/ITP30010 Database Systems32\nSet Operations•Set operations UNION, INTERSECT, and EXCEPT•Each of the above operations automatically eliminates duplicates•To retain all duplicates, use ALL:•UNION ALL•INTERSECT ALL•EXCEPT ALL\n•C.f., SELECT retains all duplicates by default\nECE30030/ITP30010 Database Systems33\nSet Operations: UNION•Find courses that ran in Fall 2017 or in Spring 2018•(SELECT course_id  FROM teaches WHERE semester = 'Fall' AND year = 2017)UNION(SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018)\nECE30030/ITP30010 Database Systems34\n\nSet Operations: INTERSECT•Find courses that ran in Fall 2017 and in Spring 2018•(SELECT course_id  FROM teaches WHERE semester = 'Fall' AND year = 2017)INTERSECT(SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018)•C.f., MySQL does NOT support INTERSECT•One can emulate INTERSECT using JOIN (we’ll study JOIN later)•SELECT LT.course_idFROM (SELECT course_id FROM teaches WHERE semester = 'Fall' AND year = 2017) AS LTJOIN (SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018) AS RTON LT.course_id=RT.course_id;\nECE30030/ITP30010 Database Systems35\n\nSet Operations: EXCEPT•Find courses that ran in Fall 2017 but not in Spring 2018•(SELECT course_id  FROM teaches WHERE semester = 'Fall' AND year = 2017)EXCEPT(SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018)•C.f., MySQL does NOT support EXCEPT•One can emulate EXCEPT using NOT IN•SELECT course_id FROM teaches WHERE semester = 'Fall' AND year = 2017AND course_id NOT IN(SELECT course_id  FROM teaches  WHERE semester = 'Spring' AND year = 2018);\nECE30030/ITP30010 Database Systems36\n\nAgenda•Structured query language (SQL)•SQL data manipulation language (DML)•SELECT, FROM, WHERE•NULL values•Set operations•String operations, ordering•Aggregate functions, aggregation•SQL data definition language (DDL)\nECE30030/ITP30010 Database Systems37\nString Operations•SQL includes a string-matching operator for comparisons on character strings•The operator LIKE uses patterns that are described using two special characters:•percent (%) – The % character matches any substring•underscore (_) – The _ character matches any character•Find the names of all instructors whose name includes the substring “ri” SELECT name FROM instructor WHERE name LIKE ‘%ri%'\nECE30030/ITP30010 Database Systems38\n\nString Operations•Escape character: Use backslash (\\) as the escape character•E.g., Match the string “100%” LIKE '100 \\%’ ESCAPE  ‘\\’\nECE30030/ITP30010 Database Systems39\nString Operations•Patterns are case sensitive•Pattern matching examples:•'Intro%' matches any string beginning with “Intro”•'%Comp%' matches any string containing “Comp” as a substring•'_ _ _' matches any string of exactly three characters•'_ _ _ %' matches any string of at least three characters•SQL supports a variety of string operations such as•concatenation (using “||”)•converting from upper to lower case (and vice versa)•finding string length, extracting substrings, etc.\nECE30030/ITP30010 Database Systems40\nOrdering the Display of Tuples•List in alphabetic order the names of all instructors•SELECT DISTINCT nameFROM instructorORDER BY name\nECE30030/ITP30010 Database Systems41\n\nOrdering the Display of Tuples•Can sort on multiple attributes•E.g., SELECT dept_name, name     FROM instructor      ORDER BY dept_name, name\nECE30030/ITP30010 Database Systems42\n\nOrdering the Display of Tuples•We may specify DESC for descending order or ASC for ascending order, for each attribute; ascending order is the default•E.g., ORDER BY name DESC\nECE30030/ITP30010 Database Systems43\n\nAgenda•Structured query language (SQL)•SQL data manipulation language (DML)•SELECT, FROM, WHERE•NULL values•Set operations•String operations, ordering•Aggregate functions, aggregation•SQL data definition language (DDL)\nECE30030/ITP30010 Database Systems44\nAggregate Functions•These functions operate on the multiset of values of a column of a relation, and return a value•AVG:  average value•MIN:  minimum value•MAX:  maximum value•SUM:  sum of values•COUNT:  number of values\nECE30030/ITP30010 Database Systems45\nAggregate Functions Examples•Find the average salary of instructors in the Computer Science department•SELECT AVG(salary)FROM instructorWHERE dept_name= 'Comp. Sci.';•Find the total number of instructors who teach a course in the Spring 2018 semester•SELECT COUNT(DISTINCT ID)FROM teachesWHERE semester = 'Spring’ AND year = 2018;•Find the number of tuples in the teaches relation•SELECT COUNT (*)FROM teaches;\nECE30030/ITP30010 Database Systems46\n\nAggregate Functions: Group By•Find the average salary of instructors in each department•SELECT dept_name, AVG(salary) AS avg_salaryFROM instructorGROUP BY dept_name;\nECE30030/ITP30010 Database Systems47\n\nAggregation•Attributes in SELECT clause outside of aggregate functions must appear in GROUP BY list•/* erroneous query */SELECT dept_name, ID, AVG(salary)FROM instructorGROUP BY dept_name;\nECE30030/ITP30010 Database Systems48\n\nAggregate Functions – Having Clause•Find the names and average salaries of all departments whose average salary is greater than 65000•SELECT dept_name, AVG(salary) AS avg_salaryFROM instructorGROUP BY dept_nameHAVING AVG(salary) > 65000;\nECE30030/ITP30010 Database Systems49\n\nAggregate Functions – Having Clause•Note: predicates in the HAVING clause are applied after the formation of groups whereas predicates in the WHERE clause are applied before forming groups\nECE30030/ITP30010 Database Systems50\nSELECT dept_name, AVG(salary) AS avg_salaryFROM instructorGROUP BY dept_nameHAVING AVG(salary) > 65000;\nSELECT dept_name, AVG(salary) AS avg_salaryFROM instructorWHERE salary > 65000GROUP BY dept_name;\n\nSQL Commands\nSQLDMLSELECTINSERTUPDATEDELETE\nDDLCREATEALTERDROP\nECE30030/ITP30010 Database Systems51\nINSERT•Basic syntax•Insert data into every column:•INSERT INTO tablenameVALUES (col1_value, col2_value, …)•Must list values in the same order as in the table schema•If some data values are unknown, must type NULL •For character sequences, use quotation marks•Single quotation marks are preferred (but double quotation marks are allowed)•Value in quotations is case-sensitive•Insert data into selected columns•INSERT INTO tablename (col1_name, col3_name, col4_name, …)VALUES (col1_value, col3_value, col4_value, …)\nECE30030/ITP30010 Database Systems52\nINSERT•Add a new tuple to course•INSERT INTO courseVALUES ('CS-437', 'Database Systems', 'Comp. Sci.', 4);•or equivalently•INSERT INTO course (course_id, title, dept_name, credits)VALUES ('CS-437', 'Database Systems', 'Comp. Sci.', 4);•Add a new tuple to student  with tot_creds set to null•INSERT INTO studentVALUES ('3003', 'Green', 'Finance', null);\nECE30030/ITP30010 Database Systems53\nINSERT•A foreign key specifies that an attribute from one relation has to map to a tuple in another relation•Value in one relation must appear in another relation\nECE30030/ITP30010 Database Systems54\nRelation: instructor\nRelation: department\nINSERT•A foreign key specifies that an attribute from one relation has to map to a tuple in another relation•Value in one relation must appear in another relation•Make sure all foreign keys that new row references have already been added to database•One cannot insert a foreign key value unless the corresponding value exists in the referenced relation\nECE30030/ITP30010 Database Systems55\nINSERT•Inserting results of other SELECT query•Make each student in the Music department who has earned more than 144 credit hours an instructor in the Music department with a salary of  $18,000•INSERT INTO instructor  SELECT ID, name, dept_name, 18000  FROM student   WHERE dept_name = 'Music’ AND total_cred > 144;•The SELECT FROM WHERE statement is evaluated fully before any of its results are inserted into the relation•Otherwise queries like  INSERT INTO table1 SELECT * FROM table1would cause problem\nECE30030/ITP30010 Database Systems56\nUPDATE•Basic syntax•Updating a table•UPDATE tablenameSET col1_name = new_col1_value, col2_name = new_col2_value, …;•Updating a table with conditions•UPDATE tablenameSET col1_name = new_col1_value, col2_name = new_col2_value, …WHERE predicate;\nECE30030/ITP30010 Database Systems57\nUPDATE•Give a 5% salary raise to all instructors•UPDATE instructorSET salary = salary * 1.05•Give a 5% salary raise to those instructors who earn less than 70000•UPDATE instructorSET salary = salary * 1.05WHERE salary < 70000;•Give a 5% salary raise to instructors whose salary is less than average•UPDATE instructorSET salary = salary * 1.05WHERE salary <  (SELECT AVG(salary) FROM instructor);\nECE30030/ITP30010 Database Systems58\nUPDATE•Increase salaries of instructors whose salary is over $100,000 by 3%, and all others by a 5%•Write two UPDATE statements:  UPDATE instructor  SET salary = salary * 1.03  WHERE salary > 100000;  UPDATE instructor  SET salary = salary * 1.05  WHERE salary <= 100000;•The order is important•Can be done better using the case statement (next slide)\nECE30030/ITP30010 Database Systems59\nCASE Statement for Conditional Update•The following query is equivalent to the previous UPDATE queries•UPDATE instructorSET salary = CASE                           WHEN salary <= 100000 THEN salary * 1.05                           ELSE salary * 1.03                       END\nECE30030/ITP30010 Database Systems60\nUPDATE with Scalar Subqueries•Recompute and update tot_creds value for all students•UPDATE student SSET tot_cred = (SELECT SUM(credits)                             FROM takes, course                             WHERE takes.course_id = course.course_id  AND                                            S.ID= takes.ID  AND                                            takes.grade <> 'F' AND                                            takes.grade IS NOT NULL);\nECE30030/ITP30010 Database Systems61\nDELETE•Basic syntax•To remove specific rows•DELETE FROM tablenameWHERE predicate;•To remove all rows•DELETE FROM tablename;•This is equivalent to TRUNCATE:TRUNCATE (TABLE) tablename;•One cannot truncate a table with foreign key constraints•Must disable the constraints first (we will cover ALTER when we study SQL DDL):ALTER TABLE tablenameDISABLE CONSTRAINT constraint_name;\nECE30030/ITP30010 Database Systems62\nDELETE•Delete all instructors•DELETE FROM instructor;•Delete all instructors from the Finance department•DELETE FROM instructorWHERE dept_name= 'Finance';•Delete all tuples in the instructor relation for those instructors associated with a department located in the Watson building•DELETE FROM instructorWHERE dept name IN (SELECT dept name        FROM department        WHERE building = 'Watson');\nECE30030/ITP30010 Database Systems63\nDELETE•Delete all instructors whose salary is less than the average salary of instructors•Example:  DELETE FROM instructor                WHERE salary < (SELECT AVG (salary)                  FROM instructor);•Issue:  as we delete tuples from instructor, the average salary changes•Solution used in SQL:1.First, compute AVG(salary) and find all tuples to delete2.Next, delete all tuples found above (without recomputing AVG or retesting the tuples)\nECE30030/ITP30010 Database Systems64\nEOF•Coming next:•More on Structured Query Language\nECE30030/ITP30010 Database Systems65"
              }
            ],
            "notebook_title": "관계형 데이터베이스 시스템: MySQL 소개 및 SQL 심층 활용",
            "holistic_chapters": [
              {
                "chapter_title": "관계형 데이터베이스 시스템(R-DBMS) 개요 및 MySQL 소개",
                "source_pdf_filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_1a4c2f45-b482-4e82-826e-fa8945eb99c7_DB03 - mysql.pdf",
                "chapter_content_summary": "이 장에서는 관계형 데이터베이스 관리 시스템(R-DBMS)의 기본 개념을 소개하고, 대표적인 오픈소스 R-DBMS인 MySQL에 대해 심층적으로 다룹니다. MySQL의 정의, Oracle 소유권, 표준 SQL 호환성, 상업적 웹 서비스에서의 활용 사례, 기업 사용 통계, 그리고 MySQL의 인기 요인(다양한 운영체제 및 프로그래밍 언어 지원, 비용 효율성, 고성능)을 설명합니다. 또한, R-DBMS 시장에서의 MySQL의 트렌드와 인기도를 살펴보고, MySQL 5.x와 8.x 버전의 주요 차이점 및 MySQL 커뮤니티 버전을 다운로드하고 Docker 이미지를 활용하는 방법을 안내합니다. MySQL이 대규모 데이터 처리, 다중 사용자 지원, 효율성, 안정성, 보안성 측면에서 갖는 강점들을 강조합니다.",
                "chapter_full_text": "ECE30030/ITP30010 Database SystemsHandshaking with an R-DBMSCharmgil Hongcharmgil@handong.eduSpring, 2025Handong Global University\n1\nAgenda•Introduction to MySQL•SQL preview\nECE30030/ITP30010 Database Systems2\nMySQL•MySQL is an SQL-based relational database management system (DBMS)•Free and open-source R-DBMS (under GPL)•Owned by Oracle•Commercial version of MySQL is also provided (including technical support)•“My” came from the name of co-founder Michael Widenius’ daughter•C.f., MariaDB•Compatible with standard SQL•Frequently used for commercial web services\nECE30030/ITP30010 Database Systems3\n* Image src: https://en.wikipedia.org/wiki/MySQL\nMySQL•Companies using MySQL (a study by Enlyft)•“We have data on 199,498 (out of 1,409,176) companies that use MySQL”•Often used by companies with 10-50 employees and 1M-10M dollars in revenue•C.f., Oracle 12 is most often used by companies with 50-200 employees and >1000M dollars in revenue\nECE30030/ITP30010 Database Systems4* Source: https://enlyft.com/tech/products/mysql \nMySQL•Companies using MySQL (full list: https://www.mysql.com/customers/)\nECE30030/ITP30010 Database Systems5\n* Source: https://stackshare.io/mysql \nMySQL•Why MySQL?•Popular•Active discussions all over the Internet•Versatile: runs on Linux, Windows, Mac OS X, Solaris, FreeBSD, …•Supports wide range of programming languages (C/C++, Java, Python, .Net, …)•Cost starts from zero•High performance (fast and reliable)\nECE30030/ITP30010 Database Systems6* Image src: https://db-engines.com/en/ranking\nDBMS Trend Popularity\n•Score definition: https://db-engines.com/en/ranking_definition\nECE30030/ITP30010 Database Systems7* Image src: https://db-engines.com/en/ranking_trend \nMySQL•Why MySQL?•Popular•Active discussions all over the Internet•Versatile: runs on Linux, Windows, Mac OS X, Solaris, FreeBSD, …•Supports wide range of programming languages (C/C++, Java, Python, .Net, …)•Cost starts from zero•High performance (fast and reliable)\nECE30030/ITP30010 Database Systems8* Image src: https://dev.mysql.com/downloads/\nMySQL\nECE30030/ITP30010 Database Systems9\n•Massive•Convenient•Multi-user•Safe•Efficient•Reliable\nCan handle terabytes of dataSupports high-level query languageSupports concurrent data accessSupports transactionsCan handle thousands of queries/second99.99% up-time in many real-world products\nMySQL Versions•MySQL 5.x vs 8.x\nECE30030/ITP30010 Database Systems10\nVersion 5.x-Most popular version of MySQL-More stable and conventionalVersion 8.x-Current version-Provides up-to-date DB functionalities (better storage engine, faster, more secure)\n* Source: https://www.eversql.com/mysql-8-adoption-usage-rate/#:~:text=MySQL%205.7%20is%20still%20the,17%25%20are%20using%20MySQL%208. \nMySQL Versions•MySQL 5.x vs 8.x\nECE30030/ITP30010 Database Systems11\nVersion 5.x-Most popular version of MySQL-More stable and conventionalVersion 8.x-Current version-Provides up-to-date DB functionalities (better storage engine, faster, more secure)\n* Source: https://severalnines.com/database-blog/mysql-performance-benchmarking-mysql-57-vs-mysql-80 \nMySQL Versions•MySQL 5.x vs 8.x\nECE30030/ITP30010 Database Systems12\nVersion 5.x-Most popular version of MySQL-More stable and conventionalVersion 8.x-Current version-Provides up-to-date DB functionalities (better storage engine, faster, more secure)\n* Source: https://severalnines.com/database-blog/mysql-performance-benchmarking-mysql-57-vs-mysql-80 \nWhere to Get MySQL?•https://dev.mysql.com/downloads/•Look for the “Community” versions – the branch that is available for free•”Enterprise” versions are the commercial ones•We have prepared a Docker image for the course•Consists of Ubuntu Server, MySQL, example databases for course activities\nECE30030/ITP30010 Database Systems13* Image src: https://www.docker.com \nWhere to Get MySQL?\nECE30030/ITP30010 Database Systems14\n* Image source: https://baumannalexj.medium.com/connect-your-db-tool-to-a-dockerized-mysql-server-container-bc18853524ed   https://www.jetbrains.com/datagrip/features/look_and_feel.html"
              },
              {
                "chapter_title": "SQL(구조적 질의어)의 이해: 기본 개념과 역사",
                "source_pdf_filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf",
                "chapter_content_summary": "SQL(Structured Query Language)의 정의와 관계형 데이터베이스를 조작하는 주된 언어로서의 역할을 설명합니다. SQL이 '무엇을 할지'를 명시하는 고수준 언어이며, DBMS가 '어떻게 할지'를 결정하는 쿼리 최적화 과정을 다룹니다. 또한, SQL의 두 가지 주요 측면인 데이터 정의 언어(DDL)와 데이터 조작 언어(DML)를 소개하고, 무결성, 뷰 정의, 트랜잭션 제어, 내장 SQL 및 동적 SQL, 권한 부여와 같은 SQL의 다양한 구성 요소를 살펴봅니다. 마지막으로, IBM SEQUEL에서 시작하여 Oracle V2를 거쳐 ANSI 및 ISO 표준으로 발전한 SQL의 간략한 역사를 소개하고, 기본적인 SQL 쿼리 구조(SELECT, FROM, WHERE)를 설명합니다.",
                "chapter_full_text": "ECE30030/ITP30010 Database SystemsStructured Query LanguageReading: Chapter 3\nCharmgil Hongcharmgil@handong.eduSpring, 2025Handong Global University\n1\nAgenda•Structured query language (SQL)•SQL data manipulation language (DML)•SELECT, FROM, WHERE•NULL values•Set operations•String operations, ordering•Aggregate functions, aggregation•SQL data definition language (DDL)   --   NEXT CLASS\nECE30030/ITP30010 Database Systems2\nStructured Query Language (SQL)•SQL: Structured Query Language•The principal language used to describe and manipulate relational databases•Very high-level•Say “what to do” rather than “how to do it”•SQL is not specifying data-manipulation details•DBMSs figure out the “best” way to execute queries•Called “query optimization”•Two aspects to SQL•Data definition: for declaring database schemas (DDL)•Data manipulation: for querying (asking questions about) databases and for modifying the database (DML)\nECE30030/ITP30010 Database Systems3\nSQL Parts•DML – provides the ability to query information from the database and to insert tuples into, delete tuples from, and modify tuples in the database•Integrity – the DDL includes commands for specifying integrity constraints•View definition – the DDL includes commands for defining views•Transaction control – includes commands for specifying the beginning and ending of transactions•Embedded SQL and dynamic SQL – define how SQL statements can be embedded within general-purpose programming language•Authorization – includes commands for specifying access rights to relations and viewsECE30030/ITP30010 Database Systems4\nA Brief History•IBM SEQUEL (Structured English Query Language) was developed as a part of the System R project (Chamberlin and Boyce, early 1970s)•Later on, SEQUEL was renamed SQL (structured query language)•System R à System/38 (1979), SQL/DS (1981), DB2 (1983)•Relational Software, Inc released the first commercial implementation of SQL, Oracle V2 for VAX computers•Relational Software, Inc is now Oracle Corporation•ANSI and ISO standardized SQL:•SQL-86,  SQL-89,  SQL-92,  SQL:1999,  …,  SQL:2011,  SQL:2016 (current)•SQL-92 is supported by the most of database systems\nECE30030/ITP30010 Database Systems5\nBasic Query Structure•A typical SQL query has the form:   SELECT A1, A2, ..., An FROM r1, r2, ..., rm WHERE P•Ai represents an attribute•Ri represents a relation•P is a predicate\n•The result of an SQL query is a relation\nECE30030/ITP30010 Database Systems6"
              },
              {
                "chapter_title": "SQL 데이터 조작 언어(DML) 기초: SELECT, FROM, WHERE 절",
                "source_pdf_filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf",
                "chapter_content_summary": "이 장에서는 SQL 데이터 조작 언어(DML)의 핵심 구성 요소인 SELECT, FROM, WHERE 절을 상세히 다룹니다. 'instructor' 및 'teaches'와 같은 예시 관계(테이블)를 사용하여 실제 쿼리 작성 방법을 시연합니다. SELECT 절을 통해 원하는 속성을 선택하고, 중복을 포함하거나 제거하는 방법(ALL, DISTINCT), 모든 속성을 선택하는 '*' 사용법, 리터럴 및 산술 표현식 활용, 그리고 AS 키워드를 사용한 속성 이름 변경 방법을 학습합니다. WHERE 절에서는 논리 연산자(AND, OR, NOT) 및 비교 연산자(<, <=, >, >=, =, <>, BETWEEN)를 사용하여 조건을 지정하고, 튜플 비교를 수행하는 방법을 설명합니다. 마지막으로 FROM 절을 통해 쿼리에 포함될 관계를 지정하고, 카르테시안 곱을 이해하며, WHERE 절과 결합하여 JOIN 연산을 구현하는 방법을 구체적인 예시와 함께 제시합니다. 또한, AS 키워드를 이용한 관계 및 속성 이름 변경(별칭 지정)을 다룹니다.",
                "chapter_full_text": "ECE30030/ITP30010 Database Systems7\nSQL Data Manipulation Language•The SQL data-manipulation language (DML) allows querying (ask questions about) and modifying the databases\nECE30030/ITP30010 Database Systems8\nRunning Examples•Relations (tables): instructor, teaches\nECE30030/ITP30010 Database Systems9\nInstructor relationteaches relation\nBasic Query Structure•A typical SQL query has the form:   SELECT A1, A2, ..., An FROM r1, r2, ..., rm WHERE P•Ai represents an attribute•Ri represents a relation•P is a predicate\n•The result of an SQL query is a relation\nECE30030/ITP30010 Database Systems10\nThe SELECT Clause•The SELECT clause lists the attributes desired in the result of a query•Corresponds to the projection operation of the relational algebra\n•Example: Find the names of all instructors•SQL: SELECT name FROM instructor;\nECE30030/ITP30010 Database Systems11\nNote•Note: SQL names are case insensitive•E.g., Name ≡ NAME ≡ name•SQL commands (SELECT, FROM, WHERE, …) are written in upper case (just a convention)•MySQL has an option flag, lower_case_table_names•Link: https://dev.mysql.com/doc/refman/8.0/en/identifier-case-sensitivity.html \nECE30030/ITP30010 Database Systems12\nThe SELECT Clause•SQL allows duplicates in relations as well as in query results•The keyword ALL specifies that duplicates should not be removed SELECT ALL dept_name FROM instructor\nECE30030/ITP30010 Database Systems13\nThe SELECT Clause•SQL allows duplicates in relations as well as in query results•The keyword ALL specifies that duplicates should not be removed SELECT ALL dept_name FROM instructor•To force the elimination of duplicates, insert the keyword DISTINCT after SELECT•Find the department names of all instructor, removing duplicates: SELECT DISTINCT dept_name FROM instructor;\nECE30030/ITP30010 Database Systems14\nThe SELECT Clause•An asterisk in the select clause denotes “all attributes” SELECT * FROM instructor;•An attribute can be a literal with no FROM clause SELECT ‘437’;•Result is a table with one column and a single row with value “437”•Can give the column a name using AS: SELECT ‘437’ AS FOO\nECE30030/ITP30010 Database Systems15\nThe SELECT Clause•An attribute can be a literal with FROM clause SELECT 'A' FROM instructor•Result is a table with one column and N rows (number of tuples in the instructor table), each row with value “A”\nECE30030/ITP30010 Database Systems16\nThe SELECT Clause•The SELECT clause can contain arithmetic expressions involving the operation, +, –, *, and /, and operating on constants or attributes of tuples•The query:     SELECT ID, name, salary/12      FROM instructorwould return a relation that is the same as the instructor relation,except that the value of the attribute salary is divided by 12\n17\nThe SELECT Clause•The SELECT clause can contain arithmetic expressions involving the operation, +, –, *, and /, and operating on constants or attributes of tuples•Can rename “salary/12” using the AS clause:  SELECT ID, name, salary/12 AS monthly_salary   FROM instructor\n18\nThe WHERE Clause•The WHERE clause specifies conditions that the result must satisfy•Corresponds to the selection predicate of the relational algebra•E.g., To find all instructors in Comp. Sci. dept: SELECT name FROM instructor  WHERE dept_name = 'Comp. Sci.';\nECE30030/ITP30010 Database Systems19\nThe WHERE Clause•SQL allows the use of the logical connectives AND, OR, and NOT•The operands of the logical connectives can be expressions involving the comparison operators <, <=, >, >=, =, and <>•<> means not equal (there is no != in SQL)•Comparisons can be applied to results of arithmetic expressions•E.g., To find all instructors in Comp. Sci. with salary > 70,000: SELECT name FROM instructor WHERE dept_name = 'Comp. Sci.' AND salary > 70000;\nECE30030/ITP30010 Database Systems20\nThe WHERE Clause•SQL includes a BETWEEN comparison operator•Example: Find the names of all instructors with salary between $90,000 and $100,000 (that is, ³ $90,000 and £ $100,000)•SELECT nameFROM instructorWHERE salary BETWEEN 90000 AND 100000\nECE30030/ITP30010 Database Systems21\nThe WHERE Clause•Tuple comparison: makes comparisons per tuple•SELECT name, course_idFROM instructor, teachesWHERE (instructor.ID, dept_name) = (teaches.ID, 'Biology');\nECE30030/ITP30010 Database Systems22\nThe FROM Clause•The FROM clause lists the relations involved in the query•Corresponds to the Cartesian-product operation of the relational algebra•Find the Cartesian-product instructor × teaches SELECT * FROM instructor, teaches;•Generates every possible instructor-teaches pairs, with all attributes from both relations•For common attributes (e.g., ID), the attributes in the resulting table are renamed using the relation name (e.g., instructor.ID)\nECE30030/ITP30010 Database Systems23\nThe FROM Clause•Find the Cartesian-product instructor X teaches SELECT * FROM instructor, teaches;\n24\ninstructor.IDnamedept_namesalaryteaches.IDcourse_idsec_idsemesteryear10101SrinivasanComp. Sci.6500076766BIO-101 1Summer201712121WuFinance9000076766BIO-101 1Summer201715151MozartMusic4000076766BIO-101 1Summer201722222EinsteinPhysics9500076766BIO-101 1Summer201732343El SaidHistory6000076766BIO-101 1Summer2017… … … … … … … … …10101SrinivasanComp. Sci.6500010101CS-101 1Fall 201712121WuFinance9000010101CS-101 1Fall 201715151MozartMusic4000010101CS-101 1Fall 201722222EinsteinPhysics9500010101CS-101 1Fall 201732343El SaidHistory6000010101CS-101 1Fall 2017… … … … … … … … …… … … … … … … … …10101SrinivasanComp. Sci.6500083821CS-190 2Spring201712121WuFinance9000083821CS-190 2Spring201715151MozartMusic4000083821CS-190 2Spring2017… … … … … … … … …10101SrinivasanComp. Sci.6500010101CS-315 1Spring201812121WuFinance9000010101CS-315 1Spring201815151MozartMusic4000010101CS-315 1Spring2018… … … … … … … … …… … … … … … … … …\nImplementing JOIN•Cartesian-product is not very useful directly; but useful combined with WHERE-clause condition (selection operation in relational algebra)•Cartesian-product + selection = join•E.g., Find the names of all instructors who have taught some course and the course_id SELECT name, course_id FROM instructor , teaches WHERE instructor.ID = teaches.ID\nECE30030/ITP30010 Database Systems25\nImplementing JOIN•Cartesian-product is not very useful directly; but useful combined with WHERE-clause condition (selection operation in relational algebra)•Cartesian-product + selection = join•Find the names of all instructors in the Music department who have taught some course and the course_id SELECT name, course_id FROM instructor , teaches WHERE instructor.ID = teaches.ID  AND instructor. dept_name = 'Music'\nECE30030/ITP30010 Database Systems26\nThe Rename Operation•The SQL allows renaming relations and attributes using the AS clause:   old-name AS new-name•Find the names of all instructors who have a higher salary than some instructor in ‘Comp. Sci.’•SELECT DISTINCT T.nameFROM instructor AS T, instructor AS SWHERE T.salary > S.salary AND S.dept_name = 'Comp. Sci.'\nECE30030/ITP30010 Database Systems27\nThe Rename Operation•The SQL allows renaming relations and attributes using the AS clause:   old-name AS new-name•Find the names of all instructors who have a higher salary than some instructor in ‘Comp. Sci.’•SELECT DISTINCT T.nameFROM instructor AS T, instructor AS SWHERE T.salary > S.salary AND S.dept_name = 'Comp. Sci.'•Keyword AS is optional and may be omitted  instructor AS T  ≡  instructor T\nECE30030/ITP30010 Database Systems28"
              },
              {
                "chapter_title": "SQL DML 고급 기능: NULL 값, 집합 연산, 문자열 처리 및 정렬",
                "source_pdf_filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf",
                "chapter_content_summary": "이 장에서는 SQL DML의 고급 기능을 탐구합니다. 먼저, 알려지지 않거나 존재하지 않는 값을 나타내는 NULL 값의 특성을 이해하고, 산술 연산에서의 NULL 동작 및 IS NULL / IS NOT NULL 술어를 사용하여 NULL 값을 확인하는 방법을 배웁니다. 다음으로, 여러 쿼리 결과를 결합하는 집합 연산인 UNION, INTERSECT, EXCEPT를 살펴봅니다. 각 연산이 기본적으로 중복을 제거하며, ALL 키워드를 사용하여 중복을 유지하는 방법을 설명합니다. 특히 MySQL에서 INTERSECT와 EXCEPT가 직접 지원되지 않을 때 JOIN 또는 NOT IN을 사용하여 에뮬레이션하는 기법을 소개합니다. 이어서, 문자열 패턴 매칭을 위한 LIKE 연산자와 '%' (모든 부분 문자열), '_' (단일 문자) 특수 문자의 사용법을 다룹니다. 백슬래시를 이용한 이스케이프 문자 처리, 패턴 매칭의 대소문자 구분, 그리고 연결, 대소문자 변환, 길이 확인, 부분 문자열 추출 등 다양한 SQL 문자열 함수를 소개합니다. 마지막으로, ORDER BY 절을 사용하여 쿼리 결과를 특정 속성을 기준으로 오름차순(ASC) 또는 내림차순(DESC)으로 정렬하는 방법을 학습하며, 여러 속성을 기준으로 정렬하는 예시도 제시합니다.",
                "chapter_full_text": "ECE30030/ITP30010 Database Systems29\nNULL Values•It is possible for tuples to have a NULL value for some of their attributes•NULL signifies an unknown value or that a value does not exist•The result of any arithmetic expression involving NULL is NULL•E.g.,  5 + NULL returns NULL\nECE30030/ITP30010 Database Systems30\nIS NULL / IS NOT NULL•The predicate IS NULL can be used to check for NULL values•E.g., Find all instructors whose salary is null SELECT name FROM instructor WHERE salary IS NULL•The predicate IS NOT NULL succeeds if the value on which it is applied is not null\nECE30030/ITP30010 Database Systems31\nECE30030/ITP30010 Database Systems32\nSet Operations•Set operations UNION, INTERSECT, and EXCEPT•Each of the above operations automatically eliminates duplicates•To retain all duplicates, use ALL:•UNION ALL•INTERSECT ALL•EXCEPT ALL\n•C.f., SELECT retains all duplicates by default\nECE30030/ITP30010 Database Systems33\nSet Operations: UNION•Find courses that ran in Fall 2017 or in Spring 2018•(SELECT course_id  FROM teaches WHERE semester = 'Fall' AND year = 2017)UNION(SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018)\nECE30030/ITP30010 Database Systems34\nSet Operations: INTERSECT•Find courses that ran in Fall 2017 and in Spring 2018•(SELECT course_id  FROM teaches WHERE semester = 'Fall' AND year = 2017)INTERSECT(SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018)•C.f., MySQL does NOT support INTERSECT•One can emulate INTERSECT using JOIN (we’ll study JOIN later)•SELECT LT.course_idFROM (SELECT course_id FROM teaches WHERE semester = 'Fall' AND year = 2017) AS LTJOIN (SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018) AS RTON LT.course_id=RT.course_id;\nECE30030/ITP30010 Database Systems35\nSet Operations: EXCEPT•Find courses that ran in Fall 2017 but not in Spring 2018•(SELECT course_id  FROM teaches WHERE semester = 'Fall' AND year = 2017)EXCEPT(SELECT course_id  FROM teaches WHERE semester = 'Spring' AND year = 2018)•C.f., MySQL does NOT support EXCEPT•One can emulate EXCEPT using NOT IN•SELECT course_id FROM teaches WHERE semester = 'Fall' AND year = 2017AND course_id NOT IN(SELECT course_id  FROM teaches  WHERE semester = 'Spring' AND year = 2018);\nECE30030/ITP30010 Database Systems36\nECE30030/ITP30010 Database Systems37\nString Operations•SQL includes a string-matching operator for comparisons on character strings•The operator LIKE uses patterns that are described using two special characters:•percent (%) – The % character matches any substring•underscore (_) – The _ character matches any character•Find the names of all instructors whose name includes the substring “ri” SELECT name FROM instructor WHERE name LIKE ‘%ri%'\nECE30030/ITP30010 Database Systems38\nString Operations•Escape character: Use backslash (\\) as the escape character•E.g., Match the string “100%” LIKE '100 \\%’ ESCAPE  ‘\\’\nECE30030/ITP30010 Database Systems39\nString Operations•Patterns are case sensitive•Pattern matching examples:•'Intro%' matches any string beginning with “Intro”•'%Comp%' matches any string containing “Comp” as a substring•'_ _ _' matches any string of exactly three characters•'_ _ _ %' matches any string of at least three characters•SQL supports a variety of string operations such as•concatenation (using “||”)•converting from upper to lower case (and vice versa)•finding string length, extracting substrings, etc.\nECE30030/ITP30010 Database Systems40\nOrdering the Display of Tuples•List in alphabetic order the names of all instructors•SELECT DISTINCT nameFROM instructorORDER BY name\nECE30030/ITP30010 Database Systems41\nOrdering the Display of Tuples•Can sort on multiple attributes•E.g., SELECT dept_name, name     FROM instructor      ORDER BY dept_name, name\nECE30030/ITP30010 Database Systems42\nOrdering the Display of Tuples•We may specify DESC for descending order or ASC for ascending order, for each attribute; ascending order is the default•E.g., ORDER BY name DESC\nECE30030/ITP30010 Database Systems43"
              },
              {
                "chapter_title": "SQL DML 집계 함수 및 데이터 수정 (INSERT, UPDATE, DELETE)",
                "source_pdf_filename": "cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf",
                "chapter_content_summary": "이 장에서는 SQL 데이터 조작 언어(DML)의 고급 기능인 집계 함수와 데이터를 수정하는 명령어를 다룹니다. AVG, MIN, MAX, SUM, COUNT와 같은 집계 함수를 사용하여 컬럼 값의 멀티셋에 대한 통계 값을 계산하는 방법을 학습합니다. 특히 GROUP BY 절을 이용한 데이터 그룹화와 HAVING 절을 이용한 그룹별 필터링을 심층적으로 다루며, WHERE 절과의 차이점을 명확히 설명합니다. 또한, DML의 핵심 명령인 INSERT, UPDATE, DELETE에 대해 자세히 알아봅니다. INSERT 명령을 통해 테이블에 새로운 튜플을 추가하는 다양한 방법(모든 컬럼, 선택된 컬럼, NULL 값 처리, SELECT 쿼리 결과 삽입)과 외래 키 제약 조건의 중요성을 강조합니다. UPDATE 명령으로는 기존 데이터를 수정하는 기본 구문, 조건부 업데이트, CASE 문을 사용한 복잡한 조건 처리, 스칼라 서브쿼리 활용법을 배웁니다. 마지막으로 DELETE 명령을 통해 테이블에서 특정 행 또는 모든 행을 삭제하는 방법과 TRUNCATE 명령의 차이점, 그리고 삭제 시 서브쿼리 사용 시의 고려사항을 설명합니다.",
                "chapter_full_text": "ECE30030/ITP30010 Database Systems44\nAggregate Functions•These functions operate on the multiset of values of a column of a relation, and return a value•AVG:  average value•MIN:  minimum value•MAX:  maximum value•SUM:  sum of values•COUNT:  number of values\nECE30030/ITP30010 Database Systems45\nAggregate Functions Examples•Find the average salary of instructors in the Computer Science department•SELECT AVG(salary)FROM instructorWHERE dept_name= 'Comp. Sci.';•Find the total number of instructors who teach a course in the Spring 2018 semester•SELECT COUNT(DISTINCT ID)FROM teachesWHERE semester = 'Spring’ AND year = 2018;•Find the number of tuples in the teaches relation•SELECT COUNT (*)FROM teaches;\nECE30030/ITP30010 Database Systems46\nAggregate Functions: Group By•Find the average salary of instructors in each department•SELECT dept_name, AVG(salary) AS avg_salaryFROM instructorGROUP BY dept_name;\nECE30030/ITP30010 Database Systems47\nAggregation•Attributes in SELECT clause outside of aggregate functions must appear in GROUP BY list•/* erroneous query */SELECT dept_name, ID, AVG(salary)FROM instructorGROUP BY dept_name;\nECE30030/ITP30010 Database Systems48\nAggregate Functions – Having Clause•Find the names and average salaries of all departments whose average salary is greater than 65000•SELECT dept_name, AVG(salary) AS avg_salaryFROM instructorGROUP BY dept_nameHAVING AVG(salary) > 65000;\nECE30030/ITP30010 Database Systems49\nAggregate Functions – Having Clause•Note: predicates in the HAVING clause are applied after the formation of groups whereas predicates in the WHERE clause are applied before forming groups\nECE30030/ITP30010 Database Systems50\nSELECT dept_name, AVG(salary) AS avg_salaryFROM instructorGROUP BY dept_nameHAVING AVG(salary) > 65000;\nSELECT dept_name, AVG(salary) AS avg_salaryFROM instructorWHERE salary > 65000GROUP BY dept_name;\nSQL Commands\nSQLDMLSELECTINSERTUPDATEDELETE\nDDLCREATEALTERDROP\nECE30030/ITP30010 Database Systems51\nINSERT•Basic syntax•Insert data into every column:•INSERT INTO tablenameVALUES (col1_value, col2_value, …)•Must list values in the same order as in the table schema•If some data values are unknown, must type NULL •For character sequences, use quotation marks•Single quotation marks are preferred (but double quotation marks are allowed)•Value in quotations is case-sensitive•Insert data into selected columns•INSERT INTO tablename (col1_name, col3_name, col4_name, …)VALUES (col1_value, col3_value, col4_value, …)\nECE30030/ITP30010 Database Systems52\nINSERT•Add a new tuple to course•INSERT INTO courseVALUES ('CS-437', 'Database Systems', 'Comp. Sci.', 4);•or equivalently•INSERT INTO course (course_id, title, dept_name, credits)VALUES ('CS-437', 'Database Systems', 'Comp. Sci.', 4);•Add a new tuple to student  with tot_creds set to null•INSERT INTO studentVALUES ('3003', 'Green', 'Finance', null);\nECE30030/ITP30010 Database Systems53\nINSERT•A foreign key specifies that an attribute from one relation has to map to a tuple in another relation•Value in one relation must appear in another relation\nECE30030/ITP30010 Database Systems54\nRelation: instructor\nRelation: department\nINSERT•A foreign key specifies that an attribute from one relation has to map to a tuple in another relation•Value in one relation must appear in another relation•Make sure all foreign keys that new row references have already been added to database•One cannot insert a foreign key value unless the corresponding value exists in the referenced relation\nECE30030/ITP30010 Database Systems55\nINSERT•Inserting results of other SELECT query•Make each student in the Music department who has earned more than 144 credit hours an instructor in the Music department with a salary of  $18,000•INSERT INTO instructor  SELECT ID, name, dept_name, 18000  FROM student   WHERE dept_name = 'Music’ AND total_cred > 144;•The SELECT FROM WHERE statement is evaluated fully before any of its results are inserted into the relation•Otherwise queries like  INSERT INTO table1 SELECT * FROM table1would cause problem\nECE30030/ITP30010 Database Systems56\nUPDATE•Basic syntax•Updating a table•UPDATE tablenameSET col1_name = new_col1_value, col2_name = new_col2_value, …;•Updating a table with conditions•UPDATE tablenameSET col1_name = new_col1_value, col2_name = new_col2_value, …WHERE predicate;\nECE30030/ITP30010 Database Systems57\nUPDATE•Give a 5% salary raise to all instructors•UPDATE instructorSET salary = salary * 1.05•Give a 5% salary raise to those instructors who earn less than 70000•UPDATE instructorSET salary = salary * 1.05WHERE salary < 70000;•Give a 5% salary raise to instructors whose salary is less than average•UPDATE instructorSET salary = salary * 1.05WHERE salary <  (SELECT AVG(salary) FROM instructor);\nECE30030/ITP30010 Database Systems58\nUPDATE•Increase salaries of instructors whose salary is over $100,000 by 3%, and all others by a 5%•Write two UPDATE statements:  UPDATE instructor  SET salary = salary * 1.03  WHERE salary > 100000;  UPDATE instructor  SET salary = salary * 1.05  WHERE salary <= 100000;•The order is important•Can be done better using the case statement (next slide)\nECE30030/ITP30010 Database Systems59\nCASE Statement for Conditional Update•The following query is equivalent to the previous UPDATE queries•UPDATE instructorSET salary = CASE                           WHEN salary <= 100000 THEN salary * 1.05                           ELSE salary * 1.03                       END\nECE30030/ITP30010 Database Systems60\nUPDATE with Scalar Subqueries•Recompute and update tot_creds value for all students•UPDATE student SSET tot_cred = (SELECT SUM(credits)                             FROM takes, course                             WHERE takes.course_id = course.course_id  AND                                            S.ID= takes.ID  AND                                            takes.grade <> 'F' AND                                            takes.grade IS NOT NULL);\nECE30030/ITP30010 Database Systems61\nDELETE•Basic syntax•To remove specific rows•DELETE FROM tablenameWHERE predicate;•To remove all rows•DELETE FROM tablename;•This is equivalent to TRUNCATE:TRUNCATE (TABLE) tablename;•One cannot truncate a table with foreign key constraints•Must disable the constraints first (we will cover ALTER when we study SQL DDL):ALTER TABLE tablenameDISABLE CONSTRAINT constraint_name;\nECE30030/ITP30010 Database Systems62\nDELETE•Delete all instructors•DELETE FROM instructor;•Delete all instructors from the Finance department•DELETE FROM instructorWHERE dept_name= 'Finance';•Delete all tuples in the instructor relation for those instructors associated with a department located in the Watson building•DELETE FROM instructorWHERE dept name IN (SELECT dept name        FROM department        WHERE building = 'Watson');\nECE30030/ITP30010 Database Systems63\nDELETE•Delete all instructors whose salary is less than the average salary of instructors•Example:  DELETE FROM instructor                WHERE salary < (SELECT AVG (salary)                  FROM instructor);•Issue:  as we delete tuples from instructor, the average salary changes•Solution used in SQL:1.First, compute AVG(salary) and find all tuples to delete2.Next, delete all tuples found above (without recomputing AVG or retesting the tuples)\nECE30030/ITP30010 Database Systems64"
              }
            ],
            "generated_content": [
              {
                "title": "관계형 데이터베이스 시스템(R-DBMS) 개요 및 MySQL 소개",
                "metadata": "Source: cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_1a4c2f45-b482-4e82-826e-fa8945eb99c7_DB03 - mysql.pdf, Text length: 2496 chars",
                "documentContent": [
                  {
                    "type": "heading",
                    "content": "목차",
                    "level": 1
                  },
                  {
                    "type": "paragraph",
                    "content": "MySQL 소개",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "SQL 미리보기",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "MySQL",
                    "level": 1
                  },
                  {
                    "type": "paragraph",
                    "content": "MySQL은 SQL 기반의 관계형 데이터베이스 관리 시스템(DBMS)입니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "GPL 라이선스 하의 무료 오픈소스 R-DBMS입니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "오라클이 소유하고 있습니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "상업용 MySQL 버전도 제공됩니다(기술 지원 포함).",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "“My”는 공동 창립자 Michael Widenius의 딸 이름에서 유래했습니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "참고: MariaDB",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "표준 SQL과 호환됩니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "상업용 웹 서비스에 자주 사용됩니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "MySQL 사용 기업",
                    "level": 1
                  },
                  {
                    "type": "paragraph",
                    "content": "Enlyft의 연구에 따르면, MySQL을 사용하는 1,409,176개 회사 중 199,498개 회사에 대한 데이터를 보유하고 있습니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "주로 직원 수 10-50명, 매출 100만-1000만 달러 규모의 회사에서 사용됩니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "참고: Oracle 12는 직원 수 50-200명, 매출 10억 달러 이상 규모의 회사에서 가장 많이 사용됩니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "MySQL을 사용하는 회사 전체 목록은 https://www.mysql.com/customers/ 에서 확인할 수 있습니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "MySQL을 사용하는 이유",
                    "level": 1
                  },
                  {
                    "type": "paragraph",
                    "content": "인기 많음",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "인터넷 전반에 걸쳐 활발한 토론이 이루어집니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "다재다능함: Linux, Windows, Mac OS X, Solaris, FreeBSD 등 다양한 운영체제에서 실행됩니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "다양한 프로그래밍 언어(C/C++, Java, Python, .Net 등)를 지원합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "비용이 0부터 시작합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "고성능 (빠르고 신뢰할 수 있음)",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "DBMS 인기 추세",
                    "level": 1
                  },
                  {
                    "type": "paragraph",
                    "content": "점수 정의: https://db-engines.com/en/ranking_definition",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "MySQL의 주요 특징",
                    "level": 1
                  },
                  {
                    "type": "paragraph",
                    "content": "방대함: 테라바이트 단위의 데이터를 처리할 수 있습니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "편리함: 고수준 질의어를 지원합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "다중 사용자: 동시 데이터 접근을 지원합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "안전함: 트랜잭션을 지원합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "효율적임: 초당 수천 건의 질의를 처리할 수 있습니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "신뢰성: 많은 실제 제품에서 99.99%의 가동 시간을 자랑합니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "MySQL 버전",
                    "level": 1
                  },
                  {
                    "type": "paragraph",
                    "content": "MySQL 5.x 대 8.x",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "버전 5.x: MySQL의 가장 인기 있는 버전이며, 더 안정적이고 보편적입니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "버전 8.x: 현재 버전으로, 최신 DB 기능(더 나은 스토리지 엔진, 더 빠른 속도, 더 강력한 보안)을 제공합니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "MySQL 얻는 방법",
                    "level": 1
                  },
                  {
                    "type": "paragraph",
                    "content": "https://dev.mysql.com/downloads/",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "무료로 사용 가능한 \"커뮤니티\" 버전을 찾아보세요.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "”엔터프라이즈” 버전은 상업용입니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "이 강의를 위해 Docker 이미지가 준비되어 있습니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "Ubuntu 서버, MySQL, 그리고 강의 활동을 위한 예제 데이터베이스로 구성되어 있습니다.",
                    "level": null
                  }
                ],
                "aiNotes": {
                  "summary": "본 문서는 관계형 데이터베이스 관리 시스템(R-DBMS)의 개요와 MySQL에 대해 소개합니다. MySQL이 SQL 기반의 무료 오픈소스 R-DBMS이며, 오라클이 소유하고 있음을 설명합니다. 또한 MySQL의 광범위한 사용 현황, 다양한 운영체제 및 프로그래밍 언어 지원, 고성능, 안정성 등의 장점을 강조합니다. MySQL 5.x와 8.x 버전의 주요 차이점을 비교하고, MySQL을 다운로드하고 활용할 수 있는 방법을 안내합니다.",
                  "keyConcepts": [
                    {
                      "term": "관계형 데이터베이스 관리 시스템 (R-DBMS)",
                      "definition": "SQL 기반으로 데이터를 관계형 모델에 따라 저장, 관리, 검색하는 시스템입니다."
                    },
                    {
                      "term": "MySQL",
                      "definition": "오라클이 소유한 SQL 기반의 오픈소스 R-DBMS로, 상업용 웹 서비스에 널리 사용되며 높은 성능과 안정성을 제공합니다."
                    },
                    {
                      "term": "오픈소스 소프트웨어",
                      "definition": "소스 코드가 공개되어 누구나 자유롭게 사용, 수정, 배포할 수 있는 소프트웨어입니다."
                    },
                    {
                      "term": "SQL (Structured Query Language)",
                      "definition": "관계형 데이터베이스와 상호작용하고 데이터를 정의, 조작, 제어하기 위한 표준 언어입니다."
                    },
                    {
                      "term": "MySQL 버전 5.x vs 8.x",
                      "definition": "5.x는 가장 대중적이고 안정적인 버전이며, 8.x는 현재 버전으로 최신 기능, 향상된 스토리지 엔진, 속도 및 보안을 제공합니다."
                    }
                  ],
                  "importantTerms": [
                    {
                      "term": "DBMS",
                      "definition": "데이터베이스 관리 시스템(Database Management System)의 약자로, 데이터베이스를 효율적으로 관리하는 소프트웨어입니다."
                    },
                    {
                      "term": "GPL",
                      "definition": "General Public License의 약자로, 자유 소프트웨어 라이선스의 일종이며, 소프트웨어의 복사, 배포, 수정 권한을 부여합니다."
                    },
                    {
                      "term": "MariaDB",
                      "definition": "MySQL의 한 포크(fork)로, MySQL과 높은 호환성을 가지며 오픈소스 커뮤니티에 의해 개발되고 있습니다."
                    },
                    {
                      "term": "트랜잭션",
                      "definition": "데이터베이스의 논리적인 작업 단위로, 데이터의 무결성을 보장하기 위해 전부 실행되거나 전혀 실행되지 않아야 하는 일련의 연산입니다."
                    },
                    {
                      "term": "스토리지 엔진",
                      "definition": "데이터베이스 시스템 내에서 데이터를 디스크에 저장하고 검색하는 방식을 담당하는 구성 요소입니다."
                    },
                    {
                      "term": "Docker",
                      "definition": "애플리케이션을 컨테이너라는 격리된 환경에서 개발, 배포, 실행할 수 있게 해주는 플랫폼입니다."
                    }
                  ],
                  "outline": [
                    {
                      "text": "목차",
                      "id": "목차",
                      "children": null
                    },
                    {
                      "text": "MySQL",
                      "id": "mysql",
                      "children": [
                        {
                          "text": "MySQL 정의 및 특징",
                          "id": "mysql-정의-및-특징",
                          "children": null
                        },
                        {
                          "text": "MySQL 사용 기업",
                          "id": "mysql-사용-기업",
                          "children": null
                        },
                        {
                          "text": "MySQL을 사용하는 이유",
                          "id": "mysql을-사용하는-이유",
                          "children": null
                        },
                        {
                          "text": "MySQL의 주요 특징",
                          "id": "mysql의-주요-특징",
                          "children": null
                        }
                      ]
                    },
                    {
                      "text": "DBMS 인기 추세",
                      "id": "dbms-인기-추세",
                      "children": null
                    },
                    {
                      "text": "MySQL 버전",
                      "id": "mysql-버전",
                      "children": null
                    },
                    {
                      "text": "MySQL 얻는 방법",
                      "id": "mysql-얻는-방법",
                      "children": null
                    }
                  ]
                },
                "quiz": [
                  {
                    "question": "MySQL의 주요 특징이 아닌 것은 무엇인가요?",
                    "options": [
                      "오라클이 소유한 상용 소프트웨어이다.",
                      "SQL 기반의 관계형 데이터베이스 관리 시스템이다.",
                      "GPL 라이선스 하에 무료 오픈소스 버전이 제공된다.",
                      "다양한 운영체제와 프로그래밍 언어를 지원한다."
                    ],
                    "answerIndex": 0,
                    "explanation": "MySQL은 오라클이 소유하고 있지만, GPL 라이선스 하에 무료 오픈소스 버전이 제공되며 상용 버전도 별도로 존재합니다. 따라서 '오라클이 소유한 상용 소프트웨어이다'는 MySQL의 모든 특징을 포괄하지 않습니다."
                  },
                  {
                    "question": "MySQL 5.x 버전과 8.x 버전의 주요 차이점은 무엇인가요?",
                    "options": [
                      "5.x는 최신 기능에 중점을 둔 반면 8.x는 안정성에 중점을 둡니다.",
                      "5.x는 현재 버전이고 8.x는 이전 버전입니다.",
                      "5.x는 더 안정적이고 대중적이며, 8.x는 최신 기능과 향상된 성능을 제공합니다.",
                      "5.x는 유료 버전이고 8.x는 무료 버전입니다."
                    ],
                    "answerIndex": 2,
                    "explanation": "MySQL 5.x는 가장 대중적이고 안정적인 버전으로 남아있지만, 8.x는 최신 버전으로서 더 나은 스토리지 엔진, 속도 및 보안 등 최신 기능을 제공합니다."
                  },
                  {
                    "question": "다음 중 MySQL을 얻을 수 있는 방법으로 본문에 언급되지 않은 것은 무엇인가요?",
                    "options": [
                      "dev.mysql.com/downloads/에서 커뮤니티 버전 다운로드",
                      "MySQL 엔터프라이즈 버전 구매",
                      "Docker 이미지를 통해 구축",
                      "CD-ROM으로 설치"
                    ],
                    "answerIndex": 3,
                    "explanation": "본문에서는 공식 다운로드 페이지에서 커뮤니티 버전 다운로드, 엔터프라이즈 버전 구매, 그리고 Docker 이미지 활용 방법이 언급되었으나, CD-ROM을 통한 설치는 언급되지 않았습니다."
                  }
                ]
              },
              {
                "title": "SQL(구조적 질의어)의 이해: 기본 개념과 역사",
                "metadata": "Source: cd0e465a-9cfa-47bf-93fa-9eb3748fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf, Text length: 1968 chars",
                "documentContent": [
                  {
                    "type": "heading",
                    "content": "서론",
                    "level": 1
                  },
                  {
                    "type": "paragraph",
                    "content": "이 문서는 관계형 데이터베이스를 다루는 핵심 언어인 SQL(구조적 질의어)의 기본 개념과 역사, 그리고 주요 구성 요소에 대해 설명합니다. SQL은 데이터베이스에 '무엇을 할지'를 지시하는 높은 수준의 언어로, '어떻게 할지'에 대한 세부 사항은 DBMS(데이터베이스 관리 시스템)의 질의 최적화 기능에 맡깁니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "구조적 질의어 (SQL) 개요",
                    "level": 1
                  },
                  {
                    "type": "heading",
                    "content": "SQL의 정의 및 특징",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "SQL은 관계형 데이터베이스를 기술하고 조작하는 데 사용되는 주요 언어입니다. SQL은 매우 높은 수준의 언어로, 사용자에게 데이터 조작의 세부 사항을 명시하는 대신 '무엇을 할지'를 지시하도록 합니다. DBMS는 질의 최적화(query optimization)를 통해 질의를 실행하는 '최적의' 방법을 찾아냅니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "SQL의 주요 구성 요소",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "SQL은 크게 두 가지 주요 측면으로 나뉩니다:",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "데이터 정의: 데이터베이스 스키마를 선언하는 데 사용되는 DDL(Data Definition Language).",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "데이터 조작: 데이터베이스에 질의하고(질문을 던지고) 데이터베이스를 수정하는 데 사용되는 DML(Data Manipulation Language).",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "SQL의 다양한 기능",
                    "level": 1
                  },
                  {
                    "type": "heading",
                    "content": "데이터 조작 언어 (DML)",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "DML은 데이터베이스에서 정보를 질의하고, 튜플을 삽입, 삭제, 수정하는 기능을 제공합니다. `SELECT`, `FROM`, `WHERE`와 같은 구문이 DML의 핵심을 이룹니다. 또한, NULL 값 처리, 집합 연산, 문자열 연산, 정렬, 그리고 집계 함수와 같은 고급 기능도 포함됩니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "기타 SQL 기능",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "SQL은 DML 외에도 다양한 기능을 포함합니다:",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "무결성: DDL은 무결성 제약 조건을 명시하기 위한 명령어를 포함합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "뷰 정의: DDL은 뷰를 정의하기 위한 명령어를 포함합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "트랜잭션 제어: 트랜잭션의 시작과 끝을 명시하기 위한 명령어를 포함합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "임베디드 SQL 및 동적 SQL: SQL 문을 범용 프로그래밍 언어 내에 포함하는 방법을 정의합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "권한 부여: 관계 및 뷰에 대한 접근 권한을 명시하기 위한 명령어를 포함합니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "SQL의 간략한 역사",
                    "level": 1
                  },
                  {
                    "type": "heading",
                    "content": "초기 개발: IBM SEQUEL과 System R",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "SQL의 전신인 IBM SEQUEL(Structured English Query Language)은 1970년대 초 Chamberlin과 Boyce에 의해 System R 프로젝트의 일환으로 개발되었습니다. 이후 SEQUEL은 SQL(Structured Query Language)로 이름이 변경되었습니다. System R은 System/38(1979), SQL/DS(1981), DB2(1983)로 발전했습니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "상업적 구현 및 표준화",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "Relational Software, Inc.(현재 Oracle Corporation)는 VAX 컴퓨터용 Oracle V2를 출시하며 최초의 상업적 SQL 구현을 선보였습니다. ANSI와 ISO는 SQL을 표준화했으며, SQL-86을 시작으로 SQL-89, SQL-92, SQL:1999 등을 거쳐 현재는 SQL:2016에 이르렀습니다. 특히 SQL-92는 대부분의 데이터베이스 시스템에서 지원됩니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "기본 질의 구조",
                    "level": 1
                  },
                  {
                    "type": "heading",
                    "content": "SELECT-FROM-WHERE 구문",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "전형적인 SQL 질의는 다음과 같은 형태를 가집니다:",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "SELECT A1, A2, ..., An\nFROM r1, r2, ..., rm\nWHERE P",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "여기서 Ai는 속성(attribute)을 나타내고, Ri는 관계(relation)를 나타내며, P는 술어(predicate)입니다. SQL 질의의 결과는 항상 관계(테이블)입니다.",
                    "level": null
                  }
                ],
                "aiNotes": {
                  "summary": "이 문서는 관계형 데이터베이스의 핵심 언어인 SQL(구조적 질의어)에 대해 설명합니다. SQL의 정의와 특징, 데이터 정의 언어(DDL)와 데이터 조작 언어(DML)로의 구분, 그리고 무결성 제약 조건, 뷰 정의, 트랜잭션 제어 등 다양한 기능을 다룹니다. 또한, IBM의 SEQUEL 개발부터 Oracle의 상업적 구현, 그리고 ANSI 및 ISO 표준화에 이르는 SQL의 간략한 역사와 함께, `SELECT-FROM-WHERE`로 대표되는 SQL의 기본 질의 구조를 소개합니다.",
                  "keyConcepts": [
                    {
                      "term": "SQL (구조적 질의어)",
                      "definition": {
                        "easy": null,
                        "medium": "관계형 데이터베이스를 기술하고 조작하는 데 사용되는 주요 언어로, '무엇을 할지'를 지시하는 높은 수준의 언어입니다.",
                        "hard": null
                      }
                    },
                    {
                      "term": "DML (데이터 조작 언어)",
                      "definition": {
                        "easy": null,
                        "medium": "데이터베이스에서 정보를 질의하고, 튜플을 삽입, 삭제, 수정하는 기능을 제공하는 SQL의 한 부분입니다.",
                        "hard": null
                      }
                    },
                    {
                      "term": "DDL (데이터 정의 언어)",
                      "definition": {
                        "easy": null,
                        "medium": "데이터베이스 스키마를 선언하고 무결성 제약 조건 및 뷰 정의와 같은 데이터베이스 구조 관련 기능을 담당하는 SQL의 한 부분입니다.",
                        "hard": null
                      }
                    },
                    {
                      "term": "질의 최적화",
                      "definition": {
                        "easy": null,
                        "medium": "DBMS가 SQL 질의를 효율적으로 실행하기 위해 '최적의' 실행 계획을 찾는 과정입니다.",
                        "hard": null
                      }
                    }
                  ],
                  "importantTerms": [
                    {
                      "term": "SQL",
                      "definition": "Structured Query Language의 약자로, 관계형 데이터베이스를 관리하는 표준 언어입니다."
                    },
                    {
                      "term": "DML",
                      "definition": "Data Manipulation Language의 약자로, 데이터 검색, 삽입, 수정, 삭제 등 데이터 조작에 사용되는 SQL 명령어 집합입니다."
                    },
                    {
                      "term": "DDL",
                      "definition": "Data Definition Language의 약자로, 데이터베이스 스키마 정의, 테이블 생성 및 수정, 뷰 생성 등 데이터 구조 정의에 사용되는 SQL 명령어 집합입니다."
                    },
                    {
                      "term": "SEQUEL",
                      "definition": "Structured English Query Language의 약자로, SQL의 초기 명칭이자 IBM System R 프로젝트에서 개발되었습니다."
                    },
                    {
                      "term": "System R",
                      "definition": "IBM에서 1970년대 초에 개발한 관계형 데이터베이스 시스템 연구 프로젝트로, SQL의 기원이 되었습니다."
                    },
                    {
                      "term": "질의 최적화 (Query Optimization)",
                      "definition": "DBMS가 SQL 질의를 가장 효율적으로 실행하기 위한 방법을 결정하는 과정입니다."
                    },
                    {
                      "term": "SELECT-FROM-WHERE",
                      "definition": "SQL에서 데이터를 질의하는 가장 기본적인 구문 형태입니다."
                    }
                  ],
                  "outline": [
                    {
                      "text": "서론",
                      "id": "서론",
                      "children": null
                    },
                    {
                      "text": "구조적 질의어 (SQL) 개요",
                      "id": "구조적-질의어-sql-개요",
                      "children": [
                        {
                          "text": "SQL의 정의 및 특징",
                          "id": "sql의-정의-및-특징",
                          "children": null
                        },
                        {
                          "text": "SQL의 주요 구성 요소",
                          "id": "sql의-주요-구성-요소",
                          "children": null
                        }
                      ]
                    },
                    {
                      "text": "SQL의 다양한 기능",
                      "id": "sql의-다양한-기능",
                      "children": [
                        {
                          "text": "데이터 조작 언어 (DML)",
                          "id": "데이터-조작-언어-dml",
                          "children": null
                        },
                        {
                          "text": "기타 SQL 기능",
                          "id": "기타-sql-기능",
                          "children": null
                        }
                      ]
                    },
                    {
                      "text": "SQL의 간략한 역사",
                      "id": "sql의-간략한-역사",
                      "children": [
                        {
                          "text": "초기 개발: IBM SEQUEL과 System R",
                          "id": "초기-개발-ibm-sequel과-system-r",
                          "children": null
                        },
                        {
                          "text": "상업적 구현 및 표준화",
                          "id": "상업적-구현-및-표준화",
                          "children": null
                        }
                      ]
                    },
                    {
                      "text": "기본 질의 구조",
                      "id": "기본-질의-구조",
                      "children": [
                        {
                          "text": "SELECT-FROM-WHERE 구문",
                          "id": "select-from-where-구문",
                          "children": null
                        }
                      ]
                    }
                  ]
                },
                "quiz": [
                  {
                    "question": "SQL의 주요 특징 중 하나는 무엇입니까?",
                    "options": [
                      "데이터 조작의 세부 사항을 명시합니다.",
                      "데이터베이스에 '무엇을 할지'보다 '어떻게 할지'를 지시합니다.",
                      "DBMS가 질의 실행 방법을 최적화하도록 합니다.",
                      "비관계형 데이터베이스를 조작하는 데 주로 사용됩니다."
                    ],
                    "answerIndex": 2,
                    "explanation": "SQL은 '무엇을 할지'를 명시하며, '어떻게 할지'에 대한 세부 사항은 DBMS의 질의 최적화 기능에 맡깁니다."
                  },
                  {
                    "question": "최초의 상업적 SQL 구현을 출시한 회사는 어디입니까?",
                    "options": [
                      "IBM",
                      "Microsoft",
                      "Relational Software, Inc. (현재 Oracle Corporation)",
                      "ANSI"
                    ],
                    "answerIndex": 2,
                    "explanation": "Relational Software, Inc. (현재 Oracle Corporation)가 VAX 컴퓨터용 Oracle V2를 통해 최초의 상업적 SQL 구현을 출시했습니다."
                  },
                  {
                    "question": "SQL의 구성 요소 중 데이터베이스 스키마를 선언하고 무결성 제약 조건 및 뷰를 정의하는 역할을 하는 것은 무엇입니까?",
                    "options": [
                      "DML (Data Manipulation Language)",
                      "DDL (Data Definition Language)",
                      "Transaction Control (트랜잭션 제어)",
                      "Authorization (권한 부여)"
                    ],
                    "answerIndex": 1,
                    "explanation": "DDL(데이터 정의 언어)은 데이터베이스 스키마를 선언하고 무결성 제약 조건 및 뷰를 정의하는 데 사용됩니다."
                  }
                ]
              },
              {
                "title": "SQL 데이터 조작 언어(DML) 기초: SELECT, FROM, WHERE 절",
                "metadata": "Source: cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf, Text length: 4209 chars",
                "documentContent": [
                  {
                    "type": "heading",
                    "content": "SQL 데이터 조작 언어(DML)",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "SQL 데이터 조작 언어(DML)는 데이터베이스를 질의(질문)하고 수정할 수 있도록 합니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "실행 예시",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "관계(테이블): instructor, teaches",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "Instructor 관계 및 Teaches 관계",
                    "level": 2
                  },
                  {
                    "type": "heading",
                    "content": "기본 질의 구조",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "일반적인 SQL 질의는 다음과 같은 형태를 가집니다: SELECT A1, A2, ..., An FROM r1, r2, ..., rm WHERE P",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "Ai는 속성을 나타냅니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "Ri는 관계를 나타냅니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "P는 술어(predicate)입니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "SQL 질의의 결과는 관계(relation)입니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "SELECT 절",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "SELECT 절은 질의 결과에 필요한 속성들을 나열합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "관계 대수의 프로젝션(projection) 연산에 해당합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "예시: 모든 강사의 이름을 찾기",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "SQL: SELECT name FROM instructor;",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "참고",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "참고: SQL 이름은 대소문자를 구분하지 않습니다. 예: Name ≡ NAME ≡ name",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "SQL 명령(SELECT, FROM, WHERE 등)은 대문자로 작성하는 것이 일반적인 관례입니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "MySQL에는 lower_case_table_names라는 옵션 플래그가 있습니다. 링크: https://dev.mysql.com/doc/refman/8.0/en/identifier-case-sensitivity.html",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "SELECT 절: 중복 처리",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "SQL은 관계뿐만 아니라 질의 결과에서도 중복을 허용합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "ALL 키워드는 중복을 제거하지 않도록 지정합니다. SELECT ALL dept_name FROM instructor",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "중복 제거를 강제하려면 SELECT 뒤에 DISTINCT 키워드를 삽입합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "모든 강사의 부서 이름을 중복 없이 찾기: SELECT DISTINCT dept_name FROM instructor;",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "SELECT 절: 모든 속성 및 리터럴 사용",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "SELECT 절의 별표(*)는 “모든 속성”을 의미합니다. SELECT * FROM instructor;",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "속성은 FROM 절 없이 리터럴(상수)이 될 수 있습니다. SELECT ‘437’;",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "결과는 하나의 열과 “437” 값을 가진 단일 행으로 구성된 테이블입니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "AS를 사용하여 열에 이름을 부여할 수 있습니다: SELECT ‘437’ AS FOO",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "속성은 FROM 절을 포함하는 리터럴이 될 수 있습니다. SELECT 'A' FROM instructor",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "결과는 하나의 열과 N개의 행(instructor 테이블의 튜플 수)으로 구성된 테이블이며, 각 행은 “A” 값을 가집니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "SELECT 절: 산술 표현식",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "SELECT 절은 +, –, *, / 연산을 포함하는 산술 표현식을 포함할 수 있으며, 상수 또는 튜플의 속성에 대해 작동합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "질의: SELECT ID, name, salary/12 FROM instructor는 instructor 관계와 동일한 관계를 반환하지만, salary 속성 값이 12로 나뉘어 표시됩니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "AS 절을 사용하여 “salary/12”의 이름을 변경할 수 있습니다: SELECT ID, name, salary/12 AS monthly_salary FROM instructor",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "WHERE 절",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "WHERE 절은 결과가 만족해야 하는 조건을 지정합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "관계 대수의 선택(selection) 술어에 해당합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "예시: ‘Comp. Sci.’ 부서의 모든 강사를 찾으려면: SELECT name FROM instructor WHERE dept_name = 'Comp. Sci.';",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "WHERE 절: 논리 연산자와 비교 연산자",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "SQL은 AND, OR, NOT 논리 연결자를 사용할 수 있도록 합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "논리 연결자의 피연산자는 <, <=, >, >=, =, <>와 같은 비교 연산자를 포함하는 표현식일 수 있습니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "<>는 같지 않음을 의미합니다 (SQL에는 !=가 없습니다).",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "비교는 산술 표현식의 결과에도 적용될 수 있습니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "예시: ‘Comp. Sci.’ 부서에 속하며 급여가 70,000보다 많은 모든 강사를 찾으려면: SELECT name FROM instructor WHERE dept_name = 'Comp. Sci.' AND salary > 70000;",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "WHERE 절: BETWEEN 연산자",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "SQL에는 BETWEEN 비교 연산자가 포함되어 있습니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "예시: 급여가 $90,000에서 $100,000 사이(즉, $90,000 이상 $100,000 이하)인 모든 강사의 이름을 찾으려면:",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "SELECT name FROM instructor WHERE salary BETWEEN 90000 AND 100000",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "WHERE 절: 튜플 비교",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "튜플 비교: 튜플별로 비교를 수행합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "SELECT name, course_id FROM instructor, teaches WHERE (instructor.ID, dept_name) = (teaches.ID, 'Biology');",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "FROM 절",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "FROM 절은 질의에 관련된 관계(테이블)들을 나열합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "관계 대수의 카티션 곱(Cartesian-product) 연산에 해당합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "예시: instructor × teaches의 카티션 곱을 찾으려면: SELECT * FROM instructor, teaches;",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "두 관계의 모든 속성을 포함하여 가능한 모든 instructor-teaches 쌍을 생성합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "공통 속성(예: ID)의 경우, 결과 테이블의 속성 이름은 관계 이름(예: instructor.ID)을 사용하여 변경됩니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "FROM 절: 카티션 곱 예시",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "instructor X teaches의 카티션 곱을 찾으려면: SELECT * FROM instructor, teaches;",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "결과 테이블은 instructor와 teaches 관계의 모든 속성을 포함하며, 각 instructor 튜플과 각 teaches 튜플의 모든 가능한 조합을 생성합니다. 예를 들어, instructor.ID, name, dept_name, salary와 teaches.ID, course_id, sec_id, semester, year와 같은 속성들이 조합되어 나타납니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "조인 구현",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "카티션 곱은 직접적으로는 유용하지 않지만, WHERE 절 조건(관계 대수의 선택 연산)과 결합하면 유용합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "카티션 곱 + 선택 = 조인(join)",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "예시: 어떤 과목을 가르친 모든 강사의 이름과 course_id를 찾으려면: SELECT name, course_id FROM instructor , teaches WHERE instructor.ID = teaches.ID",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "음악과에 속하며 어떤 과목을 가르친 모든 강사의 이름과 course_id를 찾으려면: SELECT name, course_id FROM instructor , teaches WHERE instructor.ID = teaches.ID AND instructor. dept_name = 'Music'",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "이름 변경(Rename) 연산",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "SQL은 AS 절을 사용하여 관계와 속성의 이름을 변경할 수 있도록 합니다: old-name AS new-name",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "예시: 'Comp. Sci.' 부서의 어떤 강사보다 급여가 높은 모든 강사의 이름을 찾으려면:",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "SELECT DISTINCT T.name FROM instructor AS T, instructor AS S WHERE T.salary > S.salary AND S.dept_name = 'Comp. Sci.'",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "AS 키워드는 선택 사항이며 생략될 수 있습니다. instructor AS T ≡ instructor T",
                    "level": null
                  }
                ],
                "aiNotes": {
                  "summary": "본 문서는 SQL 데이터 조작 언어(DML)의 핵심 구성 요소인 SELECT, FROM, WHERE 절의 기초를 다룹니다. 각 절의 기본적인 기능과 함께 중복 처리(ALL, DISTINCT), 산술 표현식, 조건 필터링(AND, OR, NOT, BETWEEN), 테이블 간의 조인(JOIN) 구현, 그리고 테이블 및 속성 이름 변경(AS)과 같은 다양한 활용 방법을 예시와 함께 설명합니다. 또한 SQL 이름의 대소문자 구분 규칙에 대한 내용도 포함되어 있습니다.",
                  "keyConcepts": [
                    {
                      "term": "SQL DML",
                      "definition": "데이터베이스에서 데이터를 질의하고 수정하는 데 사용되는 언어입니다."
                    },
                    {
                      "term": "SELECT 절",
                      "definition": "질의 결과에 포함할 속성(컬럼)을 지정하는 부분으로, 관계 대수의 프로젝션(Projection) 연산에 해당합니다."
                    },
                    {
                      "term": "FROM 절",
                      "definition": "데이터를 검색할 관계(테이블)를 지정하는 부분으로, 관계 대수의 카티션 곱(Cartesian Product) 연산에 해당합니다."
                    },
                    {
                      "term": "WHERE 절",
                      "definition": "질의 결과가 만족해야 할 조건을 지정하는 부분으로, 관계 대수의 선택(Selection) 연산에 해당합니다."
                    },
                    {
                      "term": "조인 (JOIN)",
                      "definition": "FROM 절의 카티션 곱과 WHERE 절의 선택 조건을 결합하여 두 개 이상의 테이블에서 관련 튜플을 연결하여 새로운 테이블을 생성하는 연산입니다."
                    }
                  ],
                  "importantTerms": [
                    {
                      "term": "DML (Data Manipulation Language)",
                      "definition": "데이터베이스에서 데이터를 검색, 삽입, 삭제, 수정하는 데 사용되는 언어."
                    },
                    {
                      "term": "SELECT",
                      "definition": "SQL 쿼리의 결과를 정의하는 절로, 어떤 컬럼을 반환할지 지정."
                    },
                    {
                      "term": "FROM",
                      "definition": "SQL 쿼리에서 데이터를 검색할 테이블을 지정하는 절."
                    },
                    {
                      "term": "WHERE",
                      "definition": "SQL 쿼리에서 특정 조건을 만족하는 행만 선택하도록 필터링하는 절."
                    },
                    {
                      "term": "DISTINCT",
                      "definition": "SELECT 절에서 중복된 결과를 제거할 때 사용하는 키워드."
                    },
                    {
                      "term": "AS",
                      "definition": "SQL에서 테이블이나 컬럼의 이름을 변경(별칭 지정)할 때 사용하는 키워드."
                    },
                    {
                      "term": "카티션 곱 (Cartesian Product)",
                      "definition": "두 테이블의 모든 가능한 행 조합을 생성하는 연산."
                    }
                  ],
                  "outline": [
                    {
                      "text": "SQL 데이터 조작 언어(DML) 개요",
                      "id": "sql-데이터-조작-언어-dml-개요",
                      "children": null
                    },
                    {
                      "text": "기본 질의 구조",
                      "id": "기본-질의-구조",
                      "children": null
                    },
                    {
                      "text": "SELECT 절의 활용",
                      "id": "select-절의-활용",
                      "children": [
                        {
                          "text": "속성 선택 및 프로젝션",
                          "id": "속성-선택-및-프로젝션",
                          "children": null
                        },
                        {
                          "text": "대소문자 구분 및 SQL 명령 규칙",
                          "id": "대소문자-구분-및-sql-명령-규칙",
                          "children": null
                        },
                        {
                          "text": "중복 처리 (ALL, DISTINCT)",
                          "id": "중복-처리-all-distinct",
                          "children": null
                        },
                        {
                          "text": "모든 속성 선택 (*) 및 리터럴 사용",
                          "id": "모든-속성-선택-및-리터럴-사용",
                          "children": null
                        },
                        {
                          "text": "산술 표현식 및 결과 이름 변경 (AS)",
                          "id": "산술-표현식-및-결과-이름-변경-as",
                          "children": null
                        }
                      ]
                    },
                    {
                      "text": "WHERE 절의 활용",
                      "id": "where-절의-활용",
                      "children": [
                        {
                          "text": "조건 지정 및 선택 연산",
                          "id": "조건-지정-및-선택-연산",
                          "children": null
                        },
                        {
                          "text": "논리 연산자 (AND, OR, NOT) 및 비교 연산자",
                          "id": "논리-연산자-and-or-not-및-비교-연산자",
                          "children": null
                        },
                        {
                          "text": "BETWEEN 연산자",
                          "id": "between-연산자",
                          "children": null
                        },
                        {
                          "text": "튜플 비교",
                          "id": "튜플-비교",
                          "children": null
                        }
                      ]
                    },
                    {
                      "text": "FROM 절의 활용",
                      "id": "from-절의-활용",
                      "children": [
                        {
                          "text": "관계 지정 및 카티션 곱",
                          "id": "관계-지정-및-카티션-곱",
                          "children": null
                        },
                        {
                          "text": "조인 구현 (Cartesian-product + selection)",
                          "id": "조인-구현-cartesian-product-selection",
                          "children": null
                        }
                      ]
                    },
                    {
                      "text": "이름 변경 (AS) 연산",
                      "id": "이름-변경-as-연산",
                      "children": null
                    }
                  ]
                },
                "quiz": [
                  {
                    "question": "중복된 값을 제거하고 강사들의 부서 이름을 검색하는 올바른 SQL 쿼리는 무엇입니까?",
                    "options": [
                      "SELECT ALL dept_name FROM instructor;",
                      "SELECT dept_name FROM instructor;",
                      "SELECT DISTINCT dept_name FROM instructor;",
                      "SELECT UNIQUE dept_name FROM instructor;"
                    ],
                    "answerIndex": 2,
                    "explanation": "`DISTINCT` 키워드는 SELECT 절에서 중복된 결과를 제거하는 데 사용됩니다."
                  },
                  {
                    "question": "'Comp. Sci.' 부서에 속하며 급여가 70,000보다 많은 모든 강사의 이름을 찾는 SQL 쿼리로 가장 적절한 것은 무엇입니까?",
                    "options": [
                      "SELECT name FROM instructor WHERE dept_name = 'Comp. Sci.' OR salary > 70000;",
                      "SELECT name FROM instructor WHERE dept_name = 'Comp. Sci.' AND salary > 70000;",
                      "SELECT name FROM instructor WHERE dept_name <> 'Comp. Sci.' AND salary <= 70000;",
                      "SELECT name FROM instructor WHERE dept_name = 'Comp. Sci.' BETWEEN salary 70000;"
                    ],
                    "answerIndex": 1,
                    "explanation": "`AND` 논리 연산자는 두 조건을 모두 만족하는 경우를 찾을 때 사용됩니다."
                  },
                  {
                    "question": "다음 SQL 쿼리 `SELECT DISTINCT T.name FROM instructor AS T, instructor AS S WHERE T.salary > S.salary AND S.dept_name = 'Comp. Sci.'`에 대한 설명으로 옳은 것은 무엇입니까?",
                    "options": [
                      "이 쿼리는 'Comp. Sci.' 부서 강사들 중 가장 높은 급여를 받는 강사의 이름을 찾습니다.",
                      "이 쿼리는 'Comp. Sci.' 부서의 특정 강사보다 급여가 높은 다른 강사들의 이름을 찾습니다.",
                      "이 쿼리는 'Comp. Sci.' 부서의 모든 강사 이름을 나열합니다.",
                      "이 쿼리는 두 개의 다른 테이블에서 강사 정보를 조인합니다."
                    ],
                    "answerIndex": 1,
                    "explanation": "`FROM instructor AS T, instructor AS S`는 instructor 테이블을 두 개의 별칭(T와 S)으로 사용하여 자체 조인(self-join)을 수행하며, `WHERE T.salary > S.salary AND S.dept_name = 'Comp. Sci.'` 조건은 'Comp. Sci.' 부서의 어떤 강사(S)보다 급여가 높은 강사(T)를 찾습니다."
                  }
                ]
              },
              {
                "title": "SQL DML 고급 기능: NULL 값, 집합 연산, 문자열 처리 및 정렬",
                "metadata": "Source: cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf, Text length: 3206 chars",
                "documentContent": [
                  {
                    "type": "heading",
                    "content": "NULL 값",
                    "level": 1
                  },
                  {
                    "type": "paragraph",
                    "content": "튜플에 일부 속성에 대해 NULL 값이 있을 수 있습니다. NULL은 알 수 없거나 값이 존재하지 않음을 의미합니다. NULL이 포함된 모든 산술 표현식의 결과는 NULL입니다. 예를 들어, '5 + NULL'은 NULL을 반환합니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "IS NULL / IS NOT NULL",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "술어 `IS NULL`은 NULL 값을 확인하는 데 사용됩니다. 예를 들어, `SELECT name FROM instructor WHERE salary IS NULL`은 급여가 NULL인 모든 강사의 이름을 찾습니다. `IS NOT NULL` 술어는 적용된 값이 NULL이 아닐 때 성공합니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "집합 연산",
                    "level": 1
                  },
                  {
                    "type": "paragraph",
                    "content": "`UNION`, `INTERSECT`, `EXCEPT`와 같은 집합 연산이 있습니다. 이 연산들은 각각 자동으로 중복을 제거합니다. 모든 중복을 유지하려면 `ALL` 키워드를 사용합니다(예: `UNION ALL`, `INTERSECT ALL`, `EXCEPT ALL`). 참고로 `SELECT` 문은 기본적으로 모든 중복을 유지합니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "UNION",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "`UNION`은 두 쿼리의 결과를 결합합니다. 예를 들어, 2017년 가을 또는 2018년 봄에 개설된 강좌를 찾을 수 있습니다. (`SELECT course_id FROM teaches WHERE semester = 'Fall' AND year = 2017) UNION (SELECT course_id FROM teaches WHERE semester = 'Spring' AND year = 2018`).",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "INTERSECT",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "`INTERSECT`는 두 쿼리 결과의 공통 부분을 찾습니다. 예를 들어, 2017년 가을과 2018년 봄 모두에 개설된 강좌를 찾을 수 있습니다. MySQL은 `INTERSECT`를 직접 지원하지 않으므로, `JOIN`을 사용하여 에뮬레이션할 수 있습니다. (`SELECT LT.course_id FROM (SELECT course_id FROM teaches WHERE semester = 'Fall' AND year = 2017) AS LT JOIN (SELECT course_id FROM teaches WHERE semester = 'Spring' AND year = 2018) AS RT ON LT.course_id=RT.course_id;`)",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "EXCEPT",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "`EXCEPT`는 첫 번째 쿼리 결과에서 두 번째 쿼리 결과를 제외한 부분을 찾습니다. 예를 들어, 2017년 가을에 개설되었지만 2018년 봄에는 개설되지 않은 강좌를 찾을 수 있습니다. MySQL은 `EXCEPT`를 직접 지원하지 않으므로, `NOT IN`을 사용하여 에뮬레이션할 수 있습니다. (`SELECT course_id FROM teaches WHERE semester = 'Fall' AND year = 2017 AND course_id NOT IN(SELECT course_id FROM teaches WHERE semester = 'Spring' AND year = 2018);`)",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "문자열 연산",
                    "level": 1
                  },
                  {
                    "type": "paragraph",
                    "content": "SQL은 문자열 비교를 위한 문자열 일치 연산자를 포함합니다. `LIKE` 연산자는 두 가지 특수 문자를 사용하여 패턴을 설명합니다. 퍼센트(`%`) 문자는 모든 부분 문자열과 일치하고, 밑줄(`_`) 문자는 모든 단일 문자와 일치합니다. 예를 들어, `SELECT name FROM instructor WHERE name LIKE ‘%ri%'`는 이름에 \"ri\" 부분 문자열이 포함된 모든 강사의 이름을 찾습니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "이스케이프 문자(예: 백슬래시 `\\`)를 사용하여 특수 문자를 리터럴로 일치시킬 수 있습니다. 예를 들어, \"100%\" 문자열과 일치시키려면 `LIKE '100 \\%' ESCAPE '\\'`를 사용합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "패턴은 대소문자를 구분합니다. 패턴 일치 예시: 'Intro%'는 \"Intro\"로 시작하는 모든 문자열과 일치하고, '%Comp%'는 \"Comp\"를 포함하는 모든 문자열과 일치하며, '_ _ _'는 정확히 세 문자로 된 모든 문자열과 일치하고, '_ _ _ %'는 최소 세 문자로 된 모든 문자열과 일치합니다. SQL은 연결(`||`), 대소문자 변환, 문자열 길이 찾기, 부분 문자열 추출 등 다양한 문자열 연산을 지원합니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "튜플 표시 정렬",
                    "level": 1
                  },
                  {
                    "type": "paragraph",
                    "content": "`ORDER BY` 절을 사용하여 튜플의 표시 순서를 정렬할 수 있습니다. 예를 들어, 모든 강사의 이름을 알파벳 순서로 나열하려면 `SELECT DISTINCT name FROM instructor ORDER BY name`을 사용합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "여러 속성을 기준으로 정렬할 수 있습니다. 예를 들어, `SELECT dept_name, name FROM instructor ORDER BY dept_name, name`과 같이 부서 이름과 이름 순으로 정렬할 수 있습니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "각 속성에 대해 내림차순(`DESC`) 또는 오름차순(`ASC`)을 지정할 수 있으며, 오름차순이 기본값입니다. 예를 들어, `ORDER BY name DESC`는 이름을 내림차순으로 정렬합니다.",
                    "level": null
                  }
                ],
                "aiNotes": {
                  "summary": "이 문서는 SQL DML의 고급 기능을 다룹니다. NULL 값의 개념과 `IS NULL`, `IS NOT NULL`을 이용한 처리 방법을 설명합니다. 또한 `UNION`, `INTERSECT`, `EXCEPT`와 같은 집합 연산의 사용법과 `ALL` 키워드를 통한 중복 유지 방법, 그리고 MySQL에서의 에뮬레이션 방안을 제시합니다. 마지막으로 `LIKE` 연산자를 활용한 문자열 패턴 매칭과 `ORDER BY` 절을 이용한 결과 정렬 방법에 대해 자세히 설명합니다.",
                  "keyConcepts": [
                    {
                      "term": "NULL 값 처리",
                      "definition": "데이터베이스에서 알 수 없거나 존재하지 않는 값을 나타내는 NULL을 다루는 방법과 관련된 SQL 기능."
                    },
                    {
                      "term": "SQL 집합 연산",
                      "definition": "여러 쿼리 결과를 `UNION`, `INTERSECT`, `EXCEPT`를 사용하여 결합하거나 비교하는 기능."
                    },
                    {
                      "term": "문자열 패턴 매칭",
                      "definition": "`LIKE` 연산자와 `%`, `_` 특수 문자를 사용하여 문자열 내의 특정 패턴을 검색하는 방법."
                    },
                    {
                      "term": "결과 집합 정렬",
                      "definition": "`ORDER BY` 절을 사용하여 쿼리 결과 튜플의 표시 순서를 오름차순(`ASC`) 또는 내림차순(`DESC`)으로 지정하는 방법."
                    }
                  ],
                  "importantTerms": [
                    {
                      "term": "NULL",
                      "definition": "알 수 없거나 존재하지 않는 값."
                    },
                    {
                      "term": "IS NULL / IS NOT NULL",
                      "definition": "NULL 값을 확인하는 데 사용되는 술어."
                    },
                    {
                      "term": "UNION",
                      "definition": "두 쿼리 결과를 합치는 집합 연산자이며, 기본적으로 중복을 제거한다."
                    },
                    {
                      "term": "LIKE",
                      "definition": "문자열 패턴 매칭에 사용되는 연산자."
                    },
                    {
                      "term": "%",
                      "definition": "`LIKE` 연산자에서 임의의 부분 문자열과 일치하는 특수 문자."
                    },
                    {
                      "term": "_",
                      "definition": "`LIKE` 연산자에서 임의의 단일 문자와 일치하는 특수 문자."
                    },
                    {
                      "term": "ORDER BY",
                      "definition": "쿼리 결과의 정렬 순서를 지정하는 절."
                    }
                  ],
                  "outline": [
                    {
                      "text": "NULL 값",
                      "id": "null-값",
                      "children": [
                        {
                          "text": "NULL 값의 정의 및 특징",
                          "id": "null-값의-정의-및-특징",
                          "children": null
                        },
                        {
                          "text": "IS NULL / IS NOT NULL 술어",
                          "id": "is-null-is-not-null-술어",
                          "children": null
                        }
                      ]
                    },
                    {
                      "text": "집합 연산",
                      "id": "집합-연산",
                      "children": [
                        {
                          "text": "집합 연산의 종류 (UNION, INTERSECT, EXCEPT)",
                          "id": "집합-연산의-종류",
                          "children": null
                        },
                        {
                          "text": "중복 제거 및 ALL 키워드",
                          "id": "중복-제거-및-all-키워드",
                          "children": null
                        },
                        {
                          "text": "UNION 예시",
                          "id": "union-예시",
                          "children": null
                        },
                        {
                          "text": "INTERSECT 예시 및 MySQL 에뮬레이션",
                          "id": "intersect-예시-및-mysql-에뮬레이션",
                          "children": null
                        },
                        {
                          "text": "EXCEPT 예시 및 MySQL 에뮬레이션",
                          "id": "except-예시-및-mysql-에뮬레이션",
                          "children": null
                        }
                      ]
                    },
                    {
                      "text": "문자열 연산",
                      "id": "문자열-연산",
                      "children": [
                        {
                          "text": "LIKE 연산자 및 패턴 매칭 특수 문자 (%, _)",
                          "id": "like-연산자-및-패턴-매칭-특수-문자",
                          "children": null
                        },
                        {
                          "text": "이스케이프 문자",
                          "id": "이스케이프-문자",
                          "children": null
                        },
                        {
                          "text": "패턴 매칭 예시 및 특징 (대소문자 구분)",
                          "id": "패턴-매칭-예시-및-특징",
                          "children": null
                        },
                        {
                          "text": "기타 문자열 함수",
                          "id": "기타-문자열-함수",
                          "children": null
                        }
                      ]
                    },
                    {
                      "text": "튜플 표시 정렬",
                      "id": "튜플-표시-정렬",
                      "children": [
                        {
                          "text": "ORDER BY 절 기본 사용법",
                          "id": "order-by-절-기본-사용법",
                          "children": null
                        },
                        {
                          "text": "여러 속성으로 정렬",
                          "id": "여러-속성으로-정렬",
                          "children": null
                        },
                        {
                          "text": "오름차순 (ASC) 및 내림차순 (DESC) 지정",
                          "id": "오름차순-및-내림차순-지정",
                          "children": null
                        }
                      ]
                    }
                  ]
                },
                "quiz": [
                  {
                    "question": "SQL에서 NULL 값이 포함된 산술 연산의 결과는 무엇입니까?",
                    "options": [
                      "0",
                      "1",
                      "NULL",
                      "오류"
                    ],
                    "answerIndex": 2,
                    "explanation": "NULL이 포함된 산술 표현식의 결과는 항상 NULL입니다."
                  },
                  {
                    "question": "다음 중 두 쿼리 결과의 중복을 포함하여 합치는 SQL 집합 연산자는 무엇입니까?",
                    "options": [
                      "UNION",
                      "INTERSECT ALL",
                      "UNION ALL",
                      "EXCEPT"
                    ],
                    "answerIndex": 2,
                    "explanation": "`UNION`은 중복을 제거하지만, `UNION ALL`은 모든 중복을 유지하면서 두 쿼리 결과를 합칩니다."
                  },
                  {
                    "question": "`LIKE` 연산자에서 임의의 단일 문자와 일치하는 특수 문자는 무엇입니까?",
                    "options": [
                      "%",
                      "_",
                      "\\",
                      "?"
                    ],
                    "answerIndex": 1,
                    "explanation": "`%`는 임의의 부분 문자열과 일치하고, `_`는 임의의 단일 문자와 일치합니다."
                  }
                ]
              },
              {
                "title": "SQL DML: 집계 함수 및 데이터 수정 (INSERT, UPDATE, DELETE)",
                "metadata": "Source: cd0e465a-9cfa-47bf-93fa-9eb3744fcb3d_d770f338-b133-4996-a012-f87d85ecd585_DB04 - SQL.pdf, Text length: 5040 chars",
                "documentContent": [
                  {
                    "type": "heading",
                    "content": "집계 함수 (Aggregate Functions)",
                    "level": 1
                  },
                  {
                    "type": "paragraph",
                    "content": "집계 함수는 릴레이션의 특정 컬럼 값들의 멀티셋에 대해 작동하며 단일 값을 반환합니다. 주요 집계 함수는 다음과 같습니다:",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **AVG**: 평균값",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **MIN**: 최솟값",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **MAX**: 최댓값",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **SUM**: 합계",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **COUNT**: 값의 개수",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "집계 함수 예시",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "집계 함수는 다양한 질의에 사용될 수 있습니다. 예를 들어, 컴퓨터 공학과 강사들의 평균 급여를 찾거나, 2018년 봄 학기에 강의를 가르친 강사의 총 수를 세거나, `teaches` 릴레이션의 튜플 수를 세는 데 활용됩니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **컴퓨터 공학과 강사들의 평균 급여 찾기:**",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "SELECT AVG(salary)\nFROM instructor\nWHERE dept_name= 'Comp. Sci.';",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **2018년 봄 학기에 강의를 가르친 강사의 총 수 찾기:**",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "SELECT COUNT(DISTINCT ID)\nFROM teaches\nWHERE semester = 'Spring’ AND year = 2018;",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **`teaches` 릴레이션의 튜플 수 찾기:**",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "SELECT COUNT (*)\nFROM teaches;",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "GROUP BY 절",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "`GROUP BY` 절은 특정 컬럼의 값을 기준으로 행들을 그룹으로 묶고, 각 그룹에 대해 집계 함수를 적용할 때 사용됩니다. 예를 들어, 각 부서의 강사 평균 급여를 찾을 수 있습니다.",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "SELECT dept_name, AVG(salary) AS avg_salary\nFROM instructor\nGROUP BY dept_name;",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "GROUP BY 규칙",
                    "level": 3
                  },
                  {
                    "type": "paragraph",
                    "content": "`SELECT` 절에 집계 함수 외에 사용된 모든 속성은 반드시 `GROUP BY` 목록에 포함되어야 합니다. 그렇지 않으면 오류가 발생합니다.",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "/* 오류가 발생하는 질의 */\nSELECT dept_name, ID, AVG(salary)\nFROM instructor\nGROUP BY dept_name;",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "HAVING 절",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "`HAVING` 절은 `GROUP BY` 절에 의해 생성된 그룹에 조건을 적용하여 결과를 필터링하는 데 사용됩니다. 예를 들어, 평균 급여가 65000을 초과하는 모든 부서의 이름과 평균 급여를 찾을 수 있습니다.",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "SELECT dept_name, AVG(salary) AS avg_salary\nFROM instructor\nGROUP BY dept_name\nHAVING AVG(salary) > 65000;",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "HAVING과 WHERE의 차이",
                    "level": 3
                  },
                  {
                    "type": "paragraph",
                    "content": "`HAVING` 절의 조건은 그룹이 형성된 **후**에 적용되는 반면, `WHERE` 절의 조건은 그룹을 형성하기 **전**에 적용됩니다. 이는 데이터 필터링 시점의 중요한 차이입니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "SQL DML 명령어",
                    "level": 1
                  },
                  {
                    "type": "paragraph",
                    "content": "SQL 데이터 조작 언어(DML)는 데이터베이스 내의 데이터를 검색, 삽입, 수정, 삭제하는 데 사용됩니다. 주요 DML 명령어는 `SELECT`, `INSERT`, `UPDATE`, `DELETE`입니다. 데이터 정의 언어(DDL)는 `CREATE`, `ALTER`, `DROP`과 같이 데이터베이스 스키마를 정의하고 관리하는 데 사용됩니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "INSERT (데이터 삽입)",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "`INSERT` 문은 테이블에 새로운 행(튜플)을 추가하는 데 사용됩니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "기본 문법",
                    "level": 3
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **모든 컬럼에 데이터 삽입:**",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "INSERT INTO tablename\nVALUES (col1_value, col2_value, …)",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "    *   값은 테이블 스키마와 동일한 순서로 나열되어야 합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "    *   알 수 없는 데이터 값은 `NULL`로 지정해야 합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "    *   문자열은 따옴표를 사용하며, 작은따옴표(')가 권장됩니다. 따옴표 안의 값은 대소문자를 구분합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **선택한 컬럼에 데이터 삽입:**",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "INSERT INTO tablename (col1_name, col3_name, col4_name, …)\nVALUES (col1_value, col3_value, col4_value, …)",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "INSERT 예시",
                    "level": 3
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **`course` 테이블에 새로운 튜플 추가:**",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "INSERT INTO course\nVALUES ('CS-437', 'Database Systems', 'Comp. Sci.', 4);",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "    또는 동일하게:",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "INSERT INTO course (course_id, title, dept_name, credits)\nVALUES ('CS-437', 'Database Systems', 'Comp. Sci.', 4);",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **`student` 테이블에 `tot_creds`가 NULL인 새로운 튜플 추가:**",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "INSERT INTO student\nVALUES ('3003', 'Green', 'Finance', null);",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "외래 키 제약 조건과 INSERT",
                    "level": 3
                  },
                  {
                    "type": "paragraph",
                    "content": "외래 키는 한 릴레이션의 속성이 다른 릴레이션의 튜플에 매핑되어야 함을 지정합니다. 즉, 한 릴레이션의 값이 다른 릴레이션에 존재해야 합니다. 새로운 행을 삽입할 때는 해당 행이 참조하는 모든 외래 키가 데이터베이스에 이미 추가되어 있는지 확인해야 합니다. 참조된 릴레이션에 해당 값이 존재하지 않으면 외래 키 값을 삽입할 수 없습니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "다른 SELECT 쿼리 결과 삽입",
                    "level": 3
                  },
                  {
                    "type": "paragraph",
                    "content": "`SELECT` 쿼리의 결과를 다른 테이블에 삽입할 수 있습니다. 이때 `SELECT FROM WHERE` 문은 그 결과가 릴레이션에 삽입되기 전에 완전히 평가됩니다. 이는 `INSERT INTO table1 SELECT * FROM table1`과 같은 질의에서 발생할 수 있는 문제를 방지합니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **음악학과 학생 중 144학점 이상을 이수한 학생들을 $18,000 급여의 음악학과 강사로 추가:**",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "INSERT INTO instructor\n  SELECT ID, name, dept_name, 18000\n  FROM student\n  WHERE dept_name = 'Music’ AND total_cred > 144;",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "UPDATE (데이터 수정)",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "`UPDATE` 문은 테이블의 기존 데이터를 수정하는 데 사용됩니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "기본 문법",
                    "level": 3
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **테이블 업데이트 (조건 없음):** 모든 행의 지정된 컬럼을 수정합니다.",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "UPDATE tablename\nSET col1_name = new_col1_value, col2_name = new_col2_value, …;",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **조건 있는 테이블 업데이트:** `WHERE` 절의 조건과 일치하는 행만 수정합니다.",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "UPDATE tablename\nSET col1_name = new_col1_value, col2_name = new_col2_value, …\nWHERE predicate;",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "UPDATE 예시",
                    "level": 3
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **모든 강사의 급여를 5% 인상:**",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "UPDATE instructor\nSET salary = salary * 1.05",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **급여가 70000 미만인 강사의 급여를 5% 인상:**",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "UPDATE instructor\nSET salary = salary * 1.05\nWHERE salary < 70000;",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **급여가 평균 급여 미만인 강사의 급여를 5% 인상:**",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "UPDATE instructor\nSET salary = salary * 1.05\nWHERE salary <  (SELECT AVG(salary) FROM instructor);",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "CASE 문을 이용한 조건부 UPDATE",
                    "level": 3
                  },
                  {
                    "type": "paragraph",
                    "content": "여러 조건에 따라 다른 값을 적용해야 할 경우 `CASE` 문을 사용할 수 있습니다. 이는 여러 `UPDATE` 문을 사용하는 것보다 효율적이며, 실행 순서에 따른 문제를 방지할 수 있습니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **급여가 $100,000 초과인 강사는 3% 인상, 그 외는 5% 인상:**",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "UPDATE instructor\nSET salary = CASE\n                           WHEN salary <= 100000 THEN salary * 1.05\n                           ELSE salary * 1.03\n                       END",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "스칼라 서브쿼리를 이용한 UPDATE",
                    "level": 3
                  },
                  {
                    "type": "paragraph",
                    "content": "스칼라 서브쿼리(단일 값을 반환하는 서브쿼리)를 사용하여 컬럼 값을 업데이트할 수 있습니다.",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **모든 학생의 `tot_creds` 값을 재계산하여 업데이트:**",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "UPDATE student S\nSET tot_cred = (SELECT SUM(credits)\n                             FROM takes, course\n                             WHERE takes.course_id = course.course_id  AND\n                                            S.ID= takes.ID  AND\n                                            takes.grade <> 'F' AND\n                                            takes.grade IS NOT NULL);",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "DELETE (데이터 삭제)",
                    "level": 2
                  },
                  {
                    "type": "paragraph",
                    "content": "`DELETE` 문은 테이블에서 행을 제거하는 데 사용됩니다.",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "기본 문법",
                    "level": 3
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **특정 행 제거:** `WHERE` 절의 조건과 일치하는 행을 제거합니다.",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "DELETE FROM tablename\nWHERE predicate;",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **모든 행 제거:** 테이블의 모든 행을 제거합니다.",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "DELETE FROM tablename;",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "TRUNCATE와의 비교",
                    "level": 3
                  },
                  {
                    "type": "paragraph",
                    "content": "`DELETE FROM tablename;`는 `TRUNCATE (TABLE) tablename;`와 기능적으로 유사하게 테이블의 모든 행을 제거합니다. 그러나 `TRUNCATE`는 외래 키 제약 조건이 있는 테이블에서는 사용할 수 없습니다. 외래 키 제약 조건이 있는 테이블을 `TRUNCATE`하려면 먼저 제약 조건을 비활성화해야 합니다.",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "ALTER TABLE tablename\nDISABLE CONSTRAINT constraint_name;",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "DELETE 예시",
                    "level": 3
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **모든 강사 삭제:**",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "DELETE FROM instructor;",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **재무학과 강사 모두 삭제:**",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "DELETE FROM instructor\nWHERE dept_name= 'Finance';",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "•   **Watson 건물에 위치한 부서에 소속된 강사 모두 삭제:**",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "DELETE FROM instructor\nWHERE dept_name IN (SELECT dept_name\n        FROM department\n        WHERE building = 'Watson');",
                    "level": null
                  },
                  {
                    "type": "heading",
                    "content": "서브쿼리를 이용한 DELETE 시 주의사항",
                    "level": 3
                  },
                  {
                    "type": "paragraph",
                    "content": "서브쿼리를 사용하여 `DELETE` 작업을 수행할 때, 삭제되는 튜플이 서브쿼리의 결과에 영향을 미칠 수 있습니다. 예를 들어, 강사 평균 급여보다 낮은 급여를 가진 강사를 삭제하는 경우, 강사가 삭제됨에 따라 평균 급여가 변경될 수 있습니다.",
                    "level": null
                  },
                  {
                    "type": "code",
                    "content": "DELETE FROM instructor\nWHERE salary < (SELECT AVG (salary) FROM instructor);",
                    "level": null
                  },
                  {
                    "type": "paragraph",
                    "content": "SQL에서는 이러한 문제를 해결하기 위해 다음과 같은 방식을 사용합니다. 먼저 `AVG(salary)`를 계산하고 삭제할 모든 튜플을 찾은 다음, 평균을 재계산하거나 튜플을 재확인하지 않고 찾아진 모든 튜플을 삭제합니다.",
                    "level": null
                  }
                ],
                "aiNotes": {
                  "summary": "이 문서는 SQL의 데이터 조작 언어(DML) 중 집계 함수와 데이터 수정 명령어(INSERT, UPDATE, DELETE)에 대해 설명합니다. 집계 함수의 종류(AVG, MIN, MAX, SUM, COUNT)와 사용 예시를 제시하며, GROUP BY 및 HAVING 절의 사용법과 WHERE 절과의 차이점을 강조합니다. 또한, INSERT 명령어를 이용한 데이터 삽입 방법, 외래 키 제약 조건과의 관계, 그리고 SELECT 쿼리 결과 삽입에 대해 다룹니다. UPDATE 명령어의 기본 문법, 다양한 조건부 업데이트 예시, 그리고 CASE 문 및 스칼라 서브쿼리 활용법을 설명합니다. 마지막으로 DELETE 명령어의 기본 문법, TRUNCATE와의 차이점, 외래 키 제약 조건, 그리고 서브쿼리를 사용한 삭제 시의 처리 방식에 대해 상세히 기술합니다.",
                  "keyConcepts": [
                    {
                      "term": "집계 함수 (Aggregate Functions)",
                      "definition": "릴레이션의 컬럼 값들의 멀티셋에 대해 작동하여 단일 값을 반환하는 함수 (예: AVG, MIN, MAX, SUM, COUNT)."
                    },
                    {
                      "term": "GROUP BY",
                      "definition": "SQL에서 특정 컬럼의 값을 기준으로 행들을 그룹으로 묶어 각 그룹에 대해 집계 함수를 적용할 수 있게 하는 절."
                    },
                    {
                      "term": "HAVING 절",
                      "definition": "GROUP BY 절에 의해 생성된 그룹에 조건을 적용하여 결과를 필터링하는 데 사용되는 절. WHERE 절과 달리 그룹화 후에 적용된다."
                    },
                    {
                      "term": "INSERT",
                      "definition": "SQL에서 테이블에 새로운 행(튜플)을 추가하는 데 사용되는 DML 명령어."
                    },
                    {
                      "term": "UPDATE",
                      "definition": "SQL에서 테이블의 기존 데이터를 수정하는 데 사용되는 DML 명령어."
                    },
                    {
                      "term": "DELETE",
                      "definition": "SQL에서 테이블의 행을 제거하는 데 사용되는 DML 명령어."
                    }
                  ],
                  "importantTerms": [
                    {
                      "term": "멀티셋 (Multiset)",
                      "definition": "중복된 값을 허용하는 집합."
                    },
                    {
                      "term": "튜플 (Tuple)",
                      "definition": "릴레이션(테이블)의 한 행을 의미한다."
                    },
                    {
                      "term": "외래 키 (Foreign Key)",
                      "definition": "한 릴레이션의 속성이 다른 릴레이션의 기본 키를 참조하여 두 릴레이션 간의 관계를 설정하는 제약 조건."
                    },
                    {
                      "term": "스칼라 서브쿼리 (Scalar Subquery)",
                      "definition": "단일 행, 단일 컬럼의 값을 반환하는 서브쿼리."
                    },
                    {
                      "term": "TRUNCATE",
                      "definition": "테이블의 모든 행을 빠르게 제거하는 DDL 명령어. DELETE와 달리 외래 키 제약 조건이 있는 테이블에는 직접 적용할 수 없다."
                    }
                  ],
                  "outline": [
                    {
                      "text": "집계 함수 (Aggregate Functions)",
                      "id": "집계-함수-aggregate-functions",
                      "children": [
                        {
                          "text": "집계 함수 예시",
                          "id": "집계-함수-예시",
                          "children": null
                        },
                        {
                          "text": "GROUP BY 절",
                          "id": "group-by-절",
                          "children": [
                            {
                              "text": "GROUP BY 규칙",
                              "id": "group-by-규칙",
                              "children": null
                            }
                          ]
                        },
                        {
                          "text": "HAVING 절",
                          "id": "having-절",
                          "children": [
                            {
                              "text": "HAVING과 WHERE의 차이",
                              "id": "having과-where의-차이",
                              "children": null
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "text": "SQL DML 명령어",
                      "id": "sql-dml-명령어",
                      "children": [
                        {
                          "text": "INSERT (데이터 삽입)",
                          "id": "insert-데이터-삽입",
                          "children": [
                            {
                              "text": "기본 문법",
                              "id": "기본-문법",
                              "children": null
                            },
                            {
                              "text": "INSERT 예시",
                              "id": "insert-예시",
                              "children": null
                            },
                            {
                              "text": "외래 키 제약 조건과 INSERT",
                              "id": "외래-키-제약-조건과-insert",
                              "children": null
                            },
                            {
                              "text": "다른 SELECT 쿼리 결과 삽입",
                              "id": "다른-select-쿼리-결과-삽입",
                              "children": null
                            }
                          ]
                        },
                        {
                          "text": "UPDATE (데이터 수정)",
                          "id": "update-데이터-수정",
                          "children": [
                            {
                              "text": "기본 문법",
                              "id": "기본-문법-1",
                              "children": null
                            },
                            {
                              "text": "UPDATE 예시",
                              "id": "update-예시",
                              "children": null
                            },
                            {
                              "text": "CASE 문을 이용한 조건부 UPDATE",
                              "id": "case-문을-이용한-조건부-update",
                              "children": null
                            },
                            {
                              "text": "스칼라 서브쿼리를 이용한 UPDATE",
                              "id": "스칼라-서브쿼리를-이용한-update",
                              "children": null
                            }
                          ]
                        },
                        {
                          "text": "DELETE (데이터 삭제)",
                          "id": "delete-데이터-삭제",
                          "children": [
                            {
                              "text": "기본 문법",
                              "id": "기본-문법-2",
                              "children": null
                            },
                            {
                              "text": "TRUNCATE와의 비교",
                              "id": "truncate와의-비교",
                              "children": null
                            },
                            {
                              "text": "DELETE 예시",
                              "id": "delete-예시",
                              "children": null
                            },
                            {
                              "text": "서브쿼리를 이용한 DELETE 시 주의사항",
                              "id": "서브쿼리를-이용한-delete-시-주의사항",
                              "children": null
                            }
                          ]
                        }
                      ]
                    }
                  ]
                },
                "quiz": [
                  {
                    "question": "다음 중 SQL의 `HAVING` 절에 대한 설명으로 올바른 것은 무엇입니까?",
                    "options": [
                      "그룹을 형성하기 전에 개별 행에 조건을 적용합니다.",
                      "집계 함수가 적용된 그룹에 조건을 적용합니다.",
                      "테이블에서 데이터를 삭제할 때 사용됩니다.",
                      "새로운 행을 테이블에 삽입할 때 사용됩니다."
                    ],
                    "answerIndex": 1,
                    "explanation": "`HAVING` 절은 `GROUP BY` 절에 의해 생성된 그룹에 조건을 적용하여 필터링하는 데 사용됩니다. `WHERE` 절과 달리 그룹화가 완료된 후에 적용됩니다."
                  },
                  {
                    "question": "SQL `INSERT` 문을 사용하여 새 행을 삽입할 때, 외래 키(Foreign Key) 제약 조건과 관련하여 반드시 지켜야 할 사항은 무엇입니까?",
                    "options": [
                      "외래 키 값은 항상 NULL로 설정되어야 합니다.",
                      "새로운 행의 외래 키 값이 참조하는 릴레이션에 이미 존재해야 합니다.",
                      "외래 키 값은 삽입 후 자동으로 생성됩니다.",
                      "외래 키 제약 조건은 `INSERT` 작업에 영향을 미치지 않습니다."
                    ],
                    "answerIndex": 1,
                    "explanation": "외래 키는 다른 릴레이션의 기본 키를 참조하므로, 새로운 행을 삽입할 때 해당 외래 키 값이 참조하는 릴레이션에 이미 존재해야 참조 무결성이 유지됩니다."
                  },
                  {
                    "question": "다음 SQL `UPDATE` 문 중, 급여가 $100,000 이하인 강사의 급여는 5% 인상하고, $100,000 초과인 강사의 급여는 3% 인상하는 올바른 방법은 무엇입니까?",
                    "options": [
                      "UPDATE instructor SET salary = salary * 1.05 WHERE salary <= 100000; UPDATE instructor SET salary = salary * 1.03 WHERE salary > 100000;",
                      "UPDATE instructor SET salary = CASE WHEN salary <= 100000 THEN salary * 1.05 ELSE salary * 1.03 END;",
                      "UPDATE instructor SET salary = salary * 1.03 OR salary * 1.05;",
                      "UPDATE instructor WHERE salary <= 100000 SET salary = salary * 1.05; ELSE SET salary = salary * 1.03;"
                    ],
                    "answerIndex": 1,
                    "explanation": "`CASE` 문은 여러 조건에 따라 다른 값을 적용할 때 사용되는 효율적인 방법입니다. 제시된 `CASE` 문은 주어진 조건에 따라 급여 인상률을 정확하게 적용합니다. 두 개의 `UPDATE` 문을 사용하는 첫 번째 옵션도 가능하지만, 순서에 따라 결과가 달라질 수 있고 `CASE` 문이 더 간결하고 안전한 방법입니다."
                  }
                ]
              }
            ],
            "final_result": "'관계형 데이터베이스 시스템: MySQL 소개 및 SQL 심층 활용' 노트북(ID: 2)에 5개의 챕터가 성공적으로 처리 및 저장되었습니다."
          }
        }
      ],
      "final_result": "'관계형 데이터베이스 시스템: MySQL 소개 및 SQL 심층 활용' 노트북(ID: 2)에 5개의 챕터가 성공적으로 처리 및 저장되었습니다."
    }
  }
]